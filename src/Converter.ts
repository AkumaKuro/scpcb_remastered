import { Graphics3D, AppTitle, int, Collisions, range, float, GetParent, EntityName, Chr, DebugLog, CountChildren, GetChild, Float, Int, Color, KeyHit, Exit, LoadAnimMesh, Delay, FlushKeys, Input } from "./Helper/bbhelper.ts"
import {CloseFile, CopyFile, CurrentDir, Eof, FilePos, FileSize, ReadFile, ReadLine, TextureName, WriteByte, WriteFile, WriteFloat, WriteInt, WriteLine, WriteString} from "./Helper/Files.ts"
import { ReadPixelFast, SetBuffer, BackBuffer, TextureBuffer, BBText, Cls, ClsColor, Flip } from "./Helper/graphics.ts"
import { Sqr } from "./Helper/math.ts"
import { AddMesh, CountSurfaces, CountTriangles, CountVertices, CreateMesh, EntityPitch, EntityRoll, EntityX, EntityY, EntityYaw, EntityZ, FreeBrush, FreeEntity, GetBrushTexture, GetSurface, GetSurfaceBrush, PositionMesh, RotateMesh, ScaleMesh, TFormedX, TFormedY, TFormedZ, TriangleVertex, VertexBlue, VertexGreen, VertexRed, VertexU, VertexV, VertexX, VertexY, VertexZ } from "./Helper/Mesh.ts"
import { Replace, Len, Mid, Right, Lower, Instr, Left, Trim, Upper, BBString } from "./Helper/strings.ts"
import { FreeTexture, LockBuffer, TextureHeight, TextureWidth, UnlockBuffer } from "./Helper/textures.ts"
import { TFormVector } from "./Helper/vector.ts"

Graphics3D (640,480,0,2)

AppTitle ("Convert SCP-CB rooms (B3D generated by 3DWS) to RMESH")

const HIT_MAP: int = 1
const HIT_PLAYER: int = 2

Collisions (HIT_PLAYER,HIT_MAP,2,2)

function StripPath(file: string) : string {
	let name: string = ""
	if (Len(file)>0) {
		for (let i of range(Len(file), 0, -1)) {
			
			let mi = Mid(file,i,1) 
			if (mi == "\\" || mi == "/") {
				return name
			}
			
			name=mi+name 
		} 
		
	}
	
	return name
}

export function StripFilename(file: string) : string {
	let mi: string = ""
	let lastSlash: int = 0
	if (Len(file)>0) {
		for (let i of range(1, Len(file) + 1)) {
			mi = Mid(file,i,1)
			if (mi == "\\" || mi == "/") {
				lastSlash = i
			}
		}
	}
	
	return Left(file,lastSlash)
}

function EntityScaleX(entity, globl: boolean = false) : float {
	if (globl) {
		TFormVector(1,0,0,entity,0)
	} else {
		TFormVector(1,0,0,entity,GetParent(entity))
	}
	return Sqr(TFormedX()*TFormedX()+TFormedY()*TFormedY()+TFormedZ()*TFormedZ()) 
}

function EntityScaleY(entity, globl: boolean = false) : float {
	if (globl) {
		TFormVector(0,1,0,entity,0)
	} else {
		TFormVector(0,1,0,entity,GetParent(entity))
	}
	return Sqr(TFormedX()*TFormedX()+TFormedY()*TFormedY()+TFormedZ()*TFormedZ()) 
}

function EntityScaleZ(entity, globl: boolean = false) : float {
	if (globl) {
		TFormVector(0,0,1,entity,0)
	} else {
		TFormVector(0,0,1,entity,GetParent(entity))
	}
	return Sqr(TFormedX()*TFormedX()+TFormedY()*TFormedY()+TFormedZ()*TFormedZ()) 
}

function Piece(str: string, entry, char: string = " ") : string {
	while (Instr(str,char+char)) {
		str = Replace(str,char+char,char)
	}

	for (let n of range(1, entry)) {
		let p = Instr(str,char)
		str = Right(str, Len(str) - p)
	}

	let p = Instr(str,char)
	let a

	if (p < 1) {
		a = str
	} else {
		a = Left(str, p - 1)
	}
	return a
}

function KeyValue(entity, key: string, defaultvalue: string = "") : string {
	let properties = EntityName(entity)
	properties=Replace(properties,Chr(13),"")
	key=Lower(key)
	while (true) {
		let p: int = Instr(properties,Chr(10))
		let test: string
		if (p) {
			test=(Left(properties,p-1))
		} else {
			test=properties
		}
		let testkey: string = Piece(test,1,"=")
		testkey=Trim(testkey)
		testkey=Replace(testkey,Chr(34),"")
		testkey=Lower(testkey)
		if (testkey==key) {
			let value = Piece(test,2,"=")
			value=Trim(value)
			value=Replace(value,Chr(34),"")
			return value
		}
		if (!p) {
			return defaultvalue
		}
		properties=Right(properties,Len(properties)-p)
	}
}

enum IsAlphaResult {
	Opaque = 1,
	LightMap = 2,
	Transparent = 3
}

function isAlpha(tex: int) : IsAlphaResult { //detect transparency in textures
	let temp1s: string = StripPath(TextureName(tex))
	let temp1i: int
	if (Instr(temp1s,".png") != 0 || Instr(temp1s,".tga") != 0 || Instr(temp1s,".tpic") != 0) {
		LockBuffer(TextureBuffer(tex))
		for (let x of range(0, TextureWidth(tex))) {
			for (let y of range(TextureHeight(tex))) {
				temp1i=ReadPixelFast(x,y,TextureBuffer(tex))
				temp1i=temp1i >> 24
				if (temp1i<255) {
					UnlockBuffer(TextureBuffer(tex))
					return IsAlphaResult.Transparent //texture has transparency
				}
			}
		}
		UnlockBuffer(TextureBuffer(tex))
		return IsAlphaResult.Opaque //texture is opaque
	} else if (Instr(temp1s,"_lm") != 0) { //texture is a lightmap
		return IsAlphaResult.LightMap
	}
	return IsAlphaResult.Opaque //texture is opaque
}

function SaveRoomMesh(BaseMesh: int,filename: string) { //base mesh should be a 3D World Studio mesh
	
	DebugLog(filename + "___" + BaseMesh)
		
	let node: int
	let classname: string
	let surf: int
	let brush: int
	let tex: int
	let texname: string
	
	let temp1i: int
	
	let tempmesh: int = BaseMesh
	
	let f: int = WriteFile(filename)
	
	let drawnmesh: int = CreateMesh()
	let hiddenmesh: int = CreateMesh()
	let TriggerboxAmount: int = 0
	let Triggerbox: any[] = new Array(128)
	let TriggerboxName: Array<string> = new Array(128)
	
	for (let c of range(1, CountChildren(tempmesh) + 1)) {
		node=GetChild(tempmesh,c)	
		classname = Lower(KeyValue(node,"classname"))
		
		switch (classname) {
			case "mesh":
				ScaleMesh(node,EntityScaleX(node),EntityScaleY(node),EntityScaleZ(node))
				RotateMesh(node,EntityPitch(node),EntityYaw(node),EntityRoll(node))
				PositionMesh(node,EntityX(node),EntityY(node),EntityZ(node))
				AddMesh(node,drawnmesh)
			case "brush":
				RotateMesh(node,EntityPitch(node),EntityYaw(node),EntityRoll(node))
				PositionMesh(node,EntityX(node),EntityY(node),EntityZ(node))
				AddMesh(node,drawnmesh)
			case "field_hit":
				RotateMesh(node,EntityPitch(node),EntityYaw(node),EntityRoll(node))
				PositionMesh(node,EntityX(node),EntityY(node),EntityZ(node))
				AddMesh(node,hiddenmesh)
			case "trigger":
				Triggerbox[TriggerboxAmount] = CreateMesh()
				RotateMesh(node,EntityPitch(node),EntityYaw(node),EntityRoll(node))
				PositionMesh(node,EntityX(node),EntityY(node),EntityZ(node))
				AddMesh(node,Triggerbox[TriggerboxAmount])
				TriggerboxName[TriggerboxAmount] = BBString(KeyValue(node,"event","event"),1)
				TriggerboxAmount=TriggerboxAmount+1
		}
	}
	
	if (TriggerboxAmount == 0) {
		WriteString (f,"RoomMesh")
	} else {
		WriteString (f,"RoomMesh.HasTriggerBox")
	}
		
	WriteInt(f,CountSurfaces(drawnmesh))
	DebugLog(CountSurfaces(drawnmesh))
	for (let i of range(1, CountSurfaces(drawnmesh) + 1)) {
		surf = GetSurface(drawnmesh,i)
		brush = GetSurfaceBrush(surf)
		
		tex = GetBrushTexture(brush,0)
		if (tex!=0) {
			WriteByte(f,isAlpha(tex))
			texname=TextureName(tex)
			WriteString(f,StripPath(texname))
			FreeTexture(tex)
		} else {
			WriteByte(f,0)
		}
		
		tex=GetBrushTexture(brush,1)
		if (tex!=0) {
			WriteByte(f,isAlpha(tex))
			texname=TextureName(tex)
			WriteString(f,StripPath(texname))
			FreeTexture(tex)
		} else {
			WriteByte(f,0)
		}
		
		FreeBrush(brush)
		
		WriteInt(f,CountVertices(surf))
		for (let j of range(CountVertices(surf))) {
			
			//world coords
			WriteFloat (f,VertexX(surf,j))
			WriteFloat (f,VertexY(surf,j))
			WriteFloat (f,VertexZ(surf,j))
			
			//texture coords
			WriteFloat (f,VertexU(surf,j,0))
			WriteFloat (f,VertexV(surf,j,0))
			
			WriteFloat (f,VertexU(surf,j,1))
			WriteFloat (f,VertexV(surf,j,1))
			
			//colors
			WriteByte (f,VertexRed(surf,j))
			WriteByte (f,VertexGreen(surf,j))
			WriteByte (f,VertexBlue(surf,j))
		}
		
		WriteInt (f,CountTriangles(surf))
		for (let j of range(CountTriangles(surf))) {
			WriteInt (f,TriangleVertex(surf,j,0))
			WriteInt (f,TriangleVertex(surf,j,1))
			WriteInt (f,TriangleVertex(surf,j,2))
		}
	}
	
	
	WriteInt (f,CountSurfaces(hiddenmesh))
	DebugLog(CountSurfaces(hiddenmesh))
	for (let i of range(1, CountSurfaces(hiddenmesh) + 1)) {
		surf = GetSurface(hiddenmesh,i)
		WriteInt (f,CountVertices(surf))
		for (let j of range(CountVertices(surf))) {
			//world coords
			WriteFloat (f,VertexX(surf,j))
			WriteFloat (f,VertexY(surf,j))
			WriteFloat (f,VertexZ(surf,j))
		}
		
		WriteInt (f,CountTriangles(surf))
		for (let j of range(CountTriangles(surf))) {
			WriteInt (f,TriangleVertex(surf,j,0))
			WriteInt (f,TriangleVertex(surf,j,1))
			WriteInt (f,TriangleVertex(surf,j,2))
		}
	}
	
	if (TriggerboxAmount > 0) {
		WriteInt (f,TriggerboxAmount)
		for (let z of range(TriggerboxAmount)) {
			WriteInt (f,CountSurfaces(Triggerbox[z]))
			DebugLog (CountSurfaces(Triggerbox[z]))
			for (let i of range(1, CountSurfaces(Triggerbox[z]) + 1)) {
				surf=GetSurface(Triggerbox[z],i)
				WriteInt (f,CountVertices(surf))
				for (let j of range(CountVertices(surf))) {
					//world coords
					WriteFloat (f,VertexX(surf,j))
					WriteFloat (f,VertexY(surf,j))
					WriteFloat (f,VertexZ(surf,j))
				}
				
				WriteInt (f,CountTriangles(surf))
				for (let j of range(CountTriangles(surf))) {
					WriteInt (f,TriangleVertex(surf,j,0))
					WriteInt (f,TriangleVertex(surf,j,1))
					WriteInt (f,TriangleVertex(surf,j,2))
				}
			}
			WriteString(f,TriggerboxName[z])
		}
	}
	
	temp1i=0
	
	for (let c of range(1, CountChildren(tempmesh) + 1)) {
		node=GetChild(tempmesh,c)	
		classname = Lower(KeyValue(node,"classname"))
		
		if (classname in ["screen", "waypoint", "light", "spotlight", "soundemitter", "playerstart", "model"]) {
			temp1i=temp1i+1
		}
	}
	
	WriteInt (f,temp1i)
	
	for (let c of range(1, CountChildren(tempmesh) + 1)) {
		
		node=GetChild(tempmesh,c)	
		classname = Lower(KeyValue(node,"classname"))
		
		switch (classname) {
			case "screen":
				WriteString(f,classname)
				
				WriteFloat(f,EntityX(node))
				WriteFloat(f,EntityY(node))
				WriteFloat(f,EntityZ(node))
				
				WriteString(f,KeyValue(node,"imgpath",""))
			case "waypoint":
				WriteString(f,classname)
				
				WriteFloat(f,EntityX(node))
				WriteFloat(f,EntityY(node))
				WriteFloat(f,EntityZ(node))
			case "light":
				WriteString(f,classname)
				
				WriteFloat(f,EntityX(node))
				WriteFloat(f,EntityY(node))
				WriteFloat(f,EntityZ(node))
				
				WriteFloat(f,Float(KeyValue(node,"range","1")))
				WriteString(f,KeyValue(node,"color","255 255 255"))
				WriteFloat(f,Float(KeyValue(node,"intensity","1.0")))
			case "spotlight":
				WriteString(f,classname)
				
				WriteFloat(f,EntityX(node))
				WriteFloat(f,EntityY(node))
				WriteFloat(f,EntityZ(node))
				
				WriteFloat(f,Float(KeyValue(node,"range","1")))
				WriteString(f,KeyValue(node,"color","255 255 255"))
				WriteFloat(f,Float(KeyValue(node,"intensity","1.0")))
				WriteString(f,KeyValue(node,"angles","0 0 0"))
				
				WriteInt(f,Int(KeyValue(node,"innerconeangle","")))
				WriteInt(f,Int(KeyValue(node,"outerconeangle","")))
			case "soundemitter":
				WriteString(f,classname)
				
				WriteFloat(f,EntityX(node))
				WriteFloat(f,EntityY(node))
				WriteFloat(f,EntityZ(node))
				
				WriteInt(f,Int(KeyValue(node,"sound","0")))
				WriteFloat(f,Float(KeyValue(node,"range","1")))
			case "playerstart":
				WriteString(f,classname)
				
				WriteFloat(f,EntityX(node))
				WriteFloat(f,EntityY(node))
				WriteFloat(f,EntityZ(node))
				
				WriteString(f,KeyValue(node,"angles","0 0 0"))
			case "model":
				WriteString(f,classname)
				
				WriteString(f,KeyValue(node,"file",""))
				
				WriteFloat(f,EntityX(node))
				WriteFloat(f,EntityY(node))
				WriteFloat(f,EntityZ(node))
				
				WriteFloat(f,EntityPitch(node))
				WriteFloat(f,EntityYaw(node))
				WriteFloat(f,EntityRoll(node))
				
				WriteFloat(f,EntityScaleX(node))
				WriteFloat(f,EntityScaleY(node))
				WriteFloat(f,EntityScaleZ(node))
		}	
	}
	
	WriteString (f,"EOF")
	
	CloseFile (f)
	
	FreeEntity (drawnmesh)
	FreeEntity (hiddenmesh)
	
}

export function GetINIString(file: string, section: string, parameter: string) : string {
	let TemporaryString: string = ""
	let f = ReadFile(file)
	
	while (!Eof(f)) {
		if (ReadLine(f) == "["+section+"]") {
			do { 
				TemporaryString = ReadLine(f)
				if (Trim( Left(TemporaryString, Max(Instr(TemporaryString,"=")-1,0)) ) == parameter) {
					CloseFile (f)
					return Trim( Right(TemporaryString,Len(TemporaryString)-Instr(TemporaryString,"=")) )
				}
			} while (!(Left(TemporaryString,1) == "[" || Eof(f)))
			CloseFile (f)
			return ""
		}
	}
	
	CloseFile (f)
	return ''
}

export function GetINIInt(file: string, section: string, parameter: string) : int {
	let strtemp: string = Lower(GetINIString(file, section, parameter))
	
	switch (strtemp) {
		case "true":
			return 1
		case "false":
			return 0
		default:
			return Int(strtemp)
	}
}

export function GetINIFloat(file: string, section: string, parameter: string) : float {
	return Float(GetINIString(file, section, parameter))
}

export function PutINIValue(INI_sAppName: string, INI_sSection: string, INI_sKey: string, INI_sValue: string) : boolean {
	
	INI_sSection = "[" + Trim(INI_sSection) + "]"
	let INI_sUpperSection = Upper(INI_sSection)
	INI_sKey = Trim(INI_sKey)
	INI_sValue = Trim(INI_sValue)
	let INI_sFilename = CurrentDir() + "\\"  + INI_sAppName
	
// Retrieve the INI data (if it exists)
	
	let INI_sContents = INI_FileToString(INI_sFilename)
	
// (Re)Create the INI file updating/adding the SECTION, KEY and VALUE
	
	let INI_bWrittenKey = false
	let INI_bSectionFound = false
	let INI_sCurrentSection = ""
	
	let INI_lFileHandle = WriteFile(INI_sFilename)
	if (INI_lFileHandle == 0) {return false} // Create file failed!
	
	let INI_lOldPos = 1
	let INI_lPos = Instr(INI_sContents, Chr(0))
	
	while (INI_lPos != 0) {
		
		let INI_sTemp =Trim(Mid(INI_sContents, INI_lOldPos, (INI_lPos - INI_lOldPos)))
		
		if (INI_sTemp != "") {
			
			if (Left(INI_sTemp, 1) == "[" && Right(INI_sTemp, 1) == "]") {
				
				// Process SECTION
				
				if ((INI_sCurrentSection == INI_sUpperSection) && !INI_bWrittenKey) {
					INI_bWrittenKey = INI_CreateKey(INI_lFileHandle, INI_sKey, INI_sValue)
				}
				INI_sCurrentSection = Upper(INI_CreateSection(INI_lFileHandle, INI_sTemp))
				if (INI_sCurrentSection == INI_sUpperSection) {
					INI_bSectionFound = true
				}
				
			} else {
				
				// KEY=VALUE
				
				let lEqualsPos = Instr(INI_sTemp, "=")
				if (lEqualsPos != 0) {
					if ((INI_sCurrentSection == INI_sUpperSection) && (Upper(Trim(Left(INI_sTemp, (lEqualsPos - 1)))) == Upper(INI_sKey))) {
						if (INI_sValue != "") {
							INI_CreateKey(INI_lFileHandle, INI_sKey, INI_sValue)
						}
						INI_bWrittenKey = true
					} else {
						WriteLine(INI_lFileHandle, INI_sTemp)
					}
				}
			}
		}
		
		// Move through the INI file...
		
		INI_lOldPos = INI_lPos + 1
		INI_lPos = Instr(INI_sContents, Chr(0), INI_lOldPos)
		
	}
	
	// KEY wasn't found in the INI file - Append a new SECTION if required and create our KEY=VALUE line
	
	if (!INI_bWrittenKey) {
		if (!INI_bSectionFound) {
			INI_CreateSection(INI_lFileHandle, INI_sSection)
		}
		INI_CreateKey(INI_lFileHandle, INI_sKey, INI_sValue)
	}
	
	CloseFile(INI_lFileHandle)
	
	return true // Success
}

function INI_FileToString(INI_sFilename: string) : string {
	
	let INI_sString: string = ""
	let INI_lFileHandle = ReadFile(INI_sFilename)
	if (INI_lFileHandle != 0) {
		while (!(Eof(INI_lFileHandle))) {
			INI_sString = INI_sString + ReadLine(INI_lFileHandle) + Chr(0)
		}
		CloseFile(INI_lFileHandle)
	}
	return INI_sString
}

function INI_CreateSection(INI_lFileHandle: int, INI_sNewSection: string) : string {
	
	if (FilePos(INI_lFileHandle) != 0) {
		WriteLine (INI_lFileHandle, "")
	} // Blank line between sections
	WriteLine(INI_lFileHandle, INI_sNewSection)
	return INI_sNewSection
	
}

function INI_CreateKey(INI_lFileHandle: int, INI_sKey: string, INI_sValue: string) : boolean {
	
	WriteLine (INI_lFileHandle, INI_sKey + "=" + INI_sValue)
	return true
}

// matemaattiset funktiot:
function Min(a: float,b: float) : float {
	if (a < b) {
		return a
	} else {
		return b
	}
}

function Max(a: float,b: float) : float {
	if (a > b) {
		return a
	} else {
		return b
	}
}

let state: int = 0

SetBuffer(BackBuffer())
ClsColor(0,0,0)
Cls()
Color(255,255,255)
BBText(5,5,"Press a key:")
BBText(5,25,"1 - Convert B3D (generated by 3D World Studio) to RMESH")
BBText(5,45,"2 - Convert a specific B3D (generated by 3D World Studio) to RMESH")
BBText(5,65,"3 - Reset rooms.ini to use B3D meshes")
BBText(5,85,"ESC - Close without doing anything")
Flip()

while (!KeyHit(1)) {
	if (KeyHit(2) || KeyHit(79)) {
		state=1
		Exit()
	}
	if (KeyHit(3) || KeyHit(80)) {
		state=2
		Exit()
	}
	if (KeyHit(4) || KeyHit(81)) {
		state=3
		Exit()
	}
}

let Stri: string
let TemporaryString: string
let f: int

class INIConvert {
	file: string
	section: string
	key: string
	value: string
	static each: INIConvert[] = []
}

let ic: INIConvert

if (state=1) { //convert B3D to Rmesh
	
	if (FileSize("Data/rooms_b3d.ini") == 0) {
		CopyFile ("Data/rooms.ini","Data/rooms_b3d.ini")
	}
	
	f = ReadFile("Data/rooms.ini")
	
	while (!Eof(f)) {
		TemporaryString = Trim(ReadLine(f))
		if (Left(TemporaryString,1) == "[") {
			TemporaryString = Mid(TemporaryString, 2, Len(TemporaryString) - 2)
			
			if (TemporaryString != "room ambience") {
				Stri=GetINIString("Data/rooms.ini",TemporaryString,"mesh path")
				
				let mesh = LoadAnimMesh(Stri)
				SaveRoomMesh(mesh,Replace(Stri,".b3d",".rmesh"))
				
				Cls()
				BBText (5,5,"Converted "+Chr(34)+Stri+Chr(34))
				Flip()
				
				let ic: INIConvert = new INIConvert()
				ic.file="Data/rooms.ini"
				ic.section=TemporaryString
				ic.key="mesh path"
				ic.value=Replace(Stri,".b3d",".rmesh")
				
			}
		}
	}
	
	for (ic of INIConvert.each) {
		PutINIValue(ic.file,ic.section,ic.key,ic.value)
	}
	
	Cls()
	BBText (5,5,"Conversion complete")
	Flip()
	Delay (1000)
	
	CloseFile (f)
} else if (state=2) {
	
	Cls()
	Flip()
	FlushKeys()
	Stri=Input("Path for the room to be converted: ")
	let mesh: int = LoadAnimMesh(Stri)
	SaveRoomMesh(mesh,Replace(Stri,".b3d",".rmesh"))
	Cls()
	BBText(5,5,"Conversion of "+Stri+" complete")
	Flip()
	Delay (1000)
	
} else if (state=3) {
	f = ReadFile("Data/rooms.ini")
	
	while (!Eof(f)) {
		TemporaryString = Trim(ReadLine(f))
		if (Left(TemporaryString,1) == "[") {
			TemporaryString = Mid(TemporaryString, 2, Len(TemporaryString) - 2)
			
			if (TemporaryString != "room ambience") {
				Stri=GetINIString("Data/rooms.ini",TemporaryString,"mesh path")
				
				let ic: INIConvert = new INIConvert()
				ic.file="Data/rooms.ini"
				ic.section=TemporaryString
				ic.key="mesh path"
				ic.value=Replace(Stri,".rmesh",".b3d")
				
			}
		}
	}
	
	for (ic of INIConvert.each) {
		PutINIValue(ic.file,ic.section,ic.key,ic.value)
	}
	
	Cls()
	BBText (5,5,"Reset complete")
	Flip()
	Delay (1000)
	
	CloseFile(f)
}