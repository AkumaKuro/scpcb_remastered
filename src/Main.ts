
let InitErrorStr: string = ""
if (FileSize("fmod.dll")==0) {InitErrorStr=InitErrorStr+ "fmod.dll"+Chr(13)+Chr(10)}
if (FileSize("zlibwapi.dll")==0) {InitErrorStr=InitErrorStr+ "zlibwapi.dll"+Chr(13)+Chr(10)}

if (Len(InitErrorStr)>0) {
	RuntimeError ("The following DLLs were not found in the game directory:"+Chr(13)+Chr(10)+Chr(13)+Chr(10)+InitErrorStr)
}

const Freq		=	44100	//Hz
const Channels	=	64		//Standartwert
const Flags		=	0
const Mode		=	2		//Mode = 2 means that the sounds play in a loop
const F_Offset	=	0
const Lenght	=	0
const MaxVol	=	255
const MinVol	=	0
const PanLeft	=	0
const PanRight	=	255
const PanMid	=	-1
const AllChannel=	-3
const FreeChannel = -1

FSOUND_Init(Freq, Channels, Flags)

function LoadImage_Strict(file: string) {
	if (FileType(file) != FileTypeResult.EXISTS) {
		RuntimeError ("Image " + Chr(34) + file + Chr(34) + " missing. ")
	}

	let tmp = LoadImage(file)
	return tmp
}


class Sound {
	static each: Sound[]
	internalHandle: int
	name: string
	channels: int[] = new Array(32)
	releaseTime: int
}

function AutoReleaseSounds() {
	let snd: Sound
	for (snd of Sound.each) {
		let tryRelease: boolean = true
		for (let i of range(32)) {
			if (snd.channels[i] != 0) {
				if (ChannelPlaying(snd.channels[i])) {
					tryRelease = false
					snd.releaseTime = MilliSecs2()+5000
					break
				}
			}
		}
		if (tryRelease) {
			if (snd.releaseTime < MilliSecs2()) {
				if (snd.internalHandle != 0) {
					FreeSound (snd.internalHandle)
					snd.internalHandle = 0
				}
			}
		}
	}
}

function PlaySound_Strict(sndHandle: int) : int {
	let snd: Sound = Sound.each[sndHandle] // Object
	if (snd != null) {
		let shouldPlay: boolean = true
		for (let i of range(32)) {
			if (snd.channels[i] != 0) {
				if (!ChannelPlaying(snd.channels[i])) {
					if (snd.internalHandle = 0) {
						if (FileType(snd.name) != 1) {
							CreateConsoleMsg("Sound " + Chr(34) + snd.name + Chr(34) + " not found.")
							if (ConsoleOpening) {
								ConsoleOpen = true
							}
						} else {
							if (EnableSFXRelease) {
								snd.internalHandle = LoadSound(snd.name)
							}
						}
						if (snd.internalHandle == 0) {
							CreateConsoleMsg("Failed to load Sound: " + Chr(34) + snd.name + Chr(34))
							if (ConsoleOpening) {
								ConsoleOpen = true
							}
						}
					}
					if (ConsoleFlush) {
						snd.channels[i] = PlaySound(ConsoleFlushSnd)
					} else {
						snd.channels[i] = PlaySound(snd.internalHandle)
					}
					ChannelVolume (snd.channels[i],SFXVolume)
					snd.releaseTime = MilliSecs2()+5000 //release after 5 seconds
					return snd.channels[i]
				}
			} else {
				if (snd.internalHandle == 0) {
					if (FileType(snd.name) != 1) {
						CreateConsoleMsg("Sound " + Chr(34) + snd.name + Chr(34) + " not found.")
						if (ConsoleOpening) {
							ConsoleOpen = True
						}
					} else {
						if (EnableSFXRelease) {
							snd.internalHandle = LoadSound(snd.name)
						}
					}
						
					if (snd.internalHandle == 0) {
						CreateConsoleMsg("Failed to load Sound: " + Chr(34) + snd.name + Chr(34))
						if (ConsoleOpening) {
							ConsoleOpen = True
						}
					}
				}
				if (ConsoleFlushSnd) {
					snd.channels[i] = PlaySound(ConsoleFlushSnd)
				} else {
					snd.channels[i] = PlaySound(snd.internalHandle)
				}
				ChannelVolume(snd.channels[i],SFXVolume)
				snd.releaseTime = MilliSecs2()+5000 //release after 5 seconds
				return snd.channels[i]
			}
		}
	}
	return 0
}

export function LoadSound_Strict(file: string) {
	let snd: Sound = new Sound()
	snd.name = file
	snd.internalHandle = 0
	snd.releaseTime = 0
	if (!EnableSFXRelease) {
		if (snd.internalHandle = 0) { 
			snd.internalHandle = LoadSound(snd.name)
		}
	}
	
	return Handle(snd)
}

function FreeSound_Strict(sndHandle: int) {
	let snd: Sound = Object.Sound(sndHandle)
	if (snd) {
		if (snd.internalHandle != 0) {
			FreeSound(snd.internalHandle)
			snd.internalHandle = 0
		}
		Delete(snd)
	}
}

class Stream {
	sfx: int
	chn: int
}

function StreamSound_Strict(file: string,volume: float = 1.0,custommode=Mode) {
	if (FileType(file$)!=1) {
		CreateConsoleMsg("Sound " + Chr(34) + file$ + Chr(34) + " not found.")
		if (ConsoleOpening) {
			ConsoleOpen = True
		}
		return 0
	}
	
	let st: Stream = new Stream()
	st.sfx = FSOUND_Stream_Open(file$,custommode,0)
	
	if (st.sfx = 0) {
		CreateConsoleMsg("Failed to stream Sound (returned 0): " + Chr(34) + file$ + Chr(34))
		if (ConsoleOpening) {
			ConsoleOpen = True
		}
		return 0
	}
	
	st.chn = FSOUND_Stream_Play(FreeChannel,st.sfx)
	
	if (st.chn = -1) {
		CreateConsoleMsg("Failed to stream Sound (returned -1): " + Chr(34) + file$ + Chr(34))
		if (ConsoleOpening) {
			ConsoleOpen = True
		}
		return -1
	}
	
	FSOUND_SetVolume(st.chn,volume*255)
	FSOUND_SetPaused(st.chn,False)
	
	return Handle(st)
}

function StopStream_Strict(streamHandle: int) {
	let st: Stream = Stream.each[streamHandle]
	
	if (st == Null) {
		CreateConsoleMsg("Failed to stop stream Sound: Unknown Stream")
		return
	}
	if (st.chn == 0 || st.chn == -1) {
		CreateConsoleMsg("Failed to stop stream Sound: Return value "+st.chn)
		return
	}
	
	FSOUND_StopSound(st.chn)
	FSOUND_Stream_Stop(st.sfx)
	FSOUND_Stream_Close(st.sfx)
	Delete(st)
	
}

function SetStreamVolume_Strict(streamHandle: int,volume: float) {
	let st: Stream = Stream.each[streamHandle]
	
	if (st == Null) {
		CreateConsoleMsg("Failed to set stream Sound volume: Unknown Stream")
		return
	}
	if (st.chn == 0 || st.chn == -1) {
		CreateConsoleMsg("Failed to set stream Sound volume: Return value "+st.chn)
		return
}
	
	FSOUND_SetVolume(st.chn,volume*255.0)
	FSOUND_SetPaused(st.chn,False)
	
}

function SetStreamPaused_Strict(streamHandle: int,paused: int) {
	let st: Stream = Object.Stream(streamHandle)
	
	if (st = Null) {
		CreateConsoleMsg("Failed to pause/unpause stream Sound: Unknown Stream")
		return
	}
	if (st.chn == 0 || st.chn == -1) {
		CreateConsoleMsg("Failed to pause/unpause stream Sound: Return value "+st.chn)
		return
	}
	
	FSOUND_SetPaused(st.chn,paused)
	
}

function IsStreamPlaying_Strict(streamHandle: int) {
	let st: Stream = Object.Stream(streamHandle)
	
	if (st  ==  Null) {
		CreateConsoleMsg("Failed to find stream Sound: Unknown Stream")
		return
	}
	if (st.chn == 0 || st.chn == -1) {
		CreateConsoleMsg("Failed to find stream Sound: Return value "+st.chn)
		return
	}
	
	return FSOUND_IsPlaying(st.chn)
	
}

function SetStreamPan_Strict(streamHandle: int,pan: float) {
	let st: Stream = Object.Stream(streamHandle)
	
	if (st = Null) {
		CreateConsoleMsg("Failed to find stream Sound: Unknown Stream")
		return
	}

	if (st.chn == 0 || st.chn == -1) {
		CreateConsoleMsg("Failed to find stream Sound: Return value "+st.chn)
		return
	}
	
	//-1 = Left = 0
	//0 = Middle = 127.5 (127)
	//1 = Right = 255
	let fmod_pan: int = 0
	fmod_pan = Int((255.0/2.0)+((255.0/2.0)*pan))
	FSOUND_SetPan(st.chn,fmod_pan)
	
}

function UpdateStreamSoundOrigin(streamHandle: int,cam: int,entity: int,trange: float = 10,volume: float = 1.0) {
	trange = Max(trange,1.0)
	
	if (volume>0) {
		
		let dist: float = EntityDistance(cam, entity) / trange
		if (1 - dist > 0 && 1 - dist < 1) {
			
			let panvalue: float = Sin(-DeltaYaw(cam,entity))
			
			SetStreamVolume_Strict(streamHandle,volume*(1-dist)*SFXVolume)
			SetStreamPan_Strict(streamHandle,panvalue)
		} else {
			SetStreamVolume_Strict(streamHandle,0.0)
		}
	} else {
		if (streamHandle != 0) {
			SetStreamVolume_Strict(streamHandle,0.0)
		} 
	}
}

function LoadMesh_Strict(File$,parent=0) {
	if (FileType(File$) != 1) {RuntimeError("3D Mesh " + File$ + " not found.")}
	tmp = LoadMesh(File$, parent)
	if (tmp == 0) {RuntimeError("Failed to load 3D Mesh: " + File)}
	return tmp  
}   

function LoadAnimMesh_Strict(File: string,parent=0) {
	DebugLog (File)
	if (FileType(File) != 1) {RuntimeError ("3D Animated Mesh " + File + " not found.")}
	let tmp = LoadAnimMesh(File, parent)
	if (tmp = 0) {RuntimeError ("Failed to load 3D Animated Mesh: " + File )}
	return tmp
}   

//don't use in LoadRMesh, as Reg does this manually there. If you wanna fuck around with the logic in that function, be my guest 
function LoadTexture_Strict(File: string, flags = 1) {
	if (FileType(File$) != 1) {RuntimeError("Texture " + File$ + " not found.")}
	tmp = LoadTexture(File$, flags+(256*(EnableVRam=True)))
	if (tmp = 0) {RuntimeError("Failed to load Texture: " + File)}
	return tmp 
}   

function LoadBrush_Strict(file: string,flags,u: float=1.0,v: float=1.0) {
	if (FileType(file)!=1) {RuntimeError("Brush Texture " + file$ + "not found.")}
	tmp = LoadBrush(file$, flags, u, v)
	if (tmp == 0) {RuntimeError("Failed to load Brush: " + file)}
	return tmp 
} 

function LoadFont_Strict(file: string = "Tahoma", height=13, bold=0, italic=0, underline=0) {
	if (FileType(file$)!=1) {RuntimeError("Font " + file$ + " not found.")}
	tmp = LoadFont(file, height, bold, italic, underline)  
	if (tmp == 0) {RuntimeError("Failed to load Font: " + file$ )}
	return tmp
}


// -- Declare Windows API constants.
const C_GWL_STYLE = -16
const C_WS_POPUP = 0x80000000
const C_HWND_TOP = 0
const C_SWP_SHOWWINDOW = 0x0040

// -- Get the width and height of the desktop and place them into these globals.
var G_desktop_screen_width
var G_desktop_screen_height
GetDesktopSize()

var G_viewport_x = 0
var G_viewport_y = 0
var G_viewport_width = G_desktop_screen_width
var G_viewport_height = G_desktop_screen_height

// -- Get the OS handle of the app window.
var G_app_handle = SystemProperty( "AppHWND" )

if (!Windowed3D()) {
	RuntimeError("FATAL ERROR: Your computer does not support the rendering of 3D graphics within a window.")
}

// == FUNCTIONS ==


function GetDesktopSize() {
	// Gets the width and height of the desktop on the main monitor and returns them in
	// the globals G_desktop_screen_width and G_desktop_screen_height.
	
	let rectangle = CreateBank( 16 )
	api_GetClientRect( api_GetDesktopWindow(), rectangle )
	G_desktop_screen_width = PeekInt( rectangle, 8 ) - PeekInt( rectangle, 0 )
	G_desktop_screen_height = PeekInt( rectangle, 12 ) - PeekInt( rectangle, 4 )
	FreeBank(rectangle)
}


export function SyncGame() {
	// NOTES:
	// This function should be run immediately before a game session begins and also after resuming from a pause.

	// *** At this point everything should be setup and ready to start/restart the game immediately. ***

	// Reset the input devices.
	MoveMouse(G_viewport_center_x, G_viewport_center_y)
	FlushMouse()
	FlushKeys()
	MouseXSpeed()
	MouseYSpeed()
	MouseHit(1)
	MouseHit(2)
	MouseHit(3)

	// Set and render the backbuffer, and then flip it to the frontbuffer.
	SetBuffer(BackBuffer())
	RenderWorld()
	Flip()

	// Synch the timing. This assumes that the 'G_old_time' global holds the Millisecs() time
	// set at the start of the previous loop and is used with render-tweening or delta-timing.
	G_old_time = MilliSecs()
	
}

export var KeyName: string[] = new Array(211)
KeyName[1] = "Esc"
for (let i of range(2, 11)) {
	KeyName[i] = Str(i - 1)
}
KeyName[11]="0"
KeyName[12]="-"
KeyName[13]="="
KeyName[14]="Backspace"
KeyName[15]="TAB"
KeyName[16]="Q"
KeyName[17]="W"
KeyName[18]="E"
KeyName[19]="R"
KeyName[20]="T"
KeyName[21]="Y"
KeyName[22]="U"
KeyName[23]="I"
KeyName[24]="O"
KeyName[25]="P"
KeyName[26]="["
KeyName[27]="]"
KeyName[28]="Enter"
KeyName[29]="Left Ctrl"
KeyName[30]="A"
KeyName[31]="S"
KeyName[32]="D"
KeyName[33]="F"
KeyName[34]="G"
KeyName[35]="H"
KeyName[36]="J"
KeyName[37]="K"
KeyName[38]="L"
KeyName[39]=";"
KeyName[40]="'"
KeyName[42]="Left Shift"
KeyName[43]="\\"
KeyName[44]="Z"
KeyName[45]="X"
KeyName[46]="C"
KeyName[47]="V"
KeyName[48]="B"
KeyName[49]="N"
KeyName[50]="M"
KeyName[51]=","
KeyName[52]="."
KeyName[54]="Right Shift"
KeyName[56]="Left Alt"
KeyName[57]="Space"
KeyName[58]="Caps Lock"
KeyName[59]="F1"
KeyName[60]="F2"
KeyName[61]="F3"
KeyName[62]="F4"
KeyName[63]="F5"
KeyName[64]="F6"
KeyName[65]="F7"
KeyName[66]="F8"
KeyName[67]="F9"
KeyName[68]="F10"
KeyName[157]="Right Control"
KeyName[184]="Right Alt"
KeyName[200]="Up"
KeyName[203]="Left"
KeyName[205]="Right"
KeyName[208]="Down"

export var OptionFile: string = "options.ini"

// <summary>Pokes a NULL terminated string to a bank.</summary>
// <param name="bankHandle">Bank handle to poke to.</param>
// <param name="offset">Offset in bytes that the poke operation will be started at.</param>
// <param name="value">The string to poke.</param>
// <remarks>If the end of the bank is reached, string will still end with a NULL byte.</remarks>


// <subsystem>Blitz.Bank</subsystem>
export function PokeString(bankHandle: int, offset: int, value: string) {
	
	let stringPos		= 1
	let bankPos		= offset + stringPos - 1
	let bankLength	= BankSize(bankHandle) - 1
	
	while ((stringPos <= Len(value)) && (bankPos < bankLength)) {
		PokeByte (bankHandle, bankPos, Asc(Mid(value, stringPos, 1)))
		
		// Move to next char
		bankPos 	= bankPos + 1
		stringPos 	= stringPos + 1
	}
	
	// Add the null byte to end of string
	PokeByte (bankHandle, bankPos, 0)
	
}

export function PeekString(bankHandle: int, offset: int) : string {
	
	let bankPos		= offset
	let bankLength	= BankSize(bankHandle)
	let peekedString: string = ""
	let endFound: boolean = false
	let currentByte	= 0
	
	while ((bankPos < bankLength) && !endFound) {
		
		currentByte	= PeekByte(bankHandle, bankPos)
		
		if (currentByte == 0) {
			endFound = true
		} else {
			peekedString = peekedString + Chr(currentByte)
		}
		
		bankPos = bankPos + 1
	}
	
	return peekedString
	
}

export function DumpBank(bankHandle: int, rowSize: int = 16) {
	
	let dumpString: string	= ""
	let ascString: string	= ""
	
	// Header
	DebugLog("Bank Size: " + BankSize(bankHandle))
	for (let i of range(BankSize(bankHandle))) {
		
		// Dump is raw data (as hex), asc is the ascii data
		dumpString = dumpString + Right(Hex(PeekByte(bankHandle, i)), 2) + " "
		ascString	= ascString + Chr(PeekByte(bankHandle, i))
		
		// Dump the line if we're at the end of the row
		if (i % rowSize == rowSize - 1) {
			DebugLog(dumpString + "   " + ascString)
			dumpString = ""
			ascString = ""
		}
	}
	
	// Any extra data not dumped.
	DebugLog (dumpString + "   " + ascString)	
}


export function File_GetDirName(path: string): string {
	// Strip trailing slashes & return the part of the path that isn't the filename
	if (Right(path, 1) == "/" || Right(path, 1) == "\\") {
		path = Left(path, Len(path) - 1)
	}
	return Left(path, Len(path) - Len(File_GetFileName(path)))
}

export function File_GetFileName(path: string): string {
	
	if (path = "") {return ""}
	
	let fileName: string	= File_SplitAfterChar(File_ConvertSlashes(path), "/")
	if (fileName == "") {
		fileName = path
	}
	
	return fileName
}

export function File_GetExtension(fileName$) : string {
	return File_SplitAfterChar(File_ConvertSlashes(fileName$), ".")
}

function File_ConvertSlashes(fileName: string): string {
	return Replace(fileName, "\\", "/")
}

function File_SplitAfterChar(fileName: string, char: string): string {
	
	let afterChar: string	= ""
	
	// Start at the end of the name, and look for the char
	for (let stringPos of range(Len(fileName), 0, -1)) {
		if (Mid(fileName, stringPos, 1) == char) {
			afterChar = Right(fileName, Len(fileName) - stringPos)
			break
		}
	}
	
	return afterChar	
}

const ZIPAPI_DEFLATED: int 				= 8

const ZIPAPI_APPEND_CREATE			= 0

const ZIPAPI_APPEND_CREATEAFTER		= 1

const ZIPAPI_APPEND_ADDINZIP		= 2

const ZIPAPI_DEFAULT_COMPRESSION: int	= -1

const ZIPAPI_NO_COMPRESSION         = 0

const ZIPAPI_BEST_SPEED             = 1

const ZIPAPI_BEST_COMPRESSION       = 9

const ZIPAPI_MAX_WBITS: int				= 15
const ZIPAPI_DEF_MEM_LEVEL			= 8
const ZIPAPI_DEFAULT_STRATEGY		= 0

const ZIPAPI_DATA_HEADER: int			= 10101982

const ZIPAPI_OK: int					= 0

const ZIPAPI_EOF					= 0

const ZIPAPI_STREAM_END				= 1

const ZIPAPI_NEED_DICT				= 2

const ZIPAPI_ERRNO					= -1

const ZIPAPI_STREAM_ERROR			= -2

const ZIPAPI_DATA_ERROR				= -3

const ZIPAPI_MEM_ERROR				= -4

const ZIPAPI_BUF_ERROR				= -5

const ZIPAPI_VERSION_ERROR			= -6

const ZIPAPI_END_OF_LIST_OF_FILE: int	= -100

const ZIPAPI_PARAMERROR: int			= -102

const ZIPAPI_BADZIPFILE				= -103

const ZIPAPI_INTERNALERROR			= -104

const ZIPAPI_CRCERROR				= -105

const ZIPAPI_INVALIDPOINTER: int		= -51

const ZIPAPI_INVALIDBANK: int			= -50

const ZIPAPI_HEADER_INT: int			= 67324752

function ZipApi_CompressBank(bankHandle: int, compressionLevel: int = ZIPAPI_DEFAULT_COMPRESSION): int {
	
	// Check inputs
	if (bankHandle < 1) {return ZIPAPI_INVALIDBANK}
	
	// Compress the bank and append our data to the end
	let compressedBank	= ZipApi_Compress(bankHandle, compressionLevel)
	
	// Check it worked - return if not
	if (compressedBank < 1) {return compressedBank}
	
	// Resize the result to accomodata header, then add our header data
	// and uncompressed length to the end of the bank
	ResizeBank(compressedBank, BankSize(compressedBank) + 8)
	
	PokeInt(compressedBank, BankSize(compressedBank) - 8, ZIPAPI_DATA_HEADER)
	PokeInt(compressedBank, BankSize(compressedBank) - 4, BankSize(bankHandle))
	
	return compressedBank 
	
}

function ZipApi_UnCompressBank(bankHandle: int): int {
	
	// Check inputs (valid bank & has header)
	if (bankHandle < 1) {return ZIPAPI_INVALIDBANK}
	if (PeekInt(bankHandle, BankSize(bankHandle) - 8) != ZIPAPI_DATA_HEADER) {return ZIPAPI_INVALIDBANK}
	
	// Get new size
	let dataSize	= PeekInt(bankHandle, BankSize(bankHandle) - 4)
	
	// Create a new bank from resized data( so we don't alter the original input )
	let dataBank	= CreateBank(BankSize(bankHandle) - 8)
	CopyBank(bankHandle, 0, dataBank, 0, BankSize(dataBank))
	
	// Uncompress it
	let returnBank	= ZipApi_UnCompress(dataBank, dataSize)
	
	// Cleanup & return
	FreeBank (dataBank)
	return returnBank	
}

function ZipApi_Compress(bankHandle: int, compressionLevel: int = ZIPAPI_DEFAULT_COMPRESSION): int {
	
	// Check bank input - return 0 if invalid
	if (bankHandle < 1) {return 0}
	if (BankSize(bankHandle) < 1) {return 0}
	
	// Check compression level and limit appropriately
	if (compressionLevel < 1) {compressionLevel = 1}
	if (compressionLevel > 9) {compressionLevel = 9}
	
	// Create a bank to place compressed data into
	let destBank = CreateBank(ZlibWapi_CompressBound(BankSize(bankHandle)))
	
	// Create bank to store dest size & populate
	let destSize	= CreateBank(4)
	PokeInt(destSize, 0, BankSize(destBank))
	
	// Compress
	let zipResult = ZlibWapi_Compress2(destBank, destSize, bankHandle, BankSize(bankHandle), compressionLevel)
	
	// Check bank was compressed properly	
	if (zipResult != ZIPAPI_OK) {
		
		// Failed, so cleanup & return error
		FreeBank (destSize)
		FreeBank (destBank)
		return zipResult
		
	}
	
	// Resize result
	ResizeBank(destBank, PeekInt(destSize, 0))
	
	// Cleanup & return result
	FreeBank(destSize)
	return destBank
}

function ZipApi_UnCompress(bankHandle: int, unpackedSize: int = 0) : int {
	
	// Check bank input - return 0 if invalid
	if (bankHandle < 1) {
		return ZIPAPI_INVALIDBANK
	}
	if (BankSize(bankHandle) < 1) {
		return ZIPAPI_INVALIDBANK
	}
	
	// Create a bank to place uncompressed data into
	// If no size is specified, use input * 100 just to be safe
	if (unpackedSize == 0) {unpackedSize = BankSize(bankHandle) * 100}
	let destBank	= CreateBank(unpackedSize)
	
	// Create bank to store uncompressed size & populate
	let destSize	= CreateBank(4)
	PokeInt(destSize, 0, BankSize(destBank))
	
	// Compress
	let zipResult	= ZlibWapi_UnCompress(destBank, destSize, bankHandle, BankSize(bankHandle))
	
	// Check bank was compressed properly	
	if (zipResult != ZIPAPI_OK) {
		
		// Failed, so cleanup & return error
		FreeBank(destSize)
		FreeBank(destBank)
		return zipResult
		
	}
	
	// Resize result
	ResizeBank(destBank, PeekInt(destSize, 0))
	
	// Cleanup & return result
	FreeBank (destSize)
	return destBank	
	
}

function ZipApi_Open(fileName: string) : int {
	return ZlibWapi_UnzOpen(fileName)
}

function ZipApi_Close(zipHandle: int, cleanUp: boolean = true) : int {
	
	if (cleanUp) {
		
		ZipApi_GotoFirstFile(zipHandle)
		
		do {
			
			let currentFile: ZIPAPI_UnzFileInfo = ZipApi_GetCurrentFileInfo(zipHandle)
			
			if (currentFile != null) {
				if (FileType(SystemProperty("tempdir") + File_GetFileName(currentFile.FileName)) == FILETYPE_FOUND) {
					DeleteFile(SystemProperty("tempdir") + File_GetFileName(currentFile.FileName))		
				}
				
			}
			
		} while (ZipApi_GotoNextFile(zipHandle) != ZIPAPI_END_OF_LIST_OF_FILE)
		
	}
	
	return ZlibWapi_UnzClose(zipHandle)
	
}

function ZipApi_ExtractFile(zipHandle, fileName: string, destName: string = "", password: string = "") : string {
	
	// Check inputs
	if (zipHandle < 1) {return ""}
	if (fileName = "") {return ""}
	
	// Get the name of the extracted file
	if (destName == "") {
		destName = SystemProperty("TEMPDIR") + File_GetFileName(fileName)
	}
	
	let prevFile: ZIPAPI_UnzFileInfo = ZipApi_GetCurrentFileInfo(zipHandle)
	ZipApi_GotoFirstFile(zipHandle)

	// Find file
	if (ZlibWapi_UnzLocateFile(zipHandle, File_ConvertSlashes(fileName), false) == ZIPAPI_END_OF_LIST_OF_FILE) {	// Couldn't find it
		
		// Reset
		if (prevFile) {
			ZlibWapi_UnzLocateFile(zipHandle, prevFile.FileName, false)
			ZIPAPI_UnzFileInfo_Dispose(prevFile)
		}
		
		return ""		
		
	}
	
	let fileInfo: ZIPAPI_UnzFileInfo = ZipApi_GetCurrentFileInfo(zipHandle)
	
	// Create a buffer to store unpacked contents in
	let fileBuffer	= CreateBank(fileInfo.UnCompressedSize)
	
	// Open the file for reading, read all bytes and cleanup
	let fileHandle
	
	// Check if we're using a password
	if (password != "") {
		// Password protected
		fileHandle	= ZlibWapi_UnzOpenCurrentFilePassword(zipHandle, password$)
	} else {
		fileHandle	= ZlibWapi_UnzOpenCurrentFile(zipHandle)
	}
	
	if (fileHandle != ZIPAPI_OK) {
		return ""
	}
	
	// Read all bytes (depacks too)
	let bytesRead	= ZlibWapi_UnzReadCurrentFile(zipHandle, fileBuffer, BankSize(fileBuffer))
	
	if (bytesRead = ZIPAPI_DATA_ERROR) { // Extraction error
		destName = ""
	}
	
	// Cleanup
	ZlibWapi_UnzCloseCurrentFile(zipHandle)
	
	if (bytesRead == fileInfo.UnCompressedSize) {
		// Save
		let fileOut = WriteFile(destName)
		WriteBytes(fileBuffer, fileOut, 0, BankSize(fileBuffer))
		CloseFile(fileOut)
	}
	
	// Reset
	if (prevFile) {
		ZlibWapi_UnzLocateFile(zipHandle, prevFile.FileName, False)
		ZIPAPI_UnzFileInfo_Dispose(prevFile)
	}
	
	// Cleanup
	FreeBank(fileBuffer)
	
	return destName
	
}

function ZipApi_ExtractFileAsBank(zipHandle, fileName$, password$ = "") : int {
	
	// Check inputs
	if (zipHandle < 1) {return ZIPAPI_INVALIDPOINTER}
	if (fileName == "") {return ZIPAPI_END_OF_LIST_OF_FILE}
	
	// Find file & get quick information
	let prevFile: ZIPAPI_UnzFileInfo = ZipApi_GetCurrentFileInfo(zipHandle)
	ZipApi_GotoFirstFile(zipHandle)
	
	// Find file
	if (ZlibWapi_UnzLocateFile(zipHandle, File_ConvertSlashes(fileName), False) = ZIPAPI_END_OF_LIST_OF_FILE) { // Couldn't find it
		
		// Reset
		if (prevFile != Null) {
			ZlibWapi_UnzLocateFile(zipHandle, prevFile.FileName, False)
			ZIPAPI_UnzFileInfo_Dispose(prevFile)
		}
		
		return ZIPAPI_END_OF_LIST_OF_FILE		
		
	}
	
	let fileInfo: ZIPAPI_UnzFileInfo = ZipApi_GetCurrentFileInfoFast(zipHandle)
	
	// Create a buffer to store unpacked contents in
	let fileBuffer	= CreateBank(fileInfo.UnCompressedSize)
	
	// Open the file for reading, read all bytes and cleanup
	let fileHandle
	
	// Check if we're using a password
	if (password != "") {
		// Password protected
		fileHandle	= ZlibWapi_UnzOpenCurrentFilePassword(zipHandle, password$)
	} else {
		fileHandle	= ZlibWapi_UnzOpenCurrentFile(zipHandle)
	}
	
	if (fileHandle != ZIPAPI_OK) {
		return 0
	}
	
	// Read all bytes (depacks too)
	let bytesRead	= ZlibWapi_UnzReadCurrentFile(zipHandle, fileBuffer, BankSize(fileBuffer))
	if (bytesRead = ZIPAPI_DATA_ERROR) {
		FreeBank(fileBuffer)
		fileBuffer = 0
	}
	
	// Reset
	if (prevFile != Null) {
		ZlibWapi_UnzLocateFile(zipHandle, prevFile.FileName, False)
		ZIPAPI_UnzFileInfo_Dispose(prevFile)
	}
	
	// Cleanup
	ZlibWapi_UnzCloseCurrentFile(zipHandle)
	
	return fileBuffer
	
}

function ZipApi_GetFileInfo(zipHandle: int, fileName: string, caseSensitive: boolean = false) : ZIPAPI_UnzFileInfo | null {
	
	// Check inputs
	if (zipHandle < 1) {return null}
	if (fileName == "") {return null}
	
	// Store the current file, so we can reset file pointer afterwards
	let previousFile: ZIPAPI_UnzFileInfo 	= ZipApi_GetCurrentFileInfo(zipHandle)
	let fileInfo: ZIPAPI_UnzFileInfo		= Null
	
	// Find the file
	if (ZlibWapi_UnzLocateFile(zipHandle, fileName, caseSensitive) == ZIPAPI_END_OF_LIST_OF_FILE) {
		//TODO: Not found - insert your error code here (if you wish)
		return null
	}
	
	// Get file information
	fileInfo = ZipApi_GetCurrentFileInfo(zipHandle)
	
	// Reset internal pointer
	ZlibWapi_UnzLocateFile(zipHandle, previousFile.FileName, False)
	
	// Cleanup and return
	ZIPAPI_UnzFileInfo_Dispose(previousFile)
	
	return fileInfo
	
}

function ZipApi_GotoFirstFile(zipHandle: int) {
	if (zipHandle < 1) {return ZIPAPI_INVALIDPOINTER}
	return ZlibWapi_UnzGoToFirstFile(zipHandle)
}

function ZipApi_GotoNextFile(zipHandle) {
	if (zipHandle < 1) {return ZIPAPI_INVALIDPOINTER}
	return ZlibWapi_UnzGoToNextFile(zipHandle)
}

function ZipApi_GetCurrentFileInfo(zipHandle: int) : ZIPAPI_UnzFileInfo {
	if (zipHandle < 1) {return Null}
	
	// Get default information
	let fileInfo: ZIPAPI_UnzFileInfo = ZipApi_GetCurrentFileInfoFast(zipHandle)
	
	// Now we want to get filename and other fields
	let tBank				= CreateBank(ZIPAPI_UNZFILEINFO_LENGTH)
	let fileNameBank		= CreateBank(fileInfo.FileNameLength + 1)
	let extraFieldBank	= CreateBank(fileInfo.ExtraFieldLength + 1)
	let commentBank		= CreateBank(fileInfo.CommentLength + 1)
	
	// Call method a second time - this is so we get the exact length of these fields
	ZlibWapi_UnzGetCurrentFileInfo(zipHandle, tBank, fileNameBank, fileInfo.FileNameLength, extraFieldBank, fileInfo.ExtraFieldLength, commentBank, fileInfo.CommentLength)
	
	// Peek our strings
	fileInfo.FileName	= PeekString(fileNameBank, 0)
	fileInfo.ExtraField	= PeekString(extraFieldBank, 0)
	fileInfo.Comment	= PeekString(commentBank, 0)
	
	// Cleanup & Return
	FreeBank(tBank)
	FreeBank(fileNameBank)
	FreeBank(extraFieldBank)
	FreeBank(commentBank)
	
	return fileInfo
	
}

function ZipApi_GetGlobalInfo(zipHandle): ZIPAPI_GlobalInfo {
	
	if (zipHandle < 1) {
		return Null
	}
	
	let zipInfo: ZIPAPI_GlobalInfo = Null
	
	// Create buffer bank and get global info
	let infoBank = CreateBank(ZIPAPI_GLOBALINFO_LENGTH)
	
	if (ZlibWapi_UnzGetGlobalInfo(zipHandle, infoBank) != ZIPAPI_OK) {
		// TODO: Error message here
		return Null
	}
	
	zipInfo = ZIPAPI_GlobalInfo_FromBank(infoBank)
	
	// Now get the comment
	let commentBank	= CreateBank(zipInfo.CommentLength + 1)
	
	if (ZlibWapi_UnzGetGlobalComment(zipHandle, commentBank, zipInfo.CommentLength) != ZIPAPI_OK) {
		// TODO: Error message here
		return Null
	}
	
	zipInfo.Comment		= PeekString(commentBank, 0)
	
	// Cleanup & Return
	FreeBank(infoBank)
	FreeBank(commentBank)
	
	return zipInfo
	
}

// <summary>Gets the total uncompressed size of a Zip file.</summary>
// <param name="zipHandle">Zip file handle.</param>
// <returns>Integer containing the total uncompressed size in bytes, or an error code.</returns>
// <subsystem>Blitz.File.ZipApi</subsystem>
function ZipApi_GetUnpackedSize(zipHandle: int): int {
	
	// Check inputs
	if (zipHandle < 1) {
		return ZIPAPI_INVALIDPOINTER
	}
	
	let totalSize	= 0
	
	// Iterate through files, getting their uncompressed size and adding it to the total
	ZipApi_GotoFirstFile(zipHandle)
	do {
		let fileInfo: ZIPAPI_UnzFileInfo = ZipApi_GetCurrentFileInfo(zipHandle)
		
		if (fileInfo != Null) {
			totalSize += fileInfo.UnCompressedSize
			ZIPAPI_UnzFileInfo_Dispose(fileInfo)
		}
		
	} while (!(ZipApi_GotoNextFile(zipHandle) = ZIPAPI_END_OF_LIST_OF_FILE))
	
	return totalSize
	
}

// <summary>Check that a file has the correct header.</summary>
// <param name="fileName">The name of the file to check.</param>
// <remarks>Use this to verify a zip file's validity.</remarks>
// <returns>True if the file is valid, or false if not.</returns>
// <subsystem>Blitz.File.ZipApi</subsystem>
function ZipApi_VerifyZipFileHeader(fileName: string) {
	
	if (FileType(fileName) != 1) {return False}
	
	// Open the file and read the first four bytes
	let fileIn	= ReadFile(fileName)
	let header	= ReadInt(fileIn)	
	CloseFile(fileIn)
	
	return (header == ZIPAPI_HEADER_INT)
	
}

function ZipApi_CreateZip(fileName: string, fileMode: int = ZIPAPI_APPEND_CREATE) {
	return ZlibWapi_ZipOpen(fileName, fileMode)
}

function ZipApi_AddFile(zipHandle, fileName: string, includePath: boolean = True, password: string = "") : int {
	
	// Check inputs
	if (zipHandle < 1) {return false}
	if (fileName$ = "") {return false}
	if (FileType(fileName) != 1) {return false}
	
	// Read file data into memory
	let fileData	= CreateBank(FileSize(fileName$))
	let fileIn	= ReadFile(fileName)
	ReadBytes(fileData, fileIn, 0, BankSize(fileData)) 
	CloseFile(fileIn)
	
	// Generate the filename as it will appear in the Zip archive
	let zipFileName: string = fileName
	if (!includePath) {	// Strip path
		zipFileName = File_GetFileName(zipFileName)
	}
	
	// Add file data to the zip (possible password protected)
	if (password = "") {
		ZipApi_ZipOpenFileInZip(zipHandle, zipFileName$, ZIPAPI_Date_FromFile(fileName))
	} else {
		ZipApi_ZipOpenFileInZip(zipHandle, zipFileName$, ZIPAPI_Date_FromFile(fileName), "", 0, 0, True, ZIPAPI_DEFAULT_COMPRESSION, password, ZipApi_Crc32(fileData))
	}
	
	// Write our data
	ZlibWapi_ZipWriteFileInZip(zipHandle, fileData, BankSize(fileData))
	
	// Cleanup & Close
	FreeBank(fileData)
	ZlibWapi_ZipCloseFileInZip(zipHandle)
	
	return True
	
}

function ZipApi_AddBankAsFile(zipHandle, bankHandle: int, fileName: String, password: String = "") : int {
	
	// Check inputs
	if (zipHandle < 1) {return false}
	if (bankHandle < 1) {return false}
	if (fileName$ == "") {return false}
	
	// Add file data to the zip
	if (password = "") {
		ZipApi_ZipOpenFileInZip(zipHandle, fileName$, ZIPAPI_Date_Create())
	} else {
		// Password protected
		ZipApi_ZipOpenFileInZip(zipHandle, fileName$, ZIPAPI_Date_Create(), "", 0, 0, True, ZIPAPI_DEFAULT_COMPRESSION, password, ZipApi_Crc32(bankHandle))	
	}
	
	// Write our data
	let fileResult = ZlibWapi_ZipWriteFileInZip(zipHandle, bankHandle, BankSize(bankHandle))
	
	// Cleanup & Close
	ZlibWapi_ZipCloseFileInZip(zipHandle)
	
	return (fileResult == ZIPAPI_OK)
	
}

function ZipApi_CloseZip(zipHandle: int, globalComment: string = "") {
	ZlibWapi_ZipClose(zipHandle, globalComment)
}

function ZipApi_Crc32(bankHandle: int) : int {
	
	// Check bank handle
	if (bankHandle < 1) {
		return 0
	}
	
	// Initialise CRC with an empty bank
	let tempBank	= CreateBank(0)
	let crcValue	= ZlibWapi_Crc32(0, tempBank, 0)
	FreeBank(tempBank)
	
	// Calculate & return
	crcValue	=  ZlibWapi_Crc32(crcValue, bankHandle, BankSize(bankHandle))
	
	return crcValue
	
}

function ZipApi_Adler32(bankHandle: int): int {
	
	// Check bank handle
	if (bankHandle < 1) {return 0}
	
	// Initialise CRC with an empty bank
	let tempBank		= CreateBank(0)
	let adlerValue	= ZlibWapi_Adler32(0, tempBank, 0)
	FreeBank (tempBank)
	
	// Calculate & return
	adlerValue	=  ZlibWapi_Adler32(adlerValue, bankHandle, BankSize(bankHandle))
	
	return adlerValue
	
}

function ZipApi_ZipOpenFileInZip(zipHandle, fileName: string, fileDate: ZIPAPI_Date, comment: string = "", extraFieldLocal: int = 0, extraFieldGlobal: int = 0, compress: boolean = true, compressionLevel: int = ZIPAPI_DEFAULT_COMPRESSION, password: string = "", crc32 = 0) : int {
	
	// Check inputs
	if (zipHandle < 1) {
		return False
	}
	
	// Set compression mode
	let compressionMethod
	if (compress) {
		compressionMethod = ZIPAPI_DEFLATED
	} else {
		compressionMethod = 0
	}
	
	// Create zipInfo bank
	let zipInfo = CreateBank (36)
	ZipApi_Date_ToBank(fileDate, zipInfo, 0)
	
	let localFieldBank: int = extraFieldLocal
	let globalFieldBank: int = extraFieldGlobal
	
	// Create banks for extra fields (if appropriate)
	if (localFieldBank = 0) {
		localFieldBank = CreateBank(0)
	}
	if (globalFieldBank = 0) {
		globalFieldBank = CreateBank(0)
	}
	
	// Open zip file
	let openFileResult
	if (password = "") {
		openFileResult = ZlibWapi_ZipOpenNewFileInZip(zipHandle, fileName, zipInfo, localFieldBank, BankSize(localFieldBank), globalFieldBank, BankSize(globalFieldBank), comment, compressionMethod, compressionLevel)
	} else {
		// Password Protected
		openFileResult = ZlibWapi_ZipOpenNewFileInZip3(zipHandle, fileName, zipInfo, localFieldBank, BankSize(localFieldBank), globalFieldBank, BankSize(globalFieldBank), comment, compressionMethod, compressionLevel, 0, -ZIPAPI_MAX_WBITS, ZIPAPI_DEF_MEM_LEVEL, ZIPAPI_DEFAULT_STRATEGY, password, crc32)
	}
	
	// Cleanup
	FreeBank(zipInfo)
	if (extraFieldLocal == 0) {
		FreeBank(localFieldBank)
	}
	if (extraFieldGlobal == 0) {
		FreeBank(globalFieldBank)
	}
	
	return (openFileResult == ZIPAPI_OK)
	
}

// <summary>Gets information about the current file in an opened ZIP.</summary>
// <param name="zipHandle">ZIP handle opened with ZipApi_Open.</param>
// <returns>ZIPAPI_UnzFileInfo object, or null if it failed.</returns>
// <subsystem>Blitz.File.ZipApi</subsystem>
function ZipApi_GetCurrentFileInfoFast(zipHandle: int) : ZIPAPI_UnzFileInfo {
	if (zipHandle < 1) {
		return Null
	}
	
	let fileInfo: ZIPAPI_UnzFileInfo = Null
	
	// Create a bank for file information
	let infoBank	= CreateBank(ZIPAPI_UNZFILEINFO_LENGTH)
	
	// A temporary bank, because it tends to crash if 0 is passed
	let tBank		= CreateBank(0)
	
	// Get information
	ZlibWapi_UnzGetCurrentFileInfo(zipHandle, infoBank, tBank, 0, tBank, 0, tBank, 0) 
	fileInfo = ZIPAPI_UnzFileInfo_FromBank(infoBank)
	
	// Check file info is valid
	if (fileInfo == null) {
		return Null
	}
	
	// Don't get anything else, just cleanup and done
	FreeBank(tBank)
	FreeBank(infoBank)
	
	return fileInfo
	
}

// --------------------------------------------------
// -- Type : ZIPAPI_UnzFileInfo
// --------------------------------------------------

// <summary>Size of the ZIPAPI_UnzFileInfo type in bytes.</summary>
// <subsystem>Blitz.File.ZipApi</subsystem>
const ZIPAPI_UNZFILEINFO_LENGTH: int = 80

// <summary>Information about a file within a Zip archive.</summary>
// <subsystem>Blitz.File.ZipApi</subsystem>
class ZIPAPI_UnzFileInfo {
	
	Version: int				// The Zip version this file was made by.
	VersionNeeded: int		// Zip version needed to extract.
	Flag: int					// General purpose bit flag.
	CompressionMethod: int	// Compression method.
	DosDate: int				// Last mod file data in Dos format.
	Crc32					// CRC-32 of the file.
	CompressedSize: int		// Compressed size in bytes.
	UnCompressedSize: int		// UnCompressed size in bytes.
	
	DiskNumberStart: int		// Disk number start.
	InternalFileAttr: int		// Internal file attributes.
	ExternalFileAttr: int		// External file attributes.
	
	Date: ZIPAPI_Date		// Date modified.
	
	//== Blitz Specific Fields - saves you having to mess around with strings ==//
	FileName: string				// File name
	ExtraField: string			// Extra field
	Comment: string				// Comment	
	
	// == Internal
	FileNameLength: int		// Length of the filename.
	ExtraFieldLength: int		// Length of the extra field.
	CommentLength: int		// Length of the file comment.
}

// <summary>Create a ZIPAPI_UnzFileInfo object and read data from the contents of a bank.</summary>
// <param name="bankIn">The bank to read from.</param>
// <returns>ZIPAPI_UnzFileInfo, or Null if it couldn't be read.</returns>
// <subsystem>Blitz.File.ZipApi</subsystem>
function ZIPAPI_UnzFileInfo_FromBank(bankIn: int) : ZIPAPI_UnzFileInfo {
	
	// Check inputs
	if (bankIn < 1) {
		return Null
	}
	if (BankSize(bankIn) != ZIPAPI_UNZFILEINFO_LENGTH) {
		return Null
	}
	
	let info: ZIPAPI_UnzFileInfo = new ZIPAPI_UnzFileInfo()
	
	info.Version			= PeekInt(bankIn, 0)
	info.VersionNeeded		= PeekInt(bankIn, 4)
	info.Flag				= PeekInt(bankIn, 8)
	info.CompressionMethod	= PeekInt(bankIn, 12)
	info.DosDate			= PeekInt(bankIn, 16)
	info.Crc32				= PeekInt(bankIn, 20)
	info.CompressedSize		= PeekInt(bankIn, 24)
	info.UnCompressedSize	= PeekInt(bankIn, 28)
	info.FileNameLength		= PeekInt(bankIn, 32)
	info.ExtraFieldLength	= PeekInt(bankIn, 36)
	info.CommentLength		= PeekInt(bankIn, 40)
	info.DiskNumberStart	= PeekInt(bankIn, 44)
	info.InternalFileAttr	= PeekInt(bankIn, 48)
	info.ExternalFileAttr	= PeekInt(bankIn, 52)
	
	// Grab the date - copy date information to a bank so we don't have to mess around with offsets
	let dateBank = CreateBank(ZIPAPI_DATE_LENGTH)
	CopyBank(bankIn, 56, dateBank, 0, ZIPAPI_DATE_LENGTH)
	info.Date = ZipApi_Date_FromBank(dateBank)
	
	// Cleanup & return
	FreeBank(dateBank)
	
	return info
	
}

// <summary>Free the memory used by a ZIPAPI_UnzFileInfo object.</summary>
// <param name="this">ZIPAPI_UnzFileInfo object to delete.</param>
// <subsystem>Blitz.File.ZipApi</subsystem>
function ZIPAPI_UnzFileInfo_Dispose (info: ZIPAPI_UnzFileInfo) {
	ZIPAPI_Date_Dispose(info.Date)
	Delete(info)
}

// --------------------------------------------------
// -- Type : ZIPAPI_GlobalInfo
// --------------------------------------------------

// <summary>Size of the ZIPAPI_GlobalInfo type in bytes.</summary>
// <subsystem>Blitz.File.ZipApi</subsystem>
const ZIPAPI_GLOBALINFO_LENGTH	= 8

// <summary>Information about a ZIP file.</summary>
// <subsystem>Blitz.File.ZLib</subsystem>
class ZIPAPI_GlobalInfo {
	NumberOfEntries: int			// The number of files in this zip.
	CommentLength: int			// The length of the comment string.
	
	// == Blitz Specific == //
	Comment: string					// Global comment string.
}

// <summary>Create a ZIPAPI_GlobalInfo object and read data from the contents of a bank.</summary>
// <param name="bankIn">The bank to read from.</param>
// <returns>ZIPAPI_GlobalInfo, or Null if it couldn't be read.</returns>
// <subsystem>Blitz.File.ZipApi</subsystem>
function ZIPAPI_GlobalInfo_FromBank(bankIn: int) : ZIPAPI_GlobalInfo {
	let info: ZIPAPI_GlobalInfo = new ZIPAPI_GlobalInfo()
	
	info.NumberOfEntries = PeekInt(bankIn, 0)
	info.CommentLength = PeekInt(bankIn, 4)
	
	return info
}

// <summary>Free the memory used by a ZIPAPI_GlobalInfo object and delete it.</summary>
// <param name="this">The ZIPAPI_GlobalInfo object to delete.</param>
// <subsystem>Blitz.File.ZipApi</subsystem>
function ZIPAPI_GlobalInfo_Dispose(info: ZIPAPI_GlobalInfo) {
	Delete(info)
}

// --------------------------------------------------
// -- Type : ZIPAPI_Date
// --------------------------------------------------

// <summary>Size of the ZIPAPI_Date type in bytes.</summary>
// <subsystem>Blitz.File.ZipApi</subsystem>
const ZIPAPI_DATE_LENGTH: int = 24

// <summary>The date information for a file in a ZIP archive.</summary>
// <subsystem>Blitz.File.ZipApi</subsystem>
class ZIPAPI_Date {
	Seconds: int			// Seconds after the minute 	[0,59]
	Minutes: int			// Minutes after the hour		[0,59]
	Hours: int			// Hours since midnight		[0,23]
	Day: int				// Day of the month			[1,31]
	Month: int			// Months since January		[0,11]
	Year: int				// Years						[1980, 2044]
}

// <summary>Create and return a new ZIPAPI_Date object, based on the current time and date.</summary>
// <returns>ZIPAPI_Date object for the current time and date.</returns>
// <subsystem>Blitz.File.ZipApi</subsystem>
function ZIPAPI_Date_Create() : ZIPAPI_Date {
	
	let date: ZIPAPI_Date	= new ZIPAPI_Date()
	
	// Get the current date
	date.Day	= Int(Left(CurrentDate(), 2))
	date.Year	= Int(Right(CurrentDate(), 4) ) - 1980
	
    switch (Upper(Mid(CurrentDate(), 4, 3))) {
    	case "JAN":
			date.Month = 0
    	case "FEB":
			date.Month = 1
    	case "MAR":
			date.Month = 2
    	case "APR":
			date.Month = 3
    	case "MAY":
			date.Month = 4
    	case "JUN":
			date.Month = 5
        case "JUL":
			date.Month = 6
        case "AUG":
			date.Month = 7
        case "SEP":
			date.Month = 8
        case "OCT":
			date.Month = 9
        case "NOV":
			date.Month = 10
        case "DEC":
			date.Month = 11
	}
	
	// Get the current time
	date.Seconds	= Int (Right(CurrentTime(), 2))
	date.Minutes	= Int (Mid(CurrentTime(), 4, 2))
	date.Hours		= Int (Left(CurrentTime(), 2))
	
	return date
	
}

// <summary>Create and return a new ZIPAPI_Date object, based on the information for a file.</summary>
// <param name="fileName">The name of the file to get information about.</param>
// <remarks>NOT YET IMPLEMENTED - Returns current time and date.</remarks>
// <returns>ZIPAPI_Date object containing the file's creation date and time.</returns>
// <subsystem>Blitz.File.ZipApi</subsystem>
function ZIPAPI_Date_FromFile(fileName: string) : ZIPAPI_Date {
	// TODO: Make this work. Will probably need to access Windows dlls
	return ZipApi_Date_Create()
}

// <summary>Creates a new ZipApi_Date object and reads its contents from a bank.</summary>
// <param name="bankIn">The bank to read information from.</param>
// <returns>The ZIPAPI_Date object, or null if it could not be read.</returns>
// <subsystem>Blitz.File.ZipApi</subsystem>
function ZIPAPI_Date_FromBank(bankIn) : ZIPAPI_Date {
	
	// Check inputs
	if (BankSize(bankIn) < ZIPAPI_DATE_LENGTH) {return Null}
	
	let date: ZIPAPI_Date = new ZIPAPI_Date()
	
	date.Seconds	= PeekInt(bankIn, 0)
	date.Minutes	= PeekInt(bankIn, 4)
	date.Hours		= PeekInt(bankIn, 8)
	date.Day		= PeekInt(bankIn, 12)
	date.Month		= PeekInt(bankIn, 16)
	date.Year		= PeekInt(bankIn, 20)
	
	return date
	
}

// <summary>Places the contents of a ZIPAPI_Date object into a bank.</summary>
// <param name="this">The ZIPAPI_Date object to poke.</param>
// <param name="bankOut">The handle of the bank to write the date to.</param>
// <param name="offset">Optional offset to start writing from.</param>
// <returns>True if the operation was successful, false if not.</returns>
// <subsystem>Blitz.File.ZipApi</subsystem>
function ZIPAPI_Date_ToBank(date: ZIPAPI_Date, bankOut, offset = 0) : boolean {
	
	// Check inputs
	if (date == Null) {
		return false
	}
	if (bankOut < 1) {
		return false
	}
	
	// Check bank can hold it
	if (BankSize(bankOut) < offset + ZIPAPI_DATE_LENGTH) {
		return false
	}
	
	// Poke it!
	PokeInt(bankOut, offset + 0 , date.Seconds)
	PokeInt(bankOut, offset + 4 , date.Minutes)
	PokeInt(bankOut, offset + 8 , date.Hours)
	PokeInt(bankOut, offset + 12, date.Day)
	PokeInt(bankOut, offset + 16, date.Month)
	PokeInt(bankOut, offset + 20, date.Year)
	
	return True
	
}

// <summary>Frees the memory used by a ZIPAPI_Date object and deletes it.</summary>
// <param name="this">The ZIPAPI_Date object to delete.</param>
// <subsystem>Blitz.File.ZipApi</subsystem>
function ZIPAPI_Date_Dispose(date: ZIPAPI_Date) {
	Delete(date)
}
// ID: 1816
// Author: Andres
// Date: 2006-09-18 11:05:21
// Title: Remote File Engine
// Description: Easy way to download and read remote files via HTTP/FTP

var UserAgent: string = "SCPCB"	// What ever you'd like to name your application
var ResponseDelay: int = 2000		// How many millisecs to wait for HTTP response
var NewLine: string = Chr(13) + Chr(10)	// Line break may differ
const RFDebugMode: boolean = false				// Debug mode

var UpdateCheckEnabled: int = GetINIInt(OptionFile, "options", "check for updates")

class transporter {
	id: int
	code: int
	filename: string
	protocol: string
}

function OpenRemoteFile(path: string, port: int = 80, variables: string = "", httpheader: string = "") : int {
	let protocol: string = Lower(Sector(path, ":", 0))
	let host: string = Sector(path, "/", 2)
	let ip: string = "www." + Sector(host, ".", Sectors(host, ".") - 1) + "." + Sector(host, ".", Sectors(host, "."))
	path = "/" + Sector(path, "/", 3, True)
	let header: int
	let bank: int
	let tim: int
	let occ: int
	
	
	let Stream: int = OpenTCPStream(host, port)
	if (!Stream) {
		Stream = OpenTCPStream(ip, port)
	}
	
	if (Stream) {
		switch (protocol) {
			case "http", "https":
				// Send request
				
				if (!Len(variables)) {
					WriteLine(Stream, "GET " + path$ + " HTTP/1.1")
				} else {
					WriteLine(Stream, "POST " + path$ + " HTTP/1.1")
				}
				WriteLine(Stream, "Host: " + host$)
				WriteLine(Stream, "User-Agent: " + UserAgent$)
				if (Len(variables$)) {
					WriteLine(Stream, "Content-Type: application/x-www-form-urlencoded")
					WriteLine(Stream, "Content-Length: " + Len(variables$))
				}
				if (Len(httpheader$)) {WriteLine(Stream, httpheader$)}
				WriteLine(Stream, "Connection: Close")
				WriteLine(Stream, "")
				if (Len(variables$)) {WriteLine(Stream, variables$)}
				
				// Debug mode
				if (RFDebugMode) {
					if (!Len(variables$)) {
						DebugLog(">>> GET " + path$ + " HTTP/1.1")
					} else {
						DebugLog(">>> POST " + path$ + " HTTP/1.1")
					}
					DebugLog(">>> Host: " + host$)
					DebugLog(">>> User-Agent: " + UserAgent$)
					if (Len(variables$)) {
						DebugLog(">>> Content-Type: application/x-www-form-urlencoded")
						DebugLog(">>> Content-Length: " + Len(variables$))
					}
					if (Len(httpheader$)) {DebugLog(">>> " + httpheader$)}
					DebugLog(">>> Connection: Close")
					DebugLog(">>> ")
					if (Len(variables$)) {DebugLog(">>> " + variables$)}
				}
				
				// Wait for response
				tim = MilliSecs()
				do {} while (!((MilliSecs() - tim) >= ResponseDelay || ReadAvail(Stream)))
				
				txt = ReadLine(Stream)
				if (RFDebugMode) {DebugLog("<<< " + txt)}
				if (Sector(txt, " ", 0) == "HTTP/1.1" || Sector(txt, " ", 0) == "HTTP/1.0") {
					code = Int(Sector(txt, " ", 1))
					if (code >= 300) {
						CloseTCPStream(Stream)
						return False
					}
				}
				
				occ = 0
				header = CreateBank(0)
				bank = CreateBank(12)// Bank Int, Stream Int, Size Int
				
				PokeInt(bank, 0, header)
				PokeInt(bank, 4, Stream)
				PokeInt(bank, 8, -1)
				
				let tp: transporter = new transporter()
				tp.id = bank
				tp.code = code
				tp.filename$ = Sector$(path$, "/", Sectors(path$, "/"))
				tp.protocol$ = "http"
				
				// Received HTTP Header
				while (true) {
					txt$ = ReadRemoteLine$(bank)
					value$ = Mid$(Sector$(txt$, ":", 1, True), 2)
					
					if (RFDebugMode) {
						DebugLog("<<< " + txt)
					}
					
					switch (Sector$(txt$, ":", 0)) {
						case "":
							return bank
						case "Content-Disposition":
							for (i of range(Sectors(value$, ";") + 1)) {
								subtxt = Trim(Sector(value, ";", i))
								subvalue = Sector(subtxt, "=", 1)
								
								switch (Sector(subtxt$, "=", 0)) {
									case "filename":
										tp.filename$ = subvalue$
										DebugLog("[" + tp.filename$ + "]")
								}
							}
						case "Content-Length":
							PokeInt(bank, 8, Int(value$))
					}
				}
			case "ftp":
				header = CreateBank(1)
				bank = CreateBank(16)
				
				PokeInt(bank, 0, header)
				PokeInt(bank, 4, Stream)
				PokeInt(bank, 8, -1)
				PokeInt(bank, 12, Stream)
				
				let tp: transporter = new transporter()
				tp.id = bank
				tp.code = "0"
				tp.filename = Sector(path, "/", Sectors(path, "/"))
				tp.protocol = "ftp"
				
				// Wait for response
				tim = MilliSecs()
				do {} while (!((MilliSecs() - tim) >= ResponseDelay || ReadAvail(Stream)))
				
				while (true) {
					if (ReadAvail(Stream)) {
						txt$ = ReadLine(Stream)
						code = Int(Sector$(txt$, " ", 0))
						value$ = Mid$(Sector$(txt$, " ", 1, True), 1)
						if (RFDebugMode) {
							DebugLog("<<< " + txt$)
						}
					} else {
						txt$ = ""
						code = 0
						value$ = ""
						cmd$ = ""
					}
					
					if (!ReadAvail(Stream)) {
						switch (code) {
							case 220:
								cmd$ = "USER " + variables
							case 331:
								cmd = "PASS " + httpheader
							case 230:
								cmd = "SIZE " + path
							case 213:
								PokeInt(bank, 8, Int(value))
								cmd = "PASV"
							case 227:
								// Connect to PASV mode
								txt = Sector(txt, "(", 1)
								host = Sector(txt, ",", 0) + "." + Sector(txt, ",", 1) + "." + Sector(txt, ",", 2) + "." + Sector(txt, ",", 3)
								port = (Int (Sector(txt, ",", 4))) * 256 + (Int (Left(Sector(txt, ",", 5), Len(Sector(txt, ",", 5)) - 1)))
								pasv_stream = OpenTCPStream(host, port)
								
								// Update stream
								PokeInt(bank, 4, pasv_stream)
								
								cmd$ = "RETR " + path$
							case 150:
								return bank
						}
						
						// ERROR
						if (code >= 400) {
							if (Stream) {CloseTCPStream(Stream)}
							if (pasv_stream) {CloseTCPStream(pasv_stream)}
							if (header) {FreeBank(header)}
							if (bank) {FreeBank(bank)}
							return 0
						}
					}
					
					if (Len(cmd)) {
						if (RFDebugMode) {
							DebugLog(">>> " + cmd$)
						}
						WriteLine(Stream, cmd)
					}
				}
				
				return bank
		}
	}
}

function CloseRemoteFile(bank: int) {
	if (PeekInt(bank, 0)) {
		FreeBank(PeekInt(bank, 0))
	}

	if (PeekInt(bank, 4)) {
		CloseTCPStream(PeekInt(bank, 4))
	}

	if (BankSize(bank) = 18) {
		if (PeekInt(bank, 12)) {
			WriteLine(PeekInt(bank, 12), "BYE")

			if (RFDebugMode) {
				DebugLog(">>> BYE")
			}
			CloseTCPStream(PeekInt(bank, 12))
		}
	}
	FreeBank(bank)
	
	for (let tp of transporter.each) {
		if (tp.id == bank) {
			Delete(tp)
			break
		}
	}
}

function EORF(bank: int) {
	if (!PeekInt(bank, 4)) {
		if (BankSize(PeekInt(bank, 0)) == 0) {return true}
	} else {
		if (Eof(PeekInt(bank, 4))) {return true}
	}
}

function RemoteFileSize(bank: int) : int {
	return PeekInt(bank, 8)
}

function RemoteFileName(bank: int) : string {
	for (let tp of transporter.each) {
		if (tp.id == bank) {
			return tp.filename
		}
	}
}

function RemoteFileCode(bank: int) : int {
	for (let tp of transporter.each) {
		if (tp.id == bank) {
			return tp.code
		}
	}
}

function RemoteFileProtocol$(bank: int) {
	for (let tp of transporter.each) {
		if (tp.id == bank) {
			return tp.protocol$
		}
	}
}

function ReadRemoteLine(bank: int) : string {
	let avail: int
	let rbank: int = PeekInt(bank, 0)
	let stream: int = PeekInt(bank, 4)
	
	// Update bank
	UpdateRemoteFile(bank)
	
	// Read line
	txt = ""
	for (i of range(BankSize(rbank))) {
		char = PeekByte(rbank, i)
		txt = txt + Chr(char)
		if (Right$(txt, Len(NewLine)) == NewLine) {
			break
		} else if (Right(txt,1) == Chr(10)) {
			break
		}
	}
	
	if (Right(txt, 2) == NewLine) {
		txt = Mid(txt, 1, Len(txt) - Len(NewLine))
	} else if (Right(txt, 1) == Right(NewLine, 1)) {
		txt = Mid(txt, 1, Len(txt) - (Len(NewLine) - 1))
	}
	
	// Resize bank
	size = BankSize(rbank) - (Len(txt) + Len(NewLine))
	if (size < 0) {size = 0}
	ResizeRemoteBank(bank, size)
	
	return txt
}

function ReadRemoteString(bank: int) : string {
	let rbank: int = PeekInt(bank, 0)
	UpdateRemoteFile(bank)
	
	let a: int = PeekInt(rbank, 0)
	
	let txt: string = ""
	for (i of range(a)) {
		txt$ = txt$ + Chr(PeekByte(rbank, 4 + i))
	}
	
	ResizeRemoteBank(bank, BankSize(rbank) - (4 + a))
	return txt
}

function ReadRemoteInt(bank: int) : int {
	let rbank: int = PeekInt(bank, 0)
	UpdateRemoteFile(bank)
	
	let a: int = PeekInt(rbank, 0)
	ResizeRemoteBank(bank, BankSize(rbank) - 4)
	return a
}

function ReadRemoteShort(bank: int) : int {
	let rbank: int = PeekInt(bank, 0)
	UpdateRemoteFile(bank)
	
	let a = PeekShort(rbank, 0)
	ResizeRemoteBank(bank, BankSize(rbank) - 2)
	return a
}

function ReadRemoteByte(bank: int) : int {
	let rbank: int = PeekInt(bank, 0)
	UpdateRemoteFile(bank)
	
	let a = PeekByte(rbank, 0)
	ResizeRemoteBank(bank, BankSize(rbank) - 1)
	return a
}

function WriteRemoteBytes(bank: int, file: int, offset: int, count: int) {
	let rbank: int = PeekInt(bank, 0)
	UpdateRemoteFile(bank)
	
	let N: int = WriteBytes(rbank, file, offset, count)
	ResizeRemoteBank(bank, BankSize(rbank) - N)
	
	return N
}

function RemoteReadAvail(bank: int) {
	UpdateRemoteFile(bank)
	received = BankSize(PeekInt(bank, 0))
	if (PeekInt(bank, 4)) {
		waiting = ReadAvail(PeekInt(bank, 4))
	} else {
		waiting = 0
	}
	return received + waiting
}

function UpdateRemoteFile(bank: int) {
	let rbank: int = PeekInt(bank, 0)
	let stream: int = PeekInt(bank, 4)
	
	if (stream && rbank) {
		avail = ReadAvail(stream)
		offset = BankSize(rbank)
		
		ResizeBank(rbank, offset + avail)
		ReadBytes(rbank, stream, offset, avail)
		
		if (Eof(stream)) {
			CloseTCPStream(stream)
			PokeInt(bank, 4, 0)
		}
	}
}

function ResizeRemoteBank(bank: int, size: int) {
	let rbank: int = PeekInt(bank, 0)
	let start = BankSize(rbank) - size
	
	if (BankSize(rbank)) {
		CopyBank(rbank, start, rbank, 0, size)
		ResizeBank(rbank, size)
	}
}

function Sector(txt: string, separator: string, Sector: int, toend: boolean = False) : string {
	let result: string = ""
	let occ
	for (i of range(1, Len(txt) + 1)) {
		if (Mid(txt, i, 1) = separator) {
			occ = occ + 1
			if (toend && occ > Sector) {
				result = result + Mid(txt, i, 1)
			}
		} else {
			if (occ => Sector) {
				result = result + Mid(txt, i, 1)
			}
		}
		if (!toend) {
			if (occ > Sector) {
				break
			}
		}
	}
	return result
}

function Sectors(txt: string, needle: string) : int {
	let occ = 0
	for (i of range(1, Len(txt) + 1, 1)) {
		if (Instr(txt, needle, i)) {
			occ = occ + 1
			i = Instr(txt, needle, i)
		} else {
			break
		}
	}
	return occ
}


const DOWNLOAD_SIZE: int = 4096*2

function Download(link: string, savepath: string = "", savefile: string = "", latest: string="") {
//Strip protocol and return false if not "http"
	inst = Instr(link, "://")
	if (inst) {
		if (Lower(Trim(Left(link$, inst - 1))) != "http") {
			return false
		}
		link$ = Right(link$, Len(link$) - inst - 2)
	}
	
//Seperate host from link
	inst = Instr(link, "/")
	if (inst == 0) {
		return false
	}
	host = Trim(Left(link, inst - 1))
	link = Trim(Right(link, Len(link) - inst + 1))
	
//Seperate path and file from the link
	for (i of range(Len(link) + 1, 1, -1)) {
		if (Mid(link$, i, 1) == "/") {
			link_path$ = Trim(Left(link$, i))
			link_file$ = Right(link$, Len(link$) - i)
			break
		}
	}
	if (link_file == "") {
		return false
	}
	if (savefile == "") {savefile = link_file$}
	
//Open TCP stream
	tcp = OpenTCPStream(host$, 80)
	if (tcp == 0) {
		return false
	}
	WriteLine(tcp, "GET " + link_path$ + link_file$ + " HTTP/1.1" + Chr(13) + Chr(10) + "Host: " + host$ + Chr(13) + Chr(10) + "User-Agent: Download_Function_By_DevilsChild" + Chr(13) + Chr(10))
	
//Download file
	l$ = ReadLine(tcp)
	inst1 = Instr(l$, " ")
	inst2 = Instr(l$, " ", inst1 + 1)
	num = Mid(l$, inst1, inst2 - inst1)
	switch (num) {
		case 200:
			conlen = -1
			chunk = False
			
			while (true) {
				l = Trim(ReadLine(tcp))
				if (l == "") {break}
				
				inst = Instr(l, ":")
				l1 = Trim(Left(l, inst - 1))
				l2 = Trim(Right(l, Len(l) - inst))
				switch (Lower(l1)) {
					case "content-length":
						conlen = l2
					case "transfer-encoding":
						if (Lower(l2) == "chunked") {chunk = True}
				}
			}
			
			if (conlen == 0) {
				file = WriteFile(savepath$ + savefile$)
				CloseFile(file)
				CloseTCPStream(tcp)
				return False //file doesn't exist ;True
			} else if (conlen > 0) {
				file = WriteFile(savepath$ + savefile$)
				bnk = CreateBank(DOWNLOAD_SIZE)
				pos = 0
				while (true) {
					avail = conlen - pos
					if (avail > DOWNLOAD_SIZE) {
						ReadBytes(bnk, tcp, 0, DOWNLOAD_SIZE)
						WriteBytes(bnk, file, 0, DOWNLOAD_SIZE)
						pos = pos + DOWNLOAD_SIZE
						
						//draw the progress bar
						
						SetBuffer(BackBuffer())
						Cls()
						
						BBText(5,5,"Downloading "+latest)
						
						Color(255,255,255)
						BBText(5,165,Str(Floor(((Float(pos)/1024.0)/1024.0)*100.0)/100.0)+"MB out of "+Str(Floor(((Float(conlen)/1024.0)/1024.0)*100.0)/100.0)+"MB downloaded")
						
						Rect(14,198,614,18,False)
						for (i of range(Int((Float(pos)/Float(conlen))*61.0))) {
							DrawImage(BlinkMeterIMG, (i*10)+17, 200)
						}
						
						BBText(320,230,Int((Float(pos)/Float(conlen))*100.0)+"%",True,False)
						
						if (DrawButton2(270,400,100,20,"Cancel",False)) {
							CloseTCPStream(tcp)
							FreeBank(bnk)
							CloseFile(file)
							return -1
						}
						
						Flip(False)
						
					} else {
						ReadBytes(bnk, tcp, 0, avail)
						WriteBytes(bnk, file, 0, avail)
						break
					}
				}
				FreeBank(bnk)
				CloseFile(file)
				CloseTCPStream(tcp)
				return True
			} else if (chunk) {
				file = WriteFile(savepath$ + savefile)
				bnk = CreateBank(DOWNLOAD_SIZE)
				
				while (true) {
					l = Trim(Upper(ReadLine(tcp)))
					ln = 0
					for (i of range(1, Len(l) + 1)) {
						ln = 16 * ln + Instr("123456789ABCDEF", Mid$(l$, i, 1))
					}
					if (ln == 0) {break}
					
					if (BankSize(bnk) < ln) {
						ResizeBank(bnk, ln)
					}
					ReadBytes(bnk, tcp, 0, ln)
					WriteBytes(bnk, file, 0, ln)
					ReadShort(tcp)
				}
				
				FreeBank(bnk)
				CloseFile(file)
				CloseTCPStream(tcp)
				return True
			} else {
				CloseTCPStream(tcp)
				return False
			}
		case 301, 302:
			while (true) {
				l = Trim(ReadLine(tcp))
				if (l == "") {break}
				
				inst = Instr(l$, ":")
				l1 = Trim(Left(l, inst - 1))
				l2 = Trim(Right(l, Len(l) - inst))
				switch (Lower(l1)) {
					case "location":
						CloseTCPStream(tcp)
						return Download(l2, savepath, savefile)
				}
			}
		default:
			CloseTCPStream(tcp)
			return False
	}
}

var UpdaterBG

class ChangeLogLines {
	txt: string
}

var UpdaterIMG
var LinesAmount: int = 0

function CheckForUpdates() {
	
	
	AppTitle("SCP - Containment Breach Updater")
	
	let delExe: string
	delExe=StripPath(GetINIString(OptionFile,"updater","old_exe"))
	if (delExe != "") { //delete the old executable
		if (FileSize(delExe)>0) {
			DeleteFile(delExe)
		}
		PutINIValue(OptionFile,"updater","old_exe","")
	}
	
	if (!UpdateCheckEnabled) {return}
	
	SetBuffer(BackBuffer())
	Cls()
	Color(255,255,255)
	BBText(320,240,"Checking for updates...",True,True)
	Flip()
	
	let updateCheck: int = OpenRemoteFile("http://www.scpcbgame.com/changelog.txt")
	
	if (updateCheck == 0) {return} //remote file couldn't be opened
	
	let latest: string = ""//
	let rl: string = ReadRemoteLine(updateCheck)
	while (!EORF(updateCheck)) {
		if (Left(Lower(rl),1) == "v" && Instr(Lower(rl),".")>0) {
			latest = Trim(Replace(rl,"v",""))
			break
		} else {
			rl = ReadRemoteLine(updateCheck)
		}
	}
	
	CloseRemoteFile(updateCheck)
	
	if (latest == "") {return}
	
	if (FileType("updates")=0) {
		CreateDir("updates")
	}
	
	DebugLog("LATEST VERSION: "+latest)
	
	let ConfirmDownload: int = 0
	let DownloadURL: string = ""
	
	if (latest != VersionNumber && latest != "") { //a new version is available!
		updateCheck = OpenRemoteFile("http://www.scpcbgame.com/index.html")
		
		if (updateCheck == 0) {return} //remote file couldn't be opened
		
		DownloadURL$ = ""
		rl$ = ReadRemoteLine(updateCheck)
		while (!EORF(updateCheck)) {
			if (Instr(Lower(rl),"undertowgames.com/file/scp")>0 && Instr(Lower(rl),".zip")>0) {
				DownloadURL = Mid(rl,Instr(Lower(rl),"http://"),Instr(Lower(rl),".zip")-Instr(Lower(rl),"http://")+4)
				DebugLog(DownloadURL)
				break
			} else {
				rl = ReadRemoteLine(updateCheck)
			}
		}
		
		CloseRemoteFile(updateCheck)
		
		UpdaterBG = LoadImage_Strict("GFX/menu/updater.jpg")
		UpdaterIMG = CreateImage(452,254)
		
		let ChangeLogURL: string = "http://www.scpcbgame.com/changelog.txt"
		Download(ChangeLogURL$,"","Changelog_Prev.txt",latest)
		let ChangeLogFile = OpenFile("Changelog_Prev.txt")
		let ChangeLogLineAmount: int = 0
		
		while (!Eof(ChangeLogFile)) {
			l$ = ReadLine(ChangeLogFile)
			if (Left(l,5) != "-----") {
				let chl: ChangeLogLines = new ChangeLogLines()
				if (l = "v"+latest) {
					chl.txt$ = "NEW UPDATE: "+l
				} else {
					chl.txt$ = l
				}
				ChangeLogLineAmount = ChangeLogLineAmount + 1
			} else {
				break
			}
		}
		CloseFile(ChangeLogFile)
		DeleteFile("Changelog_Prev.txt")
		
		UpdaterFont = LoadFont("GFX/font/cour/Courier New.ttf",16,0,0,0)
		
		while (true) {
			SetBuffer(BackBuffer())
			Cls()
			Color(255,255,255)
			MouseHit1 = MouseHit(1)
			MouseDown1 = MouseDown(1)
			DrawImage(UpdaterBG,0,0)
			if (DownloadURL == "") {
				SetFont(UpdaterFont)
				if (LinesAmount > 13) {
					let y: float = 200-(20*ScrollMenuHeight*ScrollBarY)
					LinesAmount%=0
					SetBuffer(ImageBuffer(UpdaterIMG))
					DrawImage(UpdaterBG,-20,-195)
					for (chl of ChangeLogLines.each) {
						Color(0,0,0)
						if (Right(chl.txt$,6) = "v"+latest) {
							Color(200,0,0)
						}
						RowText2(chl.txt$,2,y-195,430,254)
						y = y+(20*GetLineAmount2(chl.txt$,430,254))
						LinesAmount = LinesAmount + (GetLineAmount2(chl.txt$,430,254))
					}
					SetBuffer(BackBuffer())
					DrawImage(UpdaterIMG,20,195)
					Color(10,10,10)
					Rect(452,195,20,254,True)
					ScrollMenuHeight = LinesAmount-13
					ScrollBarY = DrawScrollBar(452,195,20,254,452,195+(254-(254-4*ScrollMenuHeight))*ScrollBarY,20,254-(4*ScrollMenuHeight),ScrollBarY,1)
				} else {
					y = 200
					LinesAmount%=0
					Color(0,0,0)
					for (chl of ChangeLogLines.each) {
						RowText2(chl.txt$,20,y,432,254)
						y = y+(20*GetLineAmount2(chl.txt$,432,254))
						LinesAmount = LinesAmount + (GetLineAmount2(chl.txt$,432,254))
					}
					ScrollMenuHeight = LinesAmount
				}
				Color(255,255,255)
				Rect(480, 200, 155, 95)
				Color(0,0,0)
				RowText2("However, a manual download is required to update the game.",482,210,150,90)
				
				SetFont(Font1)
				if (DrawButton(LauncherWidth - 30 - 90, LauncherHeight - 50 - 110, 100, 30, "TRY AGAIN", False, False, False)) {
					Delete(ChangeLogLines.each)
					if (UpdaterIMG != 0) {FreeImage(UpdaterIMG)}
					CheckForUpdates()
					return
				}
				if (DrawButton(LauncherWidth - 55 - 90, LauncherHeight - 50 - 55, 145, 30, "VISIT WEBSITE", False, False, False)) {
					ExecFile("http://scpcbgame.com")
					
					Delay(100)
					End()
				}
				if (DrawButton(LauncherWidth - 30 - 90, LauncherHeight - 50, 100, 30, "IGNORE", False, False, False)) {
					Delay(100)
					break
				}
			} else {
				SetFont(UpdaterFont)
				if (LinesAmount > 13) {
					y = 200-(20*ScrollMenuHeight*ScrollBarY)
					LinesAmount%=0
					SetBuffer(ImageBuffer(UpdaterIMG))
					DrawImage(UpdaterBG,-20,-195)
					for (chl of ChangeLogLines.each) {
						Color(0,0,0)
						if (Right(chl.txt$,6) == "v"+latest) {
							Color(200,0,0)
						}
						RowText2(chl.txt$,2,y#-195,430,254)
						y = y+(20*GetLineAmount2(chl.txt$,430,254))
						LinesAmount = LinesAmount + (GetLineAmount2(chl.txt$,430,254))
					}
					SetBuffer(BackBuffer())
					DrawImage(UpdaterIMG,20,195)
					Color(10,10,10)
					Rect(452,195,20,254,True)
					ScrollMenuHeight = LinesAmount-13
					ScrollBarY = DrawScrollBar(452,195,20,254,452,195+(254-(254-4*ScrollMenuHeight))*ScrollBarY,20,254-(4*ScrollMenuHeight),ScrollBarY,1)
				} else {
					y = 200
					LinesAmount%=0
					Color(0,0,0)
					for (chl of ChangeLogLines.each) {
						RowText2(chl.txt$,20,y,432,254)
						y = y+(20*GetLineAmount2(chl.txt$,432,254))
						LinesAmount = LinesAmount + (GetLineAmount2(chl.txt$,432,254))
					}
					ScrollMenuHeight = LinesAmount
				}
				Color(255,255,255)
				
				SetFont(Font1)
				if (DrawButton(LauncherWidth - 30 - 90, LauncherHeight - 50 - 55, 100, 30, "UPDATE", False, False, False)) {
					ConfirmDownload=True
					Cls()
					Color(255,255,255)
					BBText(320,240,"Starting download...",True,True)
					Flip()
					Delay(100)
					break
				}
				if (DrawButton(LauncherWidth - 30 - 90, LauncherHeight - 50, 100, 30, "IGNORE", False, False, False)) {
					Delay(100)
					break
				}
			}
			
			Flip()
			
			Delay(8)
			
		}
	}
	if (ConfirmDownload) {
		
		let temp: int
		
		temp=Download(DownloadURL$,"updates/",latest+".zip",latest)
		
		if (temp>0) {
			
			if (FileSize("updates/"+latest+".zip") != 0) {
				let newRun: string = ""
				let zipIn = ZipApi_Open("updates/"+latest+".zip")
				
				DebugLog(zipIn)
				
				
				temp = ZipApi_GotoFirstFile(zipIn)+"a"
				while (!temp) {
					
					SetBuffer(BackBuffer())
					Cls()
					Color(255,255,255)
					
					let fileData$	= ""
					let fileInfo: ZIPAPI_UnzFileInfo = ZipApi_GetCurrentFileInfo(zipIn)
					if (fileInfo) {
						fileData$ = fileInfo.FileName
						
						DebugLog(fileData)
						
						ZIPAPI_UnzFileInfo_Dispose(fileInfo)
						if ((Right(fileData,1) != "/") && (Right(fileData,1) != "/")) { //fileData refers to a file, not a directory
							if (Instr(fileData,"zlibwapi.dll") != 0) {
								BBText(320,240,"Can't extract zlibwapi.dll",True,True)
							} else {
								BBText(320,240,"Extracting "+Chr(34)+fileData+Chr(34),True,True)
								if (Instr(fileData,".exe") == 0 || Instr(fileData,"Map Creator") == 0) {
									ZipApi_ExtractFile(zipIn, fileData, Replace(fileData,".exe"," "+latest+".exe"))
								} else {
									ZipApi_ExtractFile(zipIn, fileData, fileData)
								}
							}
						} else if (FileType(fileData) == 0) {
							CreateDir(fileData)
						}
						
						if (Instr(fileData,".exe")>0) {
                            newRun=Chr$(34)+"SCP - Containment Breach "+latest+".exe"+Chr$(34)
                        }
					}
					
					Flip()
					temp%=ZipApi_GotoNextFile(zipIn)
					
					DebugLog(temp)
					
				}
				ZipApi_Close(zipIn)
				
				PutINIValue(OptionFile,"updater","old_exe",StripPath(GetSelfEXEName()))
				DebugLog(GetSelfEXEName())
				
				if (newRun != "") { //run the new executable
					DebugLog("running "+newRun)
					ExecFile(newRun)
				}
				
				End() //close the game
				
			}
		} else if (temp == -1) { //download cancelled by user
			Delay(100)
			
			return
		} else {
			
			SetBuffer(BackBuffer())
			Cls()
			Color(255,255,255)
			BBText(320,240,"An error has occurred while downloading the update.",True,True)
			Flip()
			
			Delay(1000)
			
			return
		}
	}
	Delete(ChangeLogLines.each)
	if (UpdaterIMG != 0) {
		FreeImage(UpdaterIMG)
	}
}

function GetSelfEXEName() : string {//use this to make the new version delete the old exe
	let lpFileName: int = CreateBank(256)
	let str_len: int = api_GetModuleFileName(0,lpFileName,BankSize(lpFileName))
	
	let exe_name: string = ""
	
	if (str_len > 0) {
		for (grab_exe_name of range(str_len)) {
			exe_name$ = exe_name + Chr(PeekByte(lpFileName,grab_exe_name))
		}
	}
	
	FreeBank(lpFileName)
	
	return exe_name
}

class Template {
	sub_template: Template[] = new Array(7)                                  //Sub templates
	emitter_blend                                             //blendmode of emitter entity
	interval
	particles_per_interval                          //particle interval
	max_particles                                             //max particles
	emitter_max_time                                          //Emitter life time
	min_time
	max_time                                        //Particle life time
	tex
	animtex
	texframe: float
	maxtexframes
	texspeed: float          //Texture
	min_ox: float
	max_ox: float
	min_oy: float
	max_oy: float
	min_oz: float
	max_oz: float      //Offset
	min_xv: float
	max_xv: float
	min_yv: float
	max_yv: float
	min_zv: float
	max_zv: float      //Velocity
	rot_vel1: float
	rot_vel2: float
	align_to_fall
	align_to_fall_offset //Rotation
	gravity: float                                                  //Gravity
	alpha: float
	alpha_vel                                         //Alpha
	sx: float
	sy: float
	size_multiplicator1: float
	size_multiplicator2: float      //Size
	size_add: float
	size_mult: float                                     //Size velocity
	r1
	g1
	b1
	r2
	g2
	b2                                    //Colors
	Brightness                                                //Brightness
	floor_y: float
	floor_bounce: float                                   //Floor
	pitch_fix
	yaw_fix                                        //Fix angles
	
	yaw: float
}

class Emitter {
	fixed
	cnt_loop: float
	age: float
	max_time: float
	tmp: Template
	owner
	ent
	surf
	del
	frozen
}

class Particle {
	emitter: Emitter
	age
	max_time  //Life time
	x: float
	y: float
	z: float     //Position
	xv: float
	yv: float
	zv: float  //Velocity
	rot: float
	rot_vel: float //Rotation
	sx: float
	sy: float       //Size
}

var ParticleCam
var ParticlePiv

function InitParticles(cam) {
	ParticleCam = cam
	ParticlePiv = CreatePivot()
	SeedRnd(MilliSecs())
}

function FreeParticles() {
	for (tmp of Template.each) {
		FreeTemplate(Handle(tmp))
	}
	for (e of Emitter.each) {
		FreeEmitter(e.ent)
	}
	Delete(Template.each)
	Delete(Emitter.each)
	Delete(Particle.each)
	if (ParticlePiv) {
		FreeEntity(ParticlePiv)
	}
}

function CreateTemplate() {
	let tmp: Template = new Template()
	template = Handle(tmp)
	SetTemplateEmitterBlend(template, 3)
	SetTemplateInterval(template, 1)
	SetTemplateParticlesPerInterval(template, 1)
	SetTemplateMaxParticles(template, -1)
	SetTemplateEmitterLifeTime(template, 100)
	SetTemplateParticleLifeTime(template, 0, 20)
	SetTemplateAlpha(template, 1)
	SetTemplateSize(template, 1, 1)
	SetTemplateSizeVel(template, 0, 1)
	SetTemplateColors(template, $FFFFFF, $FFFFFF)
	SetTemplateBrightness(template, 1)
	SetTemplateFloor(template, -1000000)
	SetTemplateFixAngles(template, -1, -1)
	return Handle(tmp)
}

function FreeTemplate(template) {
	let tmp: Template = Template.each[template]
	if (tmp.tex) {
		FreeTexture(tmp.tex)
	}
	for (i of range(8)) {
		if (tmp.sub_template[i]) {
			FreeTemplate(Handle(tmp.sub_template[i]))
		}
	}
	Delete(tmp)
}

function SetTemplateEmitterBlend(template, emitter_blend) {
	let tmp: Template = Template.each[template]
	tmp.emitter_blend = emitter_blend
}

function SetTemplateInterval(template, interval) {
	let tmp: Template = Template.each[template]
	tmp.interval = interval
}

function SetTemplateParticlesPerInterval(template, particles_per_interval) {
	let tmp: Template = Template.each[template]
	tmp.particles_per_interval = particles_per_interval
}

function SetTemplateMaxParticles(template, max_particles) {
	let tmp: Template = Template.each[template]
	tmp.max_particles = max_particles
}

function SetTemplateParticleLifeTime(template, min_time, max_time) {
	let tmp: Template = Template.each[template]
	tmp.min_time = min_time
	tmp.max_time = max_time
}

function SetTemplateEmitterLifeTime(template, emitter_max_time) {
	let tmp: Template = Template.each[template]
	tmp.emitter_max_time = emitter_max_time
}

function SetTemplateTexture(template, path: string, mode = 0, blend = 1) {
	let tmp: Template = Template.each[template]
	tmp.tex = LoadTexture(path$, mode)
	TextureBlend(tmp.tex, blend)
}

function SetTemplateAnimTexture(template, path: string, mode, blend, w, h, maxframes, speed: float = 1) {
	let tmp: Template = Template.each[template]
	tmp.animtex = True
	tmp.maxtexframes = maxframes
	tmp.texspeed = speed
	tmp.tex = LoadAnimTexture(path$, mode, w, h, 0, tmp.maxtexframes)
	TextureBlend(tmp.tex, blend)
}

function SetTemplateOffset(template, min_ox: float, max_ox: float, min_oy: float, max_oy: float, min_oz: float, max_oz: float) {
	let tmp: Template = Template.each[template]
	tmp.min_ox = min_ox
	tmp.max_ox = max_ox
	tmp.min_oy = min_oy
	tmp.max_oy = max_oy
	tmp.min_oz = min_oz
	tmp.max_oz = max_oz
}

function SetTemplateVelocity(template, min_xv: float, max_xv: float, min_yv: float, max_yv: float, min_zv: float, max_zv: float) {
	let tmp: Template = Template.each[template]
	tmp.min_xv = min_xv
	tmp.max_xv = max_xv
	tmp.min_yv = min_yv
	tmp.max_yv = max_yv
	tmp.min_zv = min_zv
	tmp.max_zv = max_zv
}

function SetTemplateRotation(template, rot_vel1: float, rot_vel2: float) {
	let tmp: Template = Template.each[template]
	tmp.rot_vel1 = rot_vel1
	tmp.rot_vel2 = rot_vel2
}

function SetTemplateAlignToFall(template, align_to_fall, align_to_fall_offset = 0) {
	tmp.Template = Object.Template(template)
	tmp.align_to_fall = align_to_fall
	tmp.align_to_fall_offset = align_to_fall_offset
}

function SetTemplateGravity(template, gravity: float) {
	tmp.Template = Object.Template(template)
	tmp.gravity = gravity
}

function SetTemplateSize(template, sx: float, sy: float, size_multiplicator1: float = 1, size_multiplicator2: float = 1) {
	tmp.Template = Object.Template(template)
	tmp.sx = sx
	tmp.sy = sy
	tmp.size_multiplicator1 = size_multiplicator1
	tmp.size_multiplicator2 = size_multiplicator2
}

function SetTemplateSizeVel(template, size_add: float, size_mult: float) {
	let tmp: Template = Template.each[template]
	tmp.size_add = size_add
	tmp.size_mult = size_mult
}

function SetTemplateAlpha(template, alpha: float) {
	tmp.Template = Template.each[template]
	tmp.alpha = alpha
}

function SetTemplateAlphaVel(template, alpha_vel) {
	tmp.Template = Template.each[template]
	tmp.alpha_vel = alpha_vel
}

function SetTemplateColors(template, col1, col2) {
	let tmp: Template = Template.each[template]
	tmp.r1 = (col1 && 0xFF0000) / 0x10000
	tmp.g1 = (col1 && 0xFF00) / 0x100
	tmp.b1 = col1 && 0xFF
	tmp.r2 = (col2 && 0xFF0000) / 0x10000
	tmp.g2 = (col2 && 0xFF00) / 0x100
	tmp.b2 = col2 && 0xFF
}

function SetTemplateBrightness(template, brightness) {
	tmp.Template = Template.each[template]
	tmp.brightness = brightness
}

function SetTemplateFloor(template, floor_y: float, floor_bounce: float = 0.5) {
	tmp.Template = Template.each[template]
	tmp.floor_y = floor_y
	tmp.floor_bounce = floor_bounce
}

function SetTemplateFixAngles(template, pitch_fix, yaw_fix) {
	let tmp: Template = Template.each[template]
	tmp.pitch_fix = pitch_fix
	tmp.yaw_fix = yaw_fix
}

function SetTemplateSubTemplate(template, sub_template, for_each_particle = False) {
	let tmp: Template = Template.each[template]
	for (i of range(8)) {
		if (tmp.sub_template[i] == Null) {
			tmp.sub_template[i] = Object.Template(sub_template)
			break
		}
	}
}

function SetEmitter(owner, template, fixed = False) {
	let e: Emitter = new Emitter()
	if (fixed) {
		e.owner = CreatePivot()
		PositionEntity(e.owner, EntityX(owner), EntityY(owner), EntityZ(owner))
		e.fixed = True
	} else {
		e.owner = owner
	}
	e.ent = CreateMesh()
	NameEntity(e.ent,"Emitter3")
	e.surf = CreateSurface(e.ent)
	e.tmp = Object.Template(template)
	e.max_time = e.tmp.emitter_max_time
	EntityBlend(e.ent, e.tmp.emitter_blend)
	EntityFX(e.ent, 34)
	if (e.tmp.tex) {
		EntityTexture(e.ent, e.tmp.tex)
		}
	for (i of range(8)) {
		if (e.tmp.sub_template[i]) {
			if (e.tmp.sub_template[i].tex) {
				SetEmitter(owner, Handle(e.tmp.sub_template[i]), fixed)
			}
		}
	}
	return e.ent
}

function FreeEmitter(ent, delete_particles = True) {
	for (e of Emitter.each) {
		if (e.owner = ent) {
			if (delete_particles) {
				for (p of Particle.each) {
					if (p.emitter = e) {
						Delete(p)
					}
				}
				FreeEntity(e.ent)
				if (e.fixed && e.owner) {
					FreeEntity(e.owner)
				}
				Delete(e)
			} else {
				e.del = True
			}
		}
	}
}

function FreezeEmitter(ent) {
	for (e of Emitter.each) {
		if (e.owner == ent) {
			e.frozen = True
		}
	}
}

function UnfreezeEmitter(ent) {
	for (e of Emitter.each) {
		if (e.owner == ent) {
			e.frozen = False
			}
	}
}

function SetTemplateYaw(template,yaw: float) {
	tmp.template = Object.Template(template)
	tmp.yaw = yaw
}

function UpdateParticles_Devil() {
	let e: Emitter
	let p: Particle
	
	for (e of Emitter.each) {
		if (e.tmp.max_particles > -1) {
			cnt_particles = 0
			for (p of Particle.each) {
				if (p.emitter == e) {
					cnt_particles = cnt_particles + 1
				}
			}
		}
		ClearSurface(e.surf)
		if (e.max_time > -1) {
			if (e.age > e.max_time) {
				e.del = True
			} else {
				e.age = e.age + 1
			}
		}
		if (!e.frozen) {
			e.cnt_loop = (e.cnt_loop + 1) % e.tmp.interval
			if (e.cnt_loop == 0 && !e.del) {
				for (i of range(1, e.tmp.particles_per_interval + 1)) {
					if ((e.tmp.max_particles > -1 && cnt_particles < e.tmp.max_particles) || e.tmp.max_particles == -1) {
						let p: Particle = new Particle()
						p.emitter = e
						p.max_time = Rand(e.tmp.min_time, e.tmp.max_time)
						p.x = EntityX(e.owner, True) + Rnd(e.tmp.min_ox, e.tmp.max_ox)
						p.y = EntityY(e.owner, True) + Rnd(e.tmp.min_oy, e.tmp.max_oy)
						p.z = EntityZ(e.owner, True) + Rnd(e.tmp.min_oz, e.tmp.max_oz)
						p.xv = Rnd(e.tmp.min_xv, e.tmp.max_xv)
						p.yv = Rnd(e.tmp.min_yv, e.tmp.max_yv)
						p.zv = Rnd(e.tmp.min_zv, e.tmp.max_zv)
						p.rot_vel = Rnd(e.tmp.rot_vel1, e.tmp.rot_vel2)
						sm = Rnd(e.tmp.size_multiplicator1, e.tmp.size_multiplicator2)
						p.sx = p.emitter.tmp.sx * sm
						p.sy = p.emitter.tmp.sy * sm
					}
				}
			}
		}
		if (e.tmp.animtex) {
			e.tmp.texframe = e.tmp.texframe + e.tmp.texspeed
			if (e.tmp.texframe > e.tmp.maxtexframes - 1) {e.tmp.texframe = 0}
			EntityTexture(e.ent, e.tmp.tex, e.tmp.texframe)
		}
		frame = frame + texspeed
		if (e.del) {
			del = True
			for (p of Particle.each) {
				if (p.emitter == e) {del = False}
			}
			if (del) {
				FreeEntity(e.ent)
				if (e.fixed && e.owner) {
					FreeEntity(e.owner)
					}
				Delete(e)
			}
		}
	}
	PositionEntity(ParticlePiv, EntityX(ParticleCam, True), EntityY(ParticleCam, True), EntityZ(ParticleCam, True))
	let cam_pitch: float = EntityPitch(ParticleCam, True)
	let cam_yaw: float = EntityYaw(ParticleCam, True)
	let cam_roll: float = EntityRoll(ParticleCam, True)
	for (p of Particle.each) {
		if (p.age > p.max_time) {
			Delete(p)
		} else {
			if (!p.emitter.frozen) {
				p.age = p.age + 1
				if (p.emitter.tmp.align_to_fall) {
					p.rot = (p.emitter.tmp.align_to_fall_offset - ATan2(p.xv, p.yv))
				} else {
					p.rot = (p.rot + p.rot_vel)
				}
				p.yv = p.yv - p.emitter.tmp.gravity
				p.x = p.x + p.xv
				p.y = p.y + p.yv
				p.z = p.z + p.zv
				if (p.y < p.emitter.tmp.floor_y) {
					p.yv = p.yv * -p.emitter.tmp.floor_bounce
				}
				p.sx = (p.sx + p.emitter.tmp.size_add) * p.emitter.tmp.size_mult
				p.sy = (p.sy + p.emitter.tmp.size_add) * p.emitter.tmp.size_mult
			}
			RotateEntity(ParticlePiv, cam_pitch, cam_yaw, cam_roll + (p.rot + p.emitter.tmp.align_to_fall_offset))
			if (p.emitter.tmp.pitch_fix > -1) {
				RotateEntity(ParticlePiv, p.emitter.tmp.pitch_fix, EntityYaw(ParticlePiv), EntityRoll(ParticlePiv))
			}
			if (p.emitter.tmp.yaw_fix > -1) {
				RotateEntity(ParticlePiv, EntityPitch(ParticlePiv), p.emitter.tmp.yaw_fix, EntityRoll(ParticlePiv))
			}
			x = EntityX(p.emitter.ent) + p.x
			y = EntityY(p.emitter.ent) + p.y
			z = EntityZ(p.emitter.ent) + p.z
			sx = p.sx
			sy = p.sy
			TFormVector(sx, -sy, 0, ParticlePiv, 0)
			v1x = TFormedX() + x
			v1y = TFormedY() + y
			v1z = TFormedZ() + z
			TFormVector(-sx, -sy, 0, ParticlePiv, 0)
			v2x = TFormedX() + x
			v2y = TFormedY() + y
			v2z = TFormedZ() + z
			TFormVector(sx, sy, 0, ParticlePiv, 0)
			v3x = TFormedX() + x
			v3y = TFormedY() + y
			v3z = TFormedZ() + z
			TFormVector(-sx, sy, 0, ParticlePiv, 0)
			v4x = TFormedX() + x
			v4y = TFormedY() + y
			v4z = TFormedZ() + z
			v1 = AddVertex(p.emitter.surf, v1x, v1y, v1z, 0, 0)
			v2 = AddVertex(p.emitter.surf, v2x, v2y, v2z, 1, 0)
			v3 = AddVertex(p.emitter.surf, v3x, v3y, v3z, 0, 1)
			v4 = AddVertex(p.emitter.surf, v4x, v4y, v4z, 1, 1)
			r = p.emitter.tmp.r1 + (p.emitter.tmp.r2 - p.emitter.tmp.r1) * Float(p.age) / Float(p.max_time)
			g = p.emitter.tmp.g1 + (p.emitter.tmp.g2 - p.emitter.tmp.g1) * Float(p.age) / Float(p.max_time)
			b = p.emitter.tmp.b1 + (p.emitter.tmp.b2 - p.emitter.tmp.b1) * Float(p.age) / Float(p.max_time)
			if (p.emitter.tmp.alpha_vel) {
				a = (1 - Float(p.age) / Float(p.max_time)) * p.emitter.tmp.alpha
			} else {
				a = p.emitter.tmp.alpha
			}
			VertexColor(p.emitter.surf, v1, r, g, b, a)
			VertexColor(p.emitter.surf, v2, r, g, b, a)
			VertexColor(p.emitter.surf, v3, r, g, b, a)
			VertexColor(p.emitter.surf, v4, r, g, b, a)
			for (i of range(1, p.emitter.tmp.Brightness + 1)) {
				AddTriangle(p.emitter.surf, v1, v2, v3)
				AddTriangle(p.emitter.surf, v3, v2, v4)
			}
		}
	}
}

export var ErrorFile: string = "error_log_"
let ErrorFileInd: int = 0
while (FileType(ErrorFile+Str(ErrorFileInd)+".txt") != 0) {
	ErrorFileInd = ErrorFileInd+1
}
ErrorFile = ErrorFile+Str(ErrorFileInd)+".txt"

export var UpdaterFont: int
export var Font1: int
export var Font2: int
export var Font3: int
export var Font4: int
export var Font5: int
export var ConsoleFont: int

export var VersionNumber: string = "1.3.11"
export var CompatibleNumber: string = "1.3.11"

export var MenuWhite: int
export var MenuBlack: int
export var ButtonSFX: int

export var EnableSFXRelease: int = GetINIInt(OptionFile, "audio", "sfx release")
export var EnableSFXRelease_Prev: int = EnableSFXRelease

export var CanOpenConsole: int = GetINIInt(OptionFile, "console", "enabled")

export var ArrowIMG: any[] = new Array(4)

//[Block]

export var LauncherWidth: int= Min(GetINIInt(OptionFile, "launcher", "launcher width"), 1024)
export var LauncherHeight: int = Min(GetINIInt(OptionFile, "launcher", "launcher height"), 768)
export var LauncherEnabled: int = GetINIInt(OptionFile, "launcher", "launcher enabled")
export var LauncherIMG: int

export var GraphicWidth: int = GetINIInt(OptionFile, "options", "width")
export var GraphicHeight: int = GetINIInt(OptionFile, "options", "height")
export var Depth: int = 0
export var Fullscreen: boolean = Boolean(GetINIInt(OptionFile, "options", "fullscreen"))

export var SelectedGFXMode: int = -1
export var SelectedGFXDriver: int = Max(GetINIInt(OptionFile, "options", "gfx driver"), 1)

export var fresize_image: int, fresize_texture: int, fresize_texture2: int
export var fresize_cam: int = -1

export var ShowFPS = GetINIInt(OptionFile, "options", "show FPS")

export var WireframeState
export var HalloweenTex

export var TotalGFXModes: int = CountGfxModes3D()
export var GFXModes: int = -1
export var GfxModeWidths: int[] = new Array(TotalGFXModes)
export var GfxModeHeights: int[] = new Array(TotalGFXModes)

export var BorderlessWindowed: int = GetINIInt(OptionFile, "options", "borderless windowed")
export var RealGraphicWidth: int
export var RealGraphicHeight: int
export var AspectRatioRatio: float

export var EnableRoomLights: int = GetINIInt(OptionFile, "options", "room lights enabled")

export var TextureDetails: int = GetINIInt(OptionFile, "options", "texture details")
export var TextureFloat: float
switch (TextureDetails) {
	case 0:
		TextureFloat = 0.8
	case 1:
		TextureFloat = 0.4
	case 2:
		TextureFloat = 0.0
	case 3:
		TextureFloat = -0.4
	case 4:
		TextureFloat = -0.8
}
var ConsoleOpening: int = GetINIInt(OptionFile, "console", "auto opening")
var SFXVolume: float = GetINIFloat(OptionFile, "audio", "sound volume")

var Bit16Mode = GetINIInt(OptionFile, "options", "16bit")


export var AATextEnable: int = GetINIInt(OptionFile, "options", "antialiased text")
export var AASelectedFont: int
export var AATextCam: int
export var AATextSprite: int[] = new Array(150)
export var AACharW: int
export var AACharH: int
export var AATextEnable_Prev: int = AATextEnable

export var AACamViewW: int
export var AACamViewH: int

export class AAFont {
	static each: AAFont[]
	texture: int
	backup: int //images don't get erased by clearworld
	
	x: int[] = new Array(128) //not going to bother with unicode
	y: int[] = new Array(128)
	w: int[] = new Array(128)
	h: int[] = new Array(128)
	
	lowResFont: int //for use on other buffers
	
	mW: int
	mH: int
	texH: int
	
	isAA: boolean
}

export function InitAAFont() {
	if (AATextEnable) {
		//Create Camera
		let cam: int = CreateCamera()
		CameraViewport (cam,0,0,10,10)//GraphicWidth,GraphicHeight
		//CameraProjMode cam, 2
		CameraZoom (cam, 0.1)
		CameraClsMode (cam, false, false)
		CameraRange (cam, 0.1, 1.5)
		MoveEntity (cam, 0, 0, -20000)
		AATextCam = cam
		CameraProjMode (cam,0)
	
	    //Create sprite
		let spr: int = CreateMesh(cam)
		let sf: int = CreateSurface(spr)
		AddVertex(sf, -1, 1, 0, 0, 0) //vertex 0// uv:0,0
		AddVertex(sf, 1, 1, 0, 1, 0)  //vertex 1// uv:1,0
		AddVertex(sf, -1, -1, 0, 0, 1)//vertex 2// uv:0,1
		AddVertex(sf, 1, -1, 0, 1, 1) //vertex 3// uv:1,1
		AddTriangle(sf, 0, 1, 2)
		AddTriangle(sf, 3, 2, 1)
		EntityFX(spr, 17+32)
		PositionEntity(spr, 0, 0, 1.0001)
		EntityOrder(spr, -100001)
		EntityBlend(spr, 1)
		AATextSprite[0] = spr
		HideEntity(AATextSprite[0])
		for (let i of range(1, 150)) {
			spr = CopyMesh(AATextSprite[0],cam)
			EntityFX(spr, 17+32)
			PositionEntity(spr, 0, 0, 1.0001)
			EntityOrder(spr, -100001)
			EntityBlend(spr, 1)
			AATextSprite[i] = spr
			HideEntity(AATextSprite[i])
		}
	}
}

export function AASpritePosition(ind: int,x: int,y: int) {
	//THE HORROR
	let nx: float = (((Float(x-(AACamViewW/2))/Float(AACamViewW))*2))
	let ny: float = -(((Float(y-(AACamViewH/2))/Float(AACamViewW))*2))
	
	//how does this work pls help
	nx = nx-((1.0/Float(AACamViewW))*(((AACharW-2) % 2)))+(1.0/Float(AACamViewW))
	ny = ny-((1.0/Float(AACamViewW))*(((AACharH-2) % 2)))+(1.0/Float(AACamViewW))
	
	PositionEntity(AATextSprite[ind],nx,ny,1.0)
}

export function AASpriteScale(ind: int,w: int,h: int) {
	ScaleEntity (AATextSprite[ind],1.0/Float(AACamViewW)*Float(w), 1/Float(AACamViewW)*Float(h), 1)
	AACharW = w
	AACharH = h
}

export function ReloadAAFont() { //CALL ONLY AFTER CLEARWORLD
	if (AATextEnable) {
		InitAAFont()
		for (let font of AAFont.each) {
			if (font.isAA) {
				font.texture = CreateTexture(1024,1024,3)
				LockBuffer(ImageBuffer(font.backup))
				LockBuffer(TextureBuffer(font.texture))
				for (let ix of range(1024)) {
					for (let iy of range(font.texH + 1)) {
						let px = ReadPixelFast(ix,iy,ImageBuffer(font.backup)) << 24
						WritePixelFast(ix,iy,0xFFFFFF+px,TextureBuffer(font.texture))
					}
				}
				UnlockBuffer(TextureBuffer(font.texture))
				UnlockBuffer(ImageBuffer(font.backup))
			}
		}
	}
}

export function AASetFont(fnt: int) {	
	AASelectedFont = fnt
	let font: AAFont = AAFont.each[AASelectedFont]
	if (AATextEnable && font.isAA) {
		for (let i of range(150)) {
			EntityTexture(AATextSprite[i],font.texture)
		}
	}
}

export function AAStringWidth(txt: string): int {
	let font: AAFont = AAFont.each[AASelectedFont]
	if ((AATextEnable) && (font.isAA)) {
		let retVal: int = 0
		for (let i of range(1, Len(txt) + 1)) {
			let char: int = Asc(Mid(txt,i,1))
			if (char>=0 && char<=127) {
				retVal=retVal+font.w[char]-2
			}
		}
		return retVal+2
	} else {
		SetFont (font.lowResFont)
		return StringWidth(txt)
	}
}

export function AAStringHeight(txt: string): int {
	let font: AAFont = AAFont.each[AASelectedFont]
	if ((AATextEnable) && (font.isAA)) {
		return font.mH
	}
	SetFont (font.lowResFont)
	return StringHeight(txt)
}

export function AAText(x: int,y: int,txt: string,cx: boolean=false,cy: boolean = false,a: float = 1.0) {
	if (Len(txt) == 0) {return}
	let font: AAFont = AAFont.each[AASelectedFont]
	
	if ((GraphicsBuffer() != BackBuffer()) || (!AATextEnable) || (!font.isAA)) {
		SetFont (font.lowResFont)
		let oldr: int = ColorRed()
		let oldg: int = ColorGreen()
		let oldb: int = ColorBlue()
		Color(oldr*a,oldg*a,oldb*a)
		BBText(x,y,txt,cx,cy)
		Color(oldr,oldg,oldb)
		return
	}
	
	if (cx) {
		x=x-(AAStringWidth(txt)/2)
	}
	
	if (cy) {
		y=y-(AAStringHeight(txt)/2)
	}
	
	if (Camera != 0) {HideEntity(Camera)}
	if (ark_blur_cam != 0) {HideEntity(ark_blur_cam)}
	
	let tX: int = 0
	CameraProjMode(AATextCam,2)
	
	let char: int
	
	let tw: int = 0
	for (let i of range(1, Len(txt) + 1)) {
		char = Asc(Mid(txt,i,1))
		if (char>=0 && char<=127) {
			tw=tw+font.w[char]
		}
	}
	
	AACamViewW = tw
	AACamViewW = AACamViewW+(AACamViewW % 2)
	AACamViewH = AAStringHeight(txt)
	AACamViewH = AACamViewH+(AACamViewH % 2)
	
	let vx: int = x
	if (vx<0) {vx=0}
	let vy: int = y
	if (vy<0) {vy=0}
	let vw: int = AACamViewW+(x-vx)
	if (vw+vx>GraphicWidth) {vw=GraphicWidth-vx}
	let vh: int = AACamViewH+(y-vy)
	if (vh+vy>GraphicHeight) {vh=GraphicHeight-vy}
	vw = vw-(vw % 2)
	vh = vh-(vh % 2)
	AACamViewH = AACamViewH+(AACamViewH % 2)
	AACamViewW = vw
	AACamViewH = vh
	
	
	CameraViewport (AATextCam,vx,vy,vw,vh)
	for (let i of range(1, Len(txt) + 1)) {
		EntityAlpha (AATextSprite[i-1],a)
		EntityColor (AATextSprite[i-1],ColorRed(),ColorGreen(),ColorBlue())
		ShowEntity( AATextSprite[i-1])
		let char: int = Asc(Mid(txt,i,1))
		if (char>=0 && char<=127) {
			AASpriteScale(i-1,font.w[char],font.h[char])
			AASpritePosition(i-1,tX+(x-vx)+(font.w[char]/2),(y-vy)+(font.h[char]/2))
			VertexTexCoords(GetSurface(AATextSprite[i-1],1),0,Float(font.x[char])/1024.0,Float(font.y[char])/1024.0)
			VertexTexCoords(GetSurface(AATextSprite[i-1],1),1,Float(font.x[char]+font.w[char])/1024.0,Float(font.y[char])/1024.0)
			VertexTexCoords(GetSurface(AATextSprite[i-1],1),2,Float(font.x[char])/1024.0,Float(font.y[char]+font.h[char])/1024.0)
			VertexTexCoords(GetSurface(AATextSprite[i-1],1),3,Float(font.x[char]+font.w[char])/1024.0,Float(font.y[char]+font.h[char])/1024.0)
			tX = tX+font.w[char]-2
		}
	}
	RenderWorld()
	CameraProjMode(AATextCam,0)
	
	for (let i of range(1, Len(txt) + 1)) {
		HideEntity(AATextSprite[i-1])
	}
	
	if (Camera != 0) {
		ShowEntity(Camera)
	}
	if (ark_blur_cam != 0) {
		ShowEntity(ark_blur_cam)
	}
}

export function AALoadFont(file: string="Tahoma", height=13, bold=0, italic=0, underline=0, AATextScaleFactor: int = 2): int {
	let newFont: AAFont = new AAFont()
	
	newFont.lowResFont = LoadFont(file,height,bold,italic,underline)
	
	SetFont (newFont.lowResFont)
	newFont.mW = FontWidth()
	newFont.mH = FontHeight()
	
	if (AATextEnable && AATextScaleFactor>1) {
		let hResFont: int = LoadFont(file,height*AATextScaleFactor,bold,italic,underline)
		let tImage: int = CreateTexture(1024,1024,3)
		let tX: int = 0
		let tY: int = 1
		
		SetFont (hResFont)
		let tCharImage: int = CreateImage(FontWidth()+2*AATextScaleFactor,FontHeight()+2*AATextScaleFactor)
		ClsColor (0,0,0)
		LockBuffer (TextureBuffer(tImage))
		
		let miy: int = newFont.mH*((newFont.mW*95/1024)+2)
		DebugLog (miy)
		
		newFont.mW = 0
		
		for (let ix of range(1024)) {
			for (let iy of range(miy + 1)) {
				WritePixelFast(ix,iy,0xFFFFFF,TextureBuffer(tImage))
			}
		}
		
		for (let i of range(32, 127)) {
			SetBuffer(ImageBuffer(tCharImage))
			Cls()

			Color(255,255,255)
			SetFont(hResFont)
			BBText(AATextScaleFactor/2,AATextScaleFactor/2,Chr(i))
			let tw: int = StringWidth(Chr(i))
			let th: int = FontHeight()
			SetFont(newFont.lowResFont)
			let dsw: int = StringWidth(Chr(i))
			let dsh: int = FontHeight()
			
			let wRatio: float = Float(tw)/Float(dsw)
			let hRatio: float = Float(th)/Float(dsh)
			
			SetBuffer(BackBuffer())
				
			LockBuffer(ImageBuffer(tCharImage))
			
			for (let iy of range(dsh)) {
				for (let ix of range(dsw)) {
					let rsx: int = Int(Float(ix)*wRatio-(wRatio*0.0))
					if ((rsx<0)) {rsx=0}
					let rsy: int = Int(Float(iy)*hRatio-(hRatio*0.0))
					if ((rsy<0)) {rsy=0}
					let rdx: int = Int(Float(ix)*wRatio+(wRatio*1.0))
					if ((rdx>tw)) {rdx=tw-1}
					let rdy: int = Int(Float(iy)*hRatio+(hRatio*1.0))
					if ((rdy>th)) {rdy=th-1}
					let ar: int = 0
					if (Abs(rsx-rdx)*Abs(rsy-rdy)>0) {
						for (let iiy of range(rsy, rdy)) {
							for (let iix of range(rsx, rdx)) {
								ar=ar+((ReadPixelFast(iix,iiy,ImageBuffer(tCharImage)) && 0xFF))
							}
						}
						ar = ar/(Abs(rsx-rdx)*Abs(rsy-rdy))
						if (ar>255) {
							ar=255
						}
						ar = ((Float(ar)/255.0)^(0.5))*255
					}
					WritePixelFast(ix+tX,iy+tY,0xFFFFFF+(ar << 24),TextureBuffer(tImage))
				}
			}
			
			UnlockBuffer(ImageBuffer(tCharImage))
	
			newFont.x[i]=tX
			newFont.y[i]=tY
			newFont.w[i]=dsw+2
			
			if (newFont.mW<newFont.w[i]-3) {newFont.mW=newFont.w[i]-3}
			
			newFont.h[i]=dsh+2
			tX=tX+newFont.w[i]+2
			if (tX>1024-FontWidth()-4) {
				tX=0
				tY=tY+FontHeight()+6
			}
		}
		
		newFont.texH = miy
		
		let backup: int = CreateImage(1024,1024)
		LockBuffer(ImageBuffer(backup))
		for (let ix of range(1024)) {
			for (let iy of range(newFont.texH + 1)) {
				let px = ReadPixelFast(ix,iy,TextureBuffer(tImage)) >> 24
				px += (px << 8) + (px << 16)
				WritePixelFast(ix,iy,0xFF000000+px,ImageBuffer(backup))
			}
		}
		UnlockBuffer(ImageBuffer(backup))
		newFont.backup = backup
		
		UnlockBuffer(TextureBuffer(tImage))
		
		
		FreeImage(tCharImage)
		FreeFont(hResFont)
		newFont.texture = tImage
		newFont.isAA = true
	} else {
		newFont.isAA = false
	}
	return Handle(newFont)
}

if (LauncherEnabled) {
	AspectRatioRatio = 1.0
	UpdateLauncher()
	
	//New "fake fullscreen" - ENDSHN Psst, it's called borderless windowed mode --Love Mark,
	if (BorderlessWindowed) {
		DebugLog ("Using Borderless Windowed Mode")
		Graphics3DExt (G_viewport_width, G_viewport_height, 0, 2)
		
		// -- Change the window style to 'WS_POPUP' and then set the window position to force the style to update.
		api_SetWindowLong( G_app_handle, C_GWL_STYLE, C_WS_POPUP )
		api_SetWindowPos( G_app_handle, C_HWND_TOP, G_viewport_x, G_viewport_y, G_viewport_width, G_viewport_height, C_SWP_SHOWWINDOW )
		
		RealGraphicWidth = G_viewport_width
		RealGraphicHeight = G_viewport_height
		
		AspectRatioRatio = (Float(GraphicWidth)/Float(GraphicHeight))/(Float(RealGraphicWidth)/Float(RealGraphicHeight))
		
		Fullscreen = false
	} else {
		AspectRatioRatio = 1.0
		RealGraphicWidth = GraphicWidth
		RealGraphicHeight = GraphicHeight
		if (Fullscreen) {
			Graphics3DExt(GraphicWidth, GraphicHeight, (16*Bit16Mode), 1)
		} else {
			Graphics3DExt(GraphicWidth, GraphicHeight, 0, 2)
		}
	}
	
} else {
	for (let i of range(1, TotalGFXModes + 1)) {
		let samefound: boolean = false
		for  (let n of range(TotalGFXModes)) {
			if (GfxModeWidths[n] == GfxModeWidth(i) && GfxModeHeights[n] == GfxModeHeight(i)) {
				samefound = true
				break
			}
		}
		if (!samefound) {
			if (GraphicWidth == GfxModeWidth(i) && GraphicHeight == GfxModeHeight(i)) {
				SelectedGFXMode = GFXModes
			}
			GfxModeWidths[GFXModes] = GfxModeWidth(i)
			GfxModeHeights[GFXModes] = GfxModeHeight(i)
			GFXModes=GFXModes+1
		}
	}
	
	GraphicWidth = GfxModeWidths[SelectedGFXMode]
	GraphicHeight = GfxModeHeights[SelectedGFXMode]
	
	//New "fake fullscreen" - ENDSHN Psst, it's called borderless windowed mode --Love Mark,
	if (BorderlessWindowed) {
		DebugLog ("Using Faked Fullscreen")
		Graphics3DExt (G_viewport_width, G_viewport_height, 0, 2)
		
		// -- Change the window style to 'WS_POPUP' and then set the window position to force the style to update.
		api_SetWindowLong( G_app_handle, C_GWL_STYLE, C_WS_POPUP )
		api_SetWindowPos( G_app_handle, C_HWND_TOP, G_viewport_x, G_viewport_y, G_viewport_width, G_viewport_height, C_SWP_SHOWWINDOW )
		
		RealGraphicWidth = G_viewport_width
		RealGraphicHeight = G_viewport_height
		
		AspectRatioRatio = (Float(GraphicWidth)/Float(GraphicHeight))/(Float(RealGraphicWidth)/Float(RealGraphicHeight))
		
		Fullscreen = false
	} else {
		AspectRatioRatio = 1.0
		RealGraphicWidth = GraphicWidth
		RealGraphicHeight = GraphicHeight
		if (Fullscreen) {
			Graphics3DExt(GraphicWidth, GraphicHeight, (16*Bit16Mode), 1)
		} else {
			Graphics3DExt(GraphicWidth, GraphicHeight, 0, 2)
		}
	}
	
}

export var MenuScale: float = (GraphicHeight / 1024.0)

SetBuffer(BackBuffer())

export var CurTime: int
export var PrevTime: int
export var LoopDelay: int
export var FPSfactor: float
export var FPSfactor2: float
export var PrevFPSFactor: float
let CheckFPS: int
export var ElapsedLoops: int
export var FPS: int
export var ElapsedTime: float

export var Framelimit: int = GetINIInt(OptionFile, "options", "framelimit")
export var Vsync: int = GetINIInt(OptionFile, "options", "vsync")

export var Opt_AntiAlias = GetINIInt(OptionFile, "options", "antialias")

export var CurrFrameLimit: float = (Framelimit-19)/100.0

export var ScreenGamma: float = GetINIFloat(OptionFile, "options", "screengamma")

export const HIT_MAP: int = 1
export const HIT_PLAYER: int = 2
export const HIT_ITEM: int = 3
export const HIT_APACHE: int = 4
export const HIT_178: int = 5
export const HIT_DEAD: int = 6
SeedRnd (MilliSecs())

export var GameSaved: int

export var CanSave: boolean = true

AppTitle ("SCP - Containment Breach v"+VersionNumber)

PlayStartupVideos()

//---------------------------------------------------------------------------------------------------------------------


export var CursorIMG: int = LoadImage_Strict("GFX/cursor.png")

export var SelectedLoadingScreen: LoadingScreens
export var LoadingScreenAmount: int
export var LoadingScreenText: int
export var LoadingBack: int = LoadImage_Strict("Loadingscreens/loadingback.jpg")
InitLoadingScreens("Loadingscreens/loadingscreens.ini")

InitAAFont()
//For some reason, Blitz3D doesn't load fonts that have filenames that
//don't match their "internal name" (i.e. their display name in applications
//like Word and such). As a workaround, I moved the files and renamed them so they
//can load without FastText.
Font1 = AALoadFont("GFX/font/cour/Courier New.ttf", Int(19 * (GraphicHeight / 1024.0)), 0,0,0)
Font2 = AALoadFont("GFX/font/courbd/Courier New.ttf", Int(58 * (GraphicHeight / 1024.0)), 0,0,0)
Font3 = AALoadFont("GFX/font/DS-DIGI/DS-Digital.ttf", Int(22 * (GraphicHeight / 1024.0)), 0,0,0)
Font4 = AALoadFont("GFX/font/DS-DIGI/DS-Digital.ttf", Int(60 * (GraphicHeight / 1024.0)), 0,0,0)
Font5 = AALoadFont("GFX/font/Journal/Journal.ttf", Int(58 * (GraphicHeight / 1024.0)), 0,0,0)

export var CreditsFont: int
export var CreditsFont2: int

ConsoleFont = AALoadFont("Blitz", Int(20 * (GraphicHeight / 1024.0)), 0,0,0,1)

AASetFont (Font2)

export var BlinkMeterIMG: int = LoadImage_Strict("GFX/blinkmeter.jpg")

DrawLoading(0, true)

// - -Viewport.
export var viewport_center_x: int = GraphicWidth / 2
export var viewport_center_y: int = GraphicHeight / 2

// -- Mouselook.
export var mouselook_x_inc: float = 0.3 // This sets both the sensitivity and direction (+/-) of the mouse on the X axis.
export var mouselook_y_inc: float = 0.3 // This sets both the sensitivity and direction (+/-) of the mouse on the Y axis.
// Used to limit the mouse movement to within a certain number of pixels (250 is used here) from the center of the screen.
// This produces smoother mouse movement than continuously moving the mouse back to the center each loop.
export var mouse_left_limit: int = 250
export var mouse_right_limit: int = GraphicsWidth () - 250
export var mouse_top_limit: int = 150
export var mouse_bottom_limit: int = GraphicsHeight () - 150 // As above.
export var mouse_x_speed_1: float
export var mouse_y_speed_1: float

export var KEY_RIGHT = GetINIInt(OptionFile, "binds", "Right key")
export var KEY_LEFT = GetINIInt(OptionFile, "binds", "Left key")
export var KEY_UP = GetINIInt(OptionFile, "binds", "Up key")
export var KEY_DOWN = GetINIInt(OptionFile, "binds", "Down key")

export var KEY_BLINK = GetINIInt(OptionFile, "binds", "Blink key")
export var KEY_SPRINT = GetINIInt(OptionFile, "binds", "Sprint key")
export var KEY_INV = GetINIInt(OptionFile, "binds", "Inventory key")
export var KEY_CROUCH = GetINIInt(OptionFile, "binds", "Crouch key")
export var KEY_SAVE = GetINIInt(OptionFile, "binds", "Save key")
export var KEY_CONSOLE = GetINIInt(OptionFile, "binds", "Console key")

export var MouseSmooth: float = GetINIFloat(OptionFile,"options", "mouse smoothing", 1.0)

export const INFINITY: float = (999.0) ^ (99999.0)
export const NAN: float = (-1.0) ^ (0.5)

export var Mesh_MinX: float
export var Mesh_MinY: float
export var Mesh_MinZ: float
export var Mesh_MaxX: float
export var Mesh_MaxY: float
export var Mesh_MaxZ: float
export var Mesh_MagX: float
export var Mesh_MagY: float
export var Mesh_MagZ: float

//player stats -------------------------------------------------------------------------------------------------------
export var KillTimer: float
export var KillAnim: int
export var FallTimer: float
export var DeathTimer: float
export var Sanity: float
export var ForceMove: float
export var ForceAngle: float
export var RestoreSanity: int

export var Playable: boolean = true

export var BLINKFREQ: float
export var BlinkTimer: float
export var EyeIrritation: float
export var EyeStuck: float
export var BlinkEffect: float = 1.0
export var BlinkEffectTimer: float

export var Stamina: float
export var StaminaEffect: float=1.0
export var StaminaEffectTimer: float

export var CameraShakeTimer: float
export var Vomit: int
export var VomitTimer: float
export var Regurgitate: int

export var SCP1025state: float[] = new Array(6)

export var HeartBeatRate: float
export var HeartBeatTimer: float
export var HeartBeatVolume: float

export var WearingGasMask: int
export var WearingHazmat: int
export var WearingVest: int
export var Wearing714: int
export var WearingNightVision: int
export var NVTimer: float

export var SuperMan: int
export var SuperManTimer: float

export var Injuries: float
export var Bloodloss: float
export var Infect: float
export var HealTimer: float

export var RefinedItems: int

export const MAXACHIEVEMENTS=37
export var Achievements: boolean[] = new Array(MAXACHIEVEMENTS)

export const Achv008: int=0
export const Achv012: int=1
export const Achv035: int=2
export const Achv049: int=3
export const Achv055=4
export const  Achv079: int=5
export const Achv096: int=6
export const Achv106: int=7
export const Achv148: int=8
export const Achv205=9
export const Achv294: int=10
export const Achv372: int=11
export const Achv420: int=12
export const Achv427=13
export const Achv500: int=14
export const Achv513: int=15
export const Achv714: int=16
export const Achv789: int=17
export const Achv860: int=18
export const Achv895: int=19
export const Achv914: int=20
export const Achv939: int=21
export const Achv966: int=22
export const Achv970=23
export const Achv1025: int=24
export const Achv1048=25
export const Achv1123=26

export const AchvMaynard: int=27
export const AchvHarp: int=28
export const AchvSNAV: int=29
export const AchvOmni: int=30
export const AchvConsole: int=31
export const AchvTesla: int=32
export const AchvPD: int=33

export const Achv1162: int = 34
export const Achv1499: int = 35

export const AchvKeter: int = 36

export var UsedConsole

export var AchievementsMenu: int
export var AchvMSGenabled: int = GetINIInt("options.ini", "options", "achievement popup enabled")
export var AchievementStrings: string[] = new Array(MAXACHIEVEMENTS)
export var AchievementDescs: string[] = new Array(MAXACHIEVEMENTS)
export var AchvIMG: int[] = new Array(MAXACHIEVEMENTS)

for (let i of range(MAXACHIEVEMENTS)) {
	let loc2: int = GetINISectionLocation("Data/achievementstrings.ini", "s"+Str(i))
	AchievementStrings[i] = GetINIString2("Data/achievementstrings.ini", loc2, "string1")
	AchievementDescs[i] = GetINIString2("Data/achievementstrings.ini", loc2, "AchvDesc")
	
	let image: string = GetINIString2("Data/achievementstrings.ini", loc2, "image") 
	
	AchvIMG[i] = LoadImage_Strict("GFX/menu/achievements/"+image+".jpg")
	AchvIMG[i] = ResizeImage2(AchvIMG[i],ImageWidth(AchvIMG[i])*GraphicHeight/768.0,ImageHeight(AchvIMG[i])*GraphicHeight/768.0)
}

var AchvLocked = LoadImage_Strict("GFX/menu/achievements/achvlocked.jpg")
AchvLocked = ResizeImage2(AchvLocked,ImageWidth(AchvLocked)*GraphicHeight/768.0,ImageHeight(AchvLocked)*GraphicHeight/768.0)

export function GiveAchievement(achvname: int, showMessage: boolean = true) {
	if (Achievements[achvname] != true) {
		Achievements[achvname] = true
		if (AchvMSGenabled && showMessage) {
			let loc2: int = GetINISectionLocation("Data/achievementstrings.ini", "s"+achvname)
			let AchievementName: string = GetINIString2("Data/achievementstrings.ini", loc2, "string1")
			CreateAchievementMsg(achvname,AchievementName)
		}
	}
}

export function AchievementTooltip(achvno: int) {
    let scale: float = GraphicHeight/768.0
    
    AASetFont(Font3)
    let width = AAStringWidth(AchievementStrings(achvno))
    AASetFont(Font1)
    if (AAStringWidth(AchievementDescs[achvno])>width) {
        width = AAStringWidth(AchievementDescs[achvno])
	}
    width = width+20*MenuScale
    
    let height = 38*scale
    
    Color(25,25,25)
    Rect(ScaledMouseX()+(20*MenuScale),ScaledMouseY()+(20*MenuScale),width,height,true)
    Color(150,150,150)
    Rect(ScaledMouseX()+(20*MenuScale),ScaledMouseY()+(20*MenuScale),width,height,false)
    AASetFont(Font3)
    AAText(ScaledMouseX()+(20*MenuScale)+(width/2),ScaledMouseY()+(35*MenuScale), AchievementStrings(achvno), true, true)
    AASetFont(Font1)
    AAText(ScaledMouseX()+(20*MenuScale)+(width/2),ScaledMouseY()+(55*MenuScale), AchievementDescs[achvno], true, true)
}

function DrawAchvIMG(x: int, y: int, achvno: int) {
	let row: int
	let scale: float = GraphicHeight/768.0
	let SeparationConst2 = 76 * scale
	row = achvno % 4
	Color( 0,0,0)
	Rect((x+((row)*SeparationConst2)), y, 64*scale, 64*scale, true)
	if (Achievements(achvno)) {
		DrawImage(AchvIMG(achvno),(x+(row*SeparationConst2)),y)
	} else {
		DrawImage(AchvLocked,(x+(row*SeparationConst2)),y)
	}
	Color (50,50,50)
	
	Rect((x+(row*SeparationConst2)), y, 64*scale, 64*scale, false)
}

var CurrAchvMSGID: int = 0

class AchievementMsg {
	achvID: int
	txt: string
	msgx: float
	msgtime: float
	msgID: int
	static each: AchievementMsg[] = []
}

function CreateAchievementMsg(id: int,txt: string): AchievementMsg {
	let amsg: AchievementMsg = new AchievementMsg()
	
	amsg.achvID = id
	amsg.txt = txt
	amsg.msgx = 0.0
	amsg.msgtime = FPSfactor2
	amsg.msgID = CurrAchvMSGID
	CurrAchvMSGID = CurrAchvMSGID + 1
	
	return amsg
}

function UpdateAchievementMsg() {
	let amsg: AchievementMsg
	let amsg2: AchievementMsg
	let scale: float = GraphicHeight/768.0
	let width: int = 264*scale
	let height: int = 84*scale
	let x: int
	let y: int
	
	for (amsg of AchievementMsg.each) {
		if (amsg.msgtime != 0) {
			x=GraphicWidth+amsg.msgx
			y=(GraphicHeight-height)
			for (amsg2 of AchievementMsg.each) {
				if (amsg2 != amsg) {
					if (amsg2.msgID > amsg.msgID) {
						y=y-height
					}
				}
			}
			DrawFrame(x,y,width,height)
			Color(0,0,0)
			Rect(x+10*scale,y+10*scale,64*scale,64*scale,true)
			DrawImage(AchvIMG[amsg.achvID],x+10*scale,y+10*scale)
			Color(50,50,50)
			Rect(x+10*scale,y+10*scale,64*scale,64*scale,false)
			Color(255,255,255)
			AASetFont(Font1)
			RowText("Achievement Unlocked - "+amsg.txt,x+84*scale,y+10*scale,width-94*scale,y-20*scale)
			if (amsg.msgtime > 0.0 && amsg.msgtime < 70*7) {
				amsg.msgtime = amsg.msgtime + FPSfactor2
				if (amsg.msgx > -width) {
					amsg.msgx = Max(amsg.msgx-4*FPSfactor2,-width%)
				}
			} else if (amsg.msgtime >= 70*7) {
				amsg.msgtime = -1
			} else if (amsg.msgtime = -1) {
				if (amsg.msgx < 0.0) {
					amsg.msgx = Min(amsg.msgx+4*FPSfactor2,0.0)
				} else {
					amsg.msgtime = 0.0
				}
			}
		} else {
			Delete(amsg)
		}
	}
}

//player coordinates, angle, speed, movement etc ---------------------------------------------------------------------
export var DropSpeed: float
export var HeadDropSpeed: float
export var CurrSpeed: float
export var user_camera_pitch: float
export var side: float
export var Crouch: int
export var CrouchState: float

export var PlayerZone: AreaName
export var PlayerRoom: Rooms

export var GrabbedEntity: int

export var InvertMouse: int = GetINIInt(OptionFile, "options", "invert mouse y")
export var MouseHit1: int
export var MouseDown1: boolean
export var MouseHit2: int
export var DoubleClick: int
export var LastMouseHit1: int
export var MouseUp1: int

export var GodMode: int
export var NoClip: int
export var NoClipSpeed: float = 2.0

export var CoffinDistance: float = 100.0

export var PlayerSoundVolume: float

//camera/lighting effects (blur, camera shake, etc)-------------------------------------------------------------------
export var Shake: float

export var ExplosionTimer: float, ExplosionSFX: int

export var LightsOn: boolean = true

export var SoundTransmission: int

//menus, GUI ---------------------------------------------------------------------------------------------------------
export var MainMenuOpen: boolean
export var MenuOpen: boolean
export var StopHidingTimer: float
export var InvOpen: boolean
export var OtherOpen: Items

export var SelectedEnding: string
export var EndingScreen: int
export var EndingTimer: float

export var MsgTimer: float
export var Msg: string
export var DeathMSG: string

export var AccessCode: int
export var KeypadInput: string
export var KeypadTimer: float
export var KeypadMSG: string

export var DrawHandIcon: int
export var DrawArrowIcon: int[] = new Array(4)

//misc ---------------------------------------------------------------------------------------------------------------


export class Difficulty {
	name: string
	description: string
	permaDeath: boolean
	aggressiveNPCs
	saveType: int
	otherFactors: int
	
	color: BColor
	
	customizable: boolean
}

export var difficulties: Difficulty[] = new Array(4)

export var SelectedDifficulty: Difficulty

export const SAFE=0
export const EUCLID=1
export const KETER=2
export const CUSTOM=3
export enum DifficultyLevel {
	SAFE,
	EUCLID,
	KETER,
	CUSTOM
}

export const SAVEANYWHERE = 0
export const SAVEONQUIT=1
export const SAVEONSCREENS=2
export enum SaveSetting {
	SAVE_ANYWHERE,
	SAVE_ON_QUIT,
	SAVE_ON_SCREENS
}

export const EASY = 0
export const NORMAL = 1
export const HARD = 2
export enum DifficultySetting {
	EASY,
	NORMAL,
	HARD
}

difficulties[DifficultyLevel.SAFE] = new Difficulty()
difficulties[DifficultyLevel.SAFE].name = "Safe"
difficulties[DifficultyLevel.SAFE].description ="The game can be saved any time. However, as in the case of SCP Objects, a Safe classification does not mean that handling it does not pose a threat."
difficulties[DifficultyLevel.SAFE].permaDeath = false
difficulties[DifficultyLevel.SAFE].aggressiveNPCs = false
difficulties[DifficultyLevel.SAFE].saveType = SaveSetting.SAVE_ANYWHERE
difficulties[DifficultyLevel.SAFE].otherFactors = DifficultySetting.EASY
difficulties[DifficultyLevel.SAFE].color = new BColor(120, 150, 50)

difficulties[DifficultyLevel.EUCLID] = new Difficulty()
difficulties[DifficultyLevel.EUCLID].name = "Euclid"
difficulties[DifficultyLevel.EUCLID].description = "In Euclid difficulty, saving is only allowed at specific locations marked by lit up computer screens. Euclid-class objects are inherently unpredictable, so that reliable containment is not always possible."
difficulties[DifficultyLevel.EUCLID].permaDeath = false
difficulties[DifficultyLevel.EUCLID].aggressiveNPCs = false
difficulties[DifficultyLevel.EUCLID].saveType = SaveSetting.SAVE_ON_SCREENS
difficulties[DifficultyLevel.EUCLID].otherFactors = DifficultySetting.NORMAL
difficulties[DifficultyLevel.EUCLID].color = new BColor(200, 200, 0)

difficulties[DifficultyLevel.KETER] = new Difficulty()
difficulties[DifficultyLevel.KETER].name = "Keter"
difficulties[DifficultyLevel.KETER].description = "Keter-class objects are considered the most dangerous ones in Foundation containment. The same can be said for this difficulty level: the SCPs are more aggressive, and you have only one life - when you die, the game is over. "
difficulties[DifficultyLevel.KETER].permaDeath = true
difficulties[DifficultyLevel.KETER].aggressiveNPCs = true
difficulties[DifficultyLevel.KETER].saveType = SaveSetting.SAVE_ON_QUIT
difficulties[DifficultyLevel.KETER].otherFactors = DifficultySetting.HARD
difficulties[DifficultyLevel.KETER].color = new BColor(200, 0, 0)

difficulties[DifficultyLevel.CUSTOM] = new Difficulty()
difficulties[DifficultyLevel.CUSTOM].name = "Custom"
difficulties[DifficultyLevel.CUSTOM].permaDeath = false
difficulties[DifficultyLevel.CUSTOM].aggressiveNPCs = true
difficulties[DifficultyLevel.CUSTOM].saveType = SaveSetting.SAVE_ANYWHERE
difficulties[DifficultyLevel.CUSTOM].customizable = true
difficulties[DifficultyLevel.CUSTOM].otherFactors = DifficultySetting.EASY
difficulties[DifficultyLevel.CUSTOM].color = new BColor(255, 255, 255)

SelectedDifficulty = difficulties[DifficultyLevel.SAFE]


export var MTFtimer: float
export var MTFrooms: Rooms[] = new Array(10)
export var MTFroomState: int[] = new Array(10)

export var RadioState: float[] = new Array(10)
export var RadioState3: int[] = new Array(10)
export var RadioState4: int[] = new Array(9)
export var RadioCHN: int[] = new Array(8)

export var OldAiPics: int[] = new Array(5)

export var PlayTime: int
export var ConsoleFlush: int
export var ConsoleFlushSnd: int = 0
export var ConsoleMusFlush: int = 0
export var ConsoleMusPlay: int = 0

export var InfiniteStamina: boolean = false
export var NVBlink: int
export var IsNVGBlinking: boolean = false

//[End block]


//----------------------------------------------  Console -----------------------------------------------------

export var ConsoleOpen: int
export var ConsoleInput: string
export var ConsoleScroll: float
export var ConsoleScrollDragging: int
export var ConsoleMouseMem: int
export var ConsoleReissue: ConsoleMsg
export var ConsoleR: int = 255
export var ConsoleG: int = 255
export var ConsoleB: int = 255

export class ConsoleMsg {
	txt: string
	isCommand: int
	r: int
	g: int
	b: int
	static each: ConsoleMsg[] = []
}

export function CreateConsoleMsg(txt: string,r: int=-1,g: int=-1,b: int=-1,isCommand: boolean = false) {
	let c: ConsoleMsg = new ConsoleMsg()
	ConsoleMsg.each.Insert(c)
	
	c.txt = txt
	c.isCommand = isCommand
	
	c.r = r
	c.g = g
	c.b = b
	
	if (c.r<0) {c.r = ConsoleR}
	if (c.g<0) {c.g = ConsoleG}
	if (c.b<0) {c.b = ConsoleB}
}

export function UpdateConsole() {
	let e: Events
	
	if (!CanOpenConsole) {
		ConsoleOpen = false
		return
	}
	
	if (ConsoleOpen) {
		let cm: ConsoleMsg
		
		AASetFont (ConsoleFont)
		
		ConsoleR = 255
		ConsoleG = 255
		ConsoleB = 255
		
		let x: int = 0
		let y: int = GraphicHeight-300*MenuScale
		let width: int = GraphicWidth
		let height: int = 300*MenuScale-30*MenuScale
		let StrTemp: string
		let temp: int
		let i: int
		let ev: Events
		let r: Rooms
		let it: Items
		
		DrawFrame (x,y,width,height+30*MenuScale)
		
		let consoleHeight: int = 0
		let scrollbarHeight: int = 0
		for (cm of ConsoleMsg.each) {
			consoleHeight = consoleHeight + 15*MenuScale
		}
		scrollbarHeight = (Float(height)/Float(consoleHeight))*height
		if (scrollbarHeight>height) {scrollbarHeight = height}
		if (consoleHeight<height) {consoleHeight = height}
		
		Color (50,50,50)
		let inBar = MouseOn(x+width-26*MenuScale,y,26*MenuScale,height)
		if (inBar) {
			Color (70,70,70)
		}
		Rect (x+width-26*MenuScale,y,26*MenuScale,height,true)
		
		
		Color (120,120,120)
		let inBox = MouseOn(x+width-23*MenuScale,y+height-scrollbarHeight+(ConsoleScroll*scrollbarHeight/height),20*MenuScale,scrollbarHeight)
		if (inBox) {Color (200,200,200)}
		if (ConsoleScrollDragging) {Color (255,255,255)}
		Rect (x+width-23*MenuScale,y+height-scrollbarHeight+(ConsoleScroll*scrollbarHeight/height),20*MenuScale,scrollbarHeight,true)
		
		if (!MouseDown(1)) {
			ConsoleScrollDragging=false
		} else if (ConsoleScrollDragging) {
			ConsoleScroll = ConsoleScroll+((ScaledMouseY()-ConsoleMouseMem)*height/scrollbarHeight)
			ConsoleMouseMem = ScaledMouseY()
		}
		
		if (!ConsoleScrollDragging) {
			if (MouseHit1) {
				if (inBox) {
					ConsoleScrollDragging=true
					ConsoleMouseMem = ScaledMouseY()
				} else if(inBar) {
					ConsoleScroll = ConsoleScroll+((ScaledMouseY()-(y+height))*consoleHeight/height+(height/2))
					ConsoleScroll = ConsoleScroll/2
				}
			}
		}
		
		mouseScroll = MouseZSpeed()
		if (mouseScroll == 1) {
			ConsoleScroll = ConsoleScroll - 15*MenuScale
		} else if (mouseScroll == -1) {
			ConsoleScroll = ConsoleScroll + 15*MenuScale
		}
		
		let reissuePos: int
		if (KeyHit(200)){
			reissuePos = 0
			if (!ConsoleReissue) {
				ConsoleReissue=First (ConsoleMsg.each)
				
				while (ConsoleReissue) {
					if (ConsoleReissue.isCommand) {
						break
					}
					reissuePos = reissuePos - 15*MenuScale
					ConsoleReissue = After (ConsoleReissue)
				}
				
			} else {
				let cm: ConsoleMsg = First (ConsoleMsg.each)
				while (cm) {
					if (cm==ConsoleReissue) {break}
					reissuePos = reissuePos-15*MenuScale
					cm = After (cm)
				}
				ConsoleReissue = After (ConsoleReissue)
				reissuePos = reissuePos-15*MenuScale
				
				while (true) {
					if (!ConsoleReissue) {
						ConsoleReissue=First (ConsoleMsg)
						reissuePos = 0
					}
				
					if (ConsoleReissue.isCommand) {
						break
					}
					reissuePos = reissuePos - 15*MenuScale
					ConsoleReissue = After (ConsoleReissue)
				}
			}
			
			if (ConsoleReissue != Null) {
				ConsoleInput = ConsoleReissue.txt
				ConsoleScroll = reissuePos+(height/2)
			}
		}
		
		if (KeyHit(208)) {
			reissuePos = -consoleHeight+15*MenuScale
			if (ConsoleReissue==Null) {
				ConsoleReissue=Last (ConsoleMsg)
				
				while (ConsoleReissue != Null) {
					if (ConsoleReissue.isCommand) {
						break
					}
					reissuePos = reissuePos + 15*MenuScale
					ConsoleReissue = Before (ConsoleReissue)
				}
				
			} else {
				cm.ConsoleMsg = Last (ConsoleMsg)
				while (cm != Null) {
					if (cm == ConsoleReissue) {break}
					reissuePos = reissuePos+15*MenuScale
					cm = Before (cm)
				}
				ConsoleReissue = Before (ConsoleReissue)
				reissuePos = reissuePos+15*MenuScale
				
				while (true) {
					if (ConsoleReissue==Null) {
						ConsoleReissue=Last (ConsoleMsg)
						reissuePos=-consoleHeight+15*MenuScale
					}
				
					if (ConsoleReissue.isCommand) {
						break
					}
					reissuePos = reissuePos + 15*MenuScale
					ConsoleReissue = Before (ConsoleReissue)
				}
			}
			
			if (ConsoleReissue!=Null) {
				ConsoleInput = ConsoleReissue.txt
				ConsoleScroll = reissuePos+(height/2)
			}
		}
		
		if (ConsoleScroll<-consoleHeight+height) {ConsoleScroll = -consoleHeight+height}
		if (ConsoleScroll>0) {ConsoleScroll = 0}
		
		Color (255, 255, 255)
		
		SelectedInputBox = 2
		let oldConsoleInput: string = ConsoleInput
		ConsoleInput = InputBox(x, y + height, width, 30*MenuScale, ConsoleInput, 2)
		if (oldConsoleInput!=ConsoleInput) {
			ConsoleReissue = null
		}
		ConsoleInput = Left(ConsoleInput, 100)
		
		if (KeyHit(28) && ConsoleInput != "") {
			ConsoleReissue = Null
			ConsoleScroll = 0
			CreateConsoleMsg(ConsoleInput,255,255,0,true)
			if (Instr(ConsoleInput, " ") > 0) {
				StrTemp = Lower(Left(ConsoleInput, Instr(ConsoleInput, " ") - 1))
			} else {
				StrTemp = Lower(ConsoleInput)
			}
			
			switch (Lower(StrTemp)) {
				case "help":
					//[Block]
					if (Instr(ConsoleInput, " ") != 0) {
						StrTemp = Lower(Right(ConsoleInput, Len(ConsoleInput) - Instr(ConsoleInput, " ")))
					} else {
						StrTemp = ""
					}
					ConsoleR = 0
					ConsoleG = 255
					ConsoleB = 255
					
					switch (Lower(StrTemp)) {
						case "1","":
							CreateConsoleMsg("LIST OF COMMANDS - PAGE 1/3")
							CreateConsoleMsg("******************************")
							CreateConsoleMsg("- asd")
							CreateConsoleMsg("- status")
							CreateConsoleMsg("- camerapick")
							CreateConsoleMsg("- ending")
							CreateConsoleMsg("- noclipspeed")
							CreateConsoleMsg("- noclip")
							CreateConsoleMsg("- injure [value]")
							CreateConsoleMsg("- infect [value]")
							CreateConsoleMsg("- heal")
							CreateConsoleMsg("- teleport [room name]")
							CreateConsoleMsg("- spawnitem [item name]")
							CreateConsoleMsg("- wireframe")
							CreateConsoleMsg("- 173speed")
							CreateConsoleMsg("- 106speed")
							CreateConsoleMsg("- 173state")
							CreateConsoleMsg("- 106state")
							CreateConsoleMsg("******************************")
							CreateConsoleMsg("Use "+Chr(34)+"help 2/3"+Chr(34)+" to find more commands.")
							CreateConsoleMsg("Use "+Chr(34)+"help [command name]"+Chr(34)+" to get more information about a command.")
							CreateConsoleMsg("******************************")
						case "2":
							CreateConsoleMsg("LIST OF COMMANDS - PAGE 2/3")
							CreateConsoleMsg("******************************")
							CreateConsoleMsg("- spawn [npc type] [state]")
							CreateConsoleMsg("- reset096")
							CreateConsoleMsg("- disable173")
							CreateConsoleMsg("- enable173")
							CreateConsoleMsg("- disable106")
							CreateConsoleMsg("- enable106")
							CreateConsoleMsg("- halloween")
							CreateConsoleMsg("- sanic")
							CreateConsoleMsg("- scp-420-j")
							CreateConsoleMsg("- godmode")
							CreateConsoleMsg("- revive")
							CreateConsoleMsg("- noclip")
							CreateConsoleMsg("- showfps")
							CreateConsoleMsg("- 096state")
							CreateConsoleMsg("- debughud")
							CreateConsoleMsg("- camerafog [near] [far]")
							CreateConsoleMsg("- gamma [value]")
							CreateConsoleMsg("- infinitestamina")
							CreateConsoleMsg("******************************")
							CreateConsoleMsg("Use "+Chr(34)+"help [command name]"+Chr(34)+" to get more information about a command.")
							CreateConsoleMsg("******************************")
						case "3":
							CreateConsoleMsg("- playmusic [clip + .wav/.ogg]")
							CreateConsoleMsg("- notarget")
							CreateConsoleMsg("- unlockexits")
						case "asd":
							CreateConsoleMsg("HELP - asd")
							CreateConsoleMsg("******************************")
							CreateConsoleMsg("Actives godmode, noclip, wireframe and")
							CreateConsoleMsg("sets fog distance to 20 near, 30 far")
							CreateConsoleMsg("******************************")
						case "camerafog":
							CreateConsoleMsg("HELP - camerafog")
							CreateConsoleMsg("******************************")
							CreateConsoleMsg("Sets the draw distance of the fog.")
							CreateConsoleMsg("The fog begins generating at 'CameraFogNear' units")
							CreateConsoleMsg("away from the camera and becomes completely opaque")
							CreateConsoleMsg("at 'CameraFogFar' units away from the camera.")
							CreateConsoleMsg("Example: camerafog 20 40")
							CreateConsoleMsg("******************************")
						case "gamma":
							CreateConsoleMsg("HELP - gamma")
							CreateConsoleMsg("******************************")
							CreateConsoleMsg("Sets the gamma correction.")
							CreateConsoleMsg("Should be set to a value between 0.0 and 2.0.")
							CreateConsoleMsg("Default is 1.0.")
							CreateConsoleMsg("******************************")
						case "noclip","fly":
							CreateConsoleMsg("HELP - noclip")
							CreateConsoleMsg("******************************")
							CreateConsoleMsg("Toggles noclip, unless a valid parameter")
							CreateConsoleMsg("is specified (on/off).")
							CreateConsoleMsg("Allows the camera to move in any direction while")
							CreateConsoleMsg("bypassing collision.")
							CreateConsoleMsg("******************************")
						case "godmode","god":
							CreateConsoleMsg("HELP - godmode")
							CreateConsoleMsg("******************************")
							CreateConsoleMsg("Toggles godmode, unless a valid parameter")
							CreateConsoleMsg("is specified (on/off).")
							CreateConsoleMsg("Prevents player death under normal circumstances.")
							CreateConsoleMsg("******************************")
						case "wireframe":
							CreateConsoleMsg("HELP - wireframe")
							CreateConsoleMsg("******************************")
							CreateConsoleMsg("Toggles wireframe, unless a valid parameter")
							CreateConsoleMsg("is specified (on/off).")
							CreateConsoleMsg("Allows only the edges of geometry to be rendered,")
							CreateConsoleMsg("making everything else transparent.")
							CreateConsoleMsg("******************************")
						case "spawnitem":
							CreateConsoleMsg("HELP - spawnitem")
							CreateConsoleMsg("******************************")
							CreateConsoleMsg("Spawns an item at the player's location.")
							CreateConsoleMsg("Any name that can appear in your inventory")
							CreateConsoleMsg("is a valid parameter.")
							CreateConsoleMsg("Example: spawnitem Key Card Omni")
							CreateConsoleMsg("******************************")
						case "spawn":
							CreateConsoleMsg("HELP - spawn")
							CreateConsoleMsg("******************************")
							CreateConsoleMsg("Spawns an NPC at the player's location.")
							CreateConsoleMsg("Valid parameters are:")
							CreateConsoleMsg("008zombie / 049 / 049-2 / 066 / 096 / 106 / 173")
							CreateConsoleMsg("/ 178-1 / 372 / 513-1 / 966 / 1499-1 / class-d")
							CreateConsoleMsg("/ guard / mtf / apache / tentacle")
							CreateConsoleMsg("******************************")
						case "revive","undead","resurrect":
							CreateConsoleMsg("HELP - revive")
							CreateConsoleMsg("******************************")
							CreateConsoleMsg("Resets the player's death timer after the dying")
							CreateConsoleMsg("animation triggers.")
							CreateConsoleMsg("Does not affect injury, blood loss")
							CreateConsoleMsg("or 008 infection values.")
							CreateConsoleMsg("******************************")
						case "teleport":
							CreateConsoleMsg("HELP - teleport")
							CreateConsoleMsg("******************************")
							CreateConsoleMsg("Teleports the player to the first instance")
							CreateConsoleMsg("of the specified room. Any room that appears")
							CreateConsoleMsg("in rooms.ini is a valid parameter.")
							CreateConsoleMsg("******************************")
						case "stopsound", "stfu":
							CreateConsoleMsg("HELP - stopsound")
							CreateConsoleMsg("******************************")
							CreateConsoleMsg("Stops all currently playing sounds.")
							CreateConsoleMsg("******************************")
						case "camerapick":
							CreateConsoleMsg("HELP - camerapick")
							CreateConsoleMsg("******************************")
							CreateConsoleMsg("Prints the texture name and coordinates of")
							CreateConsoleMsg("the model the camera is pointing at.")
							CreateConsoleMsg("******************************")
						case "status":
							CreateConsoleMsg("HELP - status")
							CreateConsoleMsg("******************************")
							CreateConsoleMsg("Prints player, camera, and room information.")
							CreateConsoleMsg("******************************")
						case "weed","scp-420-j","420":
							CreateConsoleMsg("HELP - 420")
							CreateConsoleMsg("******************************")
							CreateConsoleMsg("Generates dank memes.")
							CreateConsoleMsg("******************************")
						case "playmusic":
							CreateConsoleMsg("HELP - playmusic")
							CreateConsoleMsg("******************************")
							CreateConsoleMsg("Will play tracks in .ogg/.wav format")
							CreateConsoleMsg("from "+Chr(34)+"SFX/Music/Custom/"+Chr(34)+".")
							CreateConsoleMsg("******************************")
							
						default:
							CreateConsoleMsg("There is no help available for that command.",255,150,0)
					}
					
					//[End Block]
				case "asd":
					//[Block]
					WireFrame(1)
					WireframeState=1
					GodMode = 1
					NoClip = 1
					CameraFogNear = 15
					CameraFogFar = 20
					//[End Block]
				case "status":
					//[Block]
					ConsoleR = 0
					ConsoleG = 255
					ConsoleB = 0
					CreateConsoleMsg("******************************")
					CreateConsoleMsg("Status: ")
					CreateConsoleMsg("Coordinates: ")
					CreateConsoleMsg("    - collider: "+EntityX(Collider)+", "+EntityY(Collider)+", "+EntityZ(Collider))
					CreateConsoleMsg("    - camera: "+EntityX(Camera)+", "+EntityY(Camera)+", "+EntityZ(Camera))
					
					CreateConsoleMsg("Rotation: ")
					CreateConsoleMsg("    - collider: "+EntityPitch(Collider)+", "+EntityYaw(Collider)+", "+EntityRoll(Collider))
					CreateConsoleMsg("    - camera: "+EntityPitch(Camera)+", "+EntityYaw(Camera)+", "+EntityRoll(Camera))
					
					CreateConsoleMsg("Room: "+PlayerRoom.RoomTemplate.Name)
					for (ev of Events.each) {
						if (ev.room == PlayerRoom) {
							CreateConsoleMsg("Room event: "+ev.EventName)	
							CreateConsoleMsg("-    state: "+ev.EventState)
							CreateConsoleMsg("-    state2: "+ev.EventState2)	
							CreateConsoleMsg("-    state3: "+ev.EventState3)
							break
						}
					}
					
					CreateConsoleMsg("Room coordinates: "+Floor(EntityX(PlayerRoom.obj) / 8.0 + 0.5)+", "+ Floor(EntityZ(PlayerRoom.obj) / 8.0 + 0.5))
					CreateConsoleMsg("Stamina: "+Stamina)
					CreateConsoleMsg("Death timer: "+KillTimer)					
					CreateConsoleMsg("Blinktimer: "+BlinkTimer)
					CreateConsoleMsg("Injuries: "+Injuries)
					CreateConsoleMsg("Bloodloss: "+Bloodloss)
					CreateConsoleMsg("******************************")
					//[End Block]
				case "camerapick":
					//[Block]
					ConsoleR = 0
					ConsoleG = 255
					ConsoleB = 0
					let c = CameraPick(Camera,GraphicWidth/2, GraphicHeight/2)
					if (c == 0) {
						CreateConsoleMsg("******************************")
						CreateConsoleMsg("No entity  picked")
						CreateConsoleMsg("******************************")								
					} else {
						CreateConsoleMsg("******************************")
						CreateConsoleMsg("Picked entity:")
						let sf = GetSurface(c,1)
						let b = GetSurfaceBrush( sf )
						let t = GetBrushTexture(b,0)
						let texname = StripPath(TextureName(t))
						CreateConsoleMsg("Texture name: "+texname)
						CreateConsoleMsg("Coordinates: "+EntityX(c)+", "+EntityY(c)+", "+EntityZ(c))
						CreateConsoleMsg("******************************")							
					}
					
				case "hidedistance":
					//[Block]
					HideDistance = Float(Right(ConsoleInput, Len(ConsoleInput) - Instr(ConsoleInput, " ")))
					CreateConsoleMsg("Hidedistance set to "+HideDistance)
					
				case "ending":
					//[Block]
					SelectedEnding = Lower(Right(ConsoleInput, Len(ConsoleInput) - Instr(ConsoleInput, " ")))
					KillTimer = -0.1
					//EndingTimer = -0.1
					
				case "noclipspeed":
					//[Block]
					StrTemp = Lower(Right(ConsoleInput, Len(ConsoleInput) - Instr(ConsoleInput, " ")))
					
					NoClipSpeed = Float(StrTemp)
					
				case "injure":
					//[Block]
					StrTemp = Lower(Right(ConsoleInput, Len(ConsoleInput) - Instr(ConsoleInput, " ")))
					
					Injuries = Float(StrTemp)
					
				case "infect":
					//[Block]
					StrTemp = Lower(Right(ConsoleInput, Len(ConsoleInput) - Instr(ConsoleInput, " ")))
					
					Infect = Float(StrTemp)
					
				case "heal":
					//[Block]
					Injuries = 0
					Bloodloss = 0
					
				case "teleport":
					//[Block]
					StrTemp = Lower(Right(ConsoleInput, Len(ConsoleInput) - Instr(ConsoleInput, " ")))
					
					switch (StrTemp) {
						case "895", "scp-895":
							StrTemp = "coffin"
						case "scp-914":
							StrTemp = "914"
						case "offices", "office":
							StrTemp = "room2offices"
					}
					
					for (r of Rooms.each) {
						if (r.RoomTemplate.Name = StrTemp) {
							PositionEntity (Collider, EntityX(r.obj), EntityY(r.obj)+0.7, EntityZ(r.obj))
							ResetEntity(Collider)
							UpdateDoors()
							UpdateRooms()
							for (it of Items.each) {
								it.disttimer = 0
							}
							PlayerRoom = r
							break
						}
					}
					
					if (PlayerRoom.RoomTemplate.Name != StrTemp) {CreateConsoleMsg("Room not found.",255,150,0)}
					
				case "spawnitem":
					//[Block]
					StrTemp = Lower(Right(ConsoleInput, Len(ConsoleInput) - Instr(ConsoleInput, " ")))
					temp = false 
					for (itt of ItemTemplates.each) {
						if (Lower(itt.name) == StrTemp) {
							temp = true
							CreateConsoleMsg(itt.name + " spawned.")
							it.Items = CreateItem(itt.name, itt.tempname, EntityX(Collider), EntityY(Camera,true), EntityZ(Collider))
							EntityType(it.collider, HIT_ITEM)
							Exit
						} else if ((Lower(itt.tempname) = StrTemp)) {
							temp = true
							CreateConsoleMsg(itt.name + " spawned.")
							it.Items = CreateItem(itt.name, itt.tempname, EntityX(Collider), EntityY(Camera,true), EntityZ(Collider))
							EntityType(it.collider, HIT_ITEM)
							Exit
						}
					}
					
					if (temp = false) {CreateConsoleMsg("Item not found.",255,150,0)}
					
				case "wireframe":
					//[Block]
					StrTemp$ = Lower(Right(ConsoleInput, Len(ConsoleInput) - Instr(ConsoleInput, " ")))
					
					switch (StrTemp) {
						case "on", "1", "true":
							WireframeState = true							
						case "off", "0", "false":
							WireframeState = false
						default:
							WireframeState = !WireframeState
					}
					
					if (WireframeState) {
						CreateConsoleMsg("WIREFRAME ON")
					} else {
						CreateConsoleMsg("WIREFRAME OFF")	
					}
					
					WireFrame (WireframeState)
					
				case "173speed":
					//[Block]
					StrTemp$ = Lower(Right(ConsoleInput, Len(ConsoleInput) - Instr(ConsoleInput, " ")))
					Curr173.Speed = Float(StrTemp)
					CreateConsoleMsg("173's speed set to " + StrTemp)
					
				case "106speed":
					//[Block]
					StrTemp$ = Lower(Right(ConsoleInput, Len(ConsoleInput) - Instr(ConsoleInput, " ")))
					Curr106.Speed = Float(StrTemp)
					CreateConsoleMsg("106's speed set to " + StrTemp)
					
				case "173state":
					//[Block]
					CreateConsoleMsg("SCP-173")
					CreateConsoleMsg("Position: " + EntityX(Curr173.obj) + ", " + EntityY(Curr173.obj) + ", " + EntityZ(Curr173.obj))
					CreateConsoleMsg("Idle: " + Curr173.Idle)
					CreateConsoleMsg("State: " + Curr173.State)
					
				case "106state":
					//[Block]
					CreateConsoleMsg("SCP-106")
					CreateConsoleMsg("Position: " + EntityX(Curr106.obj) + ", " + EntityY(Curr106.obj) + ", " + EntityZ(Curr106.obj))
					CreateConsoleMsg("Idle: " + Curr106.Idle)
					CreateConsoleMsg("State: " + Curr106.State)
					
				case "reset096":
					//[Block]
					for (let n of NPCs.each) {
						if (n.NPCtype = NPCtype096) {
							n.State = 0
							StopStream_Strict(n.SoundChn)
							n.SoundChn=0
							if (n.SoundChn2!=0) {
								StopStream_Strict(n.SoundChn2)
								n.SoundChn2=0
							}
							break
						}
					}
					
				case "disable173":
					//[Block]
					Curr173.Idle = 3 //This phenominal comment is brought to you by PolyFox. His absolute wisdom in this fatigue of knowledge brought about a new era of 173 state checks.
					HideEntity(Curr173.obj)
					HideEntity(Curr173.Collider)
					
				case "enable173":
					//[Block]
					Curr173.Idle = false
					ShowEntity(Curr173.obj)
					ShowEntity(Curr173.Collider)
					
				case "disable106":
					//[Block]
					Curr106.Idle = true
					Curr106.State = 200000
					Contained106 = true
					
				case "enable106":
					//[Block]
					Curr106.Idle = false
					Contained106 = false
					ShowEntity (Curr106.Collider)
					ShowEntity (Curr106.obj)
					
				case "halloween":
					//[Block]
					HalloweenTex = !HalloweenTex
					if (HalloweenTex) {
						let tex = LoadTexture_Strict("GFX/npcs/173h.pt", 1)
						EntityTexture (Curr173.obj, tex, 0, 0)
						FreeTexture (tex)
						CreateConsoleMsg("173 JACK-O-LANTERN ON")
					} else {
						let tex2 = LoadTexture_Strict("GFX/npcs/173texture.jpg", 1)
						EntityTexture (Curr173.obj, tex2, 0, 0)
						FreeTexture (tex2)
						CreateConsoleMsg("173 JACK-O-LANTERN OFF")
					}
					
				case "sanic":
					//[Block]
					SuperMan = !SuperMan
					if (SuperMan) {
						CreateConsoleMsg("GOTTA GO FAST")
					} else {
						CreateConsoleMsg("WHOA SLOW DOWN")
					}
					
				case "scp-420-j","420","weed":
					//[Block]
					for (i of range(1, 21)) {
						if (Rand(2)==1) {
							it.Items = CreateItem("Some SCP-420-J","420", EntityX(Collider,true)+Cos((360.0/20.0)*i)*Rnd(0.3,0.5), EntityY(Camera,true), EntityZ(Collider,true)+Sin((360.0/20.0)*i)*Rnd(0.3,0.5))
						} else {
							it.Items = CreateItem("Joint","420s", EntityX(Collider,true)+Cos((360.0/20.0)*i)*Rnd(0.3,0.5), EntityY(Camera,true), EntityZ(Collider,true)+Sin((360.0/20.0)*i)*Rnd(0.3,0.5))
						}
						EntityType (it.collider, HIT_ITEM)
					}
					PlaySound_Strict (LoadTempSound("SFX/Music/420J.ogg"))
					
				case "godmode", "god":
					//[Block]
					StrTemp$ = Lower(Right(ConsoleInput, Len(ConsoleInput) - Instr(ConsoleInput, " ")))
					
					switch (StrTemp) {
						case "on", "1", "true":
							GodMode = true						
						case "off", "0", "false":
							GodMode = false
						default:
							GodMode = !GodMode
					}
					if (GodMode) {
						CreateConsoleMsg("GODMODE ON")
					} else {
						CreateConsoleMsg("GODMODE OFF")	
					}
					
				case "revive","undead","resurrect":
					//[Block]
					DropSpeed = -0.1
					HeadDropSpeed = 0.0
					Shake = 0
					CurrSpeed = 0
					
					HeartBeatVolume = 0
					
					CameraShake = 0
					Shake = 0
					LightFlash = 0
					BlurTimer = 0
					
					FallTimer = 0
					MenuOpen = false
					
					GodMode = 0
					NoClip = 0
					
					ShowEntity (Collider)
					
					KillTimer = 0
					KillAnim = 0
					
				case "noclip","fly":
					//[Block]
					StrTemp$ = Lower(Right(ConsoleInput, Len(ConsoleInput) - Instr(ConsoleInput, " ")))
					
					switch (StrTemp) {
						case "on", "1", "true":
							NoClip = true
							Playable = true
						case "off", "0", "false":
							NoClip = false	
							RotateEntity (Collider, 0, EntityYaw(Collider), 0)
						default:
							NoClip = !NoClip
							if (!NoClip) {		
								RotateEntity (Collider, 0, EntityYaw(Collider), 0)
							} else {
								Playable = true
							}
					}
					
					if (NoClip) {
						CreateConsoleMsg("NOCLIP ON")
					} else {
						CreateConsoleMsg("NOCLIP OFF")
					}
					
					DropSpeed = 0
					
				case "showfps":
					//[Block]
					ShowFPS = !ShowFPS
					CreateConsoleMsg("ShowFPS: "+Str(ShowFPS))
					
				case "096state":
					//[Block]
					for (n of NPCs.each) {
						if (n.NPCtype == NPCtype096) {
							CreateConsoleMsg("SCP-096")
							CreateConsoleMsg("Position: " + EntityX(n.obj) + ", " + EntityY(n.obj) + ", " + EntityZ(n.obj))
							CreateConsoleMsg("Idle: " + n.Idle)
							CreateConsoleMsg("State: " + n.State)
							Exit
						}
					}
					CreateConsoleMsg("SCP-096 has not spawned.")
					
				case "debughud":
					//[Block]
					StrTemp$ = Lower(Right(ConsoleInput, Len(ConsoleInput) - Instr(ConsoleInput, " ")))
					switch (StrTemp) {
						case "on", "1", "true":
							DebugHUD = true
						case "off", "0", "false":
							DebugHUD = false
						default:
							DebugHUD = !DebugHUD
					}
					
					if (DebugHUD) {
						CreateConsoleMsg("Debug Mode On")
					} else {
						CreateConsoleMsg("Debug Mode Off")
					}
					
				case "stopsound", "stfu":
					//[Block]
					for (let snd of Sound.each) {
						for (i of range(32)) {
							if (snd.channels[i]!=0) {
								StopChannel (snd.channels[i])
							}
						}
					}
					
					for (e of Events.each) {
						if (e.EventName == "alarm") {
							if (e.room.NPC[0] != null) {RemoveNPC(e.room.NPC[0])}
							if (e.room.NPC[1] != null) {RemoveNPC(e.room.NPC[1])}
							if (e.room.NPC[2] != null) {RemoveNPC(e.room.NPC[2])}
							
							FreeEntity(e.room.Objects[0])
							e.room.Objects[0]=0
							FreeEntity(e.room.Objects[1])
							e.room.Objects[1]=0
							PositionEntity (Curr173.Collider, 0,0,0)
							ResetEntity (Curr173.Collider)
							ShowEntity (Curr173.obj)
							RemoveEvent(e)
							break
						}
					}
					CreateConsoleMsg("Stopped all sounds.")
					
				case "camerafog":
					//[Block]
					let args: string = Lower(Right(ConsoleInput, Len(ConsoleInput) - Instr(ConsoleInput, " ")))
					CameraFogNear = Float(Left(args, Len(args) - Instr(args, " ")))
					CameraFogFar = Float(Right(args, Len(args) - Instr(args, " ")))
					CreateConsoleMsg("Near set to: " + CameraFogNear + ", far set to: " + CameraFogFar)
					
				case "gamma":
					//[Block]
					StrTemp = Lower(Right(ConsoleInput, Len(ConsoleInput) - Instr(ConsoleInput, " ")))
					ScreenGamma = Int(StrTemp)
					CreateConsoleMsg("Gamma set to " + ScreenGamma)
					
				case "spawn":
					//[Block]
					args = Lower(Right(ConsoleInput, Len(ConsoleInput) - Instr(ConsoleInput, " ")))
					StrTemp = Piece(args, 1)
					StrTemp2 = Piece(args, 2)
					
					//Hacky fix for when the user doesn't input a second parameter.
					if (StrTemp != StrTemp2) {
						Console_SpawnNPC(StrTemp, StrTemp2)
					} else {
						Console_SpawnNPC(StrTemp)
					}
					
				//new Console Commands in SCP:CB 1.3 - ENDSHN
				case "infinitestamina","infstam":
					//[Block]
					let StrTemp: string = Lower(Right(ConsoleInput, Len(ConsoleInput) - Instr(ConsoleInput, " ")))
					
					switch (StrTemp) {
						case "on", "1", "true":
							InfiniteStamina = true						
						case "off", "0", "false":
							InfiniteStamina = false
						default:
							InfiniteStamina = !InfiniteStamina
					}
					
					if (InfiniteStamina) {
						CreateConsoleMsg("INFINITE STAMINA ON")
					} else {
						CreateConsoleMsg("INFINITE STAMINA OFF")	
					}
					
				case "asd2":
					//[Block]
					GodMode = 1
					InfiniteStamina = 1
					Curr173.Idle = 3
					Curr106.Idle = true
					Curr106.State = 200000
					Contained106 = true
					
				case "toggle_warhead_lever":
					//[Block]
					for (e of Events.each) {
						if (e.EventName = "room2nuke") {
							e.EventState = (!e.EventState)
							Exit
						}
					}
					
				case "unlockexits":
					//[Block]
					StrTemp = Lower(Right(ConsoleInput, Len(ConsoleInput) - Instr(ConsoleInput, " ")))
					
					switch (StrTemp) {
						case "a":
							for (e of Events.each) {
								if (e.EventName = "gateaentrance") {
									e.EventState3 = 1
									e.room.RoomDoors[1].open = true
									break
								}
							}
							CreateConsoleMsg("Gate A is now unlocked.")	
						case "b":
							for (e of Events.each) {
								if (e.EventName = "exit1") {
									e.EventState3 = 1
									e.room.RoomDoors[4].open = true
									break
								}
							}	
							CreateConsoleMsg("Gate B is now unlocked.")	
						default:
							for (e of Events.each) {
								if (e.EventName = "gateaentrance") {
									e.EventState3 = 1
									e.room.RoomDoors[1].open = true
								} else if (e.EventName = "exit1") {
									e.EventState3 = 1
									e.room.RoomDoors[4].open = true
								}
							}
							CreateConsoleMsg("Gate A and B are now unlocked.")	
					}
					
					RemoteDoorOn = true
					
				case "kill","suicide":
					//[Block]
					KillTimer = -1
					switch (Rand(4)) {
						case 1:
							DeathMSG = "[REDACTED]"
						case 2:
							DeathMSG = "Subject D-9341 found dead in Sector [REDACTED]. "
							DeathMSG = DeathMSG + "The subject appears to have attained no physical damage, and there is no visible indication as to what killed him. "
							DeathMSG = DeathMSG + "Body was sent for autopsy."
						case 3:
							DeathMSG = "EXCP_ACCESS_VIOLATION"
						case 4:
							DeathMSG = "Subject D-9341 found dead in Sector [REDACTED]. "
							DeathMSG = DeathMSG + "The subject appears to have scribbled the letters "+Chr(34)+"kys"+Chr(34)+" in his own blood beside him. "
							DeathMSG = DeathMSG + "No other signs of physical trauma or struggle can be observed. Body was sent for autopsy."
					}
					
				case "playmusic":
					//[Block]
					// I think this might be broken since the FMod library streaming was added. -Mark
					if (Instr(ConsoleInput, " ")!=0) {
						StrTemp = Lower(Right(ConsoleInput, Len(ConsoleInput) - Instr(ConsoleInput, " ")))
					} else {
						StrTemp = ""
					}
					
					if (StrTemp != "") {
						PlayCustomMusic = true
						if (CustomMusic != 0) {
							FreeSound_Strict (CustomMusic)
							CustomMusic = 0
						}
						if (MusicCHN != 0) {StopChannel (MusicCHN)}
						CustomMusic = LoadSound_Strict("SFX/Music/Custom/"+StrTemp$)
						if (CustomMusic = 0) {
							PlayCustomMusic = false
						}
					} else {
						PlayCustomMusic = false
						if (CustomMusic != 0) {
							FreeSound_Strict (CustomMusic)
							CustomMusic = 0
						}
						if (MusicCHN != 0) {StopChannel (MusicCHN)}
					}
					
				case "tp":
					//[Block]
					for (n of NPCs.each) {
						if (n.NPCtype = NPCtypeMTF) {
							if (n.MTFLeader = Null) {
								PositionEntity (Collider,EntityX(n.Collider),EntityY(n.Collider)+5,EntityZ(n.Collider))
								ResetEntity (Collider)
								break
							}
						}
					}
					
				case "tele":
					//[Block]
					args = Lower(Right(ConsoleInput, Len(ConsoleInput) - Instr(ConsoleInput, " ")))
					StrTemp = Piece(args,1," ")
					StrTemp2 = Piece(args,2," ")
					StrTemp3 = Piece(args,3," ")
					PositionEntity(Collider,Float(StrTemp$),Float(StrTemp2$),Float(StrTemp3$))
					PositionEntity(Camera,Float(StrTemp$),Float(StrTemp2$),Float(StrTemp3$))
					ResetEntity(Collider)
					ResetEntity(Camera)
					CreateConsoleMsg("Teleported to coordinates (X|Y|Z): "+EntityX(Collider)+"|"+EntityY(Collider)+"|"+EntityZ(Collider))
					
				case "notarget":
					//[Block]
					StrTemp$ = Lower(Right(ConsoleInput, Len(ConsoleInput) - Instr(ConsoleInput, " ")))
					
					switch (StrTemp) {
						case "on", "1", "true":
							NoTarget = true						
						case "off", "0", "false":
							NoTarget = false	
						default:
							NoTarget = !NoTarget
					}
					
					if (NoTarget == false) {
						CreateConsoleMsg("NOTARGET OFF")
					} else {
						CreateConsoleMsg("NOTARGET ON")	
					}
					
				case "spawnradio":
					//[Block]
					it.Items = CreateItem("Radio Transceiver", "fineradio", EntityX(Collider), EntityY(Camera,true), EntityZ(Collider))
					EntityType(it.collider, HIT_ITEM)
					it.state = 101
					
				case "spawnnvg":
					//[Block]
					it.Items = CreateItem("Night Vision Goggles", "nvgoggles", EntityX(Collider), EntityY(Camera,true), EntityZ(Collider))
					EntityType(it.collider, HIT_ITEM)
					it.state = 1000
					
				case "spawnpumpkin","pumpkin":
					//[Block]
					CreateConsoleMsg("What pumpkin?")
					
				case "spawnnav":
					//[Block]
					it.Items = CreateItem("S-NAV Navigator Ultimate", "nav", EntityX(Collider), EntityY(Camera,true), EntityZ(Collider))
					EntityType(it.collider, HIT_ITEM)
					it.state = 101
					
				case "teleport173":
					//[Block]
					PositionEntity (Curr173.Collider,EntityX(Collider),EntityY(Collider)+0.2,EntityZ(Collider))
					ResetEntity (Curr173.Collider)
					
				case "seteventstate":
					//[Block]
					args$ = Lower(Right(ConsoleInput, Len(ConsoleInput) - Instr(ConsoleInput, " ")))
					StrTemp$ = Piece$(args$,1," ")
					StrTemp2$ = Piece$(args$,2," ")
					StrTemp3$ = Piece$(args$,3," ")
					let pl_room_found: boolean = false
					if (StrTemp == "" || StrTemp2 == "" || StrTemp3 == "") {
						CreateConsoleMsg("Too few parameters. This command requires 3.",255,150,0)
					} else {
						for (e of Events.each) {
							if (e.room = PlayerRoom) {
								if (Lower(StrTemp)!="keep") {
									e.EventState = Float(StrTemp)
								}
								if (Lower(StrTemp2)!="keep") {
									e.EventState2 = Float(StrTemp2)
								}
								if (Lower(StrTemp3)!="keep") {
									e.EventState3 = Float(StrTemp3)
								}
								CreateConsoleMsg("Changed event states from current player room to: "+e.EventState+"|"+e.EventState2+"|"+e.EventState3)
								pl_room_found = true
								break
							}
						}
						if (!pl_room_found) {
							CreateConsoleMsg("The current room doesn't has any event applied.",255,150,0)
						}
					}
					
				case "spawnparticles":
					//[Block]
					if (Instr(ConsoleInput, " ")!=0) {
						StrTemp = Lower(Right(ConsoleInput, Len(ConsoleInput) - Instr(ConsoleInput, " ")))
					} else {
						StrTemp = ""
					}
					
					if (Int(StrTemp) > -1 && Int(StrTemp) <= 1) { //<--- This is the maximum ID of particles by Devil Particle system, will be increased after time - ENDSHN
						SetEmitter(Collider,ParticleEffect[Int(StrTemp)])
						CreateConsoleMsg("Spawned particle emitter with ID "+Int(StrTemp)+" at player's position.")
					} else {
						CreateConsoleMsg("Particle emitter with ID "+Int(StrTemp)+" not found.",255,150,0)
					}
					
				case "giveachievement":
					//[Block]
					if (Instr(ConsoleInput, " ")!=0) {
						StrTemp = Lower(Right(ConsoleInput, Len(ConsoleInput) - Instr(ConsoleInput, " ")))
					} else {
						StrTemp = ""
					}
					
					if (Int(StrTemp)>=0 && Int(StrTemp)<MAXACHIEVEMENTS) {
						Achievements[Int(StrTemp)]=true
						CreateConsoleMsg("Achievemt "+AchievementStrings[Int(StrTemp)]+" unlocked.")
					} else {
						CreateConsoleMsg("Achievement with ID "+Int(StrTemp)+" doesn't exist.",255,150,0)
					}
					
				case "427state":
					//[Block]
					StrTemp = Lower(Right(ConsoleInput, Len(ConsoleInput) - Instr(ConsoleInput, " ")))
					
					I_427.Timer = Float(StrTemp)*70.0
					
				case "teleport106":
					//[Block]
					Curr106.State = 0
					Curr106.Idle = false
					
				case "setblinkeffect":
					//[Block]
					args$ = Lower(Right(ConsoleInput, Len(ConsoleInput) - Instr(ConsoleInput, " ")))
					BlinkEffect = Float(Left(args, Len(args) - Instr(args, " ")))
					BlinkEffectTimer = Float(Right(args, Len(args) - Instr(args, " ")))
					CreateConsoleMsg("Set BlinkEffect to: " + BlinkEffect + "and BlinkEffect timer: " + BlinkEffectTimer)
					
				case "jorge":
					//[Block]	
					CreateConsoleMsg(Chr(74)+Chr(79)+Chr(82)+Chr(71)+Chr(69)+Chr(32)+Chr(72)+Chr(65)+Chr(83)+Chr(32)+Chr(66)+Chr(69)+Chr(69)+Chr(78)+Chr(32)+Chr(69)+Chr(88)+Chr(80)+Chr(69)+Chr(67)+Chr(84)+Chr(73)+Chr(78)+Chr(71)+Chr(32)+Chr(89)+Chr(79)+Chr(85)+Chr(46))
					
				default:
					//[Block]
					CreateConsoleMsg("Command not found.",255,0,0)
					
			}
			
			ConsoleInput = ""
		}
		
		let TempY: int = y + height - 25*MenuScale - ConsoleScroll
		let count: int = 0
		for (cm of ConsoleMsg.each) {
			count = count+1
			if (count>1000) {
				Delete (cm)
			} else {
				if (TempY >= y && TempY < y + height - 20*MenuScale) {
					if (cm=ConsoleReissue) {
						Color (cm.r/4,cm.g/4,cm.b/4)
						Rect (x,TempY-2*MenuScale,width-30*MenuScale,24*MenuScale,true)
					}
					Color (cm.r,cm.g,cm.b)
					if (cm.isCommand) {
						AAText(x + 20*MenuScale, TempY, "> "+cm.txt)
					} else {
						AAText(x + 20*MenuScale, TempY, cm.txt)
					}
				}
				TempY = TempY - 15*MenuScale
			}
			
		}
		
		Color (255,255,255)
		
		if (Fullscreen) {DrawImage (CursorIMG, ScaledMouseX(),ScaledMouseY())}
	}
	
	AASetFont (Font1)
	
}

ConsoleR = 0
ConsoleG = 255
ConsoleB = 255
CreateConsoleMsg("Console commands: ")
CreateConsoleMsg("  - teleport [room name]")
CreateConsoleMsg("  - godmode [on/off]")
CreateConsoleMsg("  - noclip [on/off]")
CreateConsoleMsg("  - noclipspeed [x] (default = 2.0)")
CreateConsoleMsg("  - wireframe [on/off]")
CreateConsoleMsg("  - debughud [on/off]")
CreateConsoleMsg("  - camerafog [near] [far]")
CreateConsoleMsg(" ")
CreateConsoleMsg("  - status")
CreateConsoleMsg("  - heal")
CreateConsoleMsg(" ")
CreateConsoleMsg("  - spawnitem [item name]")
CreateConsoleMsg(" ")
CreateConsoleMsg("  - 173speed [x] (default = 35)")
CreateConsoleMsg("  - disable173/enable173")
CreateConsoleMsg("  - disable106/enable106")
CreateConsoleMsg("  - 173state/106state/096state")
CreateConsoleMsg("  - spawn [npc type]")

//---------------------------------------------------------------------------------------------------

export var DebugHUD: int

export var BlurVolume: float
export var BlurTimer: float

export var LightBlink: float
export var LightFlash: float

export var BumpEnabled: int = GetINIInt("options.ini", "options", "bump mapping enabled")
export var HUDenabled: int = GetINIInt("options.ini", "options", "HUD enabled")

export var Camera: int
export var CameraShake: float
export var CurrCameraZoom: float

export var Brightness: int = GetINIFloat("options.ini", "options", "brightness")
export var CameraFogNear: float = GetINIFloat("options.ini", "options", "camera fog near")
export var CameraFogFar: float = GetINIFloat("options.ini", "options", "camera fog far")

export var StoredCameraFogFar: float = CameraFogFar

export var MouseSens: float = GetINIFloat("options.ini", "options", "mouse sensitivity")

export var EnableVRam: int = GetINIInt("options.ini", "options", "enable vram")

export var ark_blur_image: int
export var ark_blur_texture: int
export var ark_sw: int
export var ark_sh: int
export var ark_blur_cam: int

export function CreateBlurImage() {
	//Create blur Camera
	let cam: int = CreateCamera()
	CameraProjMode(cam, CameraProjectionMode.Perspective)
	CameraZoom(cam,0.1)
	CameraClsMode(cam, false, false)
	CameraRange(cam, 0.1, 1.5)
	MoveEntity(cam, 0, 0, 10000)
	ark_blur_cam = cam
	
	ark_sw = GraphicWidth
	ark_sh = GraphicHeight
	CameraViewport(cam,0,0,ark_sw,ark_sh)
	
	//Create sprite
	let spr: int = CreateMesh(cam)
	let sf: int = CreateSurface(spr)
	AddVertex(sf, -1, 1, 0, 0, 0)
	AddVertex(sf, 1, 1, 0, 1, 0)
	AddVertex(sf, -1, -1, 0, 0, 1)
	AddVertex(sf, 1, -1, 0, 1, 1)
	AddTriangle(sf, 0, 1, 2)
	AddTriangle(sf, 3, 2, 1)
	EntityFX(spr, 17)
	ScaleEntity(spr, 2048.0 / Float(ark_sw), 2048.0 / Float(ark_sw), 1)
	PositionEntity(spr, 0, 0, 1.0001)
	EntityOrder(spr, -100000)
	EntityBlend(spr, 1)
	ark_blur_image = spr
	
	//Create blur texture
	ark_blur_texture = CreateTexture(2048, 2048, TextureFlags.StoreVRam)
	EntityTexture(spr, ark_blur_texture)
}

export function UpdateBlur(power: float) {
	
	EntityAlpha(ark_blur_image, power)
	
	CopyRect(0, 0, GraphicWidth, GraphicHeight, 1024.0 - GraphicWidth/2, 1024.0 - GraphicHeight/2, BackBuffer(), TextureBuffer(ark_blur_texture))
}

LightSpriteTex = new Array(10) // TODO used to be global export???

//----------------------------------------------  Sounds -----------------------------------------------------

//[Block]

export var SoundEmitter: int
export var TempSounds: int[] = new Array(10)
export var TempSoundCHN: int
export var TempSoundIndex: int = 0

//The Music now has to be pre-defined, as the new system uses streaming instead of the usual sound loading system Blitz3D has
export var Music: string[] = new Array(40)
Music[0] = "The Dread"
Music[1] = "HeavyContainment"
Music[2] = "EntranceZone"
Music[3] = "PD"
Music[4] = "079"
Music[5] = "GateB1"
Music[6] = "GateB2"
Music[7] = "Room3Storage"
Music[8] = "Room049"
Music[9] = "8601"
Music[10] = "106"
Music[11] = "Menu"
Music[12] = "8601Cancer"
Music[13] = "Intro"
Music[14] = "178"
Music[15] = "PDTrench"
Music[16] = "205"
Music[17] = "GateA"
Music[18] = "1499"
Music[19] = "1499Danger"
Music[20] = "049Chase"
Music[21] = "../Ending/MenuBreath"
Music[22] = "914"
Music[23] = "Ending"
Music[24] = "Credits"
Music[25] = "SaveMeFrom"

export var MusicVolume: float = GetINIFloat(OptionFile, "audio", "music volume")

export var CurrMusicStream, MusicCHN
MusicCHN = StreamSound_Strict("SFX/Music/"+Music(2)+".ogg",MusicVolume,Mode)

export var CurrMusicVolume: float = 1.0, NowPlaying: int=2, ShouldPlay: int=11
export var CurrMusic: int = 1

DrawLoading(10, true)

export var OpenDoorSFX: int[][] = new Array(3,3)
export var CloseDoorSFX: int [][] = new Array(3,3)

export var KeyCardSFX1 
export var KeyCardSFX2 
export var ButtonSFX2 
export var ScannerSFX1
export var ScannerSFX2 

export var OpenDoorFastSFX
export var CautionSFX: int 

export var NuclearSirenSFX: int

export var CameraSFX  

export var StoneDragSFX: int 

export var GunshotSFX: int
export var Gunshot2SFX: int
export var Gunshot3SFX: int
export var BullethitSFX: int

export var TeslaIdleSFX 
export var TeslaActivateSFX 
export var TeslaPowerUpSFX 

export var MagnetUpSFX: int
export var MagnetDownSFX
export var FemurBreakerSFX: int
export var EndBreathCHN: int
export var EndBreathSFX: int

export var DecaySFX: int[] = new Array(5)

export var BurstSFX 

DrawLoading(20, true)

export var RustleSFX: int[] = new Array(3)

export var Use914SFX: int
export var Death914SFX: int 

export var DripSFX: int[] = new Array(4)

export var LeverSFX: int, LightSFX: int 
export var ButtGhostSFX: int 

export var RadioSFX: any[][] = new Array(5,10) 

export var RadioSquelch 
export var RadioStatic 
export var RadioBuzz 

export var ElevatorBeepSFX, ElevatorMoveSFX  

export var PickSFX: int[] = new Array(10)

export var AmbientSFXCHN: int
export var CurrAmbientSFX: int
export var AmbientSFXAmount: any[] = new Array(6)

export enum AreaName {
	LightContainment,
	HeavyContainment,
	Entrance,
	General,
	PreBreach,
	Forest
}

AmbientSFXAmount[AreaName.LightContainment] = 8
AmbientSFXAmount[AreaName.HeavyContainment] = 11
AmbientSFXAmount[AreaName.Entrance] = 12
AmbientSFXAmount[AreaName.General] = 15
AmbientSFXAmount[AreaName.PreBreach] = 5
AmbientSFXAmount[AreaName.Forest] = 10

export var AmbientSFX: int[] = new Array(6, 15)

export var OldManSFX: int[] = new Array(8)

export var Scp173SFX: int[] = new Array(3)

export var HorrorSFX: int[] = new Array(20)


DrawLoading(25, true)

export var IntroSFX: int[] = new Array(20)


export var AlarmSFX: int[] = new Array(5)

export var CommotionState: int[] = new Array(25)

export var HeartBeatSFX 

export var VomitSFX: int

export var BreathSFX: Array[][] = new Array(2,5)
export var BreathCHN: int


export var NeckSnapSFX: Array = new Array(3)

export var DamageSFX: int[] = new Array(9)

export var MTFSFX: int[] = new Array(8)

var CoughSFX: int[] = new Array(3)
var CoughCHN: int, VomitCHN: int

var MachineSFX: int 
var ApacheSFX
var CurrStepSFX
var StepSFX: int[][][] = new Array(5, 2, 8) //(normal/metal, walk/run, id)

var Step2SFX: Array = new Array(6)

DrawLoading(30, true)

//[End block]

//New Sounds and Meshes/Other things in SCP:CB 1.3 - ENDSHN

var PlayCustomMusic: int = false, CustomMusic: int = 0

var Monitor2, Monitor3, MonitorTexture2, MonitorTexture3, MonitorTexture4, MonitorTextureOff
var MonitorTimer: float = 0.0, MonitorTimer2: float = 0.0, UpdateCheckpoint1: int, UpdateCheckpoint2: int

//This variable is for when a camera detected the player
	//false: Player is not seen (will be set after every call of the Main Loop
	//true: The Player got detected by a camera
var PlayerDetected: int
var PrevInjuries: float,PrevBloodloss: float
var NoTarget: boolean = false

var NVGImages = LoadAnimImage("GFX/battery.png",64,64,0,2)
MaskImage (NVGImages,255,0,255)

var Wearing1499: int = false
var AmbientLightRoomTex: int, AmbientLightRoomVal: int

var EnableUserTracks: int = GetINIInt(OptionFile, "audio", "enable user tracks")
var UserTrackMode: int = GetINIInt(OptionFile, "audio", "user track setting")
var UserTrackCheck: int = 0, UserTrackCheck2: int = 0
var UserTrackMusicAmount: int = 0, CurrUserTrack: int, UserTrackFlag: int = false
var UserTrackName: string[] = new Array(256)

var NTF_1499PrevX: float
var NTF_1499PrevY: float
var NTF_1499PrevZ: float
var NTF_1499PrevRoom: Rooms
var NTF_1499X: float
var NTF_1499Y: float
var NTF_1499Z: float
var NTF_1499Sky: int

var OptionsMenu: int = 0
var QuitMSG: int = 0

var InFacility: int = true

var PrevMusicVolume: float = MusicVolume
var PrevSFXVolume: float = SFXVolume
var DeafPlayer: int = false
var DeafTimer: float = 0.0

var IsZombie: int = false

var room2gw_brokendoor: int = false
var room2gw_x: float = 0.0
var room2gw_z: float = 0.0

var Menu_TestIMG
var menuroomscale: float = 8.0 / 2048.0

var CurrMenu_TestIMG: string = ""

var ParticleAmount: int = GetINIInt(OptionFile,"options","particle amount")

var NavImages: Array = new Array(5)
for (i of range(4)) {
	NavImages(i) = LoadImage_Strict("GFX/navigator/roomborder"+i+".png")
	MaskImage (NavImages(i),255,0,255)
}
NavImages(4) = LoadImage_Strict("GFX/navigator/batterymeter.png")

var NavBG = CreateImage(GraphicWidth,GraphicHeight)

var LightConeModel

var ParticleEffect: Array = new Array(10)

const MaxDTextures=8
var DTextures: Array = new Array(MaxDTextures)

var NPC049OBJ, NPC0492OBJ
var ClerkOBJ

var IntercomStreamCHN: int

var ForestNPC,ForestNPCTex
var ForestNPCData: float[] = new Array(3)


//-----------------------------------------  Images ----------------------------------------------------------

var PauseMenuIMG: int

var SprintIcon: int
var BlinkIcon: int
var CrouchIcon: int
var HandIcon: int
var HandIcon2: int

var StaminaMeterIMG: int

var KeypadHUD

var Panel294, Using294: int, Input294: string

DrawLoading(35, true)

//----------------------------------------------  Items  -----------------------------------------------------

var BurntNote: int

const MaxItemAmount: int = 10
var ItemAmount: int
var Inventory: Items[] = new Array(MaxItemAmount + 1)
var InvSelect: int, SelectedItem: Items

var ClosestItem: Items

var LastItemID: int

class ItemTemplates {
	name: string
	tempname: string
	
	sound: int
	
	found: int
	
	obj: int
	objpath: string
	parentobjpath: string
	invimg: int
	invimg2: int
	invimgpath: string
	imgpath: string
	img: int
	
	isAnim: int
	
	scale: float
	tex: int
	texpath: string
	static each: ItemTemplates[] = []
}

function CreateItemTemplate(name: string, tempname: string, objpath: string, invimgpath: string, imgpath: string, scale: float, texturepath: string = "",invimgpath2: string="",Anim: int = 0, texflags: int = 9): ItemTemplates {
	let it: ItemTemplates = new ItemTemplates
	let n
	
	
	//if another item shares the same object, copy it
	for (let it2 of ItemTemplates.each) {
		if (it2.objpath == objpath && it2.obj != 0) {
			it.obj = CopyEntity(it2.obj)
			it.parentobjpath=it2.objpath
			break
		}
	}
	
	if (it.obj = 0) {
		if (Anim!=0) {
			it.obj = LoadAnimMesh_Strict(objpath)
			it.isAnim = true
		} else {
			it.obj = LoadMesh_Strict(objpath)
			it.isAnim=false
		}
		it.objpath = objpath
	}
	it.objpath = objpath
	
	let texture: int
	
	if (texturepath != "") {
		for (let it2 of ItemTemplates.each) {
			if (it2.texpath == texturepath && it2.tex!=0) {
				texture = it2.tex
				break
			}
		}
		if (texture == 0) {
			texture=LoadTexture_Strict(texturepath,texflags)
			it.texpath = texturepath
		}
		EntityTexture(it.obj, texture)
		it.tex = texture
	}  
	
	it.scale = scale
	ScaleEntity(it.obj, scale, scale, scale, true)
	
	//if another item shares the same object, copy it
	for (let it2 of ItemTemplates.each) {
		if (it2.invimgpath == invimgpath && it2.invimg != 0) {
			it.invimg = it2.invimg
			if (it2.invimg2!=0) {
				it.invimg2 = it2.invimg2
			}
			break
		}
	}
	if (it.invimg == 0) {
		it.invimg = LoadImage_Strict(invimgpath)
		it.invimgpath = invimgpath
		MaskImage(it.invimg, 255, 0, 255)
	}
	
	if (invimgpath2 != "") {
		if (it.invimg2 == 0) {
			it.invimg2 = LoadImage_Strict(invimgpath2)
			MaskImage(it.invimg2,255,0,255)
		}
	} else {
		it.invimg2 = 0
	}
	
	it.imgpath = imgpath
	
	it.tempname = tempname
	it.name = name
	
	it.sound = 1

	HideEntity(it.obj)
	
	return it
}

export function InitItemTemplates() {
	let it: ItemTemplates,it2: ItemTemplates
	
	it = CreateItemTemplate("Some SCP-420-J", "420", "GFX/items/420.x", "GFX/items/INV420.jpg", "", 0.0005)
	it.sound = 2
	
	CreateItemTemplate("Level 1 Key Card", "key1",  "GFX/items/keycard.x", "GFX/items/INVkey1.jpg", "", 0.0004,"GFX/items/keycard1.jpg")
	CreateItemTemplate("Level 2 Key Card", "key2",  "GFX/items/keycard.x", "GFX/items/INVkey2.jpg", "", 0.0004,"GFX/items/keycard2.jpg")
	CreateItemTemplate("Level 3 Key Card", "key3",  "GFX/items/keycard.x", "GFX/items/INVkey3.jpg", "", 0.0004,"GFX/items/keycard3.jpg")
	CreateItemTemplate("Level 4 Key Card", "key4",  "GFX/items/keycard.x", "GFX/items/INVkey4.jpg", "", 0.0004,"GFX/items/keycard4.jpg")
	CreateItemTemplate("Level 5 Key Card", "key5", "GFX/items/keycard.x", "GFX/items/INVkey5.jpg", "", 0.0004,"GFX/items/keycard5.jpg")
	CreateItemTemplate("Playing Card", "misc", "GFX/items/keycard.x", "GFX/items/INVcard.jpg", "", 0.0004,"GFX/items/card.jpg")
	CreateItemTemplate("Mastercard", "misc", "GFX/items/keycard.x", "GFX/items/INVmastercard.jpg", "", 0.0004,"GFX/items/mastercard.jpg")
	CreateItemTemplate("Key Card Omni", "key6", "GFX/items/keycard.x", "GFX/items/INVkeyomni.jpg", "", 0.0004,"GFX/items/keycardomni.jpg")
	
	it = CreateItemTemplate("SCP-860", "scp860", "GFX/items/key.b3d", "GFX/items/INVkey.jpg", "", 0.001)
	it.sound = 3
	
	it = CreateItemTemplate("Document SCP-079", "paper", "GFX/items/paper.x", "GFX/items/INVpaper.jpg", "GFX/items/doc079.jpg", 0.003)
	it.sound = 0
	it = CreateItemTemplate("Document SCP-895", "paper", "GFX/items/paper.x", "GFX/items/INVpaper.jpg", "GFX/items/doc895.jpg", 0.003)
	it.sound = 0 
	it = CreateItemTemplate("Document SCP-860", "paper", "GFX/items/paper.x", "GFX/items/INVpaper.jpg", "GFX/items/doc860.jpg", 0.003)
	it.sound = 0 	
	it = CreateItemTemplate("Document SCP-860-1", "paper", "GFX/items/paper.x", "GFX/items/INVpaper.jpg", "GFX/items/doc8601.jpg", 0.003)
	it.sound = 0 	
	it = CreateItemTemplate("SCP-093 Recovered Materials", "paper", "GFX/items/paper.x", "GFX/items/INVpaper.jpg", "GFX/items/doc093rm.jpg", 0.003)
	it.sound = 0 	
	it = CreateItemTemplate("Document SCP-106", "paper", "GFX/items/paper.x", "GFX/items/INVpaper.jpg", "GFX/items/doc106.jpg", 0.003)
	it.sound = 0	
	it = CreateItemTemplate("Dr. Allok's Note", "paper", "GFX/items/paper.x", "GFX/items/INVpaper.jpg", "GFX/items/doc106_2.jpg", 0.0025)
	it.sound = 0
	it = CreateItemTemplate("Recall Protocol RP-106-N", "paper", "GFX/items/paper.x", "GFX/items/INVpaper.jpg", "GFX/items/docRP.jpg", 0.0025)
	it.sound = 0
	it = CreateItemTemplate("Document SCP-682", "paper", "GFX/items/paper.x", "GFX/items/INVpaper.jpg", "GFX/items/doc682.jpg", 0.003)
	it.sound = 0
	it = CreateItemTemplate("Document SCP-173", "paper", "GFX/items/paper.x", "GFX/items/INVpaper.jpg", "GFX/items/doc173.jpg", 0.003)
	it.sound = 0
	it = CreateItemTemplate("Document SCP-372", "paper", "GFX/items/paper.x", "GFX/items/INVpaper.jpg", "GFX/items/doc372.jpg", 0.003)
	it.sound = 0
	it = CreateItemTemplate("Document SCP-049", "paper", "GFX/items/paper.x", "GFX/items/INVpaper.jpg", "GFX/items/doc049.jpg", 0.003)
	it.sound = 0
	it = CreateItemTemplate("Document SCP-096", "paper", "GFX/items/paper.x", "GFX/items/INVpaper.jpg", "GFX/items/doc096.jpg", 0.003)
	it.sound = 0
	it = CreateItemTemplate("Document SCP-008", "paper", "GFX/items/paper.x", "GFX/items/INVpaper.jpg", "GFX/items/doc008.jpg", 0.003)
	it.sound = 0
	it = CreateItemTemplate("Document SCP-012", "paper", "GFX/items/paper.x", "GFX/items/INVpaper.jpg", "GFX/items/doc012.jpg", 0.003)
	it.sound = 0
	it = CreateItemTemplate("Document SCP-500", "paper", "GFX/items/paper.x", "GFX/items/INVpaper.jpg", "GFX/items/doc500.png", 0.003)
	it.sound = 0
	it = CreateItemTemplate("Document SCP-714", "paper", "GFX/items/paper.x", "GFX/items/INVpaper.jpg", "GFX/items/doc714.jpg", 0.003)
	it.sound = 0
	it = CreateItemTemplate("Document SCP-513", "paper", "GFX/items/paper.x", "GFX/items/INVpaper.jpg", "GFX/items/doc513.jpg", 0.003)
	it.sound = 0
	it = CreateItemTemplate("Document SCP-035", "paper", "GFX/items/paper.x", "GFX/items/INVpaper.jpg", "GFX/items/doc035.jpg", 0.003)
	it.sound = 0
	it = CreateItemTemplate("SCP-035 Addendum", "paper", "GFX/items/paper.x", "GFX/items/INVpaper.jpg", "GFX/items/doc035ad.jpg", 0.003)
	it.sound = 0
	it = CreateItemTemplate("Document SCP-939", "paper", "GFX/items/paper.x", "GFX/items/INVpaper.jpg", "GFX/items/doc939.jpg", 0.003)
	it.sound = 0
	it = CreateItemTemplate("Document SCP-966", "paper", "GFX/items/paper.x", "GFX/items/INVpaper.jpg", "GFX/items/doc966.jpg", 0.003)
	it.sound = 0
	it = CreateItemTemplate("Document SCP-970", "paper", "GFX/items/paper.x", "GFX/items/INVpaper.jpg", "GFX/items/doc970.jpg", 0.003)
	it.sound = 0
	it = CreateItemTemplate("Document SCP-1048", "paper", "GFX/items/paper.x", "GFX/items/INVpaper.jpg", "GFX/items/doc1048.jpg", 0.003)
	it.sound = 0
	it = CreateItemTemplate("Document SCP-1123", "paper", "GFX/items/paper.x", "GFX/items/INVpaper.jpg", "GFX/items/doc1123.jpg", 0.003)
	it.sound = 0
	it = CreateItemTemplate("Document SCP-1162", "paper", "GFX/items/paper.x", "GFX/items/INVpaper.jpg", "GFX/items/doc1162.jpg", 0.003)
	it.sound = 0
	it = CreateItemTemplate("Document SCP-1499", "paper", "GFX/items/paper.x", "GFX/items/INVpaper.jpg", "GFX/items/doc1499.png", 0.003)
	it.sound = 0
	it = CreateItemTemplate("Incident Report SCP-1048-A", "paper", "GFX/items/paper.x", "GFX/items/INVpaper.jpg", "GFX/items/doc1048a.jpg", 0.003)
	it.sound = 0
	
	it = CreateItemTemplate("Drawing", "paper", "GFX/items/paper.x", "GFX/items/INVpaper.jpg", "GFX/items/doc1048.jpg", 0.003)
	it.sound = 0
	
	it = CreateItemTemplate("Leaflet", "paper", "GFX/items/paper.x", "GFX/items/INVpaper.jpg", "GFX/items/leaflet.jpg", 0.003, "GFX/items/notetexture.jpg")
	it.sound = 0
	
	it = CreateItemTemplate("Dr. L's Note", "paper", "GFX/items/paper.x", "GFX/items/INVnote.jpg", "GFX/items/docL1.jpg", 0.0025, "GFX/items/notetexture.jpg")
	it.sound = 0
	it = CreateItemTemplate("Dr L's Note", "paper", "GFX/items/paper.x", "GFX/items/INVnote.jpg", "GFX/items/docL2.jpg", 0.0025, "GFX/items/notetexture.jpg")
	it.sound = 0
	it = CreateItemTemplate("Blood-stained Note", "paper", "GFX/items/paper.x", "GFX/items/INVnote.jpg", "GFX/items/docL3.jpg", 0.0025, "GFX/items/notetexture.jpg")
	it.sound = 0
	it = CreateItemTemplate("Dr. L's Burnt Note", "paper", "GFX/items/paper.x", "GFX/items/INVbn.jpg", "GFX/items/docL4.jpg", 0.0025, "GFX/items/BurntNoteTexture.jpg")
	it.sound = 0
	it = CreateItemTemplate("Dr L's Burnt Note", "paper", "GFX/items/paper.x", "GFX/items/INVbn.jpg", "GFX/items/docL5.jpg", 0.0025, "GFX/items/BurntNoteTexture.jpg")
	it.sound = 0
	it = CreateItemTemplate("Scorched Note", "paper", "GFX/items/paper.x", "GFX/items/INVbn.jpg", "GFX/items/docL6.jpg", 0.0025, "GFX/items/BurntNoteTexture.jpg")
	it.sound = 0
	
	it = CreateItemTemplate("Journal Page", "paper", "GFX/items/paper.x", "GFX/items/INVpaper.jpg", "GFX/items/docGonzales.jpg", 0.0025)
	it.sound = 0
	
	
	it = CreateItemTemplate("Log #1", "paper", "GFX/items/paper.x", "GFX/items/INVpaper.jpg", "GFX/items/f4.jpg", 0.004, "GFX/items/f4.jpg")
	it.sound = 0
	it = CreateItemTemplate("Log #2", "paper", "GFX/items/paper.x", "GFX/items/INVpaper.jpg", "GFX/items/f5.jpg", 0.004, "GFX/items/f4.jpg")
	it.sound = 0
	it = CreateItemTemplate("Log #3", "paper", "GFX/items/paper.x", "GFX/items/INVpaper.jpg", "GFX/items/f6.jpg", 0.004, "GFX/items/f4.jpg")
	it.sound = 0
	
	it = CreateItemTemplate("Strange Note", "paper", "GFX/items/paper.x", "GFX/items/INVnote.jpg", "GFX/items/docStrange.jpg", 0.0025, "GFX/items/notetexture.jpg")
	it.sound = 0
	
	it = CreateItemTemplate("Nuclear Device Document", "paper", "GFX/items/paper.x", "GFX/items/INVpaper.jpg", "GFX/items/docNDP.jpg", 0.003)
	it.sound = 0	
	it = CreateItemTemplate("Class D Orientation Leaflet", "paper", "GFX/items/paper.x", "GFX/items/INVpaper.jpg", "GFX/items/docORI.jpg", 0.003)
	it.sound = 0	
	
	it = CreateItemTemplate("Note from Daniel", "paper", "GFX/items/note.x", "GFX/items/INVnote2.jpg", "GFX/items/docdan.jpg", 0.0025)
	it.sound = 0
	
	it = CreateItemTemplate("Burnt Note", "paper", "GFX/items/paper.x", "GFX/items/INVbn.jpg", "GFX/items/bn.it", 0.003, "GFX/items/BurntNoteTexture.jpg")
	it.img = BurntNote
	it.sound = 0
	
	it = CreateItemTemplate("Mysterious Note", "paper", "GFX/items/paper.x", "GFX/items/INVnote.jpg", "GFX/items/sn.it", 0.003, "GFX/items/notetexture.jpg")
	it.sound = 0	
	
	it = CreateItemTemplate("Mobile Task Forces", "paper", "GFX/items/paper.x", "GFX/items/INVpaper.jpg", "GFX/items/docMTF.jpg", 0.003)
	it.sound = 0
	it = CreateItemTemplate("Security Clearance Levels", "paper", "GFX/items/paper.x", "GFX/items/INVpaper.jpg", "GFX/items/docSC.jpg", 0.003)
	it.sound = 0
	it = CreateItemTemplate("Object Classes", "paper", "GFX/items/paper.x", "GFX/items/INVpaper.jpg", "GFX/items/docOBJC.jpg", 0.003)
	it.sound = 0
	it = CreateItemTemplate("Document", "paper", "GFX/items/paper.x", "GFX/items/INVpaper.jpg", "GFX/items/docRAND3.jpg", 0.003)
	it.sound = 0 
	it = CreateItemTemplate("Addendum: 5/14 Test Log", "paper", "GFX/items/paper.x", "GFX/items/INVnote.jpg", "GFX/items/docRAND2.jpg", 0.003, "GFX/items/notetexture.jpg")
	it.sound = 0 
	it = CreateItemTemplate("Notification", "paper", "GFX/items/paper.x", "GFX/items/INVnote.jpg", "GFX/items/docRAND1.jpg", 0.003, "GFX/items/notetexture.jpg")
	it.sound = 0 	
	it = CreateItemTemplate("Incident Report SCP-106-0204", "paper", "GFX/items/paper.x", "GFX/items/INVpaper.jpg", "GFX/items/docIR106.jpg", 0.003)
	it.sound = 0 
	
	it = CreateItemTemplate("Ballistic Vest", "vest", "GFX/items/vest.x", "GFX/items/INVvest.jpg", "", 0.02,"GFX/items/Vest.png")
	it.sound = 2
	it = CreateItemTemplate("Heavy Ballistic Vest", "finevest", "GFX/items/vest.x", "GFX/items/INVvest.jpg", "", 0.022,"GFX/items/Vest.png")
	it.sound = 2
	it = CreateItemTemplate("Bulky Ballistic Vest", "veryfinevest", "GFX/items/vest.x", "GFX/items/INVvest.jpg", "", 0.025,"GFX/items/Vest.png")
	it.sound = 2
	
	it = CreateItemTemplate("Hazmat Suit", "hazmatsuit", "GFX/items/hazmat.b3d", "GFX/items/INVhazmat.jpg", "", 0.013)
	it.sound = 2
	it = CreateItemTemplate("Hazmat Suit", "hazmatsuit2", "GFX/items/hazmat.b3d", "GFX/items/INVhazmat.jpg", "", 0.013)
	it.sound = 2
	it = CreateItemTemplate("Heavy Hazmat Suit", "hazmatsuit3", "GFX/items/hazmat.b3d", "GFX/items/INVhazmat.jpg", "", 0.013)
	it.sound = 2
	
	it = CreateItemTemplate("cup", "cup", "GFX/items/cup.x", "GFX/items/INVcup.jpg", "", 0.04)
	it.sound = 2
	
	it = CreateItemTemplate("Empty Cup", "emptycup", "GFX/items/cup.x", "GFX/items/INVcup.jpg", "", 0.04)
	it.sound = 2	
	
	it = CreateItemTemplate("SCP-500-01", "scp500", "GFX/items/pill.b3d", "GFX/items/INVpill.jpg", "", 0.0001)
	it.sound = 2
	EntityColor(it.obj,255,0,0)
	
	it = CreateItemTemplate("First Aid Kit", "firstaid", "GFX/items/firstaid.x", "GFX/items/INVfirstaid.jpg", "", 0.05)
	it = CreateItemTemplate("Small First Aid Kit", "finefirstaid", "GFX/items/firstaid.x", "GFX/items/INVfirstaid.jpg", "", 0.03)
	it = CreateItemTemplate("Blue First Aid Kit", "firstaid2", "GFX/items/firstaid.x", "GFX/items/INVfirstaid2.jpg", "", 0.03, "GFX/items/firstaidkit2.jpg")
	it = CreateItemTemplate("Strange Bottle", "veryfinefirstaid", "GFX/items/eyedrops.b3d", "GFX/items/INVbottle.jpg", "", 0.002, "GFX/items/bottle.jpg")	
	
	it = CreateItemTemplate("Gas Mask", "gasmask", "GFX/items/gasmask.b3d", "GFX/items/INVgasmask.jpg", "", 0.02)
	it.sound = 2
	it = CreateItemTemplate("Gas Mask", "supergasmask", "GFX/items/gasmask.b3d", "GFX/items/INVgasmask.jpg", "", 0.021)
	it.sound = 2
	it = CreateItemTemplate("Heavy Gas Mask", "gasmask3", "GFX/items/gasmask.b3d", "GFX/items/INVgasmask.jpg", "", 0.021)
	it.sound = 2
	
	it = CreateItemTemplate("Origami", "misc", "GFX/items/origami.b3d", "GFX/items/INVorigami.jpg", "", 0.003)
	it.sound = 0
	
	CreateItemTemplate("Electronical components", "misc", "GFX/items/electronics.x", "GFX/items/INVelectronics.jpg", "", 0.0011)
	
	it = CreateItemTemplate("Metal Panel", "scp148", "GFX/items/metalpanel.x", "GFX/items/INVmetalpanel.jpg", "", RoomScale)
	it.sound = 2
	it = CreateItemTemplate("SCP-148 Ingot", "scp148ingot", "GFX/items/scp148.x", "GFX/items/INVscp148.jpg", "", RoomScale)
	it.sound = 2
	
	CreateItemTemplate("S-NAV 300 Navigator", "nav", "GFX/items/navigator.x", "GFX/items/INVnavigator.jpg", "GFX/items/navigator.png", 0.0008)
	CreateItemTemplate("S-NAV Navigator", "nav", "GFX/items/navigator.x", "GFX/items/INVnavigator.jpg", "GFX/items/navigator.png", 0.0008)
	CreateItemTemplate("S-NAV Navigator Ultimate", "nav", "GFX/items/navigator.x", "GFX/items/INVnavigator.jpg", "GFX/items/navigator.png", 0.0008)
	CreateItemTemplate("S-NAV 310 Navigator", "nav", "GFX/items/navigator.x", "GFX/items/INVnavigator.jpg", "GFX/items/navigator.png", 0.0008)
	
	CreateItemTemplate("Radio Transceiver", "radio", "GFX/items/radio.x", "GFX/items/INVradio.jpg", "GFX/items/radioHUD.png", 1.0)//0.0010)
	CreateItemTemplate("Radio Transceiver", "fineradio", "GFX/items/radio.x", "GFX/items/INVradio.jpg", "GFX/items/radioHUD.png", 1.0)
	CreateItemTemplate("Radio Transceiver", "veryfineradio", "GFX/items/radio.x", "GFX/items/INVradio.jpg", "GFX/items/radioHUD.png", 1.0)
	CreateItemTemplate("Radio Transceiver", "18vradio", "GFX/items/radio.x", "GFX/items/INVradio.jpg", "GFX/items/radioHUD.png", 1.02)
	
	it = CreateItemTemplate("Cigarette", "cigarette", "GFX/items/420.x", "GFX/items/INV420.jpg", "", 0.0004)
	it.sound = 2
	
	it = CreateItemTemplate("Joint", "420s", "GFX/items/420.x", "GFX/items/INV420.jpg", "", 0.0004)
	it.sound = 2
	
	it = CreateItemTemplate("Smelly Joint", "420s", "GFX/items/420.x", "GFX/items/INV420.jpg", "", 0.0004)
	it.sound = 2
	
	it = CreateItemTemplate("Severed Hand", "hand", "GFX/items/severedhand.b3d", "GFX/items/INVhand.jpg", "", 0.04)
	it.sound = 2
	it = CreateItemTemplate("Black Severed Hand", "hand2", "GFX/items/severedhand.b3d", "GFX/items/INVhand2.jpg", "", 0.04, "GFX/items/shand2.png")
	it.sound = 2
	
	CreateItemTemplate("9V Battery", "bat", "GFX/items/Battery/Battery.x", "GFX/items/Battery/INVbattery9v.jpg", "", 0.008)
	CreateItemTemplate("18V Battery", "18vbat", "GFX/items/Battery/Battery.x", "GFX/items/Battery/INVbattery18v.jpg", "", 0.01, "GFX/items/Battery/Battery 18V.jpg")
	CreateItemTemplate("Strange Battery", "killbat", "GFX/items/Battery/Battery.x", "GFX/items/Battery/INVbattery22900.jpg", "", 0.01,"GFX/items/Battery/Strange Battery.jpg")
	
	CreateItemTemplate("Eyedrops", "fineeyedrops", "GFX/items/eyedrops.b3d", "GFX/items/INVeyedrops.jpg", "", 0.0012, "GFX/items/eyedrops.jpg")
	CreateItemTemplate("Eyedrops", "supereyedrops", "GFX/items/eyedrops.b3d", "GFX/items/INVeyedrops.jpg", "", 0.0012, "GFX/items/eyedrops.jpg")
	CreateItemTemplate("ReVision Eyedrops", "eyedrops","GFX/items/eyedrops.b3d", "GFX/items/INVeyedrops.jpg", "", 0.0012, "GFX/items/eyedrops.jpg")
	CreateItemTemplate("RedVision Eyedrops", "eyedrops", "GFX/items/eyedrops.b3d", "GFX/items/INVeyedropsred.jpg", "", 0.0012,"GFX/items/eyedropsred.jpg")
	
	it = CreateItemTemplate("SCP-714", "scp714", "GFX/items/scp714.b3d", "GFX/items/INV714.jpg", "", 0.3)
	it.sound = 3
	
	it = CreateItemTemplate("SCP-1025", "scp1025", "GFX/items/scp1025.b3d", "GFX/items/INV1025.jpg", "", 0.1)
	it.sound = 0
	
	it = CreateItemTemplate("SCP-513", "scp513", "GFX/items/513.x", "GFX/items/INV513.jpg", "", 0.1)
	it.sound = 2
	
	//BoH items
	
	it = CreateItemTemplate("Clipboard", "clipboard", "GFX/items/clipboard.b3d", "GFX/items/INVclipboard.jpg", "", 0.003, "", "GFX/items/INVclipboard2.jpg", 1)
	
	it = CreateItemTemplate("SCP-1123", "1123", "GFX/items/HGIB_Skull1.b3d", "GFX/items/inv1123.jpg", "", 0.015)
	it.sound = 2
		
	it = CreateItemTemplate("Night Vision Goggles", "supernv", "GFX/items/NVG.b3d", "GFX/items/INVsupernightvision.jpg", "", 0.02)
	it.sound = 2
	it = CreateItemTemplate("Night Vision Goggles", "nvgoggles", "GFX/items/NVG.b3d", "GFX/items/INVnightvision.jpg", "", 0.02)
	it.sound = 2
	it = CreateItemTemplate("Night Vision Goggles", "finenvgoggles", "GFX/items/NVG.b3d", "GFX/items/INVveryfinenightvision.jpg", "", 0.02)
	it.sound = 2
	
	it = CreateItemTemplate("Syringe", "syringe", "GFX/items/Syringe/syringe.b3d", "GFX/items/Syringe/inv.png", "", 0.005)
	it.sound = 2
	it = CreateItemTemplate("Syringe", "finesyringe", "GFX/items/Syringe/syringe.b3d", "GFX/items/Syringe/inv.png", "", 0.005)
	it.sound = 2
	it = CreateItemTemplate("Syringe", "veryfinesyringe", "GFX/items/Syringe/syringe.b3d", "GFX/items/Syringe/inv.png", "", 0.005)
	it.sound = 2
	
	//.........
	
	//new Items in SCP:CB 1.3 - ENDSHN
	it = CreateItemTemplate("SCP-1499","scp1499","GFX/items/SCP-1499.b3d","GFX/items/INVscp1499.jpg", "", 0.023)
	it.sound = 2
	it = CreateItemTemplate("SCP-1499","super1499","GFX/items/SCP-1499.b3d","GFX/items/INVscp1499.jpg", "", 0.023)
	it.sound = 2
	CreateItemTemplate("Emily Ross' Badge", "badge", "GFX/items/badge.x", "GFX/items/INVbadge.jpg", "GFX/items/badge1.jpg", 0.0001, "GFX/items/badge1_tex.jpg")
	it = CreateItemTemplate("Lost Key", "key", "GFX/items/key.b3d", "GFX/items/INV1162_1.jpg", "", 0.001, "GFX/items/key2.png","",0,1+2+8)
	it.sound = 3
	it = CreateItemTemplate("Disciplinary Hearing DH-S-4137-17092", "oldpaper", "GFX/items/paper.x", "GFX/items/INVpaper.jpg", "GFX/items/dh.s", 0.003)
	it.sound = 0
	it = CreateItemTemplate("Coin", "coin", "GFX/items/key.b3d", "GFX/items/INVcoin.jpg", "", 0.0005, "GFX/items/coin.png","",0,1+2+8)
	it.sound = 3
	it = CreateItemTemplate("Movie Ticket", "ticket", "GFX/items/key.b3d", "GFX/items/INVticket.jpg", "GFX/items/ticket.png", 0.002, "GFX/items/tickettexture.png","",0,1+2+8)
	it.sound = 0
	CreateItemTemplate("Old Badge", "badge", "GFX/items/badge.x", "GFX/items/INVoldbadge.jpg", "GFX/items/badge2.png", 0.0001, "GFX/items/badge2_tex.png","",0,1+2+8)
	
	it = CreateItemTemplate("Quarter","25ct", "GFX/items/key.b3d", "GFX/items/INVcoin.jpg", "", 0.0005, "GFX/items/coin.png","",0,1+2+8)
	it.sound = 3
	it = CreateItemTemplate("Wallet","wallet", "GFX/items/wallet.b3d", "GFX/items/INVwallet.jpg", "", 0.0005,"","",1)
	it.sound = 2
	
	CreateItemTemplate("SCP-427","scp427","GFX/items/427.b3d","GFX/items/INVscp427.jpg", "", 0.001)
	it = CreateItemTemplate("Upgraded pill", "scp500death", "GFX/items/pill.b3d", "GFX/items/INVpill.jpg", "", 0.0001)
	it.sound = 2
	EntityColor(it.obj,255,0,0)
	it = CreateItemTemplate("Pill", "pill", "GFX/items/pill.b3d", "GFX/items/INVpillwhite.jpg", "", 0.0001)
	it.sound = 2
	EntityColor(it.obj,255,255,255)
	
	it = CreateItemTemplate("Sticky Note", "paper", "GFX/items/note.x", "GFX/items/INVnote2.jpg", "GFX/items/note682.jpg", 0.0025)
	it.sound = 0
	it = CreateItemTemplate("The Modular Site Project", "paper", "GFX/items/paper.x", "GFX/items/INVpaper.jpg", "GFX/items/docMSP.jpg", 0.003)
	it.sound = 0
	
	it = CreateItemTemplate("Research Sector-02 Scheme", "paper", "GFX/items/paper.x", "GFX/items/INVpaper.jpg", "GFX/items/docmap.jpg", 0.003)
	it.sound = 0
	
	it = CreateItemTemplate("Document SCP-427", "paper", "GFX/items/paper.x", "GFX/items/INVpaper.jpg", "GFX/items/doc427.jpg", 0.003)
	it.sound = 0
	
	for (it of ItemTemplates.each) {
		if ((it.tex != 0)) {
			if ((it.texpath != "")) {
				for (it2 of ItemTemplates.each) {
					if ((it2 != it) && (it2.tex=it.tex)) {
						it2.tex = 0
					}
				}
			}
			FreeTexture( it.tex)
			it.tex = 0
		}
	}
}



export class Items {
	name: string
	collider: int
	model: int
	itemtemplate: ItemTemplates
	DropSpeed: float
	
	r: int
	g: int
	b: int
	a: float
	
	level
	
	SoundChn: int
	
	dist: float
	disttimer: float
	
	state: float
	state2: float
	
	Picked: int
	Dropped: int
	
	invimg: int
	WontColl: boolean = false
	xspeed: float
	zspeed: float
	SecondInv: Items[] = new Array(20)
	ID: int
	invSlots: int
}

function CreateItem(name: string, tempname: string, x: float, y: float, z: float, r: int = 0,g: int = 0,b: int = 0,a: float = 1.0,invSlots: int = 0) : Items {
	CatchErrors("Uncaught (CreateItem)")
	
	let i: Items = new Items()
	let it: ItemTemplates
	
	name = Lower(name)
	tempname = Lower (tempname)
	
	for (it of ItemTemplates.each) {
		if (Lower(it.name) = name) {
			if (Lower(it.tempname) = tempname) {
				i.itemtemplate = it
				i.collider = CreatePivot()			
				EntityRadius (i.collider, 0.01)
				EntityPickMode (i.collider, 1, False)
				i.model = CopyEntity(it.obj,i.collider)
				i.name = it.name
				ShowEntity (i.collider)
				ShowEntity (i.model)
			}
		}
	} 
	
	i.WontColl = false
	
	if (i.itemtemplate == Null) {
		RuntimeError("Item template not found ("+name+", "+tempname+")")
	}
	
	ResetEntity(i.collider)
	PositionEntity(i.collider, x, y, z, true)
	RotateEntity (i.collider, 0, Rand(360), 0)
	i.dist = EntityDistance(Collider, i.collider)
	i.DropSpeed = 0.0
	
	if (tempname == "cup") {
		i.r=r
		i.g=g
		i.b=b
		i.a=a
		
		let liquid = CopyEntity(LiquidObj)
		ScaleEntity(liquid, i.itemtemplate.scale,i.itemtemplate.scale,i.itemtemplate.scale,true)
		PositionEntity(liquid, EntityX(i.collider,true),EntityY(i.collider,true),EntityZ(i.collider,true))
		EntityParent(liquid, i.model)
		EntityColor(liquid, r,g,b)
		
		if (a < 0) {
			EntityFX(liquid, 1)
			EntityAlpha(liquid, Abs(a))
		} else {
			EntityAlpha(liquid, Abs(a))
		}
		
		
		EntityShininess(liquid, 1.0)
	}
	
	i.invimg = i.itemtemplate.invimg
	if ((tempname="clipboard") && (invSlots=0)) {
		invSlots = 10
		SetAnimTime(i.model,17.0)
		i.invimg = i.itemtemplate.invimg2
	} else if ((tempname="wallet") && (invSlots=0)) {
		invSlots = 10
		SetAnimTime(i.model,0.0)
	}
	
	i.invSlots=invSlots
	
	i.ID=LastItemID+1
	LastItemID=i.ID
	
	CatchErrors("CreateItem")
	return i
}

function RemoveItem(i: Items) {
	CatchErrors("Uncaught (RemoveItem)")
	let n
	FreeEntity(i.model)
	FreeEntity(i.collider)
	i.collider = 0
	
	for (n of range(MaxItemAmount)) {
		if (Inventory(n) == i) {
			DebugLog("Removed "+i.itemtemplate.name+" from slot "+n)
			Inventory(n) = Null
			ItemAmount = ItemAmount-1
			break
		}
	}
	if (SelectedItem == i) {
		switch (SelectedItem.itemtemplate.tempname) {
			case "nvgoggles", "supernv":
				WearingNightVision = False
			case "gasmask", "supergasmask", "gasmask2", "gasmask3":
				WearingGasMask = False
			case "vest", "finevest", "veryfinevest":
				WearingVest = False
			case "hazmatsuit","hazmatsuit2","hazmatsuit3":
				WearingHazmat = False	
			case "scp714":
				Wearing714 = False
			case "scp1499","super1499":
				Wearing1499 = False
			case "scp427":
				I_427.Using = False
		}
		
		SelectedItem = Null
	}
	if (i.itemtemplate.img != 0) {
		FreeImage(i.itemtemplate.img)
		i.itemtemplate.img = 0
	}
	Delete(i)
	
	CatchErrors("RemoveItem")
}


function UpdateItems() {
	CatchErrors("Uncaught (UpdateItems)")
	let n
	let i: Items
	let i2: Items
	let xtemp: float
	let ytemp: float
	let ztemp: float
	let temp: int
	let np: NPCs
	let pick: int
	
	let HideDist = HideDistance*0.5
	let deletedItem: boolean = False
	
	ClosestItem = Null
	for (i of Items.each) {
		i.Dropped = 0
		
		if (!i.Picked) {
			if (i.disttimer < MilliSecs2()) {
				i.dist = EntityDistance(Camera, i.collider)
				i.disttimer = MilliSecs2() + 700
				if (i.dist < HideDist) {
					ShowEntity(i.collider)
				}
			}
			
			if (i.dist < HideDist) {
				ShowEntity(i.collider)
				
				if (i.dist < 1.2) {
					if (ClosestItem = Null) {
						if (EntityInView(i.model, Camera)) {
							if (EntityVisible(i.collider,Camera)) {
								ClosestItem = i
							}
						}
					} else if (ClosestItem == i || i.dist < EntityDistance(Camera, ClosestItem.collider)) {
						if (EntityInView(i.model, Camera)) {
							if (EntityVisible(i.collider,Camera)) {
								ClosestItem = i
							}
						}
					}
				}
				
				if (EntityCollided(i.collider, HIT_MAP)) {
					i.DropSpeed = 0
					i.xspeed = 0.0
					i.zspeed = 0.0
				} else {
					if (ShouldEntitiesFall) {
						pick = LinePick(EntityX(i.collider),EntityY(i.collider),EntityZ(i.collider),0,-10,0)
						if (pick) {
							i.DropSpeed = i.DropSpeed - 0.0004 * FPSfactor
							TranslateEntity(i.collider, i.xspeed*FPSfactor, i.DropSpeed * FPSfactor, i.zspeed*FPSfactor)
							if (i.WontColl) {ResetEntity(i.collider)}
						} else {
							i.DropSpeed = 0
							i.xspeed = 0.0
							i.zspeed = 0.0
						}
					} else {
						i.DropSpeed = 0
						i.xspeed = 0.0
						i.zspeed = 0.0
					}
				}
				
				if (i.dist<HideDist*0.2) {
					for (i2 of Items.each) {
						if (i!=i2 && (!i2.Picked) && i2.dist<HideDist*0.2) {
							
							xtemp = (EntityX(i2.collider,True)-EntityX(i.collider,True))
							ytemp = (EntityY(i2.collider,True)-EntityY(i.collider,True))
							ztemp = (EntityZ(i2.collider,True)-EntityZ(i.collider,True))
							
							ed = (xtemp*xtemp+ztemp*ztemp)
							if (ed<0.07 && Abs(ytemp)<0.25) {
								//items are too close together, push away
								if (PlayerRoom.RoomTemplate.Name != "room2storage") {
									xtemp = xtemp*(0.07-ed)
									ztemp = ztemp*(0.07-ed)
									
									while (Abs(xtemp)+Abs(ztemp)<0.001) {
										xtemp = xtemp+Rnd(-0.002,0.002)
										ztemp = ztemp+Rnd(-0.002,0.002)
									}
									
									TranslateEntity(i2.collider,xtemp,0,ztemp)
									TranslateEntity(i.collider,-xtemp,0,-ztemp)
								}
							}
						}
					}
				}
				
				if (EntityY(i.collider) < - 35.0) {
					DebugLog("remove: " + i.itemtemplate.name)
					RemoveItem(i)
					deletedItem=True
				}
			} else {
				HideEntity(i.collider)
			}
		} else {
			i.DropSpeed = 0
			i.xspeed = 0.0
			i.zspeed = 0.0
		}
		
		if (!deletedItem) {
			CatchErrors(Chr(34)+i.itemtemplate.name+Chr(34)+" item")
		}
		deletedItem = False
	}
	
	if (ClosestItem != Null) {
		if (MouseHit1) {PickItem(ClosestItem)}
	}
}

function PickItem(item: Items) {
	let n: int = 0
	let canpickitem: boolean = true
	let fullINV: boolean = true
	
	for (n of range(MaxItemAmount)) {
		if (Inventory(n) == Null) {
			fullINV = False
			break
		}
	}
	
	if (WearingHazmat > 0) {
		Msg = "You cannot pick up any items while wearing a hazmat suit."
		MsgTimer = 70*5
		return
	}
	
	CatchErrors("Uncaught (PickItem)")
	if (!fullINV) {
		for (n of range(MaxItemAmount)) {
			if (Inventory(n) == Null) {
				switch (item.itemtemplate.tempname) {
					case "1123":
						if (!(Wearing714 = 1)) {
							if (PlayerRoom.RoomTemplate.Name != "room1123") {
								ShowEntity (Light)
								LightFlash = 7
								PlaySound_Strict(LoadTempSound("SFX/SCP/1123/Touch.ogg"))		
								DeathMSG = "Subject D-9341 was shot dead after attempting to attack a member of Nine-Tailed Fox. Surveillance tapes show that the subject had been "
								DeathMSG = DeathMSG + "wandering around the site approximately 9 minutes prior, shouting the phrase " + Chr(34) + "get rid of the four pests" + Chr(34)
								DeathMSG = DeathMSG + " in chinese. SCP-1123 was found in [REDACTED] nearby, suggesting the subject had come into physical contact with it. How "
								DeathMSG = DeathMSG + "exactly SCP-1123 was removed from its containment chamber is still unknown."
								Kill()
							}
							for (e of Events.each) {
								if (e.eventname = "room1123") { 
									if (e.eventstate = 0) {
										ShowEntity (Light)
										LightFlash = 3
										PlaySound_Strict(LoadTempSound("SFX/SCP/1123/Touch.ogg"))
									}
									e.eventstate = Max(1, e.eventstate)
									
									Exit()
								}
							}
						}
						
						return
					case "killbat":
						ShowEntity (Light)
						LightFlash = 1.0
						PlaySound_Strict(IntroSFX(11))
						DeathMSG = "Subject D-9341 found dead inside SCP-914's output booth next to what appears to be an ordinary nine-volt battery. The subject is covered in severe "
						DeathMSG = DeathMSG + "electrical burns, and assumed to be killed via an electrical shock caused by the battery. The battery has been stored for further study."
						Kill()
					case "scp148":
						GiveAchievement(Achv148)	
					case "scp513":
						GiveAchievement(Achv513)
					case "scp860":
						GiveAchievement(Achv860)
					case "key6":
						GiveAchievement(AchvOmni)
					case "veryfinevest":
						Msg = "The vest is too heavy to pick up."
						MsgTimer = 70*6
						Exit()
					case "firstaid", "finefirstaid", "veryfinefirstaid", "firstaid2":
						item.state = 0
					case "navigator", "nav":
						if (item.itemtemplate.name = "S-NAV Navigator Ultimate") {GiveAchievement(AchvSNAV)}
					case "hazmatsuit", "hazmatsuit2", "hazmatsuit3":
						canpickitem = True
						for (z of range(MaxItemAmount)) {
							if (Inventory(z) != Null) {
								if (Inventory(z).itemtemplate.tempname == "hazmatsuit" || Inventory(z).itemtemplate.tempname == "hazmatsuit2" || Inventory(z).itemtemplate.tempname == "hazmatsuit3") {
									canpickitem = False
									Exit()
								} else if (Inventory(z).itemtemplate.tempname == "vest" || Inventory(z).itemtemplate.tempname == "finevest") {
									canpickitem = 2
									Exit()
								}
							}
						}
						
						if (!canpickitem) {
							Msg = "You are not able to wear two hazmat suits at the same time."
							MsgTimer = 70 * 5
							Return
						} else if (canpickitem == 2) {
							Msg = "You are not able to wear a vest and a hazmat suit at the same time."
							MsgTimer = 70 * 5
							Return
						} else {
							SelectedItem = item
						}
					case "vest","finevest":
						canpickitem = True
						for (z of range(MaxItemAmount)) {
							if (Inventory(z) != Null) {
								if (Inventory(z).itemtemplate.tempname == "vest" || Inventory(z).itemtemplate.tempname == "finevest") {
									canpickitem = False
									break
								} else if (Inventory(z).itemtemplate.tempname == "hazmatsuit" || Inventory(z).itemtemplate.tempname == "hazmatsuit2" || Inventory(z).itemtemplate.tempname == "hazmatsuit3") {
									canpickitem = 2
									break
								}
							}
						}
						
						if (!canpickitem) {
							Msg = "You are not able to wear two vests at the same time."
							MsgTimer = 70 * 5
							Return
						} else if (canpickitem == 2) {
							Msg = "You are not able to wear a vest and a hazmat suit at the same time."
							MsgTimer = 70 * 5
							Return
						} else {
							SelectedItem = item
						}
				}
				
				if (item.itemtemplate.sound != 66) {PlaySound_Strict(PickSFX(item.itemtemplate.sound))}
				item.Picked = True
				item.Dropped = -1
				
				item.itemtemplate.found=True
				ItemAmount = ItemAmount + 1
				
				Inventory(n) = item
				HideEntity(item.collider)
				break
			}
		}
	} else {
		Msg = "You cannot carry any more items."
		MsgTimer = 70 * 5
	}
	CatchErrors("PickItem")
}

function DropItem(item: Items,playdropsound: boolean = True) {
	if (WearingHazmat > 0) {
		Msg = "You cannot drop any items while wearing a hazmat suit."
		MsgTimer = 70*5
		return
	}
	
	CatchErrors("Uncaught (DropItem)")
	if (playdropsound) {
		if (item.itemtemplate.sound != 66) {
			PlaySound_Strict(PickSFX(item.itemtemplate.sound))
		}
	}
	
	item.Dropped = 1
	
	ShowEntity(item.collider)
	PositionEntity(item.collider, EntityX(Camera), EntityY(Camera), EntityZ(Camera))
	RotateEntity(item.collider, EntityPitch(Camera), EntityYaw(Camera)+Rnd(-20,20), 0)
	MoveEntity(item.collider, 0, -0.1, 0.1)
	RotateEntity(item.collider, 0, EntityYaw(Camera)+Rnd(-110,110), 0)
	
	ResetEntity (item.collider)
	
	item.Picked = False
	for (z of range(MaxItemAmount)) {
		if (Inventory(z) == item) {
			Inventory(z) = Null
		}
	}
	switch (item.itemtemplate.tempname) {
		case "gasmask", "supergasmask", "gasmask3":
			WearingGasMask = False
		case "hazmatsuit",  "hazmatsuit2", "hazmatsuit3":
			WearingHazmat = False
		case "vest", "finevest":
			WearingVest = False
		case "nvgoggles":
			if (WearingNightVision = 1) {
				CameraFogFar = StoredCameraFogFar
				WearingNightVision = False
			}
		case "supernv":
			if (WearingNightVision = 2) {
				CameraFogFar = StoredCameraFogFar
				WearingNightVision = False
			}
		case "finenvgoggles":
			if (WearingNightVision = 3) {
				CameraFogFar = StoredCameraFogFar
				WearingNightVision = False
			}
		case "scp714":
			Wearing714 = False
		case "scp1499","super1499":
			Wearing1499 = False
		case "scp427":
			I_427.Using = False
	}
	
	CatchErrors("DropItem")	
}

//Update any ailments inflicted by SCP-294 drinks.
export function Update294() {
	CatchErrors("Uncaught (Update294)")
	
	if (CameraShakeTimer > 0) {
		CameraShakeTimer = CameraShakeTimer - (FPSfactor/70)
		CameraShake = 2
	}
	
	if (VomitTimer > 0) {
		DebugLog(VomitTimer)
		VomitTimer = VomitTimer - (FPSfactor/70)
		
		if ((MilliSecs2() % 1600) < Rand(200, 400)) {
			if (BlurTimer == 0) {
				BlurTimer = Rnd(10, 20)*70
			}
			CameraShake = Rnd(0, 2)
		}
				
		if (Rand(50) == 50 && (MilliSecs2() % 4000) < 200) {PlaySound_Strict(CoughSFX(Rand(0,2)))}
		
		//Regurgitate when timer is below 10 seconds. (ew)
		if (VomitTimer < 10 && Rnd(0, 500 * VomitTimer) < 2) {
			if ((!ChannelPlaying(VomitCHN)) && (!Regurgitate)) {
				VomitCHN = PlaySound_Strict(LoadTempSound("SFX/SCP/294/Retch" + Rand(1, 2) + ".ogg"))
				Regurgitate = MilliSecs2() + 50
			}
		}
		
		if (Regurgitate > MilliSecs2() && Regurgitate != 0) {
			mouse_y_speed_1 = mouse_y_speed_1 + 1.0
		} else {
			Regurgitate = 0
		}
		
	} else if (VomitTimer < 0) { //vomit
		VomitTimer = VomitTimer - (FPSfactor/70)
		
		if (VomitTimer > -5) {
			if ((MilliSecs2() % 400) < 50) {CameraShake = 4}
			mouse_x_speed_1 = 0.0
			Playable = False
		} else {
			Playable = True
		}
		
		if (!Vomit) {
			BlurTimer = 40 * 70
			VomitSFX = LoadSound_Strict("SFX/SCP/294/Vomit.ogg")
			VomitCHN = PlaySound_Strict(VomitSFX)
			PrevInjuries = Injuries
			PrevBloodloss = Bloodloss
			Injuries = 1.5
			Bloodloss = 70
			EyeIrritation = 9 * 70
			
			pvt = CreatePivot()
			PositionEntity(pvt, EntityX(Camera), EntityY(Collider) - 0.05, EntityZ(Camera))
			TurnEntity(pvt, 90, 0, 0)
			EntityPick(pvt, 0.3)
			de.decals = CreateDecal(5, PickedX(), PickedY() + 0.005, PickedZ(), 90, 180, 0)
			de.Size = 0.001
			de.SizeChange = 0.001
			de.MaxSize = 0.6
			EntityAlpha(de.obj, 1.0)
			EntityColor(de.obj, 0.0, Rnd(200, 255), 0.0)
			ScaleSprite (de.obj, de.size, de.size)
			FreeEntity (pvt)
			Vomit = True
		}
		
		UpdateDecals()
		
		mouse_y_speed_1 = mouse_y_speed_1 + Max((1.0 + VomitTimer / 10), 0.0)
		
		if (VomitTimer < -15) {
			FreeSound_Strict(VomitSFX)
			VomitTimer = 0
			if (KillTimer >= 0) {
				PlaySound_Strict(BreathSFX(0,0))
			}
			Injuries = PrevInjuries
			Bloodloss = PrevBloodloss
			Vomit = False
		}
	}
	
	CatchErrors("Update294")
}

//--------------------------------------- Particles ------------------------------------------------------------



var ParticleTextures: int[] = new Array(10)

class Particles {
	obj: int
	pvt: int
	image: int
	
	R: float
	G: float
	B: float
	A: float
	size: float
	speed: float
	yspeed: float
	gravity: float
	Rchange: float
	Gchange: float
	Bchange: float
	Achange: float
	SizeChange: float
	
	lifetime: float
}
	
function CreateParticle(x: float, y: float, z: float, image: int, size: float, gravity: float = 1.0, lifetime: int = 200) : Particles {
	let p: Particles = new Particles()
	p.lifetime = lifetime
	
	p.obj = CreateSprite()
	PositionEntity(p.obj, x, y, z, True)
	EntityTexture(p.obj, ParticleTextures(image))
	RotateEntity(p.obj, 0, 0, Rnd(360))
	EntityFX(p.obj, 1 + 8)
	
	SpriteViewMode (p.obj, 3)
	
	switch (image) {
		case 0,5,6:
			EntityBlend(p.obj, 1)
		case 1,2,3,4,7:
			EntityBlend(p.obj, BLEND_ADD)
	}
	
	p.pvt = CreatePivot()
	PositionEntity(p.pvt, x, y, z, True)
	
	p.image = image
	p.gravity = gravity * 0.004
	p.R = 255
	p.G = 255
	p.B = 255
	p.A = 1.0
	p.size = size
	ScaleSprite(p.obj, p.size, p.size)
	return p
}
	
function UpdateParticles() {
	let p: Particles
	for (p of Particles.each) {
		MoveEntity(p.pvt, 0, 0, p.speed * FPSfactor)
		if (p.gravity != 0) {
			p.yspeed = p.yspeed - p.gravity * FPSfactor
		}
		TranslateEntity(p.pvt, 0, p.yspeed * FPSfactor, 0, True)
		
		PositionEntity(p.obj, EntityX(p.pvt,True), EntityY(p.pvt,True), EntityZ(p.pvt,True), True)
				
		if (p.Achange != 0) {
			p.A=Min(Max(p.A+p.Achange * FPSfactor,0.0),1.0)
			EntityAlpha(p.obj, p.A)		
		}
		
		if (p.SizeChange != 0) {
			p.size= p.size+p.SizeChange * FPSfactor
			ScaleSprite(p.obj, p.size, p.size)
		}
		
		p.lifetime=p.lifetime-FPSfactor
		if (p.lifetime <= 0 || p.size < 0.00001 || p.A <= 0) {
			RemoveParticle(p)
		}
	}
}
	
function RemoveParticle(p: Particles) {
	FreeEntity(p.obj)
	FreeEntity(p.pvt)	
	Delete(p)
}

var InSmoke: int
var HissSFX: int = LoadSound_Strict("SFX/General/Hiss.ogg")
var SmokeDelay: float = 0.0

class Emitters {
	Obj: int
	
	Size: float
	MinImage: int
	MaxImage: int
	Gravity: float
	LifeTime: int
	
	Disable: int
	
	Room: Rooms
	
	SoundCHN: int
	
	Speed: float
	RandAngle: float
	SizeChange: float
	Achange: float
}

function UpdateEmitters() {
	InSmoke = False
	for (e of Emitters.each) {
		if (FPSfactor > 0 && (PlayerRoom == e.room || e.room.dist < 8)) {
			let p: Particles = CreateParticle(EntityX(e.obj, True), EntityY(e.obj, True), EntityZ(e.obj, True), Rand(e.minimage, e.maximage), e.size, e.gravity, e.lifetime)
			p.speed = e.speed
			RotateEntity(p.pvt, EntityPitch(e.Obj, True), EntityYaw(e.Obj, True), EntityRoll(e.Obj, True), True)
			TurnEntity(p.pvt, Rnd(-e.RandAngle, e.RandAngle), Rnd(-e.RandAngle, e.RandAngle), 0)
			
			TurnEntity(p.obj, 0,0,Rnd(360))
			
			p.SizeChange = e.SizeChange
			
			p.Achange = e.achange
			e.SoundCHN = LoopSound2(HissSFX, e.SoundCHN, Camera, e.Obj)
			
			if (!InSmoke) {
				if (WearingGasMask=0 && WearingHazmat == 0) {
					let dist: float = Distance(EntityX(Camera, true), EntityZ(Camera, true), EntityX(e.obj, true), EntityZ(e.obj, true))
					if (dist < 0.8) {
						if (Abs(EntityY(Camera, True)-EntityY(e.obj,True))<5.0) {InSmoke = True}
					}
				}					
			}
		}
	}
	
	if (InSmoke) {
		if (EyeIrritation > (70 * 6)) {
			BlurVolume = Max(BlurVolume, (EyeIrritation - (70 * 6)) / (70.0 * 24.0))
			}
		if (EyeIrritation > (70 * 24)) {
			DeathMSG = "Subject D-9341 found dead in [DATA REDACTED]. Cause of death: Suffocation due to decontamination gas."
			Kill()
		}
		
		if (KillTimer >= 0) {
			if (Rand(150) == 1) {
				if (CoughCHN == 0) {
					CoughCHN = PlaySound_Strict(CoughSFX(Rand(0, 2)))
				} else {
					if (!ChannelPlaying(CoughCHN)) {
						CoughCHN = PlaySound_Strict(CoughSFX(Rand(0, 2)))
					}
				}
			}
		}
		
		EyeIrritation=EyeIrritation+FPSfactor * 4
	}
}
	
function CreateEmitter(x: float, y: float, z: float, emittertype: int) : Emitters {
	let e: Emitters = new Emitters()
		
	e.Obj = CreatePivot()
	NameEntity(e.Obj,"Emitter1")
	PositionEntity(e.Obj, x, y, z, True)
		
	switch (emittertype) {
		case 0:
			e.Size = 0.03
			e.Gravity = -0.2
			e.LifeTime = 200
			e.SizeChange = 0.005
			e.Speed = 0.004
			e.RandAngle = 20
			e.Achange = -0.008
		case 1:
			e.Size = 0.03
			e.Gravity = -0.2
			e.LifeTime = 200
			e.SizeChange = 0.008
			e.Speed = 0.004
			e.RandAngle = 40
			e.Achange = -0.01
			
			e.MinImage = 6
			e.MaxImage = 6
	}
	
	for (r of Rooms.each) {
		if (Abs(EntityX(e.Obj) - EntityX(r.obj)) < 4.0 && Abs(EntityZ(e.Obj) - EntityZ(r.obj)) < 4.0) {
			e.Room = r
		}
	}
	
	return e
		
}

class DevilEmitters {
	obj: int
	x: float
	y: float
	z: float
	particleID: int
	room: Rooms
	timer: float = 0.0
	maxtimer: float
	SoundCHN: int
	isDeconGas: boolean = false
}

function CreateDevilEmitter(x: float, y: float, z: float, room: Rooms, particleID: int, maxTime: float=2.0) : DevilEmitters {
	let dem: DevilEmitters = new DevilEmitters()
	
	dem.obj = CreatePivot()
	NameEntity(dem.obj,"Emitter2")
	PositionEntity(dem.obj,x,y,z,True)
	EntityParent(dem.obj,room.obj)
	dem.room = room
	dem.x = x
	dem.y = y
	dem.z = z
	dem.particleID = particleID
	dem.maxtimer = maxTime
	
	return dem
}

function UpdateDevilEmitters() {
	let dem: DevilEmitters
	let InSmoke: boolean = false
	
	for (dem of DevilEmitters.each) {
		if (FPSfactor > 0 && (PlayerRoom == dem.room || dem.room.dist < 8)) {
			if (dem.timer = 0) {
				SetEmitter(dem.obj,ParticleEffect[dem.particleID])
				dem.timer = FPSfactor
			} else if (dem.timer < dem.maxtimer) {
				dem.timer = Min(dem.timer+FPSfactor,dem.maxtimer)
			} else {
				dem.timer = 0.0
			}
			if (dem.isDeconGas) {
				dem.SoundCHN = LoopSound2(HissSFX, dem.SoundCHN, Camera, dem.obj)
				if (!InSmoke) {
					if (WearingGasMask == 0 && WearingHazmat == 0) {
						let dist: float = Distance(EntityX(Camera, True), EntityZ(Camera, True), EntityX(dem.obj, True), EntityZ(dem.obj, True))
						if (dist < 0.8) {
							if (Abs(EntityY(Camera, True)-EntityY(dem.obj,True))<5.0) {
								InSmoke = True
							}
						}
					}					
				}
			}
		}
	}
	
	if (InSmoke) {
		if (EyeIrritation > (70 * 6)) {
			BlurVolume = Max(BlurVolume, (EyeIrritation - (70 * 6)) / (70.0 * 24.0))
			}
		if (EyeIrritation > (70 * 24)) {
			DeathMSG = "Subject D-9341 found dead in [DATA REDACTED]. Cause of death: Suffocation due to decontamination gas."
			Kill()
		}
		
		if (KillTimer >= 0) {
			if (Rand(150) == 1) {
				if (CoughCHN == 0) {
					CoughCHN = PlaySound_Strict(CoughSFX(Rand(0, 2)))
				} else {
					if (!ChannelPlaying(CoughCHN)) {
						CoughCHN = PlaySound_Strict(CoughSFX(Rand(0, 2)))
					}
				}
			}
		}
		
		EyeIrritation=EyeIrritation+FPSfactor * 4
	}
}

function DeleteDevilEmitters() {
	Delete(DevilEmitters.each)	
}

//-------------------------------------  Doors --------------------------------------------------------------


export var ClosestButton: int
export var ClosestDoor: Doors
export var SelectedDoor: Doors
export var UpdateDoorsTimer: float
export var DoorTempID: int

export class Doors {
	obj: int
    obj2: int
    frameobj: int
    buttons: int[] = new Array(2)
	locked: boolean
    open: boolean
    angle: int
    openstate: float
    fastopen: int
	dir: int
	timer: int
    timerstate: float
	KeyCard: int
	room: Rooms
	
	DisableWaypoint: int
	
	dist: float
	
	SoundCHN: int
	
	Code$
	
	ID: int
	
	Level: int
	LevelDest: int
	
	AutoClose: int
	
	LinkedDoor: Doors
	
	IsElevatorDoor: boolean = false
	
	MTFClose: boolean = true
	NPCCalledElevator: boolean = false
	
	DoorHitOBJ: int
}

export var BigDoorOBJ: int[] = new Array(2)
export var HeavyDoorObj: int[] = new Array(2)
export var OBJTunnel: int[] = new Array(7)

export function CreateDoor(lvl, x: float, y: float, z: float, angle: float, room: Rooms, dopen: boolean = false,  big: boolean = false, keycard: boolean = false, code: string = "", useCollisionMesh: boolean = false): Doors {
	let d: Doors
	let parent
	let i: int
	if (room) {parent = room.obj}
	
	let d2: Doors
	
	d = new Doors()
	if (big == 1) {
		d.obj = CopyEntity(BigDoorOBJ(0))
		ScaleEntity(d.obj, 55 * RoomScale, 55 * RoomScale, 55 * RoomScale)
		d.obj2 = CopyEntity(BigDoorOBJ(1))
		ScaleEntity(d.obj2, 55 * RoomScale, 55 * RoomScale, 55 * RoomScale)
		
		d.frameobj = CopyEntity(DoorColl)	//CopyMesh				
		ScaleEntity(d.frameobj, RoomScale, RoomScale, RoomScale)
		EntityType (d.frameobj, HIT_MAP)
		EntityAlpha (d.frameobj, 0.0)
    } else if (big == 2) {
		d.obj = CopyEntity(HeavyDoorObj(0))
		ScaleEntity(d.obj, RoomScale, RoomScale, RoomScale)
		d.obj2 = CopyEntity(HeavyDoorObj(1))
		ScaleEntity(d.obj2, RoomScale, RoomScale, RoomScale)
		
		d.frameobj = CopyEntity(DoorFrameOBJ)
    } else if (big=3) {
		for (d2 of Doors.each) {
			if (d2 != d && d2.dir == 3) {
				d.obj = CopyEntity(d2.obj)
				d.obj2 = CopyEntity(d2.obj2)
				ScaleEntity(d.obj, RoomScale, RoomScale, RoomScale)
				ScaleEntity(d.obj2, RoomScale, RoomScale, RoomScale)
				Exit()
            }
        }
		if (d.obj == 0) {
			d.obj = LoadMesh_Strict("GFX/map/elevatordoor.b3d")
			d.obj2 = CopyEntity(d.obj)
			ScaleEntity(d.obj, RoomScale, RoomScale, RoomScale)
			ScaleEntity(d.obj2, RoomScale, RoomScale, RoomScale)
        }
		d.frameobj = CopyEntity(DoorFrameOBJ)
    } else {
		d.obj = CopyEntity(DoorOBJ)
		ScaleEntity(d.obj, (204.0 * RoomScale) / MeshWidth(d.obj), 312.0 * RoomScale / MeshHeight(d.obj), 16.0 * RoomScale / MeshDepth(d.obj))
		
		d.frameobj = CopyEntity(DoorFrameOBJ)
		d.obj2 = CopyEntity(DoorOBJ)
		
		ScaleEntity(d.obj2, (204.0 * RoomScale) / MeshWidth(d.obj), 312.0 * RoomScale / MeshHeight(d.obj), 16.0 * RoomScale / MeshDepth(d.obj))
    }
	
	PositionEntity (d.frameobj, x, y, z	)
	ScaleEntity(d.frameobj, (8.0 / 2048.0), (8.0 / 2048.0), (8.0 / 2048.0))
	EntityPickMode (d.frameobj,2)
	EntityType (d.obj, HIT_MAP)
	EntityType (d.obj2, HIT_MAP)
	
	d.ID = DoorTempID
	DoorTempID=DoorTempID+1
	
	d.KeyCard = keycard
	d.Code = code
	
	d.Level = lvl
	d.LevelDest = 66
	
	for (i of range(2)) {
		if (code != "") {
			d.buttons[i]= CopyEntity(ButtonCodeOBJ)
			EntityFX(d.buttons[i], 1)
        } else {
			if (keycard>0) {
				d.buttons[i]= CopyEntity(ButtonKeyOBJ)
            } else if (keycard<0) {
				d.buttons[i]= CopyEntity(ButtonScannerOBJ)	
            } else {
				d.buttons[i] = CopyEntity(ButtonOBJ)
            }
        }
		
		ScaleEntity(d.buttons[i], 0.03, 0.03, 0.03)
    }
	
	if (big==1) {
		PositionEntity(d.buttons[0], x - 432.0 * RoomScale, y + 0.7, z + 192.0 * RoomScale)
		PositionEntity(d.buttons[1], x + 432.0 * RoomScale, y + 0.7, z - 192.0 * RoomScale)
		RotateEntity(d.buttons[0], 0, 90, 0)
		RotateEntity(d.buttons[1], 0, 270, 0)
    } else {
		PositionEntity(d.buttons[0], x + 0.6, y + 0.7, z - 0.1)
		PositionEntity(d.buttons[1], x - 0.6, y + 0.7, z + 0.1)
		RotateEntity(d.buttons[1], 0, 180, 0		)
    }
	EntityParent(d.buttons[0], d.frameobj)
	EntityParent(d.buttons[1], d.frameobj)
	EntityPickMode(d.buttons[0], 2)
	EntityPickMode(d.buttons[1], 2)
	
	PositionEntity(d.obj, x, y, z)
	
	RotateEntity(d.obj, 0, angle, 0)
	RotateEntity(d.frameobj, 0, angle, 0)
	
	if (d.obj2 != 0) {
		PositionEntity (d.obj2, x, y, z)
		if (big=1) {
			RotateEntity(d.obj2, 0, angle, 0)
        } else {
			RotateEntity(d.obj2, 0, angle + 180, 0)
		}
		EntityParent(d.obj2, parent)
	}
	
	EntityParent(d.frameobj, parent)
	EntityParent(d.obj, parent)
	
	d.angle = angle
	d.open = dopen		
	
	EntityPickMode(d.obj, 2)
	if (d.obj2 != 0) {
		EntityPickMode(d.obj2, 2)
    }
	
	EntityPickMode (d.frameobj,2)
	
	if (d.open && big == False && Rand(8) == 1) {d.AutoClose = True}
	d.dir=big
	d.room=room
	
	d.MTFClose = True
	
	if (useCollisionMesh) {
		for (d2 of Doors.each) {
			if (d2 != d) {
				if (d2.DoorHitOBJ != 0) {
					d.DoorHitOBJ = CopyEntity(d2.DoorHitOBJ,d.frameobj)
					EntityAlpha (d.DoorHitOBJ,0.0)
					EntityFX (d.DoorHitOBJ,1)
					EntityType (d.DoorHitOBJ,HIT_MAP)
					EntityColor (d.DoorHitOBJ,255,0,0)
					HideEntity(d.DoorHitOBJ)
					Exit()
                }
            }
        }
		if (d.DoorHitOBJ == 0) {
			d.DoorHitOBJ = LoadMesh_Strict("GFX/doorhit.b3d",d.frameobj)
			EntityAlpha(d.DoorHitOBJ,0.0)
			EntityFX(d.DoorHitOBJ,1)
			EntityType(d.DoorHitOBJ,HIT_MAP)
			EntityColor(d.DoorHitOBJ,255,0,0)
			HideEntity(d.DoorHitOBJ)
        }
    }
	
	return d
	
}

function CreateButton(x: float,y: float,z: float, pitch: float,yaw: float,roll: float=0) {
	let obj = CopyEntity(ButtonOBJ)	
	
	ScaleEntity(obj, 0.03, 0.03, 0.03)
	
	PositionEntity(obj, x,y,z)
	RotateEntity(obj, pitch,yaw,roll)
	
	EntityPickMode(obj, 2)	
	
	return obj
}

function UpdateDoors() {
	
	let i: int, d: Doors, x: float, z: float, dist: float
	if (UpdateDoorsTimer <= 0) {
		for (d of Doors.each) {
			let xdist: float = Abs(EntityX(Collider)-EntityX(d.obj,True))
			let zdist: float = Abs(EntityZ(Collider)-EntityZ(d.obj,True))
			
			d.dist = xdist+zdist
			
			if (d.dist > HideDistance*2) {
				if (d.obj != 0) {HideEntity( d.obj)}
				if (d.frameobj != 0) {HideEntity( d.frameobj)}
				if (d.obj2 != 0) {HideEntity( d.obj2)}
				if (d.buttons[0] != 0) {HideEntity( d.buttons[0])}
				if (d.buttons[1] != 0) {HideEntity( d.buttons[1]				)}
            } else {
				if (d.obj != 0) {ShowEntity( d.obj)}
				if (d.frameobj != 0) {ShowEntity( d.frameobj)}
				if (d.obj2 != 0) {ShowEntity( d.obj2)}
				if (d.buttons[0] != 0) {ShowEntity( d.buttons[0])}
				if (d.buttons[1] != 0) {ShowEntity( d.buttons[1])}
            }
			
			if (PlayerRoom.RoomTemplate.Name$ = "room2sl") {
				if (ValidRoom2slCamRoom(d.room)) {
					if (d.obj != 0) {ShowEntity(d.obj)}
					if (d.frameobj != 0) {ShowEntity(d.frameobj)}
					if (d.obj2 != 0) {ShowEntity(d.obj2)}
					if (d.buttons[0] != 0) {ShowEntity(d.buttons[0])}
					if (d.buttons[1] != 0) {ShowEntity(d.buttons[1])}
                }
            }
        }
		
		UpdateDoorsTimer = 30
    } else {
		UpdateDoorsTimer = Max(UpdateDoorsTimer-FPSfactor,0)
	}
	
	ClosestButton = 0
	ClosestDoor = null
	
	for (d of Doors.each) {
		if (d.dist < HideDistance*2 || d.IsElevatorDoor>0) { //Make elevator doors update everytime because if not, this can cause a bug where the elevators suddenly won't work, most noticeable in room2tunnel - ENDSHN
			
			if ((d.openstate >= 180 || d.openstate <= 0) && GrabbedEntity == 0) {
				for (i of range(2)) {
					if (d.buttons[i] != 0) {
						if (Abs(EntityX(Collider)-EntityX(d.buttons[i],True)) < 1.0) { 
							if (Abs(EntityZ(Collider)-EntityZ(d.buttons[i],True)) < 1.0) { 
								dist = Distance(EntityX(Collider, True), EntityZ(Collider, True), EntityX(d.buttons[i], True), EntityZ(d.buttons[i], True))
								if (dist < 0.7) {
									let temp: int = CreatePivot()
									PositionEntity (temp, EntityX(Camera), EntityY(Camera), EntityZ(Camera))
									PointEntity( temp,d.buttons[i])
									
									if (EntityPick(temp, 0.6) == d.buttons[i]) {
										if (ClosestButton = 0) {
											ClosestButton = d.buttons[i]
											ClosestDoor = d
										} else {
											if (dist < EntityDistance(Collider, ClosestButton)) {
												ClosestButton = d.buttons[i]
												ClosestDoor = d
											}
										}							
									}
									
									FreeEntity (temp)
									
								}							
							}
						}
						
					}
				}
			}
			
			if (d.open) {
				if (d.openstate < 180) {
					switch (d.dir) {
						case 0:
							d.openstate = Min(180, d.openstate + FPSfactor * 2 * (d.fastopen+1))
							MoveEntity(d.obj, Sin(d.openstate) * (d.fastopen*2+1) * FPSfactor / 80.0, 0, 0)
							if (d.obj2 != 0) (MoveEntity(d.obj2, Sin(d.openstate)* (d.fastopen+1) * FPSfactor / 80.0, 0, 0)		)
						case 1:
							d.openstate = Min(180, d.openstate + FPSfactor * 0.8)
							MoveEntity(d.obj, Sin(d.openstate) * FPSfactor / 180.0, 0, 0)
							if (d.obj2 != 0) (MoveEntity(d.obj2, -Sin(d.openstate) * FPSfactor / 180.0, 0, 0))
						case 2:
							d.openstate = Min(180, d.openstate + FPSfactor * 2 * (d.fastopen+1))
							MoveEntity(d.obj, Sin(d.openstate) * (d.fastopen+1) * FPSfactor / 85.0, 0, 0)
							if (d.obj2 != 0) (MoveEntity(d.obj2, Sin(d.openstate)* (d.fastopen*2+1) * FPSfactor / 120.0, 0, 0))
						case 3:
							d.openstate = Min(180, d.openstate + FPSfactor * 2 * (d.fastopen+1))
							MoveEntity(d.obj, Sin(d.openstate) * (d.fastopen*2+1) * FPSfactor / 162.0, 0, 0)
							if (d.obj2 != 0) (MoveEntity(d.obj2, Sin(d.openstate)* (d.fastopen*2+1) * FPSfactor / 162.0, 0, 0))
						case 4: //Used for 914 only:
							d.openstate = Min(180, d.openstate + FPSfactor * 1.4)
							MoveEntity(d.obj, Sin(d.openstate) * FPSfactor / 114.0, 0, 0)
                    }
				} else {
					d.fastopen = 0
					ResetEntity(d.obj)
					if (d.obj2 != 0) {ResetEntity(d.obj2)}
					if (d.timerstate > 0) {
						d.timerstate = Max(0, d.timerstate - FPSfactor)
						if (d.timerstate + FPSfactor > 110 && d.timerstate <= 110) {d.SoundCHN = PlaySound2(CautionSFX, Camera, d.obj)}
						let sound: int
						if (d.dir == 1) {sound = Rand(0, 1)} else {sound = Rand(0, 2)}
						if (d.timerstate == 0) {
                            d.open = !d.open
                            d.SoundCHN = PlaySound2(CloseDoorSFX(d.dir,sound), Camera, d.obj)
                        }
					}
					if (d.AutoClose && RemoteDoorOn) {
						if (EntityDistance(Camera, d.obj) < 2.1) {
							if (!Wearing714) {PlaySound_Strict (HorrorSFX(7))}
							d.open = false
							d.SoundCHN = PlaySound2(CloseDoorSFX(Min(d.dir,1), Rand(0, 2)), Camera, d.obj)
							d.AutoClose = false
						}
					}				
				}
			} else {
				if (d.openstate > 0) {
					switch (d.dir) {
						case 0:
							d.openstate = Max(0, d.openstate - FPSfactor * 2 * (d.fastopen+1))
							MoveEntity(d.obj, Sin(d.openstate) * -FPSfactor * (d.fastopen+1) / 80.0, 0, 0)
							if (d.obj2 != 0) {
								MoveEntity(d.obj2, Sin(d.openstate) * (d.fastopen+1) * -FPSfactor / 80.0, 0, 0)
							}
						case 1:
							d.openstate = Max(0, d.openstate - FPSfactor*0.8)
							MoveEntity(d.obj, Sin(d.openstate) * -FPSfactor / 180.0, 0, 0)
							if (d.obj2 != 0) {MoveEntity(d.obj2, Sin(d.openstate) * FPSfactor / 180.0, 0, 0)}
							if (d.openstate < 15 && d.openstate+FPSfactor >= 15) {
								if (ParticleAmount==2) {
									for (i of range(0, Rand(76,100))) {
										let pvt: int = CreatePivot()
										PositionEntity(pvt, EntityX(d.frameobj,True)+Rnd(-0.2,0.2), EntityY(d.frameobj,True)+Rnd(0.0,1.2), EntityZ(d.frameobj,True)+Rnd(-0.2,0.2))
										RotateEntity(pvt, 0, Rnd(360), 0)
										
										let p: Particles = CreateParticle(EntityX(pvt), EntityY(pvt), EntityZ(pvt), 2, 0.002, 0, 300)
										p.speed = 0.005
										RotateEntity(p.pvt, Rnd(-20, 20), Rnd(360), 0)
										
										p.SizeChange = -0.00001
										p.size = 0.01
										ScaleSprite(p.obj,p.size,p.size)
										
										p.Achange = -0.01
										
										EntityOrder (p.obj,-1)
										
										FreeEntity( pvt)
                                    }
								}
							}
						case 2:
							d.openstate = Max(0, d.openstate - FPSfactor * 2 * (d.fastopen+1))
							MoveEntity(d.obj, Sin(d.openstate) * -FPSfactor * (d.fastopen+1) / 85.0, 0, 0)
							if (d.obj2 != 0) {
								MoveEntity(d.obj2, Sin(d.openstate) * (d.fastopen+1) * -FPSfactor / 120.0, 0, 0)
							}
						case 3:
							d.openstate = Max(0, d.openstate - FPSfactor * 2 * (d.fastopen+1))
							MoveEntity(d.obj, Sin(d.openstate) * -FPSfactor * (d.fastopen+1) / 162.0, 0, 0)
							if (d.obj2 != 0) {
								MoveEntity(d.obj2, Sin(d.openstate) * (d.fastopen+1) * -FPSfactor / 162.0, 0, 0)
							}
						case 4: //Used for 914 only:
							d.openstate = Min(180, d.openstate - FPSfactor * 1.4)
							MoveEntity(d.obj, Sin(d.openstate) * -FPSfactor / 114.0, 0, 0)
                    }
					
					if (d.angle == 0 || d.angle == 180) {
						if (Abs(EntityZ(d.frameobj, true)-EntityZ(Collider))<0.15) {
							if (Abs(EntityX(d.frameobj, true)-EntityX(Collider))<0.7*(d.dir*2+1)) {
								z = CurveValue(EntityZ(d.frameobj,true)+0.15*Sgn(EntityZ(Collider)-EntityZ(d.frameobj, true)), EntityZ(Collider), 5)
								PositionEntity (Collider, EntityX(Collider), EntityY(Collider), z)
							}
						}
					} else {
						if (Abs(EntityX(d.frameobj, true)-EntityX(Collider))<0.15) {
							if (Abs(EntityZ(d.frameobj, true)-EntityZ(Collider))<0.7*(d.dir*2+1)) {
								x = CurveValue(EntityX(d.frameobj,true)+0.15*Sgn(EntityX(Collider)-EntityX(d.frameobj, true)), EntityX(Collider), 5)
								PositionEntity (Collider, x, EntityY(Collider), EntityZ(Collider))
							}
						}
					}
					
					if (d.DoorHitOBJ != 0) {
						ShowEntity(d.DoorHitOBJ)
					}
				} else {
					d.fastopen = 0
					PositionEntity(d.obj, EntityX(d.frameobj, true), EntityY(d.frameobj, true), EntityZ(d.frameobj, true))
					if (d.obj2 != 0) {
						PositionEntity(d.obj2, EntityX(d.frameobj, true), EntityY(d.frameobj, true), EntityZ(d.frameobj, true))
					}
					if (d.obj2 != 0 && d.dir == 0) {
						MoveEntity(d.obj, 0, 0, 8.0 * RoomScale)
						MoveEntity(d.obj2, 0, 0, 8.0 * RoomScale)
					}
					if (d.DoorHitOBJ != 0) {
						HideEntity(d.DoorHitOBJ)
					}
				}
			}
			
		}
		UpdateSoundOrigin(d.SoundCHN,Camera,d.frameobj)
		
		if (d.DoorHitOBJ!=0) {
			if (DebugHUD) {
				EntityAlpha (d.DoorHitOBJ,0.5)
			} else {
				EntityAlpha (d.DoorHitOBJ,0.0)
			}
		}
	}
}

function UseDoor(d: Doors, showmsg: boolean = true, playsfx: boolean = true) {
	let temp: int = 0
	if (d.KeyCard > 0) {
		if (!SelectedItem) {
			if (showmsg) {
				if ((Instr(Msg,"The keycard") == 0 && Instr(Msg,"A keycard with") == 0) || (MsgTimer<70*3)) {
					Msg = "A keycard is required to operate this door."
					MsgTimer = 70 * 7
				}
			}
			return
		} else {
			switch (SelectedItem.itemtemplate.tempname) {
				case "key1":
					temp = 1
				case "key2":
					temp = 2
				case "key3":
					temp = 3
				case "key4":
					temp = 4
				case "key5":
					temp = 5
				case "key6":
					temp = 6
				default: 
					temp = -1
			}
			
			if (temp == -1) {
				if (showmsg) {
					if ((Instr(Msg,"The keycard")=0 && Instr(Msg,"A keycard with")==0) || (MsgTimer<70*3)) {
						Msg = "A keycard is required to operate this door."
						MsgTimer = 70 * 7
					}
				}
				return				
			} else if (temp >= d.KeyCard) {
				SelectedItem = Null
				if (showmsg) {
					if (d.locked) {
						PlaySound_Strict(KeyCardSFX2)
						Msg = "The keycard was inserted into the slot but nothing happened."
						MsgTimer = 70 * 7
						return
					} else {
						PlaySound_Strict(KeyCardSFX1)
						Msg = "The keycard was inserted into the slot."
						MsgTimer = 70 * 7	
					}
				}
			} else {
				SelectedItem = null
				if (showmsg) {
					PlaySound_Strict(KeyCardSFX2)
					if (d.locked) {
						Msg = "The keycard was inserted into the slot but nothing happened."
					} else {
						Msg = "A keycard with security clearance "+d.KeyCard+" or higher is required to operate this door."
					}
					MsgTimer = 70 * 7					
				}
				return
			}
		}	
	} else if (d.KeyCard < 0) {
		//I can't find any way to produce short circuited boolean expressions so work around this by using a temporary variable - risingstar64
		if (SelectedItem != Null) {
			temp = (SelectedItem.itemtemplate.tempname == "hand" && d.KeyCard == -1) || (SelectedItem.itemtemplate.tempname == "hand2" && d.KeyCard == -2)
		}
		SelectedItem = Null
		if (temp != 0) {
			PlaySound_Strict (ScannerSFX1)
			if ((Instr(Msg,"You placed your")=0) || (MsgTimer < 70*3)) {
				Msg = "You place the palm of the hand onto the scanner. The scanner reads: "+Chr(34)+"DNA verified. Access granted."+Chr(34)
			}
			MsgTimer = 70 * 10
		} else {
			if (showmsg) {
				PlaySound_Strict (ScannerSFX2)
				Msg = "You placed your palm onto the scanner. The scanner reads: "+Chr(34)+"DNA does not match known sample. Access denied."+Chr(34)
				MsgTimer = 70 * 10
			}
			return			
		}
	} else {
		if (d.locked) {
			if (showmsg) {
				if (!(d.IsElevatorDoor>0)) {
					PlaySound_Strict (ButtonSFX2)
					if (PlayerRoom.RoomTemplate.Name != "room2elevator") {
                        if (d.open) {
                            Msg = "You pushed the button but nothing happened."
						} else {    
                            Msg = "The door appears to be locked."
                        }    
					} else {
                        Msg = "The elevator appears to be broken."
                    }
					MsgTimer = 70 * 5
				} else {
					if (d.IsElevatorDoor == 1) {
						Msg = "You called the elevator."
						MsgTimer = 70 * 5
					} else if (d.IsElevatorDoor == 3) {
						Msg = "The elevator is already on this floor."
						MsgTimer = 70 * 5
					} else if (Msg!="You called the elevator.") {
						if ((Msg=="You already called the elevator.") || (MsgTimer<70*3)) {
							switch (Rand(10)) {
								case 1:
									Msg = "Stop spamming the button."
									MsgTimer = 70 * 7
								case 2:
									Msg = "Pressing it harder does not make the elevator come faster."
									MsgTimer = 70 * 7
								case 3:
									Msg = "If you continue pressing this button I will generate a Memory Access Violation."
									MsgTimer = 70 * 7
								default:
									Msg = "You already called the elevator."
									MsgTimer = 70 * 7
							}
						}
					} else {
						Msg = "You already called the elevator."
						MsgTimer = 70 * 7
					}
				}
				
			}
			return
		}	
	}
	
	d.open = (!d.open)
	if (d.LinkedDoor != null) {
		d.LinkedDoor.open = (!d.LinkedDoor.open)
	}
	
	let sound = 0
	if (d.dir == 1) {
		sound=Rand(0, 1)
	} else {
		sound=Rand(0, 2)
	}
	
	if (playsfx) {
		if (d.open) {
			if (d.LinkedDoor != Null) {d.LinkedDoor.timerstate = d.LinkedDoor.timer}
			d.timerstate = d.timer
			d.SoundCHN = PlaySound2 (OpenDoorSFX(d.dir, sound), Camera, d.obj)
		} else {
			d.SoundCHN = PlaySound2 (CloseDoorSFX(d.dir, sound), Camera, d.obj)
		}
		UpdateSoundOrigin(d.SoundCHN,Camera,d.obj)
	} else {
		if (d.open) {
			if (d.LinkedDoor != Null) {d.LinkedDoor.timerstate = d.LinkedDoor.timer}
			d.timerstate = d.timer
		}
	}
	
}

function RemoveDoor(d: Doors) {
	if (d.buttons[0] != 0) {EntityParent (d.buttons[0], 0)}
	if (d.buttons[1] != 0) {EntityParent (d.buttons[1], 0	)}
	
	if (d.obj != 0) {FreeEntity( d.obj)}
	if (d.obj2 != 0) {FreeEntity( d.obj2)}
	if (d.frameobj != 0) {FreeEntity( d.frameobj)}
	if (d.buttons[0] != 0) {FreeEntity( d.buttons[0])}
	if (d.buttons[1] != 0) {FreeEntity( d.buttons[1])}
	
	Delete (d)
}

DrawLoading(40,true)


class Materials {
	name: string
	Diff
	Bump
	
	StepSound: int
	static each: Materials[] = []
}

function LoadMaterials(file: string) {
	CatchErrors("Uncaught (LoadMaterials)")
	
	let TemporaryString: string
	let mat: Materials
	let StrTemp: string = ""
	
	let f = OpenFile(file)
	
	while (!Eof(f)) {
		TemporaryString = Trim(ReadLine(f))
		if (Left(TemporaryString,1) == "[") {
			TemporaryString = Mid(TemporaryString, 2, Len(TemporaryString) - 2)
			
			let mat: Materials = new Materials()
			
			mat.name = Lower(TemporaryString)
			
			if (BumpEnabled) {
				StrTemp = GetINIString(file, TemporaryString, "bump")
				if (StrTemp != "") { 
					mat.Bump =  LoadTexture_Strict(StrTemp)
					
					TextureBlend (mat.Bump, TextureBlendMode.NoBlendOrAlpha) //TODO mode 6?
					TextureBumpEnvMat(mat.Bump,0,0,-0.012)
					TextureBumpEnvMat(mat.Bump,0,1,-0.012)
					TextureBumpEnvMat(mat.Bump,1,0,0.012)
					TextureBumpEnvMat(mat.Bump,1,1,0.012)
					TextureBumpEnvOffset(mat.Bump,0.5)
					TextureBumpEnvScale (mat.Bump,1.0)
				}
			}
			
			mat.StepSound = (GetINIInt(file, TemporaryString, "stepsound")+1)
		}
	}
	
	CloseFile (f)
	
	CatchErrors("LoadMaterials")
}

function LoadWorld(file: string, rt: RoomTemplates) {
	let map=LoadAnimMesh_Strict(file)
	if (!map) {return}
	
	let x: float,y: float,z: float,i: int,c: int
	let mat: Materials
	
	let world=CreatePivot()
	let meshes=CreatePivot(world)
	let renderbrushes=CreateMesh(world)
	let collisionbrushes=CreatePivot(world)
	EntityType (collisionbrushes,HIT_MAP)
	
	for (c of range(1, CountChildren(map) + 1)) {
		
		let node=GetChild(map,c)	
		let classname: string = Lower(KeyValue(node,"classname"))
		
		switch (classname) {
				
			//===============================================================================
			//Map Geometry
			//===============================================================================
				
			case "mesh":
				EntityParent (node,meshes)
				
				if (KeyValue(node,"disablecollisions") != 1) {
					EntityType (node,HIT_MAP)
					EntityPickMode (node, 2)
				}
				
				c=c-1
				
			case "brush":
				RotateMesh (node,EntityPitch(node),EntityYaw(node),EntityRoll(node))
				PositionMesh (node,EntityX(node),EntityY(node),EntityZ(node))
				
				AddMesh (node,renderbrushes	)
				
				EntityAlpha (node,0)
				EntityType (node,HIT_MAP)
				EntityAlpha (node,0)
				EntityParent (node,collisionbrushes)
				EntityPickMode (node, 2)
				
				c=c-1
				
			//===============================================================================
			//Solid Entities
			//===============================================================================
			case "item":
				// nothing?
			case "screen":
				
				x = EntityX(node)*RoomScale
				y = EntityY(node)*RoomScale
				z = EntityZ(node)*RoomScale
				
				if (x != 0 || y != 0 || z != 0) {
					let ts: TempScreens = new TempScreens()
					ts.x = x
					ts.y = y
					ts.z = z
					ts.imgpath = KeyValue(node,"imgpath","")
					ts.roomtemplate = rt
				}
				
			case "waypoint":
				x = EntityX(node)*RoomScale
				y = EntityY(node)*RoomScale
				z = EntityZ(node)*RoomScale				
				let w: TempWayPoints = new TempWayPoints()
				w.roomtemplate = rt
				w.x = x
				w.y = y
				w.z = z
				
			case "light":
				x = EntityX(node)*RoomScale
				y = EntityY(node)*RoomScale
				z = EntityZ(node)*RoomScale
				
				if (x != 0 || y != 0 || z != 0) {
					let trange = Float(KeyValue(node,"range","1"))/2000.0
					let lcolor = KeyValue(node,"color","255 255 255")
					let intensity = Min(Float(KeyValue(node,"intensity","1.0"))*0.8,1.0)
					let r=Int(Piece(lcolor,1," "))*intensity
					let g=Int(Piece(lcolor,2," "))*intensity
					let b=Int(Piece(lcolor,3," "))*intensity
					
					AddTempLight(rt, x,y,z, 2, trange, r,g,b)
				}
			case "spotlight":
				x = EntityX(node)*RoomScale
				y = EntityY(node)*RoomScale
				z = EntityZ(node)*RoomScale
				if (x != 0 || y != 0 || z != 0) {
					let trange = Float(KeyValue(node,"range","1"))/700.0
					let lcolor = KeyValue(node,"color","255 255 255")
					let intensity = Min(Float(KeyValue(node,"intensity","1.0"))*0.8,1.0)
					let r = Int(Piece(lcolor,1," "))*intensity
					let g = Int(Piece(lcolor,2," "))*intensity
					let b = Int(Piece(lcolor,3," "))*intensity
					
					let lt: LightTemplates = AddTempLight(rt, x,y,z, 3, trange, r,g,b)
					let angles = KeyValue(node,"angles","0 0 0")
					let pitch = Piece(angles,1," ")
					let yaw = Piece(angles,2," ")
					lt.pitch = pitch
					lt.yaw = yaw
					
					lt.innerconeangle = Int(KeyValue(node,"innerconeangle",""))
					lt.outerconeangle = Int(KeyValue(node,"outerconeangle",""))	
				}
			case "soundemitter":
				for (i of range(4)) {
					if (rt.TempSoundEmitter[i] == 0) {
						rt.TempSoundEmitterX[i]=EntityX(node)*RoomScale
						rt.TempSoundEmitterY[i]=EntityY(node)*RoomScale
						rt.TempSoundEmitterZ[i]=EntityZ(node)*RoomScale
						rt.TempSoundEmitter[i]=Int(KeyValue(node,"sound","0"))
						
						rt.TempSoundEmitterRange[i]=Float(KeyValue(node,"range","1"))
						Exit()
					}
				}
				
			//Invisible collision brush
			case "field_hit":
				EntityParent (node,collisionbrushes)
				EntityType (node,HIT_MAP)
				EntityAlpha (node,0)
				c=c-1
				
			//===============================================================================
			//Point Entities
			//===============================================================================
				
			//Camera start position point entity
			case "playerstart":
				let angles = KeyValue(node,"angles","0 0 0")
				let pitch = Piece(angles,1," ")
				let yaw = Piece(angles,2," ")
				let roll = Piece(angles,3," ")
				if (cam) {
					PositionEntity (cam,EntityX(node),EntityY(node),EntityZ(node))
					RotateEntity (cam,pitch,yaw,roll)
				}
				
		}
	}
	
	EntityFX (renderbrushes, 1)
	
	FreeEntity (map)
	
	return world	
	
	
}

//RMESH STUFF////////

export function StripFilename(file: string): string {
	let mi: string = ""
	let lastSlash: int=0
	if (Len(file)>0) {
		for (let i of range(1, Len(file) + 1)) {
			mi=Mid(file,i,1)
			if (mi == "\\" || mi == "/") {
				lastSlash=i
			}
		}
	}
	
	return Left(file,lastSlash)
}

export function GetTextureFromCache(name: string): int {
	for (let tc of Materials.each) {
		if (tc.name == name) {return tc.Diff}
	}
	return 0
}

export function GetBumpFromCache(name: string): int {
	for (let tc of Materials.each) {
		if (tc.name == name) {return tc.Bump}
	}
	return 0
}

export function GetCache(name: string): Materials | null {
	for (let tc of Materials.each) {
		if (tc.name == name) {return tc}
}
	return null
}

export function AddTextureToCache(texture: int) {
	let tc: Materials = GetCache(StripPath(TextureName(texture)))
	if (!tc) {
		tc = new Materials()
		tc.name=StripPath(TextureName(texture))
		if (BumpEnabled) {
			let temp: string = GetINIString("Data/materials.ini",tc.name,"bump")
			if (temp != "") {
				tc.Bump=LoadTexture_Strict(temp)
				TextureBlend (tc.Bump,6)
				TextureBumpEnvMat (tc.Bump,0,0,-0.012)
				TextureBumpEnvMat (tc.Bump,0,1,-0.012)
				TextureBumpEnvMat (tc.Bump,1,0,0.012)
				TextureBumpEnvMat (tc.Bump,1,1,0.012)
				TextureBumpEnvOffset (tc.Bump,0.5)
				TextureBumpEnvScale (tc.Bump,1.0)
			} else {
				tc.Bump=0
			}
		}
		tc.Diff=0
	}
	if (tc.Diff == 0) {
		tc.Diff=texture
	}
}

export function ClearTextureCache() {
	for (let tc of Materials.each) {
		if (tc.Diff != 0) {
			FreeTexture(tc.Diff)
		}
		if (tc.Bump != 0) {
			FreeTexture(tc.Bump)
		}
		Delete (tc)
	}
}

export function FreeTextureCache() {
	for (let tc of Materials.each) {
		if (tc.Diff != 0) {
			FreeTexture (tc.Diff)
		}
		if (tc.Bump != 0) {
			FreeTexture (tc.Bump)
		}
		tc.Diff = 0
		tc.Bump = 0
	}
}

export function LoadRMesh(file: string,rt: RoomTemplates) {
	CatchErrors("Uncaught (LoadRMesh)")
	//generate a texture made of white
	let blankTexture: int
	blankTexture=CreateTexture(4,4,TextureFlags.Color,1)
	ClsColor (255,255,255)
	SetBuffer (TextureBuffer(blankTexture))
	Cls()
	SetBuffer (BackBuffer())
	
	let pinkTexture: int
	pinkTexture=CreateTexture(4,4,TextureFlags.Color,1)
	ClsColor (255,255,255)
	SetBuffer (TextureBuffer(pinkTexture))
	Cls()
	SetBuffer (BackBuffer())
	
	ClsColor (0,0,0)
	
	//read the file
	let f: int=ReadFile(file)
	let i: int
	let j: int
	let k: int
	let x: float
	let y: float
	let z: float
	let yaw: float
	let vertex: int
	let temp1i: int
	let temp2i: int
	let temp3i: int
	let temp1: float
	let temp2: float
	let temp3: float
	let temp1s: string
	let temp2s: string
	
	let collisionMeshes: int = CreatePivot()
	
	let hasTriggerBox: boolean = false
	
	for (i of range(4)) { //reattempt up to 3 times
		if (f == 0) {
			f=ReadFile(file)
		} else {
			break
		}
	}
	if (f == 0) {
		RuntimeError ("Error reading file "+Chr(34)+file+Chr(34))
	}
	let isRMesh: string = ReadString(f)
	if (isRMesh == "RoomMesh") {
		
	} else if (isRMesh == "RoomMesh.HasTriggerBox") {
		hasTriggerBox = true
	} else {
		RuntimeError (Chr(34)+file+Chr(34)+" is !RMESH ("+isRMesh+")")
	}
	
	file=StripFilename(file)
	
	let count: int
	let count2: int
	
	//drawn meshes
	let Opaque: int
	let Alpha: int
	
	Opaque=CreateMesh()
	Alpha=CreateMesh()
	
	count = ReadInt(f)
	let childMesh: int
	let surf: int
	let tex: int[] = new Array(2)
	let brush: int
	
	let isAlpha: int
	
	let u: float
	let v: float
	
	for (i of range(1, count + 1)) { //drawn mesh
		childMesh=CreateMesh()
		
		surf=CreateSurface(childMesh)
		
		brush=CreateBrush()
		
		tex[0]=0
		tex[1]=0
		
		isAlpha=0
		for (j of range(2)) {
			temp1i=ReadByte(f)
			if (temp1i != 0) {
				temp1s=ReadString(f)
				tex[j]=GetTextureFromCache(temp1s)
				if (tex[j]=0) { //texture is not in cache
					switch (true) {
						case temp1i<3:
							tex[j]=LoadTexture(file+temp1s,1)
						default:
							tex[j]=LoadTexture(file+temp1s,3)
					}
					
					if (tex[j] != 0) {
						if (temp1i=1) {TextureBlend (tex[j],5)}
						if (Instr(Lower(temp1s),"_lm") != 0) {
							TextureBlend (tex[j],3)
						}
						AddTextureToCache(tex[j])
					}
					
				}
				if (tex[j] != 0) {
					isAlpha=2
					if (temp1i == 3) {
						isAlpha=1
					}
					
					TextureCoords (tex[j],1-j)
				}
			}
		}
		
		if (isAlpha == 1) {
			if (tex[1] != 0) {
				TextureBlend (tex[1],2)
				BrushTexture (brush,tex[1],0,0)
			} else {
				BrushTexture (brush,blankTexture,0,0)
			}
		} else {
			if (tex[0] != 0 && tex[1] != 0) {
				let bumptex = GetBumpFromCache(StripPath(TextureName(tex[1])))
				for (j of range(2)) {
					BrushTexture (brush,tex[j],0,j+1+Int(bumptex != 0))
				}
				
				BrushTexture (brush,AmbientLightRoomTex,0)
				if (bumptex != 0) {
					BrushTexture (brush,bumptex,0,1)
				}
			} else {
				for (j of range(2)) {
					if (tex[j] != 0) {
						BrushTexture (brush,tex[j],0,j)
					} else {
						BrushTexture (brush,blankTexture,0,j)
					}
				}
			}
		}
		
		surf=CreateSurface(childMesh)
		
		if (isAlpha>0) {PaintSurface (surf,brush)}
		
		FreeBrush (brush)
		brush = 0
		
		count2=ReadInt(f) //vertices
		
		for (j of range(1, count2 + 1)) {
			//world coords
			x=ReadFloat(f)
			y=ReadFloat(f)
			z=ReadFloat(f)
			let vertex=AddVertex(surf,x,y,z)
			
			//texture coords
			for (k of range(2)) {
				u=ReadFloat(f)
				v=ReadFloat(f)
				VertexTexCoords (surf,vertex,u,v,0.0,k)
			}
			
			//colors
			let temp1i=ReadByte(f)
			let temp2i=ReadByte(f)
			let temp3i=ReadByte(f)
			VertexColor (surf,vertex,temp1i,temp2i,temp3i,1.0)
		}
		
		count2=ReadInt(f) //polys
		for (j of range(1, count2 + 1)) {
			temp1i = ReadInt(f)
			temp2i = ReadInt(f)
			temp3i = ReadInt(f)
			AddTriangle(surf,temp1i,temp2i,temp3i)
		}
		
		if (isAlpha==1) {
			AddMesh (childMesh,Alpha)
			EntityAlpha (childMesh,0.0)
		} else {
			AddMesh (childMesh,Opaque)
			EntityParent (childMesh,collisionMeshes)
			EntityAlpha (childMesh,0.0)
			EntityType (childMesh,HIT_MAP)
			EntityPickMode (childMesh,2)
			
			//make collision double-sided
			let flipChild: int = CopyMesh(childMesh)
			FlipMesh(flipChild)
			AddMesh (flipChild,childMesh)
			FreeEntity (flipChild)
		}	
	}
	
	let hiddenMesh: int
	hiddenMesh=CreateMesh()
	
	count=ReadInt(f) //invisible collision mesh
	for (i of range(1, count + 1)) {
		surf=CreateSurface(hiddenMesh)
		count2=ReadInt(f) //vertices
		for (j of range(1, count2 + 1)) {
			//world coords
			x=ReadFloat(f)
			y=ReadFloat(f)
			z=ReadFloat(f)
			let vertex=AddVertex(surf,x,y,z)
		}
		
		count2=ReadInt(f) //polys
		for (j of range(1, count2 + 1)) {
			temp1i = ReadInt(f)
			temp2i = ReadInt(f)
			temp3i = ReadInt(f)
			AddTriangle(surf,temp1i,temp2i,temp3i)
			AddTriangle(surf,temp1i,temp3i,temp2i)
		}
	}
	
	//trigger boxes
	if (hasTriggerBox) {
		DebugLog ("TriggerBoxEnable")
		rt.TempTriggerboxAmount = ReadInt(f)
		for (let tb of range(rt.TempTriggerboxAmount)) {
			rt.TempTriggerbox[tb] = CreateMesh(rt.obj)
			count = ReadInt(f)
			for (i of range(1, count + 1)) {
				surf=CreateSurface(rt.TempTriggerbox[tb])
				count2=ReadInt(f)
				for (j of range(1, count2 + 1)) {
					x=ReadFloat(f)
					y=ReadFloat(f)
					z=ReadFloat(f)
					let vertex = AddVertex(surf,x,y,z)
				}
				count2=ReadInt(f)
				for (j of range(1, count2 + 1)) {
					temp1i = ReadInt(f)
					temp2i = ReadInt(f)
					temp3i = ReadInt(f)
					AddTriangle(surf,temp1i,temp2i,temp3i)
					AddTriangle(surf,temp1i,temp3i,temp2i)
				}
			}
			rt.TempTriggerboxName[tb] = ReadString(f)
		}
	}
	
	count=ReadInt(f) //point entities
	for (i of range(1, count + 1)) {
		let temp1s = ReadString(f)
		switch (temp1s) {
			case "screen":
				
				temp1=ReadFloat(f)*RoomScale
				temp2=ReadFloat(f)*RoomScale
				temp3=ReadFloat(f)*RoomScale
				
				let temp2s = ReadString(f)
				
				if (temp1 != 0 || temp2 != 0 || temp3 != 0) {
					let ts: TempScreens = new TempScreens()
					ts.x = temp1
					ts.y = temp2
					ts.z = temp3
					ts.imgpath = temp2s
					ts.roomtemplate = rt
				}
				
			case "waypoint":
				
				temp1=ReadFloat(f)*RoomScale
				temp2=ReadFloat(f)*RoomScale
				temp3=ReadFloat(f)*RoomScale
				
				let w: TempWayPoints = new TempWayPoints()
				w.roomtemplate = rt
				w.x = temp1
				w.y = temp2
				w.z = temp3
				
			case "light":
				
				temp1=ReadFloat(f)*RoomScale
				temp2=ReadFloat(f)*RoomScale
				temp3=ReadFloat(f)*RoomScale
				
				if (temp1 != 0 || temp2 != 0 || temp3 != 0) {
					let trange = ReadFloat(f)/2000.0
					let lcolor = ReadString(f)
					let intensity = Min(ReadFloat(f)*0.8,1.0)
					let r = Int(Piece(lcolor,1," "))*intensity
					let g = Int(Piece(lcolor,2," "))*intensity
					let b = Int(Piece(lcolor,3," "))*intensity
					
					AddTempLight(rt, temp1,temp2,temp3, 2, trange, r,g,b)
				} else {
					ReadFloat(f)
					ReadString(f)
					ReadFloat(f)
				}
				
			case "spotlight":
				
				temp1=ReadFloat(f)*RoomScale
				temp2=ReadFloat(f)*RoomScale
				temp3=ReadFloat(f)*RoomScale
				
				if (temp1 != 0 || temp2 != 0 || temp3 != 0) {
					let trange = ReadFloat(f)/2000.0
					let lcolor = ReadString(f)
					let intensity = Min(ReadFloat(f)*0.8,1.0)
					let r = Int(Piece(lcolor,1," "))*intensity
					let g = Int(Piece(lcolor,2," "))*intensity
					let b = Int(Piece(lcolor,3," "))*intensity
					
					let lt: LightTemplates = AddTempLight(rt, temp1,temp2,temp3, 2, trange, r,g,b)
					let angles = ReadString(f)
					let pitch = Piece(angles,1," ")
					let yaw = Piece(angles,2," ")
					lt.pitch = pitch
					lt.yaw = yaw
					
					lt.innerconeangle = ReadInt(f)
					lt.outerconeangle = ReadInt(f)
				} else {
					ReadFloat(f)
					ReadString(f)
					ReadFloat(f)
					ReadString(f)
					ReadInt(f)
					ReadInt(f)
				}
				
			case "soundemitter":
				
				temp1i=0
				
				for (j of range(MaxRoomEmitters)) {
					if (rt.TempSoundEmitter[j] == 0) {
						rt.TempSoundEmitterX[j]=ReadFloat(f)*RoomScale
						rt.TempSoundEmitterY[j]=ReadFloat(f)*RoomScale
						rt.TempSoundEmitterZ[j]=ReadFloat(f)*RoomScale
						rt.TempSoundEmitter[j]=ReadInt(f)
						
						rt.TempSoundEmitterRange[j]=ReadFloat(f)
						temp1i=1
						Exit()
					}
				}
				
				if (temp1i == 0) {
					ReadFloat(f)
					ReadFloat(f)
					ReadFloat(f)
					ReadInt(f)
					ReadFloat(f)
				}
				
			case "playerstart":
				
				temp1=ReadFloat(f)
				temp2=ReadFloat(f)
				temp3=ReadFloat(f)
				
				let angles = ReadString(f)
				let pitch = Float(Piece(angles,1," "))
				let yaw = Float(Piece(angles,2," "))
				let roll = Float(Piece(angles,3," "))
				if (cam) {
					PositionEntity (cam,temp1,temp2,temp3)
					RotateEntity (cam,pitch,yaw,roll)
				}
			case "model":
				file = ReadString(f)
				if (file != "") {
					let model = CreatePropObj("GFX/Map/Props/"+file)
					
					temp1=ReadFloat(f)
					temp2=ReadFloat(f)
					temp3=ReadFloat(f)
					PositionEntity(model,temp1,temp2,temp3)
					
					temp1=ReadFloat(f)
					temp2=ReadFloat(f)
					temp3=ReadFloat(f)
					RotateEntity (model,temp1,temp2,temp3)
					
					temp1=ReadFloat(f)
					temp2=ReadFloat(f)
					temp3=ReadFloat(f)
					ScaleEntity (model,temp1,temp2,temp3)
					
					EntityParent (model,Opaque)
					EntityType (model,HIT_MAP)
					EntityPickMode (model,2)
				} else {
					DebugLog ("file = 0")
					temp1=ReadFloat(f)
					temp2=ReadFloat(f)
					temp3=ReadFloat(f)
					DebugLog (temp1+", "+temp2+", "+temp3)
					
					//Stop
				}
		}
	}
	
	let obj: int
	
	temp1i=CopyMesh(Alpha)
	FlipMesh (temp1i)
	AddMesh (temp1i,Alpha)
	FreeEntity (temp1i)
	
	if (brush != 0) {
		FreeBrush (brush)
	}
	
	AddMesh (Alpha,Opaque)
	FreeEntity (Alpha)
	
	EntityFX (Opaque,3)
	
	EntityAlpha (hiddenMesh,0.0)
	EntityAlpha (Opaque,1.0)
	
	//EntityType Opaque,HIT_MAP
	EntityType (hiddenMesh,HIT_MAP)
	FreeTexture (blankTexture)
	
	//AddMesh hiddenMesh,BigRoomMesh
	
	obj=CreatePivot()
	CreatePivot(obj) //skip "meshes" object
	EntityParent (Opaque,obj)
	EntityParent (hiddenMesh,obj)
	CreatePivot(obj) //skip "pointentites" object
	CreatePivot(obj) //skip "solidentites" object
	EntityParent (collisionMeshes,obj)
	
	CloseFile (f)
	
	CatchErrors("LoadRMesh")
	return obj
	
}


//-----------////////

export function StripPath(file: string): string {
	let name: string = ""
	if (Len(file) > 0) {
		for (let i of range(Len(file) + 1, 1, -1)) {
			
			let mi=Mid(file,i,1) 
			if (mi == "\\" || mi == "/") {return name}
			
			name=mi+name 
		} 
		
	} 
	
	return name
}

export function Piece(s: string,entry,char: string=" "): string {
	let p
	let a
	while (Instr(s,char+char)) {
		s=Replace(s,char+char,char)
	}
	for (let n of range(1, entry)) {
		p=Instr(s,char)
		s=Right(s,Len(s)-p)
	}
	p=Instr(s,char)
	if (p<1) {
		a=s
	} else {
		a=Left(s,p-1)
	}
	return a
}

export function KeyValue(entity,key: string,defaultvalue: string=""): string {
	let properties=EntityName(entity)
	let test
	properties=Replace(properties,Chr(13),"")
	key=Lower(key)
	while (true) {
		let p=Instr(properties,Chr(10))
		if (p) {
			test=(Left(properties,p-1))
		} else {
			test=properties
		}
		let testkey=Piece(test,1,"=")
		testkey=Trim(testkey)
		testkey=Replace(testkey,Chr(34),"")
		testkey=Lower(testkey)
		if (testkey == key) {
			let value=Piece(test,2,"=")
			value=Trim(value)
			value=Replace(value,Chr(34),"")
			return value
		}
		if (!p) {
			return defaultvalue
		}
		properties=Right(properties,Len(properties)-p)
	} 
}



//Forest gen consts
export const gridsize: int = 10
export const deviation_chance: int = 40 //out of 100
export const branch_chance: int = 65
export const branch_max_life: int = 4
export const branch_die_chance: int = 18
export const max_deviation_distance: int = 3
export const return_chance: int = 27
export const center = 5 //(gridsize-1) / 2

class DrawPortal {
	
	w: float
	h: float
	
	
	cam: int
	portal: int
	
	camZoom: float
	campitch: float
	camyaw: float
	camroll: float
	tex: int
	texw: int
	texh: int
	id: int
	static each: DrawPortal[] = []
}

export function CreateDrawPortal(x: float,y: float,z: float,pitch: float,yaw: float,roll: float,w: float,h: float,camx: float=0.0,camy: float=0.0,camz: float=0.0,campitch: float=0.0,camyaw: float=0.0,camroll: float=0.0,camZoom: float=1.0,texw: int=2048,texh: int=2048): DrawPortal {
	let ndp: DrawPortal = new DrawPortal()
	
	ndp.w = w
	ndp.h = h
	
	ndp.tex = CreateTexture(texw,texh,1+8+256+FE_RENDER+FE_ZRENDER) //make a texture we can render to
	TextureBlend (ndp.tex, FE_PROJECT)
	PositionTexture (ndp.tex,0.5,0.5)
	ScaleTexture (ndp.tex,(Float(texw)/Float(GraphicWidth))*2,(Float(texh)/Float(GraphicHeight))*2)
	//RotateTexture ndp.tex,180
	ndp.texw = texw
	ndp.texh = texh
	ndp.cam = CreateCamera() //create a camera to enable rendering
	CameraRange (ndp.cam,0.5,20.0)
	PositionEntity (ndp.cam,camx,camy,camz,true)
	RotateEntity (ndp.cam,campitch,camyaw,camroll,true)
	CameraZoom (ndp.cam,camZoom)
	
	ndp.campitch = campitch
	ndp.camyaw   = camyaw
	ndp.camroll  = camroll
	
	ndp.camZoom  = camZoom
	
	ndp.portal = CreateCube() //you can replace the cube with anything you like
	ScaleMesh (ndp.portal,w/2.0,h/2.0,d/2.0)
	FlipMesh (ndp.portal)
	//ndp.surface = GetSurface(ndp.portal,1)
	EntityTexture (ndp.portal,ndp.tex)
	
	EntityFX (ndp.portal,1)
	PositionEntity (ndp.portal,x,y,z,true)
	RotateEntity (ndp.portal,pitch,yaw,roll,true)
	
	CameraProjMode(ndp.cam,0) //prevent the camera from causing problems with the BackBuffer
	
	ndp.id = 0
	
	let temp: int = 0
	for (let c of DrawPortal.each) {
	//	temp=temp+1
		temp = Max(c.id,temp)
	}
	ndp.id = temp+1
	
	return ndp
}

export function DestroyDrawPortal(ndp: DrawPortal) {
	if (ndp.tex != 0) {FreeTexture (ndp.tex)}
	ndp.tex = 0
	ndp.texw = 0
	ndp.texh = 0
	if (ndp.cam != 0) {FreeEntity (ndp.cam)}
	ndp.cam = 0
	if (ndp.portal != 0) {FreeEntity (ndp.portal)}
	ndp.portal = 0
	Delete(ndp)
}

export function UpdateDrawPortal(ndp: DrawPortal) {
	RotateEntity (ndp.cam,ndp.campitch,ndp.camyaw,ndp.camroll,true)
	CameraZoom (ndp.cam,ndp.camZoom)
	
	CameraProjMode (ndp.cam,1) //enable the camera
	
	SetBuffer(TextureBuffer(ndp.tex))
	CameraViewport (ndp.cam,(ndp.texw/2)-(GraphicWidth/2),(ndp.texh/2)-(GraphicHeight/2),GraphicWidth,GraphicHeight)
	Cls()
	RenderWorld() //requires FastExt to render to texture
	
	CameraProjMode (ndp.cam,0) //disable the camera
	
	SetBuffer(BackBuffer())
}

export class Forest {
	TileMesh: int[] = new Array(6)
	DetailMesh: int[] = new Array(6)
	TileTexture: int[] = new Array(10)
	grid: int[] = new Array((gridsize*gridsize)+11)
	TileEntities: int[] = new Array((gridsize*gridsize)+1)
	Forest_Pivot: int
	
	Door: int[] = new Array(2)
	DetailEntities: int[] = new Array(2)
	
	ID: int
}

export function move_forward(dir: int,pathx: int,pathy: int,retval: int=0) : int {
	//move 1 unit along the grid in the designated direction
	if (dir == 1) {
		if (retval == 0) {
			return pathx
		} else {
			return pathy+1
		}
	}
	if (retval == 0) {
		return pathx-1+dir
	} else {
		return pathy
	}
}

export function chance(chanc: int) : boolean {
	//perform a chance given a probability
	return (Rand(0,100)<=chanc)
}

export function turn_if_deviating(max_deviation_distance_: int,pathx: int,center_: int,dir: int,retval: int=0) : int {
	//check if deviating and return the answer. if deviating, turn around
	let current_deviation: int = center_ - pathx
	let deviated: int = 0
	if ((dir == 0 && current_deviation >= max_deviation_distance_) || (dir == 2 && current_deviation <= -max_deviation_distance_)) {
		dir = (dir + 2) % 4
		deviated = 1
	}
	if (retval == 0) {
		return dir
	} else {
		return deviated
	}
}

function GenForestGrid(fr: Forest) {
	CatchErrors("Uncaught (GenForestGrid)")
	fr.ID=LastForestID+1
	LastForestID += 1
	
	let door1_pos: int
	let door2_pos: int
	let i: int
	let j: int
	door1_pos=Rand(3,7)
	door2_pos=Rand(3,7)
	
	//clear the grid
	for (i of range(gridsize)) {
		for (j of range(gridsize)) {
			fr.grid[(j*gridsize)+i]=0
		}
	}
	
	//set the position of the concrete and doors
	fr.grid[door1_pos]=3
	fr.grid[((gridsize-1)*gridsize)+door2_pos]=3
	
	//generate the path
	let pathx = door2_pos
	let pathy = 1
	let dir = 1 //0 = left, 1 = up, 2 = right
	fr.grid[((gridsize-1-pathy)*gridsize)+pathx] = 1
	
	let deviated: int
	
	while (pathy < gridsize -4) {
		if (dir == 1) { //determine whether to go forward or to the side
			if (chance(deviation_chance)) {
				//pick a branch direction
				dir = 2 * Rand(0,1)
				//make sure you have not passed max side distance
				dir = turn_if_deviating(max_deviation_distance,pathx,center,dir)
				deviated = turn_if_deviating(max_deviation_distance,pathx,center,dir,1)
				if (deviated) {
					fr.grid[((gridsize-1-pathy)*gridsize)+pathx]=1
				}
				pathx=move_forward(dir,pathx,pathy)
				pathy=move_forward(dir,pathx,pathy,1)
			}
			
		} else {
			//we are going to the side, so determine whether to keep going or go forward again
			dir = turn_if_deviating(max_deviation_distance,pathx,center,dir)
			deviated = turn_if_deviating(max_deviation_distance,pathx,center,dir,1)
			if (deviated || chance(return_chance)) {
				dir = 1
			}
			
			pathx=move_forward(dir,pathx,pathy)
			pathy=move_forward(dir,pathx,pathy,1)
			//if we just started going forward go twice so as to avoid creating a potential 2x2 line
			if (dir == 1) {
				fr.grid[((gridsize-1-pathy)*gridsize)+pathx]=1
				pathx=move_forward(dir,pathx,pathy)
				pathy=move_forward(dir,pathx,pathy,1)
			}
		}
		
		//add our position to the grid
		fr.grid[((gridsize-1-pathy)*gridsize)+pathx]=1
		
	}
	//finally, bring the path back to the door now that we have reached the end
	dir = 1
	while (pathy < gridsize-1) {
		pathx=move_forward(dir,pathx,pathy)
		pathy=move_forward(dir,pathx,pathy,1)
		fr.grid[((gridsize-1-pathy)*gridsize)+pathx]=1
	}
	
	if (pathx != door1_pos) {
		dir=0
		if (door1_pos>pathx) {
			dir=2
		}
		while (pathx != door1_pos) {
			pathx=move_forward(dir,pathx,pathy)
			pathy=move_forward(dir,pathx,pathy,1)
			fr.grid[((gridsize-1-pathy)*gridsize)+pathx]=1
		}
	}
	
	//attempt to create new branches
	let new_y: int
	let temp_y: int
	let new_x: int
	let branch_type: int
	let branch_pos: int
	new_y=-3 //used for counting off// branches will only be considered once every 4 units so as to avoid potentially too many branches
	while (new_y<gridsize-5) {
		new_y=new_y+4
		temp_y=new_y
		new_x=0
		if (chance(branch_chance)) {
			branch_type=-1
			if (chance(cobble_chance)) {
				branch_type=-2
			}
			//create a branch at this spot
			//determine if on left or on right
			branch_pos=2*Rand(0,1)
			//get leftmost or rightmost path in this row
			let leftmost=gridsize
			let rightmost=0
			for (i of range(gridsize + 1)) {
				if (fr.grid[((gridsize-1-new_y)*gridsize)+i]=1) {
					if (i<leftmost) {
						leftmost=i
					}
					if (i>rightmost) {
						rightmost=i
					}
				}
			}
			if (branch_pos == 0) {
				new_x=leftmost-1
			} else {
				new_x=rightmost+1
			}
			//before creating a branch make sure there are no 1's above or below
			if ((temp_y != 0 && fr.grid[((gridsize-1-temp_y+1)*gridsize)+new_x] == 1) || fr.grid[((gridsize-1-temp_y-1)*gridsize)+new_x] == 1) {
				break //break simply to stop creating the branch
			}
			fr.grid[((gridsize-1-temp_y)*gridsize)+new_x]=branch_type //make 4s so you don't confuse your branch for a path// will be changed later
			if (branch_pos == 0) {
				new_x=leftmost-2
			} else {
				new_x=rightmost+2
			}
			fr.grid[((gridsize-1-temp_y)*gridsize)+new_x]=branch_type //branch out twice to avoid creating an unwanted 2x2 path with the real path
			i = 2
			while (i<branch_max_life) {
				i=i+1
				if (chance(branch_die_chance)) {
					break
				}
				if (Rand(0,3) == 0) { //have a higher chance to go up to confuse the player
					if (branch_pos == 0) {
						new_x=new_x-1
					} else {
						new_x=new_x+1
					}
				} else {
					temp_y=temp_y+1
				}
				
				//before creating a branch make sure there are no 1's above or below
				let n=((gridsize - 1 - temp_y + 1)*gridsize)+new_x
				if (n < gridsize-1) { 
					if (temp_y != 0 && fr.grid[n] == 1) {break}
				}
				n=((gridsize - 1 - temp_y - 1)*gridsize)+new_x
				if (n>0) {
					if (fr.grid[n] == 1) {break}
				}
				
				fr.grid[((gridsize-1-temp_y)*gridsize)+new_x]=branch_type //make 4s so you don't confuse your branch for a path// will be changed later
				if (temp_y>=gridsize-2) {break}
			}
		}
	}
	
	//change branches from 4s to 1s (they were 4s so that they didn't accidently create a 2x2 path unintentionally)
	for (i of range(gridsize)) {
		for (j of range(gridsize)) {
			if (fr.grid[(i*gridsize)+j]=-1) {
				fr.grid[(i*gridsize)+j]=1
			} else if (fr.grid[(i*gridsize)+j]=-2) {
				fr.grid[(i*gridsize)+j]=1				
			}
		}
	}
	
	CatchErrors("GenForestGrid")
}

function PlaceForest(fr: Forest,x: float,y: float,z: float,r: Rooms) {
	CatchErrors("Uncaught (PlaceForest)")
	//local variables
	let tx: int,ty: int
	let tile_size: float=12.0
	let tile_type: int
	let tile_entity: int,detail_entity: int
	
	let tempf1: float,tempf2: float,tempf3: float
	let i: int
	
	if (fr.Forest_Pivot != 0) {
		FreeEntity(fr.Forest_Pivot)
		fr.Forest_Pivot=0
	}
	for (i of range(4)) {
		if (fr.TileMesh[i] != 0) {
			FreeEntity(fr.TileMesh[i])
			fr.TileMesh[i]=0
		}
	}
	for (i of range(5)) {
		if (fr.DetailMesh[i] != 0) {
			FreeEntity(fr.DetailMesh[i])
			fr.DetailMesh[i]=0
		}
	}
	for (i of range(10)) {
		if (fr.TileTexture[i] != 0) {
			FreeEntity(fr.TileTexture[i])
			fr.TileTexture[i]=0
		}
	}
	
	fr.Forest_Pivot=CreatePivot()
	PositionEntity (fr.Forest_Pivot,x,y,z,true)
	
	//load assets
	
	let hmap: any[] = new Array(ROOM4)
	let mask: any[] = new Array(ROOM4)
	let GroundTexture = LoadTexture_Strict("GFX/map/forest/forestfloor.jpg")
	let PathTexture = LoadTexture_Strict("GFX/map/forest/forestpath.jpg")
	
	hmap[ROOM1]=LoadImage_Strict("GFX/map/forest/forest1h.png")
	mask[ROOM1]=LoadTexture_Strict("GFX/map/forest/forest1h_mask.png",1+2)
	
	hmap[ROOM2]=LoadImage_Strict("GFX/map/forest/forest2h.png")
	mask[ROOM2]=LoadTexture_Strict("GFX/map/forest/forest2h_mask.png",1+2)
	
	hmap[ROOM2C]=LoadImage_Strict("GFX/map/forest/forest2Ch.png")
	mask[ROOM2C]=LoadTexture_Strict("GFX/map/forest/forest2Ch_mask.png",1+2)
	
	hmap[ROOM3]=LoadImage_Strict("GFX/map/forest/forest3h.png")
	mask[ROOM3]=LoadTexture_Strict("GFX/map/forest/forest3h_mask.png",1+2)
	
	hmap[ROOM4]=LoadImage_Strict("GFX/map/forest/forest4h.png")
	mask[ROOM4]=LoadTexture_Strict("GFX/map/forest/forest4h_mask.png",1+2)
	
	for (i of range(ROOM1, ROOM4 + 1)) {
		fr.TileMesh[i]=load_terrain(hmap[i],0.03,GroundTexture,PathTexture,mask[i])
	}
	
	//detail meshes
	fr.DetailMesh[1]=LoadMesh_Strict("GFX/map/forest/detail/treetest4.b3d")//1.b3d)
	fr.DetailMesh[2]=LoadMesh_Strict("GFX/map/forest/detail/rock.b3d")
	fr.DetailMesh[3]=LoadMesh_Strict("GFX/map/forest/detail/rock2.b3d")
	fr.DetailMesh[4]=LoadMesh_Strict("GFX/map/forest/detail/treetest5.b3d")
	fr.DetailMesh[5]=LoadMesh_Strict("GFX/map/forest/wall.b3d")
	
	for (i of range(ROOM1, ROOM4 + 1)) {
		HideEntity(fr.TileMesh[i])
	}
	for (i of range(1, 6)) {
		HideEntity(fr.DetailMesh[i])
	}
	
	tempf3=MeshWidth(fr.TileMesh[ROOM1])
	tempf1=tile_size/tempf3
	
	for (tx of range(1, gridsize)) {
		for (ty of range(1, gridsize)) {
			if (fr.grid[(ty*gridsize)+tx] == 1) {
				
				tile_type = 0
				if (tx+1<gridsize) {
					tile_type = (fr.grid[(ty*gridsize)+tx+1]>0)
				}
				if (tx-1 >= 0) {
					tile_type = tile_type+(fr.grid[(ty*gridsize)+tx-1]>0)
				}
				
				if (ty+1<gridsize) {
					tile_type = tile_type+(fr.grid[((ty+1)*gridsize)+tx]>0)
				}
				if (ty-1 >= 0) {
					tile_type = tile_type+(fr.grid[((ty-1)*gridsize)+tx]>0)
				}
								
				let angle: int=0
				switch (tile_type) {
					case 1:
						tile_entity = CopyEntity(fr.TileMesh[ROOM1])
						
						if (fr.grid[((ty+1)*gridsize)+tx]>0) {
							angle = 180
						} else if (fr.grid[(ty*gridsize)+tx-1]>0) {
							angle = 270
						} else if (fr.grid[(ty*gridsize)+tx+1]>0) {
							angle = 90
						}
						
						tile_type = ROOM1
					case 2:
						if (fr.grid[((ty-1)*gridsize)+tx]>0 && fr.grid[((ty+1)*gridsize)+tx]>0) {
							tile_entity = CopyEntity(fr.TileMesh[ROOM2])
							tile_type = ROOM2
						} else if (fr.grid[(ty*gridsize)+tx+1]>0 && fr.grid[(ty*gridsize)+tx-1]>0) {
							tile_entity = CopyEntity(fr.TileMesh[ROOM2])
							angle = 90
							tile_type = ROOM2
						} else {
							tile_entity = CopyEntity(fr.TileMesh[ROOM2C])
							if (fr.grid[(ty*gridsize)+tx-1]>0 && fr.grid[((ty+1)*gridsize)+tx]>0) {
								angle = 180
							} else if (fr.grid[(ty*gridsize)+tx+1]>0 && fr.grid[((ty-1)*gridsize)+tx]>0) {
								
							} else if (fr.grid[(ty*gridsize)+tx-1]>0 && fr.grid[((ty-1)*gridsize)+tx]>0) {
								angle = 270
							} else {
								angle = 90
							}
							tile_type = ROOM2C
						}
					case 3:
						tile_entity = CopyEntity(fr.TileMesh[ROOM3])
						
						if (fr.grid[((ty-1)*gridsize)+tx]=0) {
							angle = 180
						} else if (fr.grid[(ty*gridsize)+tx-1] == 0) {
							angle = 90
						} else if (fr.grid[(ty*gridsize)+tx+1] == 0) {
							angle = 270
						}
						
						tile_type = ROOM3
					case 4:
						tile_entity = CopyEntity(fr.TileMesh[ROOM4])	
						tile_type = ROOM4
					default:
						DebugLog("tile_type: "+tile_type)
				}
				
				if (tile_type > 0) {
					
					let itemPlaced: Array = new Array(4)
					//2, 5, 8
					let it: Items = null
					if ((ty % 3) == 2 && itemPlaced[Floor(ty/3)] == False) {
						itemPlaced[Floor(ty/3)]=true
						it.Items = CreateItem("Log #"+Int(Floor(ty/3)+1), "paper", 0,0.5,0)
						EntityType(it.collider, HIT_ITEM)
						EntityParent(it.collider, tile_entity)
					}
					
					//place trees and other details
					//only placed on spots where the value of the heightmap is above 100
					SetBuffer (ImageBuffer(hmap[tile_type]))
					width = ImageWidth(hmap[tile_type])
					tempf4 = (tempf3/Float(width))
					for (lx of range(3, width-1)) {
						for (ly of range(3, width-1)) {
							GetColor (lx,width-ly)
							
							if (ColorRed()>Rand(100,260)) {
								switch (Rand(0,7)) {
									case 0,1,2,3,4,5,6: //create a tree
										detail_entity=CopyEntity(fr.DetailMesh[1])
										//EntityType detail_entity,HIT_MAP
										tempf2=Rnd(0.25,0.4)
										
										for (i of range(4)) {
											d=CopyEntity(fr.DetailMesh[4])
											RotateEntity(d, 0, 90*i+Rnd(-20,20), 0)
											EntityParent(d,detail_entity)
											
											EntityFX(d, 1)
										}
										
										ScaleEntity(detail_entity,tempf2*1.1,tempf2,tempf2*1.1,true)
										PositionEntity(detail_entity,lx*tempf4-(tempf3/2.0),ColorRed()*0.03-Rnd(3.0,3.2),ly*tempf4-(tempf3/2.0),true)
										
										RotateEntity(detail_entity,Rnd(-5,5),Rnd(360.0),0.0,true)
										
									case 7: //add a rock
										detail_entity=CopyEntity(fr.DetailMesh[2])
										tempf2=Rnd(0.01,0.012)
										
										PositionEntity(detail_entity,lx*tempf4-(tempf3/2.0),ColorRed()*0.03-1.3,ly*tempf4-(tempf3/2.0),true)
										
										EntityFX(detail_entity, 1)
										
										RotateEntity(detail_entity,0.0,Rnd(360.0),0.0,true)
									case 6: //add a stump
										detail_entity=CopyEntity(fr.DetailMesh[4])
										tempf2=Rnd(0.1,0.12)
										ScaleEntity(detail_entity,tempf2,tempf2,tempf2,true)
										
										PositionEntity(detail_entity,lx*tempf4-(tempf3/2.0),ColorRed()*0.03-1.3,ly*tempf4-(tempf3/2.0),true)
								}
								
								EntityFX(detail_entity, 1)
								EntityParent(detail_entity,tile_entity)
							}
						}
					}
					SetBuffer(BackBuffer())
					
					TurnEntity(tile_entity, 0, angle, 0)
					
					PositionEntity(tile_entity,x+(tx*tile_size),y,z+(ty*tile_size),true)
					
					ScaleEntity(tile_entity,tempf1,tempf1,tempf1)
					EntityType(tile_entity,HIT_MAP)
					EntityFX(tile_entity,1)
					EntityParent(tile_entity,fr.Forest_Pivot)
					EntityPickMode(tile_entity,2)
					
					if (it != null) {
						EntityParent (it.collider,0)
					}
					
					fr.TileEntities[tx+(ty*gridsize)] = tile_entity
				} else {
					DebugLog("INVALID TILE @ ("+tx+", "+ty+ "): "+tile_type)
				}
			}
		}
	}
	
	//place the wall		
	for (i of range(2)) {
		ty = ((gridsize-1)*i)
		
		for (tx of range(1, gridsize)) {
			if (fr.grid[(ty*gridsize)+tx] == 3) {
				fr.DetailEntities[i]=CopyEntity(fr.DetailMesh[5])
				ScaleEntity(fr.DetailEntities[i],RoomScale,RoomScale,RoomScale)
				
				fr.Door[i] = CopyEntity(r.Objects[3])
				PositionEntity(fr.Door[i],72*RoomScale,32.0*RoomScale,0,true)
				RotateEntity(fr.Door[i], 0,180,0)
				ScaleEntity(fr.Door[i],48*RoomScale,45*RoomScale,48*RoomScale,true)
				EntityParent(fr.Door[i],fr.DetailEntities[i])
				
				frame = CopyEntity(r.Objects[2],fr.Door[i])
				PositionEntity(frame,0,32.0*RoomScale,0,true)
				ScaleEntity(frame,48*RoomScale,45*RoomScale,48*RoomScale,true)
				EntityParent(frame,fr.DetailEntities[i])
				
				EntityType(fr.DetailEntities[i],HIT_MAP)
				EntityPickMode(fr.DetailEntities[i],2)
				
				PositionEntity(fr.DetailEntities[i],x+(tx*tile_size),y,z+(ty*tile_size)+(tile_size/2)-(tile_size*i),true)
				RotateEntity(fr.DetailEntities[i],0,180*i,0)
				
				EntityParent(fr.DetailEntities[i],fr.Forest_Pivot)
			}		
		}		
	}
	
	CatchErrors("PlaceForest")
}

function PlaceForest_MapCreator(fr: Forest,x: float,y: float,z: float,r: Rooms) {
	CatchErrors("Uncaught (PlaceForest_MapCreator)")
	//local variables
	let tx: int,ty: int
	let tile_size: float=12.0
	let tile_type: int
	let tile_entity: int,detail_entity: int
	
	let tempf1: float,tempf2: float,tempf3: float
	let i: int
	
	if (fr.Forest_Pivot != 0) {
		FreeEntity(fr.Forest_Pivot)
		fr.Forest_Pivot=0
	}
	for (i of range(4)) {
		if (fr.TileMesh[i] != 0) {
			FreeEntity(fr.TileMesh[i])
			fr.TileMesh[i]=0
		}
	}
	for (i of range(5)) {
		if (fr.DetailMesh[i] != 0) {
			FreeEntity(fr.DetailMesh[i])
			fr.DetailMesh[i]=0
		}
	}
	for (i of range(10)) {
		if (fr.TileTexture[i] != 0) {
			FreeEntity(fr.TileTexture[i])
			fr.TileTexture[i]=0
		}
	}
	
	fr.Forest_Pivot=CreatePivot()
	PositionEntity (fr.Forest_Pivot,x,y,z,true)
	
	//load assets
	
	let hmap: Array = new Array(ROOM4 + 1)
	let mask: Array = new Array(ROOM4 + 1)
	let GroundTexture = LoadTexture_Strict("GFX/map/forest/forestfloor.jpg")
	let PathTexture = LoadTexture_Strict("GFX/map/forest/forestpath.jpg")
	
	hmap[ROOM1]=LoadImage_Strict("GFX/map/forest/forest1h.png")
	mask[ROOM1]=LoadTexture_Strict("GFX/map/forest/forest1h_mask.png",1+2)
	
	hmap[ROOM2]=LoadImage_Strict("GFX/map/forest/forest2h.png")
	mask[ROOM2]=LoadTexture_Strict("GFX/map/forest/forest2h_mask.png",1+2)
	
	hmap[ROOM2C]=LoadImage_Strict("GFX/map/forest/forest2Ch.png")
	mask[ROOM2C]=LoadTexture_Strict("GFX/map/forest/forest2Ch_mask.png",1+2)
	
	hmap[ROOM3]=LoadImage_Strict("GFX/map/forest/forest3h.png")
	mask[ROOM3]=LoadTexture_Strict("GFX/map/forest/forest3h_mask.png",1+2)
	
	hmap[ROOM4]=LoadImage_Strict("GFX/map/forest/forest4h.png")
	mask[ROOM4]=LoadTexture_Strict("GFX/map/forest/forest4h_mask.png",1+2)
	
	for (i of range(ROOM1, ROOM4 + 1)) {
		fr.TileMesh[i]=load_terrain(hmap[i],0.03,GroundTexture,PathTexture,mask[i])
	}
	
	//detail meshes
	fr.DetailMesh[1]=LoadMesh_Strict("GFX/map/forest/detail/treetest4.b3d")
	fr.DetailMesh[2]=LoadMesh_Strict("GFX/map/forest/detail/rock.b3d")
	fr.DetailMesh[3]=LoadMesh_Strict("GFX/map/forest/detail/rock2.b3d")
	fr.DetailMesh[4]=LoadMesh_Strict("GFX/map/forest/detail/treetest5.b3d")
	fr.DetailMesh[5]=LoadMesh_Strict("GFX/map/forest/wall.b3d")
	
	for (i of range(ROOM1, ROOM4 + 1)) {
		HideEntity(fr.TileMesh[i])
	}
	for (i of range(1, 6)) {
		HideEntity(fr.DetailMesh[i])
	}
	
	tempf3=MeshWidth(fr.TileMesh[ROOM1])
	tempf1=tile_size/tempf3
	
	DebugLog("ForestINIT")
	
	for (tx of range(gridsize)) {
		for (ty of range(gridsize)) {
			if (fr.grid[(ty*gridsize)+tx] > 0) { 
				
				tile_type = 0
				let angle: int=0
				
				tile_type = Ceil(Float(fr.grid[(ty*gridsize)+tx])/4.0)
				if (tile_type == 6) {
					tile_type = 2
				}
				angle = (fr.grid[(ty*gridsize)+tx] % 4)*90
				
				tile_entity = CopyEntity(fr.TileMesh[tile_type])
				
				DebugLog("Tile: "+tile_type+"| Angle: "+angle)
				
				if (tile_type > 0) {
					
					let itemPlaced: Array = new Array(4)
					//2, 5, 8
					let it: Items = null
					if ((ty % 3) == 2 && itemPlaced[Floor(ty/3)] == False) {
						itemPlaced[Floor(ty/3)]=true
						it.Items = CreateItem("Log : float"+Int(Floor(ty/3)+1), "paper", 0,0.5,0)
						EntityType(it.collider, HIT_ITEM)
						EntityParent(it.collider, tile_entity)
					}
					
					//place trees and other details
					//only placed on spots where the value of the heightmap is above 100
					SetBuffer (ImageBuffer(hmap[tile_type]))
					width = ImageWidth(hmap[tile_type])
					tempf4 = (tempf3/Float(width))
					for (lx of range(3, width-1)) {
						for (ly of range(3, width-1)) {
							GetColor (lx,width-ly)
							
							if (ColorRed()>Rand(100,260)) {
								detail_entity = 0
								switch (Rand(0,7)) {
									case 0,1,2,3,4,5,6: //create a tree
										detail_entity=CopyEntity(fr.DetailMesh[1])
										tempf2=Rnd(0.25,0.4)
										
										for (i of range(4)) {
											d=CopyEntity(fr.DetailMesh[4])
											RotateEntity (d, 0, 90*i+Rnd(-20,20), 0)
											EntityParent(d,detail_entity)
											
											EntityFX (d, 1)
										}
										
										ScaleEntity (detail_entity,tempf2*1.1,tempf2,tempf2*1.1,true)
										PositionEntity (detail_entity,lx*tempf4-(tempf3/2.0),ColorRed()*0.03-Rnd(3.0,3.2),ly*tempf4-(tempf3/2.0),true)
										
										RotateEntity (detail_entity,Rnd(-5,5),Rnd(360.0),0.0,true)
										
									case 7: //add a rock
										detail_entity=CopyEntity(fr.DetailMesh[2])
										tempf2=Rnd(0.01,0.012)
										
										PositionEntity (detail_entity,lx*tempf4-(tempf3/2.0),ColorRed()*0.03-1.3,ly*tempf4-(tempf3/2.0),true)
										
										EntityFX (detail_entity, 1)
										
										RotateEntity (detail_entity,0.0,Rnd(360.0),0.0,true)
									case 6: //add a stump
										detail_entity=CopyEntity(fr.DetailMesh[4])
										tempf2=Rnd(0.1,0.12)
										ScaleEntity (detail_entity,tempf2,tempf2,tempf2,true)
										
										PositionEntity (detail_entity,lx*tempf4-(tempf3/2.0),ColorRed()*0.03-1.3,ly*tempf4-(tempf3/2.0),true)
								}
								
								if (detail_entity != 0) {
									EntityFX (detail_entity, 1)
									EntityParent (detail_entity,tile_entity)
								}
							}
						}
					}
					SetBuffer (BackBuffer())
					
					TurnEntity (tile_entity, 0, angle, 0)
					
					PositionEntity (tile_entity,x+(tx*tile_size),y,z+(ty*tile_size),true)
					
					DebugLog ("tile_entity: "+(x+(tx*tile_size))+"|"+(y)+"|"+(z+(ty*tile_size)))
					
					ScaleEntity(tile_entity,tempf1,tempf1,tempf1)
					EntityType(tile_entity,HIT_MAP)
					EntityFX(tile_entity,1)
					EntityParent(tile_entity,fr.Forest_Pivot)
					EntityPickMode(tile_entity,2)
					
					if (it != null) {
						EntityParent(it.collider,0)
					}
					
					fr.TileEntities[tx+(ty*gridsize)] = tile_entity
				} else {
					DebugLog("INVALID TILE @ ("+tx+", "+ty+ "): "+tile_type)
				}
				
				if (Ceil(fr.grid[(ty*gridsize)+tx]/4.0) == 6) {
					for (i of range(2)) {
						if (fr.Door[i] == 0) {
							fr.DetailEntities[i]=CopyEntity(fr.DetailMesh[5])
							ScaleEntity(fr.DetailEntities[i],RoomScale,RoomScale,RoomScale)
							
							fr.Door[i] = CopyEntity(r.Objects[3])
							PositionEntity(fr.Door[i],72*RoomScale,32.0*RoomScale,0,true)
							RotateEntity(fr.Door[i], 0,180,0)
							ScaleEntity(fr.Door[i],48*RoomScale,45*RoomScale,48*RoomScale,true)
							EntityParent(fr.Door[i],fr.DetailEntities[i])
							
							let frame = CopyEntity(r.Objects[2],fr.Door[i])
							PositionEntity(frame,0,32.0*RoomScale,0,true)
							ScaleEntity(frame,48*RoomScale,45*RoomScale,48*RoomScale,true)
							EntityParent(frame,fr.DetailEntities[i])
							
							EntityType(fr.DetailEntities[i],HIT_MAP)
							EntityPickMode(fr.DetailEntities[i],2)
							
							PositionEntity(fr.DetailEntities[i],x+(tx*tile_size),y,z+(ty*tile_size),true)
							RotateEntity(fr.DetailEntities[i],0,angle+180,0)
							MoveEntity(fr.DetailEntities[i],0,0,-6)
							
							EntityParent(fr.DetailEntities[i],fr.Forest_Pivot)
							break
						}
					}
				}
			} else {
				DebugLog("NO TILE FOUND @ ("+tx+", "+ty+ ")")
			}
		}
	}
	
	DebugLog("ForestINIT END")
	
	CatchErrors("PlaceForest_MapCreator")
}

function DestroyForest(fr: Forest) {
	CatchErrors("Uncaught (DestroyForest)")
	let tx: int
	let ty: int
	for (tx of range(gridsize)) {
		for (ty of range(gridsize)) {
			if (fr.TileEntities[tx+(ty*gridsize)] != 0) {
				FreeEntity(fr.TileEntities[tx+(ty*gridsize)])
				fr.TileEntities[tx+(ty*gridsize)] = 0
				fr.grid[tx+(ty*gridsize)] = 0
			}
		}
	}
	if (fr.Door[0] != 0) {
		FreeEntity(fr.Door[0])
		fr.Door[0] = 0
	}
	if (fr.Door[1] != 0) {
		FreeEntity(fr.Door[1])
		fr.Door[0] = 1
	}
	if (fr.DetailEntities[0] != 0) {
		FreeEntity(fr.DetailEntities[0])
		fr.DetailEntities[0] = 0
	}
	if (fr.DetailEntities[1] != 0) {
		FreeEntity(fr.DetailEntities[1])
		fr.DetailEntities[1] = 0
	}
	
	if (fr.Forest_Pivot != 0) {
		FreeEntity(fr.Forest_Pivot)
		fr.Forest_Pivot=0
	}
	for (let i of range(4)) {
		if (fr.TileMesh[i] != 0) {
			FreeEntity(fr.TileMesh[i])
			fr.TileMesh[i]=0
		}
	}
	for (let i of range(5)) {
		if (fr.DetailMesh[i] != 0) {
			FreeEntity(fr.DetailMesh[i])
			fr.DetailMesh[i]=0
		}
	}
	for (let i of range(10)) {
		if (fr.TileTexture[i] != 0) {
			FreeEntity(fr.TileTexture[i])
			fr.TileTexture[i]=0
		}
	}
	
	CatchErrors("DestroyForest")
}


function UpdateForest(fr: Forest,ent: int) {
	CatchErrors("Uncaught (UpdateForest)")
	//local variables
	let tx: int
	let ty: int
	if (Abs(EntityY(ent,true)-EntityY(fr.Forest_Pivot,true))<12.0) {
		for (tx of range(gridsize)) {
			for (ty of range(gridsize)) {
				if (fr.TileEntities[tx+(ty*gridsize)] != 0) {
					if (Abs(EntityX(ent,true)-EntityX(fr.TileEntities[tx+(ty*gridsize)],true))<20.0) {
						if (Abs(EntityZ(ent,true)-EntityZ(fr.TileEntities[tx+(ty*gridsize)],true))<20.0) {
							ShowEntity(fr.TileEntities[tx+(ty*gridsize)])
						} else {
							HideEntity(fr.TileEntities[tx+(ty*gridsize)])
						}
					} else {
						HideEntity(fr.TileEntities[tx+(ty*gridsize)])
					}
				}
			}
		}
	}
	CatchErrors("UpdateForest")
}

export const MaxRoomLights: int = 32
export const MaxRoomEmitters: int = 8
export const MaxRoomObjects: int = 30


export const ROOM1: int = 1
export const ROOM2: int = 2
export const ROOM2C: int = 3
export const ROOM3: int = 4
export const ROOM4: int = 5

export var RoomTempID: int
export class RoomTemplates {
	static each: RoomTemplates[] = []
	obj: int
	id: int
	objPath: string
	
	zone: int[] = new Array(5)
		
	TempSoundEmitter: int[] = new Array(MaxRoomEmitters)
	TempSoundEmitterX: float[] = new Array(MaxRoomEmitters)
	TempSoundEmitterY: float[] = new Array(MaxRoomEmitters)
	TempSoundEmitterZ: float[] = new Array(MaxRoomEmitters)
	TempSoundEmitterRange: float[] = new Array(MaxRoomEmitters)
	
	Shape: int
	Name: string
	Commonness: int
	Large: int
	DisableDecals: int
	
	TempTriggerboxAmount
	TempTriggerbox: any[] = new Array(128)
	TempTriggerboxName: string[] = new Array(128)
	
	UseLightCones: int
	
	DisableOverlapCheck: boolean = true
	
	MinX: float
	MinY: float
	MinZ: float
	MaxX: float
	MaxY: float
	MaxZ: float
} 	

function CreateRoomTemplate(meshpath: string) : RoomTemplates {
	let rt: RoomTemplates = new RoomTemplates()
	
	rt.objPath = meshpath
	
	rt.id = RoomTempID
	RoomTempID=RoomTempID+1
	
	return rt
}

function LoadRoomTemplates(file: string) {
	CatchErrors("Uncaught (LoadRoomTemplates)")
	let TemporaryString: string
	let i: int
	let rt: RoomTemplates
	let StrTemp: string = ""
	
	let f = OpenFile(file)
	
	while (!Eof(f)) {
		TemporaryString = Trim(ReadLine(f))
		if (Left(TemporaryString,1) == "[") {
			TemporaryString = Mid(TemporaryString, 2, Len(TemporaryString) - 2)
			StrTemp = GetINIString(file, TemporaryString, "mesh path")
			
			rt = CreateRoomTemplate(StrTemp)
			rt.Name = Lower(TemporaryString)
			
			StrTemp = Lower(GetINIString(file, TemporaryString, "shape"))
			
			switch (StrTemp) {
				case "room1", "1":
					rt.Shape = ROOM1
				case "room2", "2":
					rt.Shape = ROOM2
				case "room2c", "2c":
					rt.Shape = ROOM2C
				case "room3", "3":
					rt.Shape = ROOM3
				case "room4", "4":
					rt.Shape = ROOM4
			}
			
			for (i of range(5)) {
				rt.zone[i]= GetINIInt(file, TemporaryString, "zone"+(i+1))
			}
			
			rt.Commonness = Max(Min(GetINIInt(file, TemporaryString, "commonness"), 100), 0)
			rt.Large = GetINIInt(file, TemporaryString, "large")
			rt.DisableDecals = GetINIInt(file, TemporaryString, "disabledecals")
			rt.UseLightCones = GetINIInt(file, TemporaryString, "usevolumelighting")
			rt.DisableOverlapCheck = GetINIInt(file, TemporaryString, "disableoverlapcheck")
		}
	}
	
	i = 1
	while (true) {
		StrTemp = GetINIString(file, "room ambience", "ambience"+i)
		if (StrTemp == "") {
			break
		}
		
		RoomAmbience[i]=LoadSound_Strict(StrTemp)
		i=i+1
	}
	
	CloseFile (f)
	
	CatchErrors("LoadRoomTemplates")
}


function LoadRoomMesh(rt: RoomTemplates) {
	
	if (Instr(rt.objPath,".rmesh") != 0) { //file is roommesh
		rt.obj = LoadRMesh(rt.objPath, rt)
	} else { //file is b3d
		if (rt.objPath != "") {
			rt.obj = LoadWorld(rt.objPath, rt)
		} else {
			rt.obj = CreatePivot()
		}
	}
	
	if (!rt.obj) {
		RuntimeError("Failed to load map file "+Chr(34)+mapfile+Chr(34)+".")
	}
	
	CalculateRoomTemplateExtents(rt)
	
	HideEntity(rt.obj)
	
}

function LoadRoomMeshes() {
	let temp: int = 0
	for (let rt of RoomTemplates.each) {
		temp=temp+1
	}
	
	let i = 0
	for (let rt of RoomTemplates.each) {
		if (Instr(rt.objpath,".rmesh") != 0) { //file is roommesh
			rt.obj = LoadRMesh(rt.objPath, rt)
		} else { //file is b3d
			if (rt.objpath != "") {
				rt.obj = LoadWorld(rt.objPath, rt)
			} else {
				rt.obj = CreatePivot()
			}
		}
		if (!rt.obj) {
			RuntimeError("Failed to load map file "+Chr(34)+mapfile+Chr(34)+".")
		}
		
		HideEntity(rt.obj)
		DrawLoading(Int(30 + (15.0 / temp)*i))
		i=i+1
	}
}


LoadRoomTemplates("Data/rooms.ini")

export var RoomScale: float = 8.0 / 2048.0
export const ZONEAMOUNT = 3
export var MapWidth: int = GetINIInt("options.ini", "options", "map size")
export var MapHeight: int = GetINIInt("options.ini", "options", "map size")
export var MapTemp: int[] = new Array(MapWidth+1, MapHeight+1)
export var MapFound: int[] = new Array(MapWidth+1, MapHeight+1)

export var RoomAmbience: int[] = new Array(20)

export var Sky

export var HideDistance: float = 15.0

export var SecondaryLightOn: boolean = true
export var PrevSecondaryLightOn: boolean = true
export var RemoteDoorOn: boolean = true
export var Contained106: boolean = false

export class Rooms {
	static each: Rooms[] = []
	zone: int
	found: int
	obj: int
	x: float
	y: float
	z: float
	angle: int
	RoomTemplate: RoomTemplates
	
	dist: float
	
	SoundCHN: int
	
	dp: DrawPortal
	fr: Forest
	
	SoundEmitter: int[] = new Array(MaxRoomEmitters)
	SoundEmitterObj: int[] = new Array(MaxRoomEmitters)
	SoundEmitterRange: float[] = new Array(MaxRoomEmitters)
	SoundEmitterCHN: int[] = new Array(MaxRoomEmitters)
	
	Lights: int[] = new Array(MaxRoomLights)
	LightIntensity: float[] = new Array(MaxRoomLights)
	
	LightSprites: int[] = new Array(MaxRoomLights)	
	
	Objects: int[] = new Array(MaxRoomObjects)
	Levers: int[] = new Array(11)
	RoomDoors: Doors[] = new Array(7)
	NPC: NPCs[] = new Array(12)
	grid: Grids
	
	Adjacent: Rooms[] = new Array(4)
	AdjDoor: Doors[] = new Array(4)
	
	NonFreeAble: int[] = new Array(10)
	Textures: int[] = new Array(10)
	
	MaxLights: int = 0
	LightSpriteHidden: int[] = new Array(MaxRoomLights)
	LightSpritesPivot: int[] = new Array(MaxRoomLights)
	LightSprites2: int[] = new Array(MaxRoomLights)
	LightHidden: int[] = new Array(MaxRoomLights)
	LightFlicker: int[] = new Array(MaxRoomLights)
	AlarmRotor: int[] = new Array(1)
	AlarmRotorLight: int[] = new Array(1)
	TriggerboxAmount
	Triggerbox: any[] = new Array(128)
	TriggerboxName: string[] = new Array(128)
	MaxWayPointY: float
	LightR: float[] = new Array(MaxRoomLights)
	LightG: float[] = new Array(MaxRoomLights)
	LightB: float[] = new Array(MaxRoomLights)
	LightCone: int[] = new Array(MaxRoomLights)
	LightConeSpark: int[] = new Array(MaxRoomLights)
	LightConeSparkTimer: float[] = new Array(MaxRoomLights)
	
	MinX: float
	MinY: float
	MinZ: float
	MaxX: float
	MaxY: float
	MaxZ: float
} 

const gridsz: int=19 //Same size as the main map itself (better for the map creator)
class Grids {
	grid: int[] = new Array(gridsz*gridsz)
	angles: int[] = new Array(gridsz*gridsz)
	Meshes: int[] = new Array(7)
	Entities: int[] = new Array(gridsz*gridsz)
	waypoints: WayPoints[] = new Array(gridsz*gridsz)
}

function UpdateGrid(grid: Grids) {
	//local variables
	let tx: int,ty: int
	for (tx of range(gridsz)) {
		for (ty of range(gridsz)) {
			if (grid.Entities[tx+(ty*gridsz)] != 0) {
				if (Abs(EntityY(Collider,true)-EntityY(grid.Entities[tx+(ty*gridsz)],true))>4.0) {Exit()}
				if (Abs(EntityX(Collider,true)-EntityX(grid.Entities[tx+(ty*gridsz)],true))<HideDistance) {
					if (Abs(EntityZ(Collider,true)-EntityZ(grid.Entities[tx+(ty*gridsz)],true))<HideDistance) {
						ShowEntity(grid.Entities[tx+(ty*gridsz)])
					} else {
						HideEntity(grid.Entities[tx+(ty*gridsz)])
					}
				} else {
					HideEntity(grid.Entities[tx+(ty*gridsz)])
				}
			}
		}
	}
}

function PlaceGrid_MapCreator(r: Rooms) {
	let x,y,i
	let Meshes: any[] = new Array(6)
	let dr: Doors
	let it: Items
	
	for (i of range(7)) {
		Meshes[i]=CopyEntity(OBJTunnel(i))
		DebugLog (i)
		HideEntity (Meshes[i])
	}
	
	for (y of range(gridsz)) {
		for (x of range(gridsz)) {
			if (r.grid.grid[x+(y*gridsz)]>0) {
				let tile_type = 0
				let angle: int=0
				
				tile_type = r.grid.grid[x+(y*gridsz)]
				angle = r.grid.angles[x+(y*gridsz)]*90.0
				
				let tile_entity = CopyEntity(Meshes[tile_type-1])
				RotateEntity(tile_entity,0,angle,0)
				ScaleEntity(tile_entity,RoomScale,RoomScale,RoomScale,true)
				PositionEntit(tile_entity,r.x+x*2.0,8.0,r.z+y*2.0,true)
				
				switch (r.grid.grid[x+(y*gridsz)]) {
					case ROOM1:
						AddLight(null, r.x+x*2.0, 8.0+(368.0*RoomScale), r.z+y*2.0, 2, 500.0 * RoomScale, 255, 255, 255)
					case ROOM2,ROOM2C:
						AddLight(null, r.x+x*2.0, 8.0+(368.0*RoomScale), r.z+y*2.0, 2, 500.0 * RoomScale, 255, 255, 255)
					case ROOM2C:
						AddLight(null, r.x+x*2.0, 8.0+(412.0*RoomScale), r.z+y*2.0, 2, 500.0 * RoomScale, 255, 255, 255)
					case ROOM3,ROOM4:
						AddLight(null,r.x+x*2.0, 8.0+(412.0*RoomScale), r.z+y*2.0, 2, 500.0 * RoomScale, 255, 255, 255)
					case ROOM4+1:
						dr=CreateDoor(r.zone,r.x+(x*2.0)+(Cos(EntityYaw(tile_entity,true))*240.0*RoomScale),8.0,r.z+(y*2.0)+(Sin(EntityYaw(tile_entity,true))*240.0*RoomScale),EntityYaw(tile_entity,true)+90.0,null,False,3,False,"")
						PositionEntity(dr.buttons[0],EntityX(dr.buttons[0],true)+(Cos(EntityYaw(tile_entity,true))*0.05),EntityY(dr.buttons[0],true)+0.0,EntityZ(dr.buttons[0],true)+(Sin(EntityYaw(tile_entity,true))*0.05),true)
						
						AddLight(null, r.x+x*2.0+(Cos(EntityYaw(tile_entity,true))*555.0*RoomScale), 8.0+(469.0*RoomScale), r.z+y*2.0+(Sin(EntityYaw(tile_entity,true))*555.0*RoomScale), 2, 600.0 * RoomScale, 255, 255, 255)
						
						let tempInt2=CreatePivot()
						RotateEntity (tempInt2,0,EntityYaw(tile_entity,true)+180.0,0,true)
						PositionEntity (tempInt2,r.x+(x*2.0)+(Cos(EntityYaw(tile_entity,true))*552.0*RoomScale),8.0+(240.0*RoomScale),r.z+(y*2.0)+(Sin(EntityYaw(tile_entity,true))*552.0*RoomScale))
						if (r.RoomDoors[1] == null) {
							r.RoomDoors[1]=dr
							r.Objects[3]=tempInt2
							PositionEntity (r.Objects[0],r.x+x*2.0,8.0,r.z+y*2.0,true)
							DebugLog ("Created door 1 successfully!")
						} else if (r.RoomDoors[1] != null && r.RoomDoors[3] == null) {
							r.RoomDoors[3]=dr
							r.Objects[5]=tempInt2
							PositionEntity (r.Objects[1],r.x+x*2.0,8.0,r.z+y*2.0,true)
							DebugLog ("Created door 2 successfully!")
						}
					case ROOM4+2:
						AddLight(null, r.x+x*2.0-(Sin(EntityYaw(tile_entity,true))*504.0*RoomScale)+(Cos(EntityYaw(tile_entity,true))*16.0*RoomScale), 8.0+(396.0*RoomScale), r.z+y*2.0+(Cos(EntityYaw(tile_entity,true))*504.0*RoomScale)+(Sin(EntityYaw(tile_entity,true))*16.0*RoomScale), 2, 500.0 * RoomScale, 255, 200, 200)
						it = CreateItem("SCP-500-01","scp500",r.x+x*2.0+(Cos(EntityYaw(tile_entity,true))*(-208.0)*RoomScale)-(Sin(EntityYaw(tile_entity,true))*1226.0*RoomScale),8.0+(80.0*RoomScale),r.z+y*2.0+(Sin(EntityYaw(tile_entity,true))*(-208.0)*RoomScale)+(Cos(EntityYaw(tile_entity,true))*1226.0*RoomScale))
						EntityType (it.collider, HIT_ITEM)
						
						it = CreateItem("Night Vision Goggles", "nvgoggles",r.x+x*2.0-(Sin(EntityYaw(tile_entity,true))*504.0*RoomScale)+(Cos(EntityYaw(tile_entity,true))*16.0*RoomScale), 8.0+(80.0*RoomScale), r.z+y*2.0+(Cos(EntityYaw(tile_entity,true))*504.0*RoomScale)+(Sin(EntityYaw(tile_entity,true))*16.0*RoomScale))
						EntityType (it.collider, HIT_ITEM)
				}
				
				r.grid.Entities[x+(y*gridsz)]=tile_entity
				wayp.WayPoints = CreateWaypoint(r.x+(x*2.0),8.2,r.z+(y*2.0),null,r)
				r.grid.waypoints[x+(y*gridsz)]=wayp
				
				if (y<gridsz-1) {
					if (r.grid.waypoints[x+((y+1)*gridsz)] != null) {
						dist=EntityDistance(r.grid.waypoints[x+(y*gridsz)].obj,r.grid.waypoints[x+((y+1)*gridsz)].obj)
						for (i of range(4)) {
							if (r.grid.waypoints[x+(y*gridsz)].connected[i]=r.grid.waypoints[x+((y+1)*gridsz)]) {
								break
							} else if (r.grid.waypoints[x+(y*gridsz)].connected[i]=null) {
								r.grid.waypoints[x+(y*gridsz)].connected[i]=r.grid.waypoints[x+((y+1)*gridsz)]
								r.grid.waypoints[x+(y*gridsz)].dist[i]=dist
								break
							}
						}
						for (i of range(4)) {
							if (r.grid.waypoints[x+((y+1)*gridsz)].connected[i]=r.grid.waypoints[x+(y*gridsz)]) {
								break
							} else if (r.grid.waypoints[x+((y+1)*gridsz)].connected[i]=null) {
								r.grid.waypoints[x+((y+1)*gridsz)].connected[i]=r.grid.waypoints[x+(y*gridsz)]
								r.grid.waypoints[x+((y+1)*gridsz)].dist[i]=dist
								break
							}
						}
					}
				}
				if (y>0) {
					if (r.grid.waypoints[x+((y-1)*gridsz)] != null) {
						dist=EntityDistance(r.grid.waypoints[x+(y*gridsz)].obj,r.grid.waypoints[x+((y-1)*gridsz)].obj)
						for (i of range(4)) {
							if (r.grid.waypoints[x+(y*gridsz)].connected[i]=r.grid.waypoints[x+((y-1)*gridsz)]) {
								break
							} else if (r.grid.waypoints[x+(y*gridsz)].connected[i]=null) {
								r.grid.waypoints[x+(y*gridsz)].connected[i]=r.grid.waypoints[x+((y-1)*gridsz)]
								r.grid.waypoints[x+(y*gridsz)].dist[i]=dist
								break
							}
						}
						for (i of range(4)) {
							if (r.grid.waypoints[x+((y-1)*gridsz)].connected[i]=r.grid.waypoints[x+(y*gridsz)]) {
								break
							} else if (r.grid.waypoints[x+(y*gridsz)].connected[i]=null) {
								r.grid.waypoints[x+((y-1)*gridsz)].connected[i]=r.grid.waypoints[x+(y*gridsz)]
								r.grid.waypoints[x+((y-1)*gridsz)].dist[i]=dist
								break
							}
						}
					}
				}
				if (x>0) {
					if (r.grid.waypoints[x-1+(y*gridsz)] != null) {
						dist=EntityDistance(r.grid.waypoints[x+(y*gridsz)].obj,r.grid.waypoints[x-1+(y*gridsz)].obj)
						for (i of range(4)) {
							if (r.grid.waypoints[x+(y*gridsz)].connected[i]=r.grid.waypoints[x-1+(y*gridsz)]) {
								break
							} else if (r.grid.waypoints[x+(y*gridsz)].connected[i]=null) {
								r.grid.waypoints[x+(y*gridsz)].connected[i]=r.grid.waypoints[x-1+(y*gridsz)]
								r.grid.waypoints[x+(y*gridsz)].dist[i]=dist
								break
							}
						}
						for (i of range(4)) {
							if (r.grid.waypoints[x-1+(y*gridsz)].connected[i]=r.grid.waypoints[x+(y*gridsz)]) {
								break
							} else if (r.grid.waypoints[x+(y*gridsz)].connected[i]=null) {
								r.grid.waypoints[x-1+(y*gridsz)].connected[i]=r.grid.waypoints[x+(y*gridsz)]
								r.grid.waypoints[x-1+(y*gridsz)].dist[i]=dist
								break
							}
						}
					}
				}
				if (x<gridsz-1) {
					if (r.grid.waypoints[x+1+(y*gridsz)] != null) {
						dist=EntityDistance(r.grid.waypoints[x+(y*gridsz)].obj,r.grid.waypoints[x+1+(y*gridsz)].obj)
						for (i of range(4)) {
							if (r.grid.waypoints[x+(y*gridsz)].connected[i]=r.grid.waypoints[x+1+(y*gridsz)]) {
								break
							} else if (r.grid.waypoints[x+(y*gridsz)].connected[i]=null) {
								r.grid.waypoints[x+(y*gridsz)].connected[i]=r.grid.waypoints[x+1+(y*gridsz)]
								r.grid.waypoints[x+(y*gridsz)].dist[i]=dist
								break
							}
						}
						for (i of range(4)) {
							if (r.grid.waypoints[x+1+(y*gridsz)].connected[i]=r.grid.waypoints[x+(y*gridsz)]) {
								break
						 	} else if (r.grid.waypoints[x+(y*gridsz)].connected[i]=null) {
								r.grid.waypoints[x+1+(y*gridsz)].connected[i]=r.grid.waypoints[x+(y*gridsz)]
								r.grid.waypoints[x+1+(y*gridsz)].dist[i]=dist
								break
							}
						}
					}
				}
			}
		}
	}
	
	for (i of range(7)) {
		r.grid.Meshes[i]=Meshes[i]
	}
	
}

function CreateRoom(zone: int, roomshape: int, x: float, y: float, z: float, name: string = "") : Rooms {
	CatchErrors("Uncaught (CreateRoom)")
	let r: Rooms = new Rooms()
	let rt: RoomTemplates
	
	r.zone = zone
	
	r.x = x
	r.y = y
	r.z = z
	
	if (name != "") {
		name = Lower(name)
		for (rt of RoomTemplates.each) {
			if (rt.Name == name) {
				r.RoomTemplate = rt
				
				if (rt.obj == 0) {
					LoadRoomMesh(rt)
				}
				
				r.obj = CopyEntity(rt.obj)
				ScaleEntity(r.obj, RoomScale, RoomScale, RoomScale)
				EntityType(r.obj, HIT_MAP)
				EntityPickMode(r.obj, 2)
				
				PositionEntity(r.obj, x, y, z)
				FillRoom(r)
				
				if (r.RoomTemplate.UseLightCones) {
					AddLightCones(r)
				}
				
				CalculateRoomExtents(r)
				return r
			}
		}
	}
	
	let temp: int = 0
	for (rt of RoomTemplates.each) {
		for (i of range(5)) {
			if (rt.zone[i]=zone) { 
				if (rt.Shape = roomshape) {
					temp=temp+rt.Commonness
					break
				}
			}
		}	
	}
	
	let RandomRoom: int = Rand(temp)
	temp = 0
	for (rt of RoomTemplates.each) {
		for (i of range(5)) {
			if (rt.zone[i] == zone && rt.Shape == roomshape) {
				temp=temp+rt.Commonness
				if (RandomRoom > temp - rt.Commonness && RandomRoom <= temp) {
					r.RoomTemplate = rt
					
					if (rt.obj == 0) {
						LoadRoomMesh(rt)
					}
					
					r.obj = CopyEntity(rt.obj)
					ScaleEntity(r.obj, RoomScale, RoomScale, RoomScale)
					EntityType(r.obj, HIT_MAP)
					EntityPickMode(r.obj, 2)
					
					PositionEntity(r.obj, x, y, z)
					FillRoom(r)
					
					if (r.RoomTemplate.UseLightCones) {
						AddLightCones(r)
					}
					
					CalculateRoomExtents(r)
					return r	
				}
			}
		}
	}
	
	CatchErrors("CreateRoom")
}

function FillRoom(r: Rooms) {
	CatchErrors("Uncaught (FillRoom)")
	let d: Doors
	let d2: Doors
	let sc: SecurityCams
	let de: Decals
	let r2: Rooms
	let sc2: SecurityCams
	let it: Items
	let i: int
	let xtemp: int
	let ytemp: int
	let ztemp: int
	
	let t1
	
	switch (r.RoomTemplate.Name) {
		case "room860":
			//[Block]
			//the wooden door
			r.Objects[2] = LoadMesh_Strict("GFX/map/forest/door_frame.b3d")
			PositionEntity(r.Objects[2],r.x + 184.0 * RoomScale,0,r.z,true)
			ScaleEntity(r.Objects[2],45.0*RoomScale,45.0*RoomScale,80.0*RoomScale,true)
			EntityParent(r.Objects[2],r.obj)
			
			r.Objects[3] =  LoadMesh_Strict("GFX/map/forest/door.b3d")
			PositionEntity(r.Objects[3],r.x + 112.0 * RoomScale,0,r.z+0.05,true)
			EntityType(r.Objects[3], HIT_MAP)
			
			ScaleEntity(r.Objects[3],46.0*RoomScale,45.0*RoomScale,46.0*RoomScale,true)
			EntityParent(r.Objects[3],r.obj)
			
			r.Objects[4] = CopyEntity(r.Objects[3])
			PositionEntity(r.Objects[4],r.x + 256.0 * RoomScale,0,r.z-0.05,true)
			RotateEntity(r.Objects[4], 0,180,0)
			ScaleEntity(r.Objects[4],46.0*RoomScale,45.0*RoomScale,46.0*RoomScale,true)
			EntityParent(r.Objects[4],r.obj)
			
			//doors to observation booth
			d = CreateDoor(r.zone, r.x + 928.0 * RoomScale,0,r.z + 640.0 * RoomScale,0,r,False,False,False,"ABCD")
			d = CreateDoor(r.zone, r.x + 928.0 * RoomScale,0,r.z - 640.0 * RoomScale,0,r,true,False,False,"ABCD")
			d.AutoClose = False
			
			//doors to the room itself
			d = CreateDoor(r.zone, r.x+416.0*RoomScale,0,r.z - 640.0 * RoomScale,0,r,False,False,1)
			d = CreateDoor(r.zone, r.x+416.0*RoomScale,0,r.z + 640.0 * RoomScale,0,r,False,False,1)
			
			//the forest
			if (I_Zone.HasCustomForest = False) {
				let fr: Forest = new Forest()
				r.fr=fr
				GenForestGrid(fr)
				PlaceForest(fr,r.x,r.y+30.0,r.z,r)
			}
			
						
			it = CreateItem("Document SCP-860-1", "paper", r.x + 672.0 * RoomScale, r.y + 176.0 * RoomScale, r.z + 335.0 * RoomScale)
			RotateEntity(it.collider, 0, r.angle+10, 0)
			EntityParent(it.collider, r.obj)
			
			it = CreateItem("Document SCP-860", "paper", r.x + 1152.0 * RoomScale, r.y + 176.0 * RoomScale, r.z - 384.0 * RoomScale)
			RotateEntity(it.collider, 0, r.angle+170, 0)
			EntityParent(it.collider, r.obj)
			//[End Block]
		case "lockroom":
			//[Block]
			d = CreateDoor(r.zone, r.x - 736.0 * RoomScale, 0, r.z - 104.0 * RoomScale, 0, r, true)
			d.timer = 70 * 5
			d.AutoClose = False
			d.open = False
			
			EntityParent(d.buttons[0], 0)
			PositionEntity(d.buttons[0], r.x - 288.0 * RoomScale, 0.7, r.z - 640.0 * RoomScale)
			EntityParent(d.buttons[0], r.obj)
			
			FreeEntity(d.buttons[1])
			d.buttons[1] = 0
			
			d2 = CreateDoor(r.zone, r.x + 104.0 * RoomScale, 0, r.z + 736.0 * RoomScale, 270, r, true)
			d2.timer = 70 * 5
			d2.AutoClose = False
			d2.open = False
			EntityParent(d2.buttons[0], 0)
			PositionEntity(d2.buttons[0], r.x + 640.0 * RoomScale, 0.7, r.z + 288.0 * RoomScale)
			RotateEntity (d2.buttons[0], 0, 90, 0)
			EntityParent(d2.buttons[0], r.obj)
			
			FreeEntity(d2.buttons[1])
			d2.buttons[1] = 0
			
			d.LinkedDoor = d2
			d2.LinkedDoor = d
			
			sc.SecurityCams = CreateSecurityCam(r.x - 688.0 * RoomScale, r.y + 384 * RoomScale, r.z + 688.0 * RoomScale, r, true)
			sc.angle = 45 + 180
			sc.turn = 45
			sc.ScrTexture = 1
			EntityTexture(sc.ScrObj, ScreenTexs[sc.ScrTexture])
			
			TurnEntity(sc.CameraObj, 40, 0, 0)
			EntityParent(sc.obj, r.obj)
			
			PositionEntity(sc.ScrObj, r.x + 668 * RoomScale, 1.1, r.z - 96.0 * RoomScale)
			TurnEntity(sc.ScrObj, 0, 90, 0)
			EntityParent(sc.ScrObj, r.obj)
			
			sc.SecurityCams = CreateSecurityCam(r.x - 112.0 * RoomScale, r.y + 384 * RoomScale, r.z + 112.0 * RoomScale, r, true)
			sc.angle = 45
			sc.turn = 45
			sc.ScrTexture = 1
			EntityTexture(sc.ScrObj, ScreenTexs[sc.ScrTexture])
			
			TurnEntity(sc.CameraObj, 40, 0, 0)
			EntityParent(sc.obj, r.obj)				
			
			PositionEntity(sc.ScrObj, r.x + 96.0 * RoomScale, 1.1, r.z - 668.0 * RoomScale)
			EntityParent(sc.ScrObj, r.obj)
			
			let em: Emitters = CreateEmitter(r.x - 175.0 * RoomScale, 370.0 * RoomScale, r.z + 656.0 * RoomScale, 0)
			TurnEntity(em.Obj, 90, 0, 0, true)
			EntityParent(em.Obj, r.obj)
			em.RandAngle = 20
			em.Speed = 0.05
			em.SizeChange = 0.007
			em.Achange = -0.006
			em.Gravity = -0.24
			
			em.Emitters = CreateEmitter(r.x - 655.0 * RoomScale, 370.0 * RoomScale, r.z + 240.0 * RoomScale, 0)
			TurnEntity(em.Obj, 90, 0, 0, true)
			EntityParent(em.Obj, r.obj)
			em.RandAngle = 20
			em.Speed = 0.05
			em.SizeChange = 0.007
			em.Achange = -0.006
			em.Gravity = -0.24
			
			//This needs more work
		case "lockroom2":
			//[Block]
			for (i of range(6)) {
				de.Decals = CreateDecal(Rand(2,3), r.x+Rnd(-392,520)*RoomScale, 3.0*RoomScale+Rnd(0,0.001), r.z+Rnd(-392,520)*RoomScale,90,Rnd(360),0)
				de.Size = Rnd(0.3,0.6)
				ScaleSprite(de.obj, de.Size,de.Size)
				CreateDecal(Rand(15,16), r.x+Rnd(-392,520)*RoomScale, 3.0*RoomScale+Rnd(0,0.001), r.z+Rnd(-392,520)*RoomScale,90,Rnd(360),0)
				de.Size = Rnd(0.1,0.6)
				ScaleSprite(de.obj, de.Size,de.Size)
				CreateDecal(Rand(15,16), r.x+Rnd(-0.5,0.5), 3.0*RoomScale+Rnd(0,0.001), r.z+Rnd(-0.5,0.5),90,Rnd(360),0)
				de.Size = Rnd(0.1,0.6)
				ScaleSprite(de.obj, de.Size,de.Size)
			}
			
			sc.SecurityCams = CreateSecurityCam(r.x + 512.0 * RoomScale, r.y + 384 * RoomScale, r.z + 384.0 * RoomScale, r, true)
			sc.angle = 45 + 90
			sc.turn = 45
			TurnEntity(sc.CameraObj, 40, 0, 0)
			EntityParent(sc.obj, r.obj)
			
			PositionEntity(sc.ScrObj, r.x + 668 * RoomScale, 1.1, r.z - 96.0 * RoomScale)
			TurnEntity(sc.ScrObj, 0, 90, 0)
			EntityParent(sc.ScrObj, r.obj)
			
			sc.SecurityCams = CreateSecurityCam(r.x - 384.0 * RoomScale, r.y + 384 * RoomScale, r.z - 512.0 * RoomScale, r, true)
			sc.angle = 45 + 90 + 180
			sc.turn = 45
			
			TurnEntity(sc.CameraObj, 40, 0, 0)
			EntityParent(sc.obj, r.obj)				
			
			PositionEntity(sc.ScrObj, r.x + 96.0 * RoomScale, 1.1, r.z - 668.0 * RoomScale)
			EntityParent(sc.ScrObj, r.obj)
			//[End Block]
		case "gatea":
			//[Block]
			r.RoomDoors[2] = CreateDoor(r.zone, r.x - 4064.0 * RoomScale, r.y-1280.0*RoomScale, r.z + 3952.0 * RoomScale, 0, r, False)
			r.RoomDoors[2].AutoClose = False
			r.RoomDoors[2].open = False
			
			d2 = CreateDoor(r.zone, r.x, r.y, r.z - 1024.0 * RoomScale, 0, r, False)
			d2.AutoClose = False
			d2.open = False
			d2.locked = true
			
			d2 = CreateDoor(r.zone, r.x-1440*RoomScale, r.y-480.0*RoomScale, r.z + 2328.0 * RoomScale, 0, r, False, False, 2)
			if (SelectedEnding == "A2") {
				d2.AutoClose = False
				d2.open = true
				d2.locked = true	
			} else {
				d2.AutoClose = False
				d2.open = False
				d2.locked = False	
			}	
			PositionEntity(d2.buttons[0], r.x-1320.0*RoomScale, EntityY(d2.buttons[0],true), r.z + 2288.0*RoomScale, true)
			PositionEntity(d2.buttons[1], r.x-1584*RoomScale, EntityY(d2.buttons[0],true), r.z + 2488.0*RoomScale, true	)
			RotateEntity (d2.buttons[1], 0, 90, 0, true)
			
			d2 = CreateDoor(r.zone, r.x-1440*RoomScale, r.y-480.0*RoomScale, r.z + 4352.0 * RoomScale, 0, r, False, False, 2)
			if (SelectedEnding == "A2") {
				d2.AutoClose = False
				d2.open = true
				d2.locked = true	
			} else {
				d2.AutoClose = False
				d2.open = False
				d2.locked = False
			}
			PositionEntity (d2.buttons[0], r.x-1320.0*RoomScale, EntityY(d2.buttons[0],true), r.z + 4384.0*RoomScale, true)
			RotateEntity (d2.buttons[0], 0, 180, 0, true	)
			PositionEntity (d2.buttons[1], r.x-1584.0*RoomScale, EntityY(d2.buttons[0],true), r.z + 4232.0*RoomScale, true	)
			RotateEntity( d2.buttons[1], 0, 90, 0, true	)
			
			for (r2 of Rooms.each) {
				if (r2.RoomTemplate.Name = "exit1") {
					r.Objects[1]=r2.Objects[1]
					r.Objects[2]=r2.Objects[2]	
				} else if (r2.RoomTemplate.Name = "gateaentrance") {
					//ylempi hissi
					r.RoomDoors[1] = CreateDoor(0, r.x+1544.0*RoomScale, r.y, r.z-64.0*RoomScale, 90, r, False, 3)
					r.RoomDoors[1].AutoClose = False
					r.RoomDoors[1].open = False
					PositionEntity(r.RoomDoors[1].buttons[0],r.x+1584*RoomScale, EntityY(r.RoomDoors[1].buttons[0],true), r.z+80*RoomScale, true)
					PositionEntity(r.RoomDoors[1].buttons[1],r.x+1456*RoomScale, EntityY(r.RoomDoors[1].buttons[1],true), r.z-208*RoomScale, true)	
					r2.Objects[1] = CreatePivot()
					PositionEntity(r2.Objects[1], r.x+1848.0*RoomScale, r.y+240.0*RoomScale, r.z-64.0*RoomScale, true)
					EntityParent (r2.Objects[1], r.obj)
				}
			}
			
			//106:n spawnpoint
			r.Objects[3]=CreatePivot()
			PositionEntity(r.Objects[3], r.x+1216.0*RoomScale, r.y, r.z+2112.0*RoomScale, true)
			EntityParent(r.Objects[3], r.obj)
			
			//sillan loppup
			r.Objects[4]=CreatePivot()
			PositionEntity(r.Objects[4], r.x, r.y+96.0*RoomScale, r.z+6400.0*RoomScale, true)
			EntityParent(r.Objects[4], r.obj)
			
			//vartiotorni 1
			r.Objects[5]=CreatePivot()
			PositionEntity(r.Objects[5], r.x+1784.0*RoomScale, r.y+2124.0*RoomScale, r.z+4512.0*RoomScale, true)
			EntityParent(r.Objects[5], r.obj)
			
			//vartiotorni 2
			r.Objects[6]=CreatePivot()
			PositionEntity(r.Objects[6], r.x-5048.0*RoomScale, r.y+1912.0*RoomScale, r.z+4656.0*RoomScale, true)
			EntityParent(r.Objects[6], r.obj)
			
			//sillan takareuna
			r.Objects[7]=CreatePivot()
			PositionEntity(r.Objects[7], r.x+1824.0*RoomScale, r.y+224.0*RoomScale, r.z+7056.0*RoomScale, true)
			EntityParent(r.Objects[7], r.obj)
			
			//sillan takareuna2
			r.Objects[8]=CreatePivot()
			PositionEntity(r.Objects[8], r.x-1824.0*RoomScale, r.y+224.0*RoomScale, r.z+7056.0*RoomScale, true)
			EntityParent(r.Objects[8], r.obj)
			
			//"valopyssy"
			r.Objects[9]=CreatePivot()
			PositionEntity(r.Objects[9], r.x+2624.0*RoomScale, r.y+992.0*RoomScale, r.z+6157.0*RoomScale, true)
			EntityParent(r.Objects[9], r.obj)
			//objects[10] = valopyssyn ylosa
			
			//tunnelin loppu
			r.Objects[11]=CreatePivot()
			PositionEntity(r.Objects[11], r.x-4064.0*RoomScale, r.y-1248.0*RoomScale, r.z-1696.0*RoomScale, true)
			EntityParent(r.Objects[11], r.obj)
			
			r.Objects[13]=LoadMesh_Strict("GFX/map/gateawall1.b3d",r.obj)
			PositionEntity(r.Objects[13], r.x-4308.0*RoomScale, r.y-1045.0*RoomScale, r.z+544.0*RoomScale, true)
			EntityColor(r.Objects[13], 25,25,25)
			EntityType(r.Objects[13],HIT_MAP)
			
			r.Objects[14]=LoadMesh_Strict("GFX/map/gateawall2.b3d",r.obj)
			PositionEntity(r.Objects[14], r.x-3820.0*RoomScale, r.y-1045.0*RoomScale, r.z+544.0*RoomScale, true)	
			EntityColor(r.Objects[14], 25,25,25)
			EntityType(r.Objects[14],HIT_MAP)
			
			r.Objects[15]=CreatePivot(r.obj)
			PositionEntity(r.Objects[15], r.x-3568.0*RoomScale, r.y-1089.0*RoomScale, r.z+4944.0*RoomScale, true)
			
			r.Objects[16] = LoadMesh_Strict("GFX/map/gatea_hitbox1.b3d",r.obj)
			EntityPickMode(r.Objects[16],2)
			EntityType(r.Objects[16],HIT_MAP)
			EntityAlpha(r.Objects[16],0.0)
			
			//[End Block]
		case "gateaentrance":
			//[Block]
			//alempi hissi
			r.RoomDoors[0] = CreateDoor(0, r.x+744.0*RoomScale, 0, r.z+512.0*RoomScale, 90, r, true, 3)
			r.RoomDoors[0].AutoClose = False
			r.RoomDoors[0].open = true
			PositionEntity(r.RoomDoors[0].buttons[1],r.x+688*RoomScale, EntityY(r.RoomDoors[0].buttons[1],true), r.z+368*RoomScale, true)
			PositionEntity(r.RoomDoors[0].buttons[0],r.x+784*RoomScale, EntityY(r.RoomDoors[0].buttons[0],true), r.z+656*RoomScale, true)
			r.Objects[0] = CreatePivot()
			PositionEntity(r.Objects[0], r.x+1048.0*RoomScale, 0, r.z+512.0*RoomScale, true)
			EntityParent(r.Objects[0], r.obj)
			
			r.RoomDoors[1] = CreateDoor(r.zone, r.x, 0, r.z - 360.0 * RoomScale, 0, r, False, true, 5)
			r.RoomDoors[1].dir = 1
			r.RoomDoors[1].AutoClose = False
			r.RoomDoors[1].open = False
			PositionEntity(r.RoomDoors[1].buttons[1], r.x+416*RoomScale, EntityY(r.RoomDoors[0].buttons[1],true), r.z-576*RoomScale, true)
			RotateEntity(r.RoomDoors[1].buttons[1],0,r.angle-90,0,true)
			PositionEntity(r.RoomDoors[1].buttons[0], r.x, 20.0, r.z, true)
			
			//[End Block]
		case "exit1":
			//[Block]
			r.Objects[0] = CreatePivot(r.obj)
			PositionEntity(r.Objects[0], r.x+4356.0*RoomScale, 9767.0*RoomScale, r.z+2588.0*RoomScale, true)
			
			r.RoomDoors[4] = CreateDoor(r.zone, r.x, 0, r.z - 320.0 * RoomScale, 0, r, False, true, 5)
			r.RoomDoors[4].dir = 1
			r.RoomDoors[4].AutoClose = False
			r.RoomDoors[4].open = False
			PositionEntity(r.RoomDoors[4].buttons[1], r.x+352*RoomScale, 0.7, r.z-528*RoomScale, true)
			RotateEntity(r.RoomDoors[4].buttons[1],0,r.angle-90,0,true)
			PositionEntity(r.RoomDoors[4].buttons[0], r.x, 7.0, r.z, true)		
			
			//kytvn takaosa
			r.Objects[3] = CreatePivot()
			PositionEntity(r.Objects[3], r.x-7680.0*RoomScale, 10992.0*RoomScale, r.z-27048.0*RoomScale, true)
			EntityParent(r.Objects[3], r.obj)
			
			//oikean puolen watchpoint 1
			r.Objects[4] = CreatePivot()
			PositionEntity(r.Objects[4], r.x+5203.36*RoomScale, 12128.0*RoomScale, r.z-1739.19*RoomScale, true)
			EntityParent(r.Objects[4], r.obj)
			//oikean puolen watchpoint 2
			r.Objects[5] = CreatePivot()
			PositionEntity(r.Objects[5], r.x+4363.02*RoomScale, 10536.0*RoomScale, r.z+2766.16*RoomScale, true)
			EntityParent(r.Objects[5], r.obj)
			//vasemman puolen watchpoint 1
			r.Objects[6] = CreatePivot()
			PositionEntity(r.Objects[6], r.x+5192.0*RoomScale, 12192.0*RoomScale, r.z-1760.0*RoomScale, True)
			EntityParent(r.Objects[6], r.obj)
			//vasemman puolen watchpoint 2
			r.Objects[7] = CreatePivot()
			PositionEntity(r.Objects[7], r.x+5192.0*RoomScale, 12192.0*RoomScale, r.z-4352.0*RoomScale, True)
			EntityParent(r.Objects[7], r.obj)
			
			//alempi hissi
			r.RoomDoors[0] = CreateDoor(0, r.x+720.0*RoomScale, 0, r.z+1432.0*RoomScale, 0, r, True, 3)
			r.RoomDoors[0].AutoClose = False
			r.RoomDoors[0].open = True
			MoveEntity(r.RoomDoors[0].buttons[0],0,0,22.0*RoomScale)
			MoveEntity(r.RoomDoors[0].buttons[1],0,0,22.0*RoomScale	)
			r.Objects[8] = CreatePivot()
			PositionEntity(r.Objects[8], r.x+720.0*RoomScale, 0, r.z+1744.0*RoomScale, True)
			EntityParent(r.Objects[8], r.obj)
			
			//ylempi hissi
			r.RoomDoors[1] = CreateDoor(0, r.x-5424.0*RoomScale, 10784.0*RoomScale, r.z-1380.0*RoomScale, 0, r, False, 3)
			r.RoomDoors[1].AutoClose = False
			r.RoomDoors[1].open = False
			MoveEntity(r.RoomDoors[1].buttons[0],0,0,22.0*RoomScale)
			MoveEntity(r.RoomDoors[1].buttons[1],0,0,22.0*RoomScale)
			r.Objects[9] = CreatePivot()
			PositionEntity(r.Objects[9], r.x-5424.0*RoomScale, 10784.0*RoomScale, r.z-1068.0*RoomScale, True)
			EntityParent(r.Objects[9], r.obj)
			
			r.RoomDoors[2] = CreateDoor(0, r.x+4352.0*RoomScale, 10784.0*RoomScale, r.z-492.0*RoomScale, 0, r, False)
			r.RoomDoors[2].AutoClose = False
			r.RoomDoors[2].open = False	
			
			r.RoomDoors[3] = CreateDoor(0, r.x+4352.0*RoomScale, 10784.0*RoomScale, r.z+500.0*RoomScale, 0, r, False)
			r.RoomDoors[3].AutoClose = False
			r.RoomDoors[3].open = False	
			
			//walkway
			r.Objects[10] = CreatePivot()
			PositionEntity(r.Objects[10], r.x+4352.0*RoomScale, 10778.0*RoomScale, r.z+1344.0*RoomScale, True)
			EntityParent(r.Objects[10], r.obj	)
			
			//"682"
			r.Objects[11] = CreatePivot()
			PositionEntity(r.Objects[11], r.x+2816.0*RoomScale, 11024.0*RoomScale, r.z-2816.0*RoomScale, True)
			EntityParent(r.Objects[11], r.obj)
						
			//"valvomon" takaovi
			r.RoomDoors[5] = CreateDoor(0, r.x+3248.0*RoomScale, 9856.0*RoomScale, r.z+6400.0*RoomScale, 0, r, False, False, 0, "ABCD")
			r.RoomDoors[5].AutoClose = False
			r.RoomDoors[5].open = False		
			
			//"valvomon" etuovi
			d.Doors = CreateDoor(0, r.x+3072.0*RoomScale, 9856.0*RoomScale, r.z+5800.0*RoomScale, 90, r, False, False, 3)
			d.AutoClose = False
			d.open = False
			
			r.Objects[14] = CreatePivot()
			PositionEntity(r.Objects[14], r.x+3536.0*RoomScale, 10256.0*RoomScale, r.z+5512.0*RoomScale, True)
			EntityParent(r.Objects[14], r.obj)
			r.Objects[15] = CreatePivot()
			PositionEntity(r.Objects[15], r.x+3536.0*RoomScale, 10256.0*RoomScale, r.z+5824.0*RoomScale, True)
			EntityParent(r.Objects[15], r.obj)
			r.Objects[16] = CreatePivot()
			PositionEntity(r.Objects[16], r.x+3856.0*RoomScale, 10256.0*RoomScale, r.z+5512.0*RoomScale, True)
			EntityParent(r.Objects[16], r.obj)
			r.Objects[17] = CreatePivot()
			PositionEntity(r.Objects[17], r.x+3856.0*RoomScale, 10256.0*RoomScale, r.z+5824.0*RoomScale, True)
			EntityParent(r.Objects[17], r.obj)
			
			//MTF:n spawnpoint
			r.Objects[18] = CreatePivot()
			//PositionEntity(r.Objects[18], r.x+3727.0*RoomScale, 10066.0*RoomScale, r.z+6623.0*RoomScale, True)
			PositionEntity(r.Objects[18], r.x+3250.0*RoomScale, 9896.0*RoomScale, r.z+6623.0*RoomScale, True)
			EntityParent(r.Objects[18], r.obj)
			
			//piste johon helikopterit pakenee nukea
			r.Objects[19] = CreatePivot()
			PositionEntity(r.Objects[19], r.x+3808.0*RoomScale, 12320.0*RoomScale, r.z-13568.0*RoomScale, True)
			EntityParent(r.Objects[19], r.obj)
			
			//[End Block]
		case "roompj":
			//[Block]
			it = CreateItem("Document SCP-372", "paper", r.x + 800.0 * RoomScale, r.y + 176.0 * RoomScale, r.z + 1108.0 * RoomScale)
			RotateEntity(it.collider, 0, r.angle, 0)
			EntityParent(it.collider, r.obj)
			
			it = CreateItem("Radio Transceiver", "radio", r.x + 800.0 * RoomScale, r.y + 112.0 * RoomScale, r.z + 944.0 * RoomScale)
			it.state = 80.0
			EntityParent(it.collider, r.obj)
			
			r.Objects[3] = LoadMesh_Strict("GFX/map/372_hb.b3d",r.obj)
			EntityPickMode(r.Objects[3],2)
			EntityType(r.Objects[3],HIT_MAP)
			EntityAlpha(r.Objects[3],0.0)
			
			d = CreateDoor(r.zone,r.x,r.y,r.z-368.0*RoomScale,0,r,True,True,2)
			d.AutoClose = False
			PositionEntity (d.buttons[0], r.x - 496.0 * RoomScale, 0.7, r.z - 272.0 * RoomScale, True)
			TurnEntity(d.buttons[0], 0, 90, 0)
			//[End Block]
		case "room079":
			//[Block]
			d = CreateDoor(r.zone, r.x, -448.0*RoomScale, r.z + 1136.0 * RoomScale, 0, r, False,True, 4)
			d.dir = 1
			d.AutoClose = False
			d.open = False
			PositionEntity(d.buttons[1], r.x + 224.0 * RoomScale, -250*RoomScale, r.z + 918.0 * RoomScale, True)
			PositionEntity(d.buttons[0], r.x - 240.0 * RoomScale, -250*RoomScale, r.z + 1366.0 * RoomScale, True)
			
			r.RoomDoors[0] = CreateDoor(r.zone, r.x + 1456.0*RoomScale, -448.0*RoomScale, r.z + 976.0 * RoomScale, 0, r, False, True, 3)
			r.RoomDoors[0].dir = 1
			r.RoomDoors[0].AutoClose = False
			r.RoomDoors[0].open = False
			PositionEntity(r.RoomDoors[0].buttons[1], r.x + 1760.0 * RoomScale, -250*RoomScale, r.z + 1236.0 * RoomScale, True)
			TurnEntity(r.RoomDoors[0].buttons[0],0,-90-90,0,True)
			PositionEntity(r.RoomDoors[0].buttons[0], r.x + 1760.0 * RoomScale, -240*RoomScale, r.z + 740.0 * RoomScale, True)
			TurnEntity(r.RoomDoors[0].buttons[1],0, 90-90,0,True)
			
			CreateDoor(0, r.x + 1144.0*RoomScale, -448.0*RoomScale, r.z + 704.0 * RoomScale, 90, r, False, False, -1)
			
			r.Objects[0] = LoadAnimMesh_Strict("GFX/map/079.b3d")
			ScaleEntity(r.Objects[0], 1.3, 1.3, 1.3, True)
			PositionEntity (r.Objects[0], r.x + 1856.0*RoomScale, -560.0*RoomScale, r.z-672.0*RoomScale, True)
			EntityParent(r.Objects[0], r.obj)
			TurnEntity(r.Objects[0],0,180,0,True)
			
			r.Objects[1] = CreateSprite(r.Objects[0])
			SpriteViewMode(r.Objects[1],2)
			PositionEntity(r.Objects[1], 0.082, 0.119, 0.010)
			ScaleSprite(r.Objects[1],0.18*0.5,0.145*0.5)
			TurnEntity(r.Objects[1],0,13.0,0)
			MoveEntity(r.Objects[1], 0,0,-0.022)
			EntityTexture (r.Objects[1],OldAiPics(0))
			
			HideEntity(r.Objects[1])
			
			r.Objects[2] = CreatePivot(r.obj)
			PositionEntity (r.Objects[2], r.x + 1184.0*RoomScale, -448.0*RoomScale, r.z+1792.0*RoomScale, True)
			
			de.Decals = CreateDecal(3,  r.x + 1184.0*RoomScale, -448.0*RoomScale+0.01, r.z+1792.0*RoomScale,90,Rnd(360),0)
			de.Size = 0.5
			ScaleSprite(de.obj, de.Size,de.Size)
			EntityParent(de.obj, r.obj)
			//[End Block]
		case "checkpoint1":
			//[Block]
			r.RoomDoors[0] = CreateDoor(0, r.x + 48.0*RoomScale, 0, r.z - 128.0 * RoomScale, 0, r, False, False, 3)
			PositionEntity(r.RoomDoors[0].buttons[0], r.x - 152.0 * RoomScale, EntityY(r.RoomDoors[0].buttons[0],True), r.z - 352.0 * RoomScale, True)
			PositionEntity(r.RoomDoors[0].buttons[1], r.x - 152.0 * RoomScale, EntityY(r.RoomDoors[0].buttons[1],True), r.z + 96.0 * RoomScale, True)
			
			r.RoomDoors[1] = CreateDoor(0, r.x - 352.0*RoomScale, 0, r.z - 128.0 * RoomScale, 0, r, False, False, 3)
			
			r.RoomDoors[1].LinkedDoor = r.RoomDoors[0]
			r.RoomDoors[0].LinkedDoor = r.RoomDoors[1]
			
			r.Objects[0] = CreatePivot(r.obj)
			PositionEntity (r.Objects[0], r.x + 720.0*RoomScale, 120.0*RoomScale, r.z+333.0*RoomScale, True)
			
			r.RoomDoors[0].timer = 70 * 5
			r.RoomDoors[1].timer = 70 * 5
			
			sc.SecurityCams = CreateSecurityCam(r.x+192.0*RoomScale, r.y+704.0*RoomScale, r.z-960.0*RoomScale, r)
			sc.angle = 45
			sc.turn = 0
			TurnEntity(sc.CameraObj, 20, 0, 0)
			
			r.Objects[2] = CopyEntity(Monitor2,r.obj)
			ScaleEntity(r.Objects[2], 2.0, 2.0, 2.0)
			PositionEntity (r.Objects[2], r.x - 152.0*RoomScale, 384.0*RoomScale, r.z+124.0*RoomScale, True)
			RotateEntity (r.Objects[2],0,180,0)
			EntityFX(r.Objects[2],1)
			
			r.Objects[3] = CopyEntity(Monitor2,r.obj)
			ScaleEntity(r.Objects[3], 2.0, 2.0, 2.0)
			PositionEntity (r.Objects[3], r.x - 152.0*RoomScale, 384.0*RoomScale, r.z-380.0*RoomScale, True)
			RotateEntity (r.Objects[3],0,0,0)
			EntityFX(r.Objects[3],1)
			
			if (MapTemp(Floor(r.x / 8.0),Floor(r.z /8.0)-1) == 0) {
				CreateDoor(r.zone, r.x, 0, r.z  - 4.0, 0, r, 0, False, 0, "GEAR")
			}
			//[End Block]
		case "checkpoint2":
			//[Block]
			r.RoomDoors[0]= CreateDoor(0, r.x - 48.0*RoomScale, 0, r.z + 128.0 * RoomScale, 0, r, False, False, 5)
			PositionEntity(r.RoomDoors[0].buttons[0], r.x + 152.0 * RoomScale, EntityY(r.RoomDoors[0].buttons[0],True), r.z - 96.0 * RoomScale, True)			
			PositionEntity(r.RoomDoors[0].buttons[1], r.x + 152.0 * RoomScale, EntityY(r.RoomDoors[0].buttons[1],True), r.z + 352.0 * RoomScale, True)
			
			r.RoomDoors[1] = CreateDoor(0, r.x + 352.0*RoomScale, 0, r.z + 128.0 * RoomScale, 0, r, False, False, 5)
			
			r.RoomDoors[1].LinkedDoor = r.RoomDoors[0]
			r.RoomDoors[0].LinkedDoor = r.RoomDoors[1]
			
			r.Objects[0] = CreatePivot(r.obj)
			PositionEntity (r.Objects[0], r.x - 720.0*RoomScale, 120.0*RoomScale, r.z+464.0*RoomScale, True)
			
			r.Objects[2] = CopyEntity(Monitor3,r.obj)
			ScaleEntity(r.Objects[2], 2.0, 2.0, 2.0)
			PositionEntity (r.Objects[2], r.x + 152.0*RoomScale, 384.0*RoomScale, r.z+380.0*RoomScale, True)
			RotateEntity (r.Objects[2],0,180,0)
			EntityFX(r.Objects[2],1)
			
			r.Objects[3] = CopyEntity(Monitor3,r.obj)
			ScaleEntity(r.Objects[3], 2.0, 2.0, 2.0)
			PositionEntity (r.Objects[3], r.x + 152.0*RoomScale, 384.0*RoomScale, r.z-124.0*RoomScale, True)
			RotateEntity (r.Objects[3],0,0,0)
			EntityFX(r.Objects[3],1)
			
			r.RoomDoors[0].timer = 70 * 5
			r.RoomDoors[1].timer = 70 * 5
			
			if (MapTemp(Floor(r.x / 8.0),Floor(r.z /8.0)-1) == 0) {
				CreateDoor(r.zone, r.x, 0, r.z  - 4.0, 0, r, 0, False, 0, "GEAR")
			}
			//[End Block]
		case "room2pit":
			//[Block]
			i = 0
			for (xtemp of range(-1, 2, 2)) {
				for (ztemp of range(-1, 2)) {
					em.Emitters = CreateEmitter(r.x + 202.0 * RoomScale * xtemp, 8.0 * RoomScale, r.z + 256.0 * RoomScale * ztemp, 0)
					em.RandAngle = 30
					em.Speed = 0.0045
					em.SizeChange = 0.007
					em.Achange = -0.016
					r.Objects[i] = em.Obj
					if (i < 3) { 
						TurnEntity(em.Obj, 0, -90, 0, True) 
					} else { 
						TurnEntity(em.Obj, 0, 90, 0, True)
					}
					TurnEntity(em.Obj, -45, 0, 0, True)
					EntityParent(em.Obj, r.obj)
					i=i+1
				}
			}
			
			r.Objects[6] = CreatePivot()
			PositionEntity(r.Objects[6], r.x + 640.0 * RoomScale, 8.0 * RoomScale, r.z - 896.0 * RoomScale)
			EntityParent(r.Objects[6], r.obj)
			
			r.Objects[7] = CreatePivot()
			PositionEntity(r.Objects[7], r.x - 864.0 * RoomScale, -400.0 * RoomScale, r.z - 632.0 * RoomScale)
			EntityParent(r.Objects[7],r.obj)
			//[End Block]
		case "room2testroom2":
			//[Block]
			r.Objects[0] = CreatePivot()
			PositionEntity(r.Objects[0], r.x - 640.0 * RoomScale, 0.5, r.z - 912.0 * RoomScale)
			EntityParent(r.Objects[0], r.obj)
			
			r.Objects[1] = CreatePivot()
			PositionEntity(r.Objects[1], r.x - 669.0 * RoomScale, 0.5, r.z - 16.0 * RoomScale) //r.x - 632
			EntityParent(r.Objects[1], r.obj)
			
			let Glasstex = LoadTexture_Strict("GFX/map/glass.png",1+2)
			r.Objects[2] = CreateSprite()
			EntityTexture(r.Objects[2],Glasstex)
			SpriteViewMode(r.Objects[2],2)
			ScaleSprite(r.Objects[2],182.0*RoomScale*0.5, 192.0*RoomScale*0.5)
			PositionEntity(r.Objects[2], r.x - 632.0 * RoomScale, 224.0*RoomScale, r.z - 208.0 * RoomScale)
			TurnEntity(r.Objects[2],0,180,0)			
			EntityParent(r.Objects[2], r.obj)
			HideEntity (r.Objects[2])
			
			FreeTexture (Glasstex)
			
			r.RoomDoors[0] = CreateDoor(r.zone, r.x - 240.0 * RoomScale, 0.0, r.z + 640.0 * RoomScale, 90, r, False, False, 1)
			r.RoomDoors[0].AutoClose = False
			r.RoomDoors[0].open = False
			
			d = CreateDoor(r.zone, r.x - 512.0 * RoomScale, 0.0, r.z + 384.0 * RoomScale, 0, r, False, False)
			d.AutoClose = False
			d.open = False					
						
			it = CreateItem("Level 2 Key Card", "key2", r.x - 914.0 * RoomScale, r.y + 137.0 * RoomScale, r.z + 61.0 * RoomScale)
			EntityParent(it.collider, r.obj)
			
			it = CreateItem("S-NAV 300 Navigator", "nav", r.x - 312.0 * RoomScale, r.y + 264.0 * RoomScale, r.z + 176.0 * RoomScale)
			it.state = 20
			EntityParent(it.collider, r.obj)
			//[End Block]
		case "room3tunnel":
			//[Block]
			
			r.Objects[0] = CreatePivot(r.obj)
			PositionEntity (r.Objects[0], r.x - 190.0*RoomScale, 4.0*RoomScale, r.z+190.0*RoomScale, True)
			
			//[End Block]
		case "room2toilets":
			//[Block]
			r.Objects[0] = CreatePivot()
			PositionEntity(r.Objects[0], r.x + 1040.0 * RoomScale, 192.0 * RoomScale, r.z)
			EntityParent(r.Objects[0], r.obj)
			
			r.Objects[1] = CreatePivot()
			PositionEntity(r.Objects[1], r.x + 1530.0*RoomScale, 0.5, r.z+512.0*RoomScale)
			EntityParent(r.Objects[1], r.obj)
			
			r.Objects[2] = CreatePivot()
			PositionEntity(r.Objects[2], r.x + 1535.0*RoomScale, r.y+150.0*RoomScale, r.z+512.0*RoomScale)
			EntityParent(r.Objects[2], r.obj)
			//[End Block]
		case "room2storage":
			//[Block]
			r.RoomDoors[0] = CreateDoor(r.zone, r.x - 1288.0 * RoomScale, 0, r.z, 270, r)
			r.RoomDoors[1] = CreateDoor(r.zone, r.x - 760.0 * RoomScale, 0, r.z, 270, r)
			r.RoomDoors[2] = CreateDoor(r.zone, r.x - 264.0 * RoomScale, 0, r.z, 270, r)
			r.RoomDoors[3] = CreateDoor(r.zone, r.x + 264.0 * RoomScale, 0, r.z, 270, r)
			r.RoomDoors[4] = CreateDoor(r.zone, r.x + 760.0 * RoomScale, 0, r.z, 270, r)
			r.RoomDoors[5] = CreateDoor(r.zone, r.x + 1288.0 * RoomScale, 0, r.z, 270, r)
			
			for (i of range(6)) {
				MoveEntity(r.RoomDoors[i].buttons[0], 0,0,-8.0)
				MoveEntity(r.RoomDoors[i].buttons[1], 0,0,-8.0)
				r.RoomDoors[i].AutoClose = False
				r.RoomDoors[i].open = False				
			}
			
			it = CreateItem("Document SCP-939", "paper", r.x + 352.0 * RoomScale, r.y + 176.0 * RoomScale, r.z + 256.0 * RoomScale)
			RotateEntity(it.collider, 0, r.angle+4, 0)
			EntityParent(it.collider, r.obj)
			
			it = CreateItem("9V Battery", "bat", r.x + 352.0 * RoomScale, r.y + 112.0 * RoomScale, r.z + 448.0 * RoomScale)
			EntityParent(it.collider, r.obj)
			
			it = CreateItem("Empty Cup", "emptycup", r.x-672*RoomScale, 240*RoomScale, r.z+288.0*RoomScale)
			EntityParent(it.collider, r.obj)
			
			it = CreateItem("Level 1 Key Card", "key1", r.x - 672.0 * RoomScale, r.y + 240.0 * RoomScale, r.z + 224.0 * RoomScale)
			EntityParent(it.collider, r.obj)
			//[End Block]
		case "room2sroom":
			//[Block]
			d = CreateDoor(r.zone, r.x + 1440.0 * RoomScale, 224.0 * RoomScale, r.z + 32.0 * RoomScale, 90, r, False, False, 4)
			d.AutoClose = False
			d.open = False
			
			it = CreateItem("Some SCP-420-J", "420", r.x + 1776.0 * RoomScale, r.y + 400.0 * RoomScale, r.z + 427.0 * RoomScale)
			EntityParent(it.collider, r.obj)
			
			it = CreateItem("Some SCP-420-J", "420", r.x + 1808.0 * RoomScale, r.y + 400.0 * RoomScale, r.z + 435.0 * RoomScale)
			EntityParent(it.collider, r.obj)
			
			it = CreateItem("Level 5 Key Card", "key5", r.x + 2232.0 * RoomScale, r.y + 392.0 * RoomScale, r.z + 387.0 * RoomScale)
			RotateEntity(it.collider, 0, r.angle, 0, True)
			EntityParent(it.collider, r.obj)
			
			it = CreateItem("Nuclear Device Document", "paper", r.x + 2248.0 * RoomScale, r.y + 440.0 * RoomScale, r.z + 372.0 * RoomScale)
			EntityParent(it.collider, r.obj)
			
			it = CreateItem("Radio Transceiver", "radio", r.x + 2240.0 * RoomScale, r.y + 320.0 * RoomScale, r.z + 128.0 * RoomScale)
			EntityParent(it.collider, r.obj)
			//[End Block]
		case "room2shaft":
			//[Block]
			d = CreateDoor(r.zone, r.x + 1552.0 * RoomScale, r.y, r.z + 552.0 * RoomScale, 0, r, False, False)
			PositionEntity(d.buttons[0], EntityX(d.buttons[0],True), EntityY(d.buttons[0],True), r.z + 518.0 * RoomScale, True)
			PositionEntity(d.buttons[1], EntityX(d.buttons[1],True), EntityY(d.buttons[1],True), r.z + 575.0 * RoomScale, True)
			d.AutoClose = False
			d.open = False
			
			d = CreateDoor(r.zone, r.x + 256.0 * RoomScale, r.y, r.z + 744.0 * RoomScale, 90, r, False, False, 2)
			d.AutoClose = False
			d.open = False
			
			it = CreateItem("Level 3 Key Card", "key3", r.x + 1119.0 * RoomScale, r.y + 233.0 * RoomScale, r.z + 494.0 * RoomScale)
			EntityParent(it.collider, r.obj)
			
			it = CreateItem("First Aid Kit", "firstaid", r.x + 1035.0 * RoomScale, r.y + 145.0 * RoomScale, r.z + 56.0 * RoomScale)
			EntityParent(it.collider, r.obj)
			RotateEntity(it.collider, 0, 90, 0)
			
			it = CreateItem("9V Battery", "bat", r.x + 1930.0 * RoomScale, r.y + 97.0 * RoomScale, r.z + 256.0 * RoomScale)
			EntityParent(it.collider, r.obj)
			it = CreateItem("9V Battery", "bat", r.x + 1061.0 * RoomScale, r.y + 161.0 * RoomScale, r.z + 494.0 * RoomScale)
			EntityParent(it.collider, r.obj)
			
			it = CreateItem("ReVision Eyedrops", "eyedrops", r.x + 1930.0*RoomScale, r.y + 225.0 * RoomScale, r.z + 128.0*RoomScale)
			EntityParent(it.collider, r.obj)
			
			//Player's position after leaving the pocket dimension
			r.Objects[0] = CreatePivot(r.obj)
			PositionEntity(r.Objects[0],r.x+1560.0*RoomScale,r.y,r.z+250.0*RoomScale,True)
			
			r.Objects[1] = CreatePivot(r.obj)
            PositionEntity(r.Objects[1],r.x + 1344.0 * RoomScale, -752.0 * RoomScale,r.z - 384.0 * RoomScale,True)
            
            de.Decals = CreateDecal(3,  r.x + 1334.0*RoomScale, -796.0*RoomScale+0.01, r.z-220.0*RoomScale,90,Rnd(360),0)
            de.Size = 0.25
            ScaleSprite(de.obj, de.Size,de.Size)
            EntityParent(de.obj, r.obj)
			
			r.Objects[2] = CreateButton(r.x + 1181.0 *RoomScale, r.y + 180.0 * RoomScale, r.z - 512.0 * RoomScale, 0, 270)
            EntityParent (r.Objects[2],r.obj)
			//[End Block]
		case "room2poffices":
			//[Block]
			d = CreateDoor(r.zone, r.x + 240.0 * RoomScale, 0.0, r.z + 448.0 * RoomScale, 90, r, False, False, 0, Str(AccessCode))
			PositionEntity(d.buttons[0], r.x + 248.0 * RoomScale, EntityY(d.buttons[0],True), EntityZ(d.buttons[0],True),True)
			PositionEntity(d.buttons[1], r.x + 232.0 * RoomScale, EntityY(d.buttons[1],True), EntityZ(d.buttons[1],True),True)			
			d.AutoClose = False
			d.open = False
			
			d = CreateDoor(r.zone, r.x - 496.0 * RoomScale, 0.0, r.z, 90, r, False, False, 0, "ABCD")
			PositionEntity(d.buttons[0], r.x - 488.0 * RoomScale, EntityY(d.buttons[0],True), EntityZ(d.buttons[0],True),True)
			PositionEntity(d.buttons[1], r.x - 504.0 * RoomScale, EntityY(d.buttons[1],True), EntityZ(d.buttons[1],True),True)				
			d.AutoClose = False
			d.open = False
			d.locked = True	
			
			d = CreateDoor(r.zone, r.x + 240.0 * RoomScale, 0.0, r.z - 576.0 * RoomScale, 90, r, False, False, 0, "7816")
			PositionEntity(d.buttons[0], r.x + 248.0 * RoomScale, EntityY(d.buttons[0],True), EntityZ(d.buttons[0],True),True)
			PositionEntity(d.buttons[1], r.x + 232.0 * RoomScale, EntityY(d.buttons[1],True), EntityZ(d.buttons[1],True),True)		
			d.AutoClose = False
			d.open = False	
			
			it = CreateItem("Mysterious Note", "paper", r.x + 736.0 * RoomScale, r.y + 224.0 * RoomScale, r.z + 544.0 * RoomScale)
			EntityParent(it.collider, r.obj)	
			it = CreateItem("Ballistic Vest", "vest", r.x + 608.0 * RoomScale, r.y + 112.0 * RoomScale, r.z + 32.0 * RoomScale)
			EntityParent(it.collider, r.obj)
			RotateEntity(it.collider, 0, 90, 0)
			
			it = CreateItem("Incident Report SCP-106-0204", "paper", r.x + 704.0 * RoomScale, r.y + 183.0 * RoomScale, r.z - 576.0 * RoomScale)
			EntityParent(it.collider, r.obj)
			it = CreateItem("Journal Page", "paper", r.x + 912 * RoomScale, r.y + 176.0 * RoomScale, r.z - 160.0 * RoomScale)
			EntityParent(it.collider, r.obj)
			it = CreateItem("First Aid Kit", "firstaid", r.x + 912.0 * RoomScale, r.y + 112.0 * RoomScale, r.z - 336.0 * RoomScale)
			EntityParent(it.collider, r.obj)
			RotateEntity(it.collider, 0, 90, 0)
			//[End Block]
		case "room2poffices2":
			//[Block]
			d = CreateDoor(r.zone, r.x + 240.0 * RoomScale, 0.0, r.z + 48.0 * RoomScale, 270, r, False, False, 3)
			PositionEntity(d.buttons[0], r.x + 224.0 * RoomScale, EntityY(d.buttons[0],True), r.z + 176.0 * RoomScale,True)
			PositionEntity(d.buttons[1], r.x + 256.0 * RoomScale, EntityY(d.buttons[1],True), EntityZ(d.buttons[1],True),True)			
			d.AutoClose = False
			d.open = False
			
			r.RoomDoors[0] = CreateDoor(r.zone, r.x - 432.0 * RoomScale, 0.0, r.z, 90, r, False, False, 0, "1234")
			PositionEntity(r.RoomDoors[0].buttons[0], r.x - 416.0 * RoomScale, EntityY(r.RoomDoors[0].buttons[0],True), r.z + 176.0 * RoomScale,True)
			FreeEntity(r.RoomDoors[0].buttons[1])
			r.RoomDoors[0].buttons[1] = 0
			r.RoomDoors[0].AutoClose = False
			r.RoomDoors[0].open = False
			r.RoomDoors[0].locked = True	
			
			de.Decals = CreateDecal(0, r.x - 808.0 * RoomScale, 0.005, r.z - 72.0 * RoomScale, 90, Rand(360), 0)
			EntityParent(de.obj, r.obj)
			de.Decals = CreateDecal(2, r.x - 808.0 * RoomScale, 0.01, r.z - 72.0 * RoomScale, 90, Rand(360), 0)
			de.Size = 0.3
			ScaleSprite(de.obj, de.Size, de.Size)
			EntityParent(de.obj, r.obj)
			
			de.Decals = CreateDecal(0, r.x - 432.0 * RoomScale, 0.01, r.z, 90, Rand(360), 0)
			EntityParent(de.obj, r.obj)
			
			r.Objects[0] = CreatePivot(r.obj)
			PositionEntity(r.Objects[0], r.x - 808.0 * RoomScale, 1.0, r.z - 72.0 * RoomScale, True)
			
			it = CreateItem("Dr. L's Burnt Note", "paper", r.x - 688.0 * RoomScale, 1.0, r.z - 16.0 * RoomScale)
			EntityParent(it.collider, r.obj)
			
			it = CreateItem("Dr L's Burnt Note", "paper", r.x - 808.0 * RoomScale, 1.0, r.z - 72.0 * RoomScale)
			EntityParent(it.collider, r.obj)
			
			it = CreateItem("The Modular Site Project", "paper", r.x + 622.0*RoomScale, r.y + 125.0*RoomScale, r.z - 73.0*RoomScale)
			EntityParent(it.collider, r.obj)
			//[End Block]
		case "room2elevator":
			//[Block]
			r.Objects[0] = CreatePivot(r.obj)
			PositionEntity(r.Objects[0], r.x+888.0*RoomScale, 240.0*RoomScale, r.z, True)
			
			r.Objects[1] = CreatePivot(r.obj)
			PositionEntity(r.Objects[1], r.x+1024.0*RoomScale-0.01, 120.0*RoomScale, r.z, True)
			
			r.RoomDoors[0] = CreateDoor(r.zone, r.x + 448.0 * RoomScale, 0.0, r.z, 90, r, False, 3)
			PositionEntity(r.RoomDoors[0].buttons[1], r.x + 416.0 * RoomScale, EntityY(r.RoomDoors[0].buttons[1],True), r.z - 208.0 * RoomScale,True)
			PositionEntity(r.RoomDoors[0].buttons[0], r.x + 480.0 * RoomScale, EntityY(r.RoomDoors[0].buttons[0],True), r.z + 184.0 * RoomScale,True)
			r.RoomDoors[0].AutoClose = False
			r.RoomDoors[0].open = True
			r.RoomDoors[0].locked = True
			//[End Block]
		case "room2cafeteria":
			//[Block]
			//scp-294
			r.Objects[0] = CreatePivot(r.obj)
			PositionEntity(r.Objects[0], r.x+1847.0*RoomScale, -240.0*RoomScale, r.z-321*RoomScale, True)
			//"spawnpoint" for the cups
			r.Objects[1] = CreatePivot(r.obj)
			PositionEntity(r.Objects[1], r.x+1780.0*RoomScale, -248.0*RoomScale, r.z-276*RoomScale, True)
			
			it = CreateItem("cup", "cup", r.x-508.0*RoomScale, -187*RoomScale, r.z+284.0*RoomScale, 240,175,70)
			EntityParent(it.collider, r.obj)
			it.name = "Cup of Orange Juice"
			
			it = CreateItem("cup", "cup", r.x+1412 * RoomScale, -187*RoomScale, r.z-716.0 * RoomScale, 87,62,45)
			EntityParent(it.collider, r.obj)
			it.name = "Cup of Coffee"
			
			it = CreateItem("Empty Cup", "emptycup", r.x-540*RoomScale, -187*RoomScale, r.z+124.0*RoomScale)
			EntityParent(it.collider, r.obj)
			
			it = CreateItem("Quarter", "25ct", r.x-447.0*RoomScale, r.y-334.0*RoomScale, r.z+36.0*RoomScale)
			EntityParent(it.collider, r.obj)
			it = CreateItem("Quarter", "25ct", r.x+1409.0*RoomScale, r.y-334.0*RoomScale, r.z-732.0*RoomScale)
			EntityParent(it.collider, r.obj)
			//[End Block]
		case "room2nuke":
			//[Block]
			//"tuulikaapin" ovi
			d = CreateDoor(r.zone, r.x + 576.0 * RoomScale, 0.0, r.z + 152.0 * RoomScale, 90, r, False, False, 5)
			d.AutoClose = False
			d.open = False
			PositionEntity(d.buttons[0], r.x + 602.0 * RoomScale, EntityY(d.buttons[0],True), r.z + 20.0 * RoomScale,True)
			PositionEntity(d.buttons[1], r.x + 550.0 * RoomScale, EntityY(d.buttons[1],True), r.z + 20.0 * RoomScale,True)
			FreeEntity(d.obj2)
			d.obj2 = 0
			
			d = CreateDoor(r.zone, r.x - 544.0 * RoomScale, 1504.0*RoomScale, r.z + 738.0 * RoomScale, 90, r, False, False, 5)
			d.AutoClose = False
			d.open = False			
			PositionEntity(d.buttons[0], EntityX(d.buttons[0],True), EntityY(d.buttons[0],True), r.z + 608.0 * RoomScale,True)
			PositionEntity(d.buttons[1], EntityX(d.buttons[1],True), EntityY(d.buttons[1],True), r.z + 608.0 * RoomScale,True)
			
			//ylkerran hissin ovi
			r.RoomDoors[0] = CreateDoor(r.zone, r.x + 1192.0 * RoomScale, 0.0, r.z, 90, r, True, 3)
			r.RoomDoors[0].AutoClose = False
			r.RoomDoors[0].open = True
			//ylkerran hissi
			r.Objects[4] = CreatePivot()
			PositionEntity(r.Objects[4], r.x + 1496.0 * RoomScale, 240.0 * RoomScale, r.z)
			EntityParent(r.Objects[4], r.obj)
			//alakerran hissin ovi
			r.RoomDoors[1] = CreateDoor(r.zone, r.x + 680.0 * RoomScale, 1504.0 * RoomScale, r.z, 90, r, False, 3)
			r.RoomDoors[1].AutoClose = False
			r.RoomDoors[1].open = False
			//alakerran hissi
			r.Objects[5] = CreatePivot()
			PositionEntity(r.Objects[5], r.x + 984.0 * RoomScale, 1744.0 * RoomScale, r.z)
			EntityParent(r.Objects[5], r.obj)
			
			for (n of range(2)) {
				r.Objects[n * 2] = CopyEntity(LeverBaseOBJ)
				r.Objects[n * 2 + 1] = CopyEntity(LeverOBJ)
				r.Levers[n] = r.Objects[n * 2 + 1]
				
				for (i of range(2)) {
					ScaleEntity(r.Objects[n * 2 + i], 0.04, 0.04, 0.04)
					PositionEntity (r.Objects[n * 2 + i], r.x - 975.0 * RoomScale, r.y + 1712.0 * RoomScale, r.z - (502.0-132.0*n) * RoomScale, True)
					
					EntityParent(r.Objects[n * 2 + i], r.obj)
				}
				RotateEntity(r.Objects[n * 2], 0, -90-180, 0)
				RotateEntity(r.Objects[n * 2 + 1], 10, -90 - 180-180, 0)
				
				EntityPickMode(r.Objects[n * 2 + 1], 1, False)
				EntityRadius(r.Objects[n * 2 + 1], 0.1)
			}
			
			it = CreateItem("Nuclear Device Document", "paper", r.x - 768.0 * RoomScale, r.y + 1684.0 * RoomScale, r.z - 768.0 * RoomScale)
			EntityParent(it.collider, r.obj)
			
			it = CreateItem("Ballistic Vest", "vest", r.x - 944.0 * RoomScale, r.y + 1652.0 * RoomScale, r.z - 656.0 * RoomScale)
			EntityParent(it.collider, r.obj)
			RotateEntity(it.collider, 0, -90, 0)
			
			sc.SecurityCams = CreateSecurityCam(r.x+624.0*RoomScale, r.y+1888.0*RoomScale, r.z-312.0*RoomScale, r)
			sc.angle = 90
			sc.turn = 45
			TurnEntity(sc.CameraObj, 20, 0, 0)
			
			r.Objects[6] = CreatePivot()
			PositionEntity (r.Objects[6],r.x+1110.0*RoomScale,r.y+36.0*RoomScale,r.z-208.0*RoomScale)
			EntityParent(r.Objects[6],r.obj)
			//[End Block]
		case "room2tunnel":
			//[Block]
			r.Objects[0] = CreatePivot()
			PositionEntity(r.Objects[0], r.x + 2640.0 * RoomScale, -2496.0 * RoomScale, r.z + 400.0 * RoomScale)
			EntityParent(r.Objects[0], r.obj)
			
			r.Objects[1] = CreatePivot()
			PositionEntity(r.Objects[1], r.x - 4336.0 * RoomScale, -2496.0 * RoomScale, r.z - 2512.0 * RoomScale)
			EntityParent(r.Objects[1], r.obj)
			
			r.Objects[2] = CreatePivot()
			RotateEntity(r.Objects[2],0.0,180.0,0.0,True)
			PositionEntity(r.Objects[2], r.x + 552.0 * RoomScale, 240.0 * RoomScale, r.z + 656.0 * RoomScale)
			EntityParent(r.Objects[2], r.obj)
		
			r.Objects[4] = CreatePivot()
			PositionEntity(r.Objects[4], r.x - 552.0 * RoomScale, 240.0 * RoomScale, r.z - 656.0 * RoomScale)
			EntityParent(r.Objects[4], r.obj)
		
			r.RoomDoors[0] = CreateDoor(r.zone, r.x + 264.0 * RoomScale, 0.0, r.z + 656.0 * RoomScale, 90, r, True, 3)
			r.RoomDoors[0].AutoClose = False
			r.RoomDoors[0].open = True
			PositionEntity(r.RoomDoors[0].buttons[1], r.x + 224.0 * RoomScale, 0.7, r.z + 480.0 * RoomScale, True)
			PositionEntity(r.RoomDoors[0].buttons[0], r.x + 304.0 * RoomScale, 0.7, r.z + 832.0 * RoomScale, True)			
			
			r.RoomDoors[2] = CreateDoor(r.zone, r.x - 264.0 * RoomScale, 0.0, r.z - 656.0 * RoomScale, 90, r, True, 3)
			r.RoomDoors[2].AutoClose = False
			r.RoomDoors[2].open = True
			PositionEntity(r.RoomDoors[2].buttons[0], r.x - 224.0 * RoomScale, 0.7, r.z - 480.0 * RoomScale, True)
			PositionEntity(r.RoomDoors[2].buttons[1], r.x - 304.0 * RoomScale, 0.7, r.z - 832.0 * RoomScale, True)
		
			temp = ((Int(AccessCode)*3) % 10000)
			if (temp < 1000) {
				temp = temp+1000
			}
			d.Doors = CreateDoor(0, r.x,r.y,r.z,0, r, False, True, False, temp)
			PositionEntity(d.buttons[0], r.x + 224.0 * RoomScale, r.y + 0.7, r.z - 384.0 * RoomScale, True)
			RotateEntity (d.buttons[0], 0,-90,0,True)
			PositionEntity(d.buttons[1], r.x - 224.0 * RoomScale, r.y + 0.7, r.z + 384.0 * RoomScale, True)		
			RotateEntity (d.buttons[1], 0,90,0,True)
			
			de.Decals = CreateDecal(0, r.x + 64.0 * RoomScale, 0.005, r.z + 144.0 * RoomScale, 90, Rand(360), 0)
			EntityParent(de.obj, r.obj)
			it = CreateItem("Scorched Note", "paper", r.x + 64.0 * RoomScale, r.y +144.0 * RoomScale, r.z - 384.0 * RoomScale)
			EntityParent(it.collider, r.obj)
			//[End Block]
		case "008":
			//[Block]
			//the container
			r.Objects[0] = CreatePivot(r.obj)
			PositionEntity(r.Objects[0], r.x + 292.0 * RoomScale, 130.0*RoomScale, r.z + 516.0 * RoomScale, True)
			
			//the lid of the container
			r.Objects[1] = LoadMesh_Strict("GFX/map/008_2.b3d")
			ScaleEntity (r.Objects[1], RoomScale, RoomScale, RoomScale)
			PositionEntity(r.Objects[1], r.x + 292 * RoomScale, 151 * RoomScale, r.z + 576.0 * RoomScale, 0)
			EntityParent(r.Objects[1], r.obj)
			
			RotateEntity(r.Objects[1],89,0,0,True)
			
			r.Levers[0] = r.Objects[1]
			
			Glasstex = LoadTexture_Strict("GFX/map/glass.png",1+2)
			r.Objects[2] = CreateSprite()
			EntityTexture(r.Objects[2],Glasstex)
			SpriteViewMode(r.Objects[2],2)
			ScaleSprite(r.Objects[2],256.0*RoomScale*0.5, 194.0*RoomScale*0.5)
			PositionEntity(r.Objects[2], r.x - 176.0 * RoomScale, 224.0*RoomScale, r.z + 448.0 * RoomScale)
			TurnEntity(r.Objects[2],0,90,0)			
			EntityParent(r.Objects[2], r.obj)
			
			FreeTexture (Glasstex)
			
			//scp-173 spawnpoint
			r.Objects[3] = CreatePivot(r.obj)
			PositionEntity(r.Objects[3], r.x - 445.0 * RoomScale, 120.0*RoomScale, r.z + 544.0 * RoomScale, True)
			
			//scp-173 attack point
			r.Objects[4] = CreatePivot(r.obj)
			PositionEntity(r.Objects[4], r.x + 67.0 * RoomScale, 120.0*RoomScale, r.z + 464.0 * RoomScale, True)
			
			r.Objects[5] = CreateSprite()
			PositionEntity(r.Objects[5], r.x - 158 * RoomScale, 368 * RoomScale, r.z + 298.0 * RoomScale)
			ScaleSprite(r.Objects[5], 0.02, 0.02)
			EntityTexture(r.Objects[5], LightSpriteTex(1))
			EntityBlend (r.Objects[5], 3)
			EntityParent(r.Objects[5], r.obj)
			HideEntity(r.Objects[5])
			
			d = CreateDoor(r.zone, r.x + 296.0 * RoomScale, 0, r.z - 672.0 * RoomScale, 180, r, True, 0, 4)
			d.AutoClose = False
			PositionEntity (d.buttons[1], r.x + 164.0 * RoomScale, EntityY(d.buttons[1],True), EntityZ(d.buttons[1],True), True)
			FreeEntity(d.buttons[0])
			d.buttons[0]=0
			FreeEntity(d.obj2)
			d.obj2=0
			r.RoomDoors[0] = d
			
			d2 = CreateDoor(r.zone, r.x + 296.0 * RoomScale, 0, r.z - 144.0 * RoomScale, 0, r, False)
			d2.AutoClose = False
			PositionEntity (d2.buttons[0], r.x + 432.0 * RoomScale, EntityY(d2.buttons[0],True), r.z - 480.0 * RoomScale, True)
			RotateEntity(d2.buttons[0], 0, -90, 0, True)			
			PositionEntity (d2.buttons[1], r.x + 164.0 * RoomScale, EntityY(d2.buttons[0],True), r.z - 128.0 * RoomScale, True)
			FreeEntity(d2.obj2)
			d2.obj2=0
			r.RoomDoors[1] = d2
			
			d.LinkedDoor = d2
			d2.LinkedDoor = d
			
			d = CreateDoor(r.zone, r.x - 384.0 * RoomScale, 0, r.z - 672.0 * RoomScale, 0, r, False, 0, 4)
			d.AutoClose = False
			d.locked = True
			r.RoomDoors[2]=d
			
			
			it = CreateItem("Hazmat Suit", "hazmatsuit", r.x - 76.0 * RoomScale, 0.5, r.z - 396.0 * RoomScale)
			EntityParent(it.collider, r.obj)
			RotateEntity(it.collider, 0, 90, 0)
			
			it = CreateItem("Document SCP-008", "paper", r.x - 245.0 * RoomScale, r.y + 192.0 * RoomScale, r.z + 368.0 * RoomScale)
			EntityParent(it.collider, r.obj)
			
			//spawnpoint for the scientist used in the "008 zombie scene"
			r.Objects[6] = CreatePivot(r.obj)
			PositionEntity(r.Objects[6], r.x + 160 * RoomScale, 672 * RoomScale, r.z - 384.0 * RoomScale, True)
			//spawnpoint for the player
			r.Objects[7] = CreatePivot(r.obj)
			PositionEntity(r.Objects[7], r.x, 672 * RoomScale, r.z + 352.0 * RoomScale, True)
			
			sc.SecurityCams = CreateSecurityCam(r.x+578.956*RoomScale, r.y+444.956*RoomScale, r.z+772.0*RoomScale, r)
			sc.angle = 135
			sc.turn = 45
			TurnEntity(sc.CameraObj, 20, 0, 0)
			//[End Block]
		case "room035":
			//[Block]
			d = CreateDoor(r.zone, r.x - 296.0 * RoomScale, 0, r.z - 672.0 * RoomScale, 180, r, True, 0, 5)
			d.AutoClose = False
			d.locked = True
			r.RoomDoors[0]=d
			PositionEntity (d.buttons[1], r.x - 164.0 * RoomScale, EntityY(d.buttons[1],True), EntityZ(d.buttons[1],True), True)
			FreeEntity(d.buttons[0])
			d.buttons[0]=0
			FreeEntity(d.obj2)
			d.obj2=0
			
			d2 = CreateDoor(r.zone, r.x - 296.0 * RoomScale, 0, r.z - 144.0 * RoomScale, 0, r, False)
			d2.AutoClose = False
			d2.locked = True
			r.RoomDoors[1]=d2
			PositionEntity (d2.buttons[0], r.x - 432.0 * RoomScale, EntityY(d2.buttons[0],True), r.z - 480.0 * RoomScale, True)
			RotateEntity(d2.buttons[0], 0, 90, 0, True)
			FreeEntity(d2.buttons[1])
			d2.buttons[1]=0
			FreeEntity(d2.obj2)
			d2.obj2=0
			
			//door to the control room
			r.RoomDoors[2] = CreateDoor(r.zone, r.x + 384.0 * RoomScale, 0, r.z - 672.0 * RoomScale, 180, r, False, 0, 5)
			r.RoomDoors[2].AutoClose = False
			
			//door to the storage room
			r.RoomDoors[3] = CreateDoor(0, r.x + 768.0 * RoomScale, 0, r.z +512.0 * RoomScale, 90, r, False, 0, 0, "5731")
			r.RoomDoors[3].AutoClose = False			
			
			d.LinkedDoor = d2
			d2.LinkedDoor = d
			
			for (i of range(2)) {
				r.Objects[i*2] = CopyEntity(LeverBaseOBJ)
				r.Objects[i*2+1] = CopyEntity(LeverOBJ)
				
				r.Levers[i] = r.Objects[i*2+1]
				
				for (n of range(2)) {
					ScaleEntity(r.Objects[i*2+n], 0.04, 0.04, 0.04)
					PositionEntity (r.Objects[i*2+n], r.x + 210.0 * RoomScale, r.y + 224.0 * RoomScale, r.z - (208-i*76) * RoomScale, True)
					
					EntityParent(r.Objects[i*2+n], r.obj)
				}
				
				RotateEntity(r.Objects[i*2], 0, -90-180, 0)
				RotateEntity(r.Objects[i*2+1], -80, -90, 0)
				
				EntityPickMode(r.Objects[i*2+1], 1, False)
				EntityRadius(r.Objects[i*2+1], 0.1)
			}
			
			//the control room
			r.Objects[3] = CreatePivot(r.obj)
			PositionEntity(r.Objects[3], r.x + 456 * RoomScale, 0.5, r.z + 400.0 * RoomScale, True)
			
			r.Objects[4] = CreatePivot(r.obj)
			PositionEntity(r.Objects[4], r.x - 576 * RoomScale, 0.5, r.z + 640.0 * RoomScale, True)
			
			for (i of range(2)) {
				em.Emitters = CreateEmitter(r.x - 272.0 * RoomScale, 10, r.z + (624.0-i*512) * RoomScale, 0)
				TurnEntity(em.Obj, 90, 0, 0, True)
				EntityParent(em.Obj, r.obj)
				em.RandAngle = 15
				em.Speed = 0.05
				em.SizeChange = 0.007
				em.Achange = -0.006
				em.Gravity = -0.24
				
				r.Objects[5+i]=em.Obj
			}
			
			//the corners of the cont chamber (needed to calculate whether the player is inside the chamber)
			r.Objects[7] = CreatePivot(r.obj)
			PositionEntity(r.Objects[7], r.x - 720 * RoomScale, 0.5, r.z + 880.0 * RoomScale, True)
			r.Objects[8] = CreatePivot(r.obj)
			PositionEntity(r.Objects[8], r.x + 176 * RoomScale, 0.5, r.z - 144.0 * RoomScale, True)			
			
			it = CreateItem("SCP-035 Addendum", "paper", r.x + 248.0 * RoomScale, r.y + 220.0 * RoomScale, r.z + 576.0 * RoomScale)
			EntityParent(it.collider, r.obj)
			
			it = CreateItem("Radio Transceiver", "radio", r.x - 544.0 * RoomScale, 0.5, r.z + 704.0 * RoomScale)
			EntityParent(it.collider, r.obj)
			
			it = CreateItem("SCP-500-01", "scp500", r.x + 1168*RoomScale, 224*RoomScale, r.z+576*RoomScale)
			EntityParent(it.collider, r.obj)
			
			it = CreateItem("Metal Panel", "scp148", r.x - 360 * RoomScale, 0.5, r.z + 644 * RoomScale)
			EntityParent(it.collider, r.obj)
			
			it = CreateItem("Document SCP-035", "paper", r.x + 1168.0 * RoomScale, 104.0 * RoomScale, r.z + 608.0 * RoomScale)
			EntityParent(it.collider, r.obj)
			//[End Block]
		case "room513":
			//[Block]
			d = CreateDoor(r.zone, r.x - 704.0 * RoomScale, 0, r.z + 304.0 * RoomScale, 0, r, False, 0, 2)
			d.AutoClose = False //: d.buttons[0] = False
			PositionEntity (d.buttons[0], EntityX(d.buttons[0],True), EntityY(d.buttons[0],True), r.z + 288.0 * RoomScale, True)
			PositionEntity (d.buttons[1], EntityX(d.buttons[1],True), EntityY(d.buttons[1],True), r.z + 320.0 * RoomScale, True)
			
			sc.SecurityCams = CreateSecurityCam(r.x-312.0 * RoomScale, r.y + 414*RoomScale, r.z + 656*RoomScale, r)
			sc.FollowPlayer = True
			
			it = CreateItem("SCP-513", "scp513", r.x - 32.0 * RoomScale, r.y + 196.0 * RoomScale, r.z + 688.0 * RoomScale)
			EntityParent(it.collider, r.obj)
			
			it = CreateItem("Blood-stained Note", "paper", r.x + 736.0 * RoomScale,1.0, r.z + 48.0 * RoomScale)
			EntityParent(it.collider, r.obj)
			
			it = CreateItem("Document SCP-513", "paper", r.x - 480.0 * RoomScale, 104.0*RoomScale, r.z - 176.0 * RoomScale)
			EntityParent(it.collider, r.obj)
			//[End Block]
		case "room966":
			//[Block]
			d = CreateDoor(r.zone, r.x - 400.0 * RoomScale, 0, r.z, -90, r, False, False, 3)
			d = CreateDoor(r.zone, r.x, 0, r.z - 480.0 * RoomScale, 180, r, False, False, 3)
			
			sc.SecurityCams = CreateSecurityCam(r.x-312.0 * RoomScale, r.y + 414*RoomScale, r.z + 656*RoomScale, r)
			sc.angle = 225
			sc.turn = 45
			TurnEntity(sc.CameraObj, 20, 0, 0)
			
			r.Objects[0] = CreatePivot(r.obj)
			PositionEntity(r.Objects[0], r.x, 0.5, r.z + 512.0 * RoomScale, True)
			
			r.Objects[1] = CreatePivot(r.obj)
			PositionEntity(r.Objects[1], r.x + 64.0 * RoomScale, 0.5, r.z - 640.0 * RoomScale, True)
			
			r.Objects[2] = CreatePivot(r.obj)
			PositionEntity(r.Objects[2], r.x, 0.5, r.z, True)
			
			r.Objects[3] = CreatePivot(r.obj)
			PositionEntity(r.Objects[3], r.x + 320.0 * RoomScale, 0.5, r.z + 704.0 * RoomScale, True)
			
			it = CreateItem("Night Vision Goggles", "nvgoggles", r.x + 320.0 * RoomScale, 0.5, r.z + 704.0 * RoomScale)
			EntityParent(it.collider, r.obj)
			it.state = 300
			
			//[End Block]
		case "room3storage":
			//[Block]
			r.Objects[0] = CreatePivot(r.obj)
			PositionEntity(r.Objects[0], r.x, 240.0 * RoomScale, r.z + 752.0 * RoomScale, True)
			
			r.Objects[1] = CreatePivot(r.obj)
			PositionEntity(r.Objects[1], r.x + 5840.0 * RoomScale, -5392.0 * RoomScale, r.z + 1360.0 * RoomScale, True)
			
			r.Objects[2] = CreatePivot(r.obj)
			PositionEntity(r.Objects[2], r.x + 608.0 * RoomScale, 240.0 * RoomScale, r.z - 624.0 * RoomScale, True)
			
			r.Objects[3] = CreatePivot(r.obj)
			PositionEntity(r.Objects[3], r.x - 456.0 * RoomScale, -5392.0 * RoomScale, r.z - 1136 * RoomScale, True)
			
			//"waypoints" #1
			r.Objects[4] = CreatePivot(r.obj)
			PositionEntity(r.Objects[4], r.x + 2128.0 * RoomScale, -5550.0 * RoomScale, r.z + 2048.0 * RoomScale, True)
			
			r.Objects[5] = CreatePivot(r.obj)
			PositionEntity(r.Objects[5], r.x + 2128.0 * RoomScale, -5550.0 * RoomScale, r.z - 1136.0 * RoomScale, True)
			
			r.Objects[6] = CreatePivot(r.obj)
			PositionEntity(r.Objects[6], r.x + 3824.0 * RoomScale, -5550.0 * RoomScale, r.z - 1168.0 * RoomScale, True)
			
			r.Objects[7] = CreatePivot(r.obj)
			PositionEntity(r.Objects[7], r.x + 3760.0 * RoomScale, -5550.0 * RoomScale, r.z + 2048.0 * RoomScale, True)
			
			r.Objects[8] = CreatePivot(r.obj)
			PositionEntity(r.Objects[8], r.x + 4848.0 * RoomScale, -5550.0 * RoomScale, r.z + 112.0 * RoomScale, True)
			
			//"waypoints" #2
			r.Objects[9] = CreatePivot(r.obj)
			PositionEntity(r.Objects[9], r.x + 592.0 * RoomScale, -5550.0 * RoomScale, r.z + 6352.0 * RoomScale, True)
			
			r.Objects[10] = CreatePivot(r.obj)
			PositionEntity(r.Objects[10], r.x + 2928.0 * RoomScale, -5550.0 * RoomScale, r.z + 6352.0 * RoomScale, True)
			
			r.Objects[11] = CreatePivot(r.obj)
			PositionEntity(r.Objects[11], r.x + 2928.0 * RoomScale, -5550.0 * RoomScale, r.z + 5200.0 * RoomScale, True)
			
			r.Objects[12] = CreatePivot(r.obj)
			PositionEntity(r.Objects[12], r.x + 592.0 * RoomScale, -5550.0 * RoomScale, r.z + 5200.0 * RoomScale, True)
			
			//"waypoints" #3
			r.Objects[13] = CreatePivot(r.obj)
			PositionEntity(r.Objects[13], r.x + 1136.0 * RoomScale, -5550.0 * RoomScale, r.z + 2944.0 * RoomScale, True)
			
			r.Objects[14] = CreatePivot(r.obj)
			PositionEntity(r.Objects[14], r.x + 1104.0 * RoomScale, -5550.0 * RoomScale, r.z + 1184.0 * RoomScale, True)
			
			r.Objects[15] = CreatePivot(r.obj)
			PositionEntity(r.Objects[15], r.x - 464.0 * RoomScale,  -5550.0 * RoomScale, r.z + 1216.0 * RoomScale, True)
			
			r.Objects[16] = CreatePivot(r.obj)
			PositionEntity(r.Objects[16], r.x - 432.0 * RoomScale, -5550.0 * RoomScale, r.z + 2976.0 * RoomScale, True)
			
			r.Objects[20] = LoadMesh_Strict("GFX/map/room3storage_hb.b3d",r.obj)
			EntityPickMode(r.Objects[20],2)
			EntityType(r.Objects[20],HIT_MAP)
			EntityAlpha(r.Objects[20],0.0)
			
			//Doors
			r.RoomDoors[0] = CreateDoor(r.zone, r.x, 0.0, r.z + 448.0 * RoomScale, 0, r, True, 3)
			r.RoomDoors[0].AutoClose = False
			r.RoomDoors[0].open = True
			PositionEntity(r.RoomDoors[0].buttons[1], r.x - 160.0 * RoomScale, 0.7, r.z + 480.0 * RoomScale, True)
			PositionEntity(r.RoomDoors[0].buttons[0], r.x + 160.0 * RoomScale, 0.7, r.z + 416.0 * RoomScale, True)	
			
			r.RoomDoors[1] = CreateDoor(r.zone, r.x + 5840.0 * RoomScale,  -5632.0 * RoomScale, r.z + 1048.0 * RoomScale, 0, r, False, 3)
			r.RoomDoors[1].AutoClose = False
			r.RoomDoors[1].open = False
			PositionEntity(r.RoomDoors[1].buttons[0], r.x + 6000.0 * RoomScale, EntityY(r.RoomDoors[1].buttons[0],True), r.z + 1008.0 * RoomScale, True)					
			PositionEntity(r.RoomDoors[1].buttons[1], r.x + 5680.0 * RoomScale, EntityY(r.RoomDoors[1].buttons[1],True), r.z + 1088.0 * RoomScale, True)
			
			r.RoomDoors[2] = CreateDoor(r.zone, r.x + 608.0 * RoomScale, 0.0, r.z - 312.0 * RoomScale, 0, r, True, 3)
			r.RoomDoors[2].AutoClose = False
			r.RoomDoors[2].open = True
			PositionEntity(r.RoomDoors[2].buttons[1], r.x + 448.0 * RoomScale, 0.7, r.z - 272.0 * RoomScale, True)	
			PositionEntity(r.RoomDoors[2].buttons[0], r.x + 768.0 * RoomScale, 0.7, r.z - 352.0 * RoomScale, True)
			
			r.RoomDoors[3] = CreateDoor(r.zone, r.x - 456.0 * RoomScale,  -5632.0 * RoomScale, r.z - 824.0 * RoomScale, 0, r, False, 3)
			r.RoomDoors[3].AutoClose = False
			r.RoomDoors[3].open = False
			//X=+176 | Z=-40
			PositionEntity(r.RoomDoors[3].buttons[0], r.x - 280.0*RoomScale, EntityY(r.RoomDoors[3].buttons[0],True), r.z - 864.0 * RoomScale, True)
			//X=-176 | Z=+40
			PositionEntity(r.RoomDoors[3].buttons[1], r.x - 632.0*RoomScale, EntityY(r.RoomDoors[3].buttons[1],True), r.z - 784.0 * RoomScale, True)
			
			em.Emitters = CreateEmitter(r.x + 5218.0 * RoomScale, -5584.0*RoomScale, r.z - 600* RoomScale, 0)
			TurnEntity(em.Obj, 20, -100, 0, True)
			EntityParent(em.Obj, r.obj)
			em.Room = r
			em.RandAngle = 15
			em.Speed = 0.03
			em.SizeChange = 0.01
			em.Achange = -0.006
			em.Gravity = -0.2 
			
			switch (Rand(3)) {
				case 1:
					x = 2312
					z = -952
				case 2:
					x = 3032
					z = 1288
				case 3:
					x = 2824
					z = 2808
			}
			
			it.Items = CreateItem("Black Severed Hand", "hand2", r.x + x*RoomScale, -5596.0*RoomScale+1.0, r.z+z*RoomScale)
			EntityParent(it.collider, r.obj)
			
			it = CreateItem("Night Vision Goggles", "nvgoggles", r.x + 1936.0 * RoomScale, r.y - 5496.0 * RoomScale, r.z - 944.0 * RoomScale)
			EntityParent(it.collider, r.obj)
			it.state = 450
			
			de.Decals = CreateDecal(3,  r.x + x*RoomScale, -5632.0*RoomScale+0.01, r.z+z*RoomScale,90,Rnd(360),0)
			de.Size = 0.5
			ScaleSprite(de.obj, de.Size,de.Size)
			EntityParent(de.obj, r.obj)
			
			//Objects [20],[21],[22],[23]
			for (n of range(10, 12)) {
				r.Objects[n * 2] = CopyEntity(LeverBaseOBJ)
				r.Objects[n * 2 + 1] = CopyEntity(LeverOBJ)
				
				r.Levers[n-10] = r.Objects[n * 2 + 1]
				
				for (i of range(2)) {
					ScaleEntity(r.Objects[n * 2 + i], 0.04, 0.04, 0.04)
					if (n == 10) {
						//r.z+6578
						PositionEntity(r.Objects[n * 2 + i],r.x+3101*RoomScale,r.y-5461*RoomScale,r.z+6568*RoomScale,True)
					} else {
						//r.z+3174
						PositionEntity(r.Objects[n * 2 + i],r.x+1209*RoomScale,r.y-5461*RoomScale,r.z+3164*RoomScale,True)
					}
					
					EntityParent(r.Objects[n * 2 + i], r.obj)
				}
				RotateEntity(r.Objects[n * 2], 0, 0, 0)
				RotateEntity(r.Objects[n * 2 + 1], -10, 0 - 180, 0)
				
				EntityPickMode(r.Objects[n * 2 + 1], 1, False)
				EntityRadius(r.Objects[n * 2 + 1], 0.1)
			}
			
			r.RoomDoors[4] = CreateDoor(r.zone,r.x+56*RoomScale,r.y-5632*RoomScale,r.z+6344*RoomScale,90,r,False,2)
			r.RoomDoors[4].AutoClose = False
			r.RoomDoors[4].open = False
			for (i of range(2)) {
				FreeEntity(r.RoomDoors[4].buttons[i])
				r.RoomDoors[4].buttons[i] = 0
			}
			
			d = CreateDoor(r.zone,r.x+1157.0*RoomScale,r.y-5632.0*RoomScale,r.z+660.0*RoomScale,0,r,False,2)
			d.locked = True
			d.open = False
			d.AutoClose = False
			for (i of range(2)) {
				FreeEntity(d.buttons[i])
				d.buttons[i]=0
			}
			
			d = CreateDoor(r.zone,r.x+234.0*RoomScale,r.y-5632.0*RoomScale,r.z+5239.0*RoomScale,90,r,False,2)
			d.locked = True
			d.open = False
			d.AutoClose = False
			for (i of range(2)) {
				FreeEntity(d.buttons[i])
				d.buttons[i]=0
			}
			
			d = CreateDoor(r.zone,r.x+3446.0*RoomScale,r.y-5632.0*RoomScale,r.z+6369.0*RoomScale,90,r,False,2)
			d.locked = True
			d.open = False
			d.AutoClose = False
			for (i of range(2)) {
				FreeEntity(d.buttons[i])
				d.buttons[i]=0
			}
			//[End Block]
		case "room049":
			//[Block]
			r.Objects[0] = CreatePivot(r.obj)
			PositionEntity(r.Objects[0], r.x + 640.0 * RoomScale, 240.0 * RoomScale, r.z + 656.0 * RoomScale, True)
			
			r.Objects[1] = CreatePivot(r.obj)
			PositionEntity(r.Objects[1], r.x + 3211.0 * RoomScale, -3280.0 * RoomScale, r.z + 1824.0 * RoomScale, True)
			
			r.Objects[2] = CreatePivot(r.obj)
			PositionEntity(r.Objects[2], r.x - 672.0 * RoomScale, 240.0 * RoomScale, r.z - 93.0 * RoomScale, True)
			
			r.Objects[3] = CreatePivot(r.obj)
			PositionEntity(r.Objects[3], r.x - 2766.0 * RoomScale, -3280.0 * RoomScale, r.z - 1277.0 * RoomScale, True)
			
			//zombie 1
			r.Objects[4] = CreatePivot(r.obj)
			PositionEntity(r.Objects[4], r.x + 528.0 * RoomScale, -3440.0 * RoomScale, r.z + 96.0 * RoomScale, True)
			//zombie 2
			r.Objects[5] = CreatePivot(r.obj)
			PositionEntity(r.Objects[5], r.x  + 64.0 * RoomScale, -3440.0 * RoomScale, r.z - 1000.0 * RoomScale, True)
			
			for (n of range(2)) {
				r.Objects[n * 2 + 6] = CopyEntity(LeverBaseOBJ)
				r.Objects[n * 2 + 7] = CopyEntity(LeverOBJ)
				
				r.Levers[n] = r.Objects[n * 2 + 7]
				
				for (i of range(2)) {
					ScaleEntity(r.Objects[n * 2 + 6 + i], 0.03, 0.03, 0.03)
					
					switch (n) {
						case 0: //power feed
							PositionEntity (r.Objects[n * 2 + 6 + i], r.x + 852.0 * RoomScale, r.y - 3374.0 * RoomScale, r.z - 854.0 * RoomScale, True)
							
						case 1: //generator
							PositionEntity (r.Objects[n * 2 + 6 + i], r.x - 834.0 * RoomScale, r.y - 3400.0 * RoomScale, r.z + 1093.0 * RoomScale, True)
							
					}
					
					EntityParent(r.Objects[n * 2 + 6 + i], r.obj)
				}
				
				RotateEntity(r.Objects[n*2+6], 0, 180+90*(!n), 0)
				RotateEntity(r.Objects[n*2+7], 81-92*n, 90*(!n), 0)
				
				EntityPickMode(r.Objects[n * 2 + 7], 1, False)
				EntityRadius(r.Objects[n * 2 + 7], 0.1)
			}
			
			
			r.RoomDoors[0] = CreateDoor(r.zone, r.x + 330.0 * RoomScale, 0.0, r.z + 656.0 * RoomScale, 90, r, True, 3)
			r.RoomDoors[0].AutoClose = False
			r.RoomDoors[0].open = True
			PositionEntity(r.RoomDoors[0].buttons[1], r.x + 288.0 * RoomScale, 0.7, r.z + 512.0 * RoomScale, True)
			PositionEntity(r.RoomDoors[0].buttons[0], r.x + 368.0 * RoomScale, 0.7, r.z + 840.0 * RoomScale, True)
			
			r.RoomDoors[1] = CreateDoor(r.zone, r.x + 2898.0 * RoomScale, -3520.0 * RoomScale, r.z + 1824.0 * RoomScale, 90, r, False, 3)
			r.RoomDoors[1].AutoClose = False
			r.RoomDoors[1].open = False	
			PositionEntity(r.RoomDoors[1].buttons[1], r.x + 2881.0 * RoomScale, EntityY(r.RoomDoors[1].buttons[1],True), r.z + 1663.0 * RoomScale, True)
			PositionEntity(r.RoomDoors[1].buttons[0], r.x + 2936.0 * RoomScale, EntityY(r.RoomDoors[1].buttons[0],True), r.z + 2009.0 * RoomScale, True)				
			
			r.RoomDoors[2] = CreateDoor(r.zone, r.x - 672.0 * RoomScale, 0.0, r.z - 408.0 * RoomScale, 0, r, True, 3)
			r.RoomDoors[2].AutoClose = False
			r.RoomDoors[2].open = True
			PositionEntity(r.RoomDoors[2].buttons[0], r.x - 487.0 * RoomScale, 0.7, r.z - 447.0 * RoomScale, True)
			PositionEntity(r.RoomDoors[2].buttons[1], r.x - 857.0 * RoomScale, 0.7, r.z - 369.0 * RoomScale, True)				
			
			r.RoomDoors[3] = CreateDoor(r.zone, r.x - 2766.0 * RoomScale, -3520.0 * RoomScale, r.z - 1592.0 * RoomScale, 0, r, False, 3)
			r.RoomDoors[3].AutoClose = False
			r.RoomDoors[3].open = False		
			PositionEntity(r.RoomDoors[3].buttons[0], r.x - 2581.0 * RoomScale, EntityY(r.RoomDoors[3].buttons[0],True), r.z - 1631.0 * RoomScale, True)
			PositionEntity(r.RoomDoors[3].buttons[1], r.x - 2951.0 * RoomScale, EntityY(r.RoomDoors[3].buttons[1],True), r.z - 1553.0 * RoomScale, True)	
			
			//storage room doors
			r.RoomDoors[4] = CreateDoor(r.zone, r.x + 272.0 * RoomScale, -3552.0 * RoomScale, r.z + 104.0 * RoomScale, 90, r, False)
			r.RoomDoors[4].AutoClose = False
			r.RoomDoors[4].open = True
			r.RoomDoors[4].locked = True
			r.RoomDoors[5] = CreateDoor(r.zone, r.x + 264.0 * RoomScale, -3520.0 * RoomScale, r.z - 1824.0 * RoomScale, 90, r, False)
			r.RoomDoors[5].AutoClose = False
			r.RoomDoors[5].open = True
			r.RoomDoors[5].locked = True
			r.RoomDoors[6] = CreateDoor(r.zone, r.x - 264.0 * RoomScale, -3520.0 * RoomScale, r.z + 1824.0 * RoomScale, 90, r, False)
			r.RoomDoors[6].AutoClose = False
			r.RoomDoors[6].open = True
			r.RoomDoors[6].locked = True
			
			d.Doors = CreateDoor(0, r.x,0,r.z, 0, r, False, 2, -2)
			
			it = CreateItem("Document SCP-049", "paper", r.x - 608.0 * RoomScale, r.y - 3332.0 * RoomScale, r.z + 876.0 * RoomScale)
			EntityParent(it.collider, r.obj)
			
			it = CreateItem("Level 4 Key Card", "key4", r.x - 512.0 * RoomScale, r.y - 3412.0 * RoomScale, r.z + 864.0 * RoomScale)
			EntityParent(it.collider, r.obj)
			
			it = CreateItem("First Aid Kit", "firstaid", r.x +385.0 * RoomScale, r.y - 3412.0 * RoomScale, r.z + 271.0 * RoomScale)
			EntityParent(it.collider, r.obj)
			
			d = CreateDoor(r.zone,r.x-272.0*RoomScale,r.y-3552.0*RoomScale,r.z+98.0*RoomScale,90,r,True,True)
			d.AutoClose = False
			d.open = True
			d.MTFClose = False
			d.locked = True
			for (i of range(2)) {
				FreeEntity(d.buttons[i])
				d.buttons[i]=0
			}
			
			d = CreateDoor(r.zone,r.x-2990.0*RoomScale,r.y-3520.0*RoomScale,r.z-1824.0*RoomScale,90,r,False,2)
			d.locked = True
			d.DisableWaypoint = True
			d = CreateDoor(r.zone,r.x-896.0*RoomScale,r.y,r.z-640*RoomScale,90,r,False,2)
			d.locked = True
			d.DisableWaypoint = True
			
			r.Objects[10] = CreatePivot(r.obj)
			PositionEntity(r.Objects[10],r.x-832.0*RoomScale,r.y-3484.0*RoomScale,r.z+1572.0*RoomScale,True)
			
			//Spawnpoint for the map layout document
			r.Objects[11] = CreatePivot(r.obj)
			PositionEntity(r.Objects[11],r.x+2642.0*RoomScale,r.y-3516.0*RoomScale,r.z+1822.0*RoomScale,True)
			r.Objects[12] = CreatePivot(r.obj)
			PositionEntity(r.Objects[12],r.x-2666.0*RoomScale,r.y-3516.0*RoomScale,r.z-1792.0*RoomScale,True)
			//[End Block]
		case "room2_2":
			//[Block]
			for (r2 of Rooms.each) {
				if (r2 != r) {
					if (r2.RoomTemplate.Name == "room2_2") {
						r.Objects[0] = CopyEntity(r2.Objects[0]) //don't load the mesh again
						break
					}
				}
			}
			if (r.Objects[0] == 0) {
				r.Objects[0] = LoadMesh_Strict("GFX/map/fan.b3d")
			}
			ScaleEntity(r.Objects[0], RoomScale, RoomScale, RoomScale)
			PositionEntity(r.Objects[0], r.x - 248 * RoomScale, 528 * RoomScale, r.z, 0)
			EntityParent(r.Objects[0], r.obj)
			//[End Block]
		case "room012":
			//[Block]
			d.Doors = CreateDoor(r.zone, r.x + 264.0 * RoomScale, 0.0, r.z + 672.0 * RoomScale, 270, r, False, False, 3)
			PositionEntity(d.buttons[0], r.x + 224.0 * RoomScale, EntityY(d.buttons[0],True), r.z + 540.0 * RoomScale, True)
			PositionEntity(d.buttons[1], r.x + 304.0 * RoomScale, EntityY(d.buttons[1],True), r.z + 840.0 * RoomScale, True)
			TurnEntity (d.buttons[1],0,0,0,True)
			
			r.RoomDoors[0] = CreateDoor(r.zone, r.x -512.0 * RoomScale, -768.0*RoomScale, r.z -336.0 * RoomScale, 0, r, False, False)
			r.RoomDoors[0].AutoClose = False
			r.RoomDoors[0].open = False
			r.RoomDoors[0].locked = True
			PositionEntity(r.RoomDoors[0].buttons[0], r.x + 176.0 * RoomScale, -512.0*RoomScale, r.z - 364.0 * RoomScale, True)
			FreeEntity (r.RoomDoors[0].buttons[1])
			r.RoomDoors[0].buttons[1]=0
			
			r.Objects[0] = CopyEntity(LeverBaseOBJ)
			r.Objects[1] = CopyEntity(LeverOBJ)
			
			r.Levers[0] = r.Objects[1]
			
			for (i of range(2)) {
				ScaleEntity(r.Objects[i], 0.04, 0.04, 0.04)
				PositionEntity (r.Objects[i], r.x + 240.0 * RoomScale, r.y - 512.0 * RoomScale, r.z - 364 * RoomScale, True)
				
				EntityParent(r.Objects[i], r.obj)
			}
			
			RotateEntity(r.Objects[1], 10, -180, 0)
			
			EntityPickMode(r.Objects[1], 1, False)
			EntityRadius(r.Objects[1], 0.1)
			
			r.Objects[2] = LoadMesh_Strict("GFX/map/room012_2.b3d")
			ScaleEntity(r.Objects[2], RoomScale, RoomScale, RoomScale)
			PositionEntity(r.Objects[2], r.x - 360 * RoomScale, - 130 * RoomScale, r.z + 456.0 * RoomScale, 0)
			EntityParent(r.Objects[2], r.obj)
			
			r.Objects[3] = CreateSprite()
			PositionEntity(r.Objects[3], r.x - 43.5 * RoomScale, - 574 * RoomScale, r.z - 362.0 * RoomScale)
			ScaleSprite(r.Objects[3], 0.015, 0.015)
			EntityTexture(r.Objects[3], LightSpriteTex(1))
			EntityBlend (r.Objects[3], 3)
			EntityParent(r.Objects[3], r.obj)
			HideEntity(r.Objects[3])
			
			r.Objects[4] = LoadMesh_Strict("GFX/map/room012_3.b3d")
			tex=LoadTexture_Strict("GFX/map/scp-012_0.jpg")
			EntityTexture(r.Objects[4],tex, 0,1)
			ScaleEntity(r.Objects[4], RoomScale, RoomScale, RoomScale)
			PositionEntity(r.Objects[4], r.x - 360 * RoomScale, - 130 * RoomScale, r.z + 456.0 * RoomScale, 0)
			EntityParent(r.Objects[4], r.Objects[2])
			
			it = CreateItem("Document SCP-012", "paper", r.x - 56.0 * RoomScale, r.y - 576.0 * RoomScale, r.z - 408.0 * RoomScale)
			EntityParent(it.collider, r.obj)
			
			it.Items = CreateItem("Severed Hand", "hand", r.x - 784*RoomScale, -576*RoomScale+0.3, r.z+640*RoomScale)
			EntityParent(it.collider, r.obj)
			
			de.Decals = CreateDecal(3,  r.x - 784*RoomScale, -768*RoomScale+0.01, r.z+640*RoomScale,90,Rnd(360),0)
			de.Size = 0.5
			ScaleSprite(de.obj, de.Size,de.Size)
			EntityParent(de.obj, r.obj)
			//[End Block]
		case "tunnel2":
			//[Block]
			r.Objects[0] = CreatePivot(r.obj)
			PositionEntity(r.Objects[0], r.x, 544.0 * RoomScale, r.z + 512.0 * RoomScale, True)
			
			r.Objects[1] = CreatePivot(r.obj)
			PositionEntity(r.Objects[1], r.x, 544.0 * RoomScale, r.z - 512.0 * RoomScale, True)
			//[End Block]
		case "room2pipes":
			//[Block]
			r.Objects[0]= CreatePivot(r.obj)
			PositionEntity(r.Objects[0], r.x + 368.0 * RoomScale, 0.0, r.z, True)
			
			r.Objects[1] = CreatePivot(r.obj)
			PositionEntity(r.Objects[1], r.x - 368.0 * RoomScale, 0.0, r.z, True)
			
			r.Objects[2] = CreatePivot(r.obj)
			PositionEntity(r.Objects[2], r.x + 224.0 * RoomScale - 0.005, 192.0 * RoomScale, r.z, True)
			
			r.Objects[3] = CreatePivot(r.obj)
			PositionEntity(r.Objects[3], r.x - 224.0 * RoomScale + 0.005, 192.0 * RoomScale, r.z, True)
			//[End Block]
		case "room3pit":
			//[Block]
			em.Emitters = CreateEmitter(r.x + 512.0 * RoomScale, -76 * RoomScale, r.z - 688 * RoomScale, 0)
			TurnEntity(em.Obj, -90, 0, 0)
			EntityParent(em.Obj, r.obj)
			em.RandAngle = 55
			em.Speed = 0.0005
			em.Achange = -0.015
			em.SizeChange = 0.007
			
			em.Emitters = CreateEmitter(r.x - 512.0 * RoomScale, -76 * RoomScale, r.z - 688 * RoomScale, 0)
			TurnEntity(em.Obj, -90, 0, 0)
			EntityParent(em.Obj, r.obj)
			em.RandAngle = 55
			em.Speed = 0.0005
			em.Achange = -0.015
			em.SizeChange = 0.007
			
			r.Objects[0]= CreatePivot(r.obj)
			PositionEntity(r.Objects[0], r.x + 704.0 * RoomScale, 112.0*RoomScale, r.z-416.0*RoomScale, True)
			//[End Block]
		case "room2servers":
			//[Block]
			d.Doors = CreateDoor(0, r.x,0,r.z, 0, r, False, 2, False)
			d.locked = True
			
			r.RoomDoors[0] = CreateDoor(r.zone, r.x - 208.0 * RoomScale, 0.0, r.z - 736.0 * RoomScale, 90, r, True, False, False, "", True)
			r.RoomDoors[0].AutoClose=False
			r.RoomDoors[1] = CreateDoor(r.zone, r.x - 208.0 * RoomScale, 0.0, r.z + 736.0 * RoomScale, 90, r, True, False, False, "", True)
			r.RoomDoors[1].AutoClose=False
			
			r.RoomDoors[2] = CreateDoor(r.zone, r.x - 672.0 * RoomScale, 0.0, r.z - 1024.0 * RoomScale, 0, r, False, False, False, "GEAR")
			r.RoomDoors[2].AutoClose=False
			r.RoomDoors[2].DisableWaypoint = True 
			FreeEntity(r.RoomDoors[2].buttons[0])
			r.RoomDoors[2].buttons[0]=0
			FreeEntity(r.RoomDoors[2].buttons[1])
			r.RoomDoors[2].buttons[1]=0
			
			for (n of range(3)) {
				r.Objects[n * 2] = CopyEntity(LeverBaseOBJ)
				r.Objects[n * 2 + 1] = CopyEntity(LeverOBJ)
				
				r.Levers[n] = r.Objects[n * 2 + 1]
				
				for (i of range(2)) {
					ScaleEntity(r.Objects[n * 2 + i], 0.03, 0.03, 0.03)
					
					switch (n) {
						case 0: //power switch
							PositionEntity (r.Objects[n * 2 + i], r.x - 1260.0 * RoomScale, r.y + 234.0 * RoomScale, r.z + 750 * RoomScale, True)	
						case 1: //generator fuel pump
							PositionEntity (r.Objects[n * 2 + i], r.x - 920.0 * RoomScale, r.y + 164.0 * RoomScale, r.z + 898 * RoomScale, True)
						case 2: //generator on/off
							PositionEntity (r.Objects[n * 2 + i], r.x - 837.0 * RoomScale, r.y + 152.0 * RoomScale, r.z + 886 * RoomScale, True)
					}
					
					EntityParent(r.Objects[n * 2 + i], r.obj)
				}
				RotateEntity(r.Objects[n*2+1], 81, -180, 0)
				
				EntityPickMode(r.Objects[n * 2 + 1], 1, False)
				EntityRadius(r.Objects[n * 2 + 1], 0.1)
			}
			
			RotateEntity(r.Objects[2+1], -81, -180, 0)
			RotateEntity(r.Objects[4+1], -81, -180, 0)
			
			//096 spawnpoint
			r.Objects[6]=CreatePivot(r.obj)
			PositionEntity(r.Objects[6],r.x-320*RoomScale,0.5,r.z,True)
			//guard spawnpoint
			r.Objects[7]=CreatePivot(r.obj)
			PositionEntity(r.Objects[7], r.x - 1328.0 * RoomScale, 0.5, r.z + 528*RoomScale, True)
			//the point where the guard walks to
			r.Objects[8]=CreatePivot(r.obj)
			PositionEntity(r.Objects[8], r.x - 1376.0 * RoomScale, 0.5, r.z + 32*RoomScale, True)
			
			r.Objects[9]=CreatePivot(r.obj)
			PositionEntity(r.Objects[9], r.x - 848*RoomScale, 0.5, r.z+576*RoomScale, True)
			//[End Block]
		case "room3servers":
			//[Block]
			it = CreateItem("9V Battery", "bat", r.x - 132.0 * RoomScale, r.y - 368.0 * RoomScale, r.z - 648.0 * RoomScale)
			EntityParent(it.collider, r.obj)
			if (Rand(2) == 1) {
				it = CreateItem("9V Battery", "bat", r.x - 76.0 * RoomScale, r.y - 368.0 * RoomScale, r.z - 648.0 * RoomScale)
				EntityParent(it.collider, r.obj)
			}
			if (Rand(2) == 1) {
				it = CreateItem("9V Battery", "bat", r.x - 196.0 * RoomScale, r.y - 368.0 * RoomScale, r.z - 648.0 * RoomScale)
				EntityParent(it.collider, r.obj)
			}
			
			it = CreateItem("S-NAV 300 Navigator", "nav", r.x + 124.0 * RoomScale, r.y - 368.0 * RoomScale, r.z - 648.0 * RoomScale)
			it.state = 20
			EntityParent(it.collider, r.obj)
			
			r.Objects[0] = CreatePivot(r.obj)
			PositionEntity(r.Objects[0], r.x + 736.0 * RoomScale, -512.0 * RoomScale, r.z - 400.0 * RoomScale, True)
			r.Objects[1] = CreatePivot(r.obj)
			PositionEntity(r.Objects[1], r.x - 552.0 * RoomScale, -512.0 * RoomScale, r.z - 528.0 * RoomScale, True)			
			r.Objects[2] = CreatePivot(r.obj)
			PositionEntity(r.Objects[2], r.x + 736.0 * RoomScale, -512.0 * RoomScale, r.z + 272.0 * RoomScale, True)
			
			r.Objects[3] = LoadMesh_Strict("GFX/npcs/duck_low_res.b3d")
			ScaleEntity(r.Objects[3], 0.07, 0.07, 0.07)
			tex = LoadTexture_Strict("GFX/npcs/duck2.png")
			EntityTexture(r.Objects[3], tex)
			PositionEntity (r.Objects[3], r.x + 928.0 * RoomScale, -640*RoomScale, r.z + 704.0 * RoomScale)
			
			EntityParent(r.Objects[3], r.obj)
			//[End Block]
		case "room3servers2":
			//[Block]
			r.Objects[0] = CreatePivot(r.obj)
			PositionEntity(r.Objects[0], r.x - 504.0 * RoomScale, -512.0 * RoomScale, r.z + 271.0 * RoomScale, True)
			r.Objects[1] = CreatePivot(r.obj)
			PositionEntity(r.Objects[1], r.x + 628.0 * RoomScale, -512.0 * RoomScale, r.z + 271.0 * RoomScale, True)			
			r.Objects[2] = CreatePivot(r.obj)
			PositionEntity(r.Objects[2], r.x - 532.0 * RoomScale, -512.0 * RoomScale, r.z - 877.0 * RoomScale, True)	
			
			it = CreateItem("Document SCP-970", "paper", r.x + 960.0 * RoomScale, r.y - 448.0 * RoomScale, r.z + 251.0 * RoomScale)
			RotateEntity(it.collider, 0, r.angle, 0)
			EntityParent(it.collider, r.obj)		
			
			it = CreateItem("Gas Mask", "gasmask", r.x + 954.0 * RoomScale, r.y - 504.0 * RoomScale, r.z + 235.0 * RoomScale)
			EntityParent(it.collider, r.obj)		
			//[End Block]
		case "testroom":
			//[Block]
			for (xtemp of range(2)) {
				for (ztemp of range(-1, 2)) {
					r.Objects[xtemp * 3 + (ztemp + 1)] = CreatePivot()
					PositionEntity(r.Objects[xtemp * 3 + (ztemp + 1)], r.x + (-236.0 + 280.0 * xtemp) * RoomScale, -700.0 * RoomScale, r.z + 384.0 * ztemp * RoomScale)
					EntityParent(r.Objects[xtemp * 3 + (ztemp + 1)], r.obj)
				}
			}
			
			r.Objects[6] = CreatePivot()
			PositionEntity(r.Objects[6], r.x + 754.0 * RoomScale, r.y - 1248.0 * RoomScale, r.z)
			EntityParent(r.Objects[6], r.obj)
			
			sc.SecurityCams = CreateSecurityCam(r.x + 744.0 * RoomScale, r.y - 856.0 * RoomScale, r.z + 236.0 * RoomScale, r)
			sc.FollowPlayer = True
			
			CreateDoor(0, r.x + 720.0 * RoomScale, 0, r.z, 0, r, False, 2, -1)
			
			CreateDoor(0, r.x - 624.0 * RoomScale, -1280.0 * RoomScale, r.z, 90, r, True)			
			
			it = CreateItem("Document SCP-682", "paper", r.x + 656.0 * RoomScale, r.y - 1200.0 * RoomScale, r.z - 16.0 * RoomScale)
			EntityParent(it.collider, r.obj)
			//[End Block]
		case "room2closets":
			//[Block]
			it = CreateItem("Document SCP-1048", "paper", r.x + 736.0 * RoomScale, r.y + 176.0 * RoomScale, r.z + 736.0 * RoomScale)
			EntityParent(it.collider, r.obj)
			
			it = CreateItem("Gas Mask", "gasmask", r.x + 736.0 * RoomScale, r.y + 176.0 * RoomScale, r.z + 544.0 * RoomScale)
			EntityParent(it.collider, r.obj)
			
			it = CreateItem("9V Battery", "bat", r.x + 736.0 * RoomScale, r.y + 176.0 * RoomScale, r.z - 448.0 * RoomScale)
			EntityParent(it.collider, r.obj)
			if (Rand(2) = 1) {
				it = CreateItem("9V Battery", "bat", r.x + 730.0 * RoomScale, r.y + 176.0 * RoomScale, r.z - 496.0 * RoomScale)
				EntityParent(it.collider, r.obj)
			}
			if (Rand(2) = 1) {
				it = CreateItem("9V Battery", "bat", r.x + 740.0 * RoomScale, r.y + 176.0 * RoomScale, r.z - 560.0 * RoomScale)
				EntityParent(it.collider, r.obj)
			}
			
			it = CreateItem("Level 1 Key Card", "key1", r.x + 736.0 * RoomScale, r.y + 240.0 * RoomScale, r.z + 752.0 * RoomScale)
			EntityParent(it.collider, r.obj)
			
			let clipboard: Items = CreateItem("Clipboard","clipboard",r.x + 736.0 * RoomScale, r.y + 224.0 * RoomScale, r.z -480.0 * RoomScale)
			EntityParent(it.collider, r.obj)
			
			it = CreateItem("Incident Report SCP-1048-A", "paper",r.x + 736.0 * RoomScale, r.y + 224.0 * RoomScale, r.z -480.0 * RoomScale)
			//clipboard.SecondInv[0] = it
			HideEntity(it.collider)
			
			r.Objects[0]=CreatePivot(r.obj)
			PositionEntity(r.Objects[0], r.x-1120*RoomScale, -256*RoomScale, r.z+896*RoomScale, True)
			r.Objects[1]=CreatePivot(r.obj)
			PositionEntity(r.Objects[1], r.x-1232*RoomScale, -256*RoomScale, r.z-160*RoomScale, True)
			
			d.Doors = CreateDoor(0, r.x - 240.0 * RoomScale, 0.0, r.z, 90, r, False)
			PositionEntity(d.buttons[0], r.x - 230.0 * RoomScale, EntityY(d.buttons[0],True), EntityZ(d.buttons[0],True), True)
			PositionEntity(d.buttons[1], r.x - 250.0 * RoomScale, EntityY(d.buttons[1],True), EntityZ(d.buttons[1],True), True)
			d.open = False
			d.AutoClose = False
			
			sc.SecurityCams = CreateSecurityCam(r.x, r.y + 704*RoomScale, r.z + 863*RoomScale, r)
			sc.angle = 180
			sc.turn = 45
			TurnEntity(sc.CameraObj, 20, 0, 0)
			//[End Block]
		case "room2offices":
			//[Block]
			it = CreateItem("Document SCP-106", "paper", r.x + 404.0 * RoomScale, r.y + 145.0 * RoomScale, r.z + 559.0 * RoomScale)
			EntityParent(it.collider, r.obj)
			
			it = CreateItem("Level 2 Key Card", "key2", r.x - 156.0 * RoomScale, r.y + 151.0 * RoomScale, r.z + 72.0 * RoomScale)
			EntityParent(it.collider, r.obj)
			
			it = CreateItem("S-NAV 300 Navigator", "nav", r.x + 305.0 * RoomScale, r.y + 153.0 * RoomScale, r.z + 944.0 * RoomScale)
			it.state = 20
			EntityParent(it.collider, r.obj)
			
			it = CreateItem("Notification", "paper", r.x -137.0 * RoomScale, r.y + 153.0 * RoomScale, r.z + 464.0 * RoomScale)
			EntityParent(it.collider, r.obj)
			
			w.waypoints = CreateWaypoint(r.x - 32.0 * RoomScale, r.y + 66.0 * RoomScale, r.z + 288.0 * RoomScale, null, r)
			w2.waypoints = CreateWaypoint(r.x, r.y + 66.0 * RoomScale, r.z - 448.0 * RoomScale, null, r)
			w.connected[0] = w2
			w.dist[0] = EntityDistance(w.obj, w2.obj)
			w2.connected[0] = w
			w2.dist[0] = w.dist[0]
			//[End Block]
		case "room2offices2":
			//[Block]
			it = CreateItem("Level 1 Key Card", "key1", r.x - 368.0 * RoomScale, r.y - 48.0 * RoomScale, r.z + 80.0 * RoomScale)
			EntityParent(it.collider, r.obj)
			
			it = CreateItem("Document SCP-895", "paper", r.x - 800.0 * RoomScale, r.y - 48.0 * RoomScale, r.z + 368.0 * RoomScale)
			EntityParent(it.collider, r.obj)
			if (Rand(2) = 1) {
				it = CreateItem("Document SCP-860", "paper", r.x - 800.0 * RoomScale, r.y - 48.0 * RoomScale, r.z - 464.0 * RoomScale)
			} else {
				it = CreateItem("SCP-093 Recovered Materials", "paper", r.x - 800.0 * RoomScale, r.y - 48.0 * RoomScale, r.z - 464.0 * RoomScale)
			}
			EntityParent(it.collider, r.obj)
			
			it = CreateItem("S-NAV 300 Navigator", "nav", r.x - 336.0 * RoomScale, r.y - 48.0 * RoomScale, r.z - 480.0 * RoomScale)
			it.state = 28
			EntityParent(it.collider, r.obj)		
			
			r.Objects[0] = LoadMesh_Strict("GFX/npcs/duck_low_res.b3d")
			ScaleEntity(r.Objects[0], 0.07, 0.07, 0.07)
			
			EntityParent(r.Objects[0], r.obj)
			
			r.Objects[1] = CreatePivot(r.obj)
			PositionEntity(r.Objects[1], r.x-808.0 * RoomScale, -72.0 * RoomScale, r.z - 40.0 * RoomScale, True)
			r.Objects[2] = CreatePivot(r.obj)
			PositionEntity(r.Objects[2], r.x-488.0 * RoomScale, 160.0 * RoomScale, r.z + 700.0 * RoomScale, True)
			r.Objects[3] = CreatePivot(r.obj)
			PositionEntity(r.Objects[3], r.x-488.0 * RoomScale, 160.0 * RoomScale, r.z - 668.0 * RoomScale, True)
			r.Objects[4] = CreatePivot(r.obj)
			PositionEntity(r.Objects[4], r.x-572.0 * RoomScale, 350.0 * RoomScale, r.z - 4.0 * RoomScale, True)
			
			temp = Rand(1,4)
			PositionEntity(r.Objects[0], EntityX(r.Objects[temp],True),EntityY(r.Objects[temp],True),EntityZ(r.Objects[temp],True),True)
			//[End Block]
		case "room2offices3":
			//[Block]
			if (Rand(2) == 1) { 
				it = CreateItem("Mobile Task Forces", "paper", r.x + 744.0 * RoomScale, r.y +240.0 * RoomScale, r.z + 944.0 * RoomScale)
				EntityParent(it.collider, r.obj)	
			} else {
				it = CreateItem("Security Clearance Levels", "paper", r.x + 680.0 * RoomScale, r.y +240.0 * RoomScale, r.z + 944.0 * RoomScale)
				EntityParent(it.collider, r.obj)			
			}
			
			it = CreateItem("Object Classes", "paper", r.x + 160.0 * RoomScale, r.y +240.0 * RoomScale, r.z + 568.0 * RoomScale)
			EntityParent(it.collider, r.obj)	
			
			it = CreateItem("Document", "paper", r.x -1440.0 * RoomScale, r.y +624.0 * RoomScale, r.z + 152.0 * RoomScale)
			EntityParent(it.collider, r.obj)	
			
			it = CreateItem("Radio Transceiver", "radio", r.x - 1184.0 * RoomScale, r.y + 480.0 * RoomScale, r.z - 800.0 * RoomScale)
			EntityParent(it.collider, r.obj)				
			
			for (i of range(Rand(0,1) + 1)) {
				it = CreateItem("ReVision Eyedrops", "eyedrops", r.x - 1529.0*RoomScale, r.y + 563.0 * RoomScale, r.z - 572.0*RoomScale + i*0.05)
				EntityParent(it.collider, r.obj)				
			}
			
			it = CreateItem("9V Battery", "bat", r.x - 1545.0 * RoomScale, r.y + 603.0 * RoomScale, r.z - 372.0 * RoomScale)
			EntityParent(it.collider, r.obj)
			if (Rand(2) == 1) {
				it = CreateItem("9V Battery", "bat", r.x - 1540.0 * RoomScale, r.y + 603.0 * RoomScale, r.z - 340.0 * RoomScale)
				EntityParent(it.collider, r.obj)
			}
			if (Rand(2) == 1) {
				it = CreateItem("9V Battery", "bat", r.x - 1529.0 * RoomScale, r.y + 603.0 * RoomScale, r.z - 308.0 * RoomScale)
				EntityParent(it.collider, r.obj)
			}
			
			r.RoomDoors[0] = CreateDoor(r.zone, r.x - 1056.0 * RoomScale, 384.0*RoomScale, r.z + 290.0 * RoomScale, 90, r, True)
			r.RoomDoors[0].AutoClose = False
			r.RoomDoors[0].open = True
			PositionEntity(r.RoomDoors[0].buttons[0], EntityX(r.RoomDoors[0].buttons[0],True),EntityY(r.RoomDoors[0].buttons[0],True),r.z + 161.0 * RoomScale,True)
			PositionEntity(r.RoomDoors[0].buttons[1], EntityX(r.RoomDoors[0].buttons[1],True),EntityY(r.RoomDoors[0].buttons[1],True),r.z + 161.0 * RoomScale,True)
			//[End Block]
		case "start":
			//[Block]
			//the containment doors
			r.RoomDoors[1] = CreateDoor(r.zone, r.x + 4000.0 * RoomScale, 384.0*RoomScale, r.z + 1696.0 * RoomScale, 90, r, True, True)
			r.RoomDoors[1].locked = False
			r.RoomDoors[1].AutoClose = False
			r.RoomDoors[1].dir = 1
			r.RoomDoors[1].open = True 
			FreeEntity(r.RoomDoors[1].buttons[0])
			r.RoomDoors[1].buttons[0] = 0
			FreeEntity(r.RoomDoors[1].buttons[1])
			r.RoomDoors[1].buttons[1] = 0
			r.RoomDoors[1].MTFClose = False
			
			r.RoomDoors[2] = CreateDoor(r.zone, r.x + 2704.0 * RoomScale, 384.0*RoomScale, r.z + 624.0 * RoomScale, 90, r, False)
			r.RoomDoors[2].AutoClose = False
			r.RoomDoors[2].open = False
			FreeEntity(r.RoomDoors[2].buttons[0])
			r.RoomDoors[2].buttons[0] = 0
			FreeEntity(r.RoomDoors[2].buttons[1])
			r.RoomDoors[2].buttons[1] = 0
			r.RoomDoors[2].MTFClose = False
			
			d.Doors = CreateDoor(r.zone, r.x + 1392.0 * RoomScale, 384.0*RoomScale, r.z + 64.0 * RoomScale, 90, r, True)
			d.AutoClose = False
			d.MTFClose = False
			d.locked = True
			
			d.Doors = CreateDoor(r.zone, r.x - 640.0 * RoomScale, 384.0*RoomScale, r.z + 64.0 * RoomScale, 90, r, False)
			d.locked = True
			d.AutoClose = False
			
			d.Doors = CreateDoor(r.zone, r.x + 1280.0 * RoomScale, 384.0*RoomScale, r.z + 312.0 * RoomScale, 180, r, True)
			d.locked = True
			d.AutoClose = False
			PositionEntity(d.buttons[0], r.x + 1120.0 * RoomScale, EntityY(d.buttons[0],True), r.z + 328.0 * RoomScale, True)
			PositionEntity(d.buttons[1], r.x + 1120.0 * RoomScale, EntityY(d.buttons[1],True), r.z + 296.0 * RoomScale, True)
			FreeEntity(d.obj2)
			d.obj2=0
			d.MTFClose = False
			
			d.Doors = CreateDoor(r.zone, r.x, 0, r.z + 1184.0 * RoomScale, 0, r, False)
			d.locked = True
			
			r.Objects[0] = LoadMesh_Strict("GFX/map/IntroDesk.b3d")
			ScaleEntity(r.Objects[0], RoomScale, RoomScale ,RoomScale)
			PositionEntity(r.Objects[0], r.x + 272.0 * RoomScale, 0, r.z + 400.0 * RoomScale)
			EntityParent(r.Objects[0], r.obj)
			
			de.Decals = CreateDecal(0, r.x + 272.0 * RoomScale, 0.005, r.z + 262.0 * RoomScale, 90, Rand(360), 0)
			EntityParent(de.obj, r.obj)
			
			r.Objects[1] = LoadMesh_Strict("GFX/map/IntroDrawer.b3d")
			ScaleEntity(r.Objects[1], RoomScale, RoomScale ,RoomScale)
			PositionEntity(r.Objects[1], r.x + 448.0 * RoomScale, 0, r.z + 192.0 * RoomScale)
			EntityParent(r.Objects[1], r.obj)
			
			de.Decals = CreateDecal(0, r.x + 456.0 * RoomScale, 0.005, r.z + 135.0 * RoomScale, 90, Rand(360), 0)
			EntityParent(de.obj, r.obj)
			
			sc.SecurityCams = CreateSecurityCam(r.x - 336.0 * RoomScale, r.y + 352 * RoomScale, r.z + 48.0 * RoomScale, r, True)
			sc.angle = 270
			sc.turn = 45
			sc.room = r
			TurnEntity(sc.CameraObj, 20, 0, 0)
			EntityParent(sc.obj, r.obj)
			
			PositionEntity(sc.ScrObj, r.x + 1456 * RoomScale, 608 * RoomScale, r.z +352.0 * RoomScale)
			TurnEntity(sc.ScrObj, 0, 90, 0)
			EntityParent(sc.ScrObj, r.obj)
			
			r.Objects[2] = CreatePivot()
			PositionEntity (r.Objects[2], EntityX(r.obj) + 40.0 * RoomScale, 460.0 * RoomScale, EntityZ(r.obj) + 1072.0 * RoomScale)
			r.Objects[3] = CreatePivot()
			PositionEntity (r.Objects[3], EntityX(r.obj) - 80.0 * RoomScale, 100.0 * RoomScale, EntityZ(r.obj) + 526.0 * RoomScale)
			r.Objects[4] = CreatePivot()
			PositionEntity (r.Objects[4], EntityX(r.obj) - 128.0 * RoomScale, 100.0 * RoomScale, EntityZ(r.obj) + 320.0 * RoomScale)
			
			r.Objects[5] = CreatePivot()
			PositionEntity (r.Objects[5], EntityX(r.obj) + 660.0 * RoomScale, 100.0 * RoomScale, EntityZ(r.obj) + 526.0 * RoomScale)
			r.Objects[6] = CreatePivot()
			PositionEntity (r.Objects[6], EntityX(r.obj) + 700 * RoomScale, 100.0 * RoomScale, EntityZ(r.obj) + 320.0 * RoomScale)
			
			r.Objects[7] = CreatePivot()
			PositionEntity (r.Objects[7], EntityX(r.obj) + 1472.0 * RoomScale, 100.0 * RoomScale, EntityZ(r.obj) + 912.0 * RoomScale)
			
			for (i of range(2, 8)) {
				EntityParent(r.Objects[i], r.obj)
			}
			
			//3384,510,2400
			CreateDevilEmitter(r.x+3384.0*RoomScale,r.y+510.0*RoomScale,r.z+2400.0*RoomScale,r,1,4)
			//[End Block]
		case "room2scps":
			//[Block]
			d.Doors = CreateDoor(r.zone, r.x + 264.0 * RoomScale, 0, r.z, 90, r, True, False, 3)
			d.AutoClose = False
			d.open = False
			PositionEntity(d.buttons[0], r.x + 320.0 * RoomScale, EntityY(d.buttons[0],True), EntityZ(d.buttons[0],True), True)
			PositionEntity(d.buttons[1], r.x + 224.0 * RoomScale, EntityY(d.buttons[1],True), EntityZ(d.buttons[1],True), True)
			
			d.Doors = CreateDoor(r.zone, r.x - 264.0 * RoomScale, 0, r.z, 270, r, True, False, 3)
			d.AutoClose = False
			d.open = False
			PositionEntity(d.buttons[0], r.x - 320.0 * RoomScale, EntityY(d.buttons[0],True), EntityZ(d.buttons[0],True), True)
			PositionEntity(d.buttons[1], r.x - 224.0 * RoomScale, EntityY(d.buttons[1],True), EntityZ(d.buttons[1],True), True)
			
			r.RoomDoors[1] = CreateDoor(r.zone, r.x-560.0 * RoomScale, 0, r.z - 272.0 * RoomScale, 0, r, True, False, 3)
			r.RoomDoors[1].AutoClose = False
			r.RoomDoors[1].open = False
			
			r.RoomDoors[2] = CreateDoor(r.zone, r.x + 560.0 * RoomScale, 0, r.z - 272.0 * RoomScale, 180, r, True, False, 3)
			r.RoomDoors[2].AutoClose = False
			r.RoomDoors[2].open = False
			
			r.RoomDoors[3] = CreateDoor(r.zone, r.x + 560.0 * RoomScale, 0, r.z + 272.0 * RoomScale, 180, r, True, False, 3)
			r.RoomDoors[3].AutoClose = False
			r.RoomDoors[3].open = False
			
			r.RoomDoors[4] = CreateDoor(r.zone, r.x-560.0 * RoomScale, 0, r.z + 272.0 * RoomScale, 0, r, True, False, 3)
            r.RoomDoors[4].AutoClose = False
			r.RoomDoors[4].open = False
			
			it = CreateItem("SCP-714", "scp714", r.x - 552.0 * RoomScale, r.y + 220.0 * RoomScale, r.z - 760.0 * RoomScale)
			EntityParent(it.collider, r.obj)
			
			it = CreateItem("SCP-1025", "scp1025", r.x + 552.0 * RoomScale, r.y + 224.0 * RoomScale, r.z - 758.0 * RoomScale)
			EntityParent(it.collider, r.obj)
			
			it = CreateItem("SCP-860", "scp860", r.x + 568.0 * RoomScale, r.y + 178.0 * RoomScale, r.z + 760.0 * RoomScale)
			EntityParent(it.collider, r.obj)
			
			sc.SecurityCams = CreateSecurityCam(r.x + 560.0 * RoomScale, r.y + 386 * RoomScale, r.z - 416.0 * RoomScale, r)
			sc.angle = 180
			sc.turn = 30
			TurnEntity(sc.CameraObj, 30, 0, 0)
			EntityParent(sc.obj, r.obj)
			
			sc.SecurityCams = CreateSecurityCam(r.x - 560.0 * RoomScale, r.y + 386 * RoomScale, r.z - 416.0 * RoomScale, r)
			sc.angle = 180
			sc.turn = 30
			TurnEntity(sc.CameraObj, 30, 0, 0)
			EntityParent(sc.obj, r.obj)
			
			sc.SecurityCams = CreateSecurityCam(r.x + 560.0 * RoomScale, r.y + 386 * RoomScale, r.z + 480.0 * RoomScale, r)
            sc.angle = 0
			sc.turn = 30
            TurnEntity(sc.CameraObj, 30, 0, 0)
            EntityParent(sc.obj, r.obj)
			
            sc.SecurityCams = CreateSecurityCam(r.x - 560.0 * RoomScale, r.y + 386 * RoomScale, r.z + 480.0 * RoomScale, r)
            sc.angle = 0
			sc.turn = 30
            TurnEntity(sc.CameraObj, 30, 0, 0)
            EntityParent(sc.obj, r.obj)
			
			it = CreateItem("Document SCP-714", "paper", r.x - 728.0 * RoomScale, r.y + 288.0 * RoomScale, r.z - 360.0 * RoomScale)
			EntityParent(it.collider, r.obj)
			
			it = CreateItem("Document SCP-427", "paper", r.x - 608.0 * RoomScale, r.y + 66.0 * RoomScale, r.z + 636.0 * RoomScale)
			EntityParent(it.collider, r.obj)
			
			let dx: float,dy: float
			for (i of range(15)) {
				switch (i) {
					case 0:
						dx = -64.0
						dz = -516.0
					case 1:
						dx = -96.0
						dz = -388.0
					case 2:
						dx = -128.0
						dz = -292.0
					case 3:
						dx = -128.0
						dz = -132.0
					case 4:
						dx = -160.0
						dz = -36.0
					case 5:
						dx = -192.0
						dz = 28.0
					case 6:
						dx = -384.0
						dz = 28.0
					case 7:
						dx = -448.0
						dz = 92.0
					case 8:
						dx = -480.0
						dz = 124.0
					case 9:
						dx = -512.0
						dz = 156.0
					case 10:
						dx = -544.0
						dz = 220.0
					case 11:
						dx = -544.0
						dz = 380.0
					case 12:
						dx = -544.0
						dz = 476.0
					case 13:
						dx = -544.0
						dz = 572.0
					case 14:
						dx = -544.0
						dz = 636.0
				}
				de.Decals = CreateDecal(Rand(15,16),r.x+dx * RoomScale,0.005,r.z+dz * RoomScale,90,Rand(360),0)
				if (i > 10) {
					de.Size = Rnd(0.2,0.25)
				} else {
					de.Size = Rnd(0.1,0.17)
				}
				EntityAlpha(de.obj, 1.0)
				ScaleSprite(de.obj,de.Size,de.Size)
				EntityParent(de.obj, r.obj)
			}
			//[End Block]
		case "room205":
			r.RoomDoors[1] = CreateDoor(r.zone, r.x + 128.0 * RoomScale, 0, r.z + 640.0 *RoomScale, 90, r, True, False, 3)
			r.RoomDoors[1].AutoClose = False
			r.RoomDoors[1].open = False
			
			r.RoomDoors[0] = CreateDoor(r.zone, r.x - 1392.0 * RoomScale, -128.0 * RoomScale, r.z - 384*RoomScale, 0, r, True, False, 3, "", True)
			r.RoomDoors[0].AutoClose = False
			r.RoomDoors[0].open = False
			FreeEntity(r.RoomDoors[0].buttons[0])
			r.RoomDoors[0].buttons[0]=0
			FreeEntity(r.RoomDoors[0].buttons[1])
			r.RoomDoors[0].buttons[1]=0
			
			sc.SecurityCams = CreateSecurityCam(r.x - 1152.0 * RoomScale, r.y + 900.0 * RoomScale, r.z + 176.0 * RoomScale, r, True)
			sc.angle = 90
			sc.turn = 0
			EntityParent(sc.obj, r.obj)
			
			sc.AllowSaving = False
			sc.RenderInterval = 0
			
			EntityParent(sc.ScrObj, 0)
			PositionEntity(sc.ScrObj, r.x - 1716.0 * RoomScale, r.y + 160.0 * RoomScale, r.z + 176.0 * RoomScale, True)
			TurnEntity(sc.ScrObj, 0, 90, 0)
			ScaleSprite(sc.ScrObj, 896.0*0.5*RoomScale, 896.0*0.5*RoomScale)
			
			EntityParent(sc.ScrObj, r.obj)
			
			CameraZoom (sc.Cam, 1.5)
			
			HideEntity(sc.ScrOverlay)
			HideEntity(sc.MonitorObj)
			
			r.Objects[0] = CreatePivot(r.obj)
			PositionEntity(r.Objects[0], r.x - 1536.0 * RoomScale, r.y + 730.0 * RoomScale, r.z + 192.0 * RoomScale, True)
			RotateEntity(r.Objects[0], 0,-90,0,True)
			
			r.Objects[1] = sc.ScrObj
			
			//[End Block]
		case "endroom":
			//[Block]
			r.RoomDoors[0] = CreateDoor(r.zone, r.x, 0, r.z + 1136 * RoomScale, 0, r, False, True, 6)
			r.RoomDoors[0].AutoClose = False
			r.RoomDoors[0].open = False
			FreeEntity(r.RoomDoors[0].buttons[0])
			r.RoomDoors[0].buttons[0]=0
			FreeEntity(r.RoomDoors[0].buttons[1])
			r.RoomDoors[0].buttons[1]=0
			//[End Block]
		case "endroomc":
			//[Block]
			d = CreateDoor(r.zone, r.x+1024*RoomScale, 0, r.z, 0, r, False, 2, False, "")
			d.open = False
			d.AutoClose = False
			d.locked = True
			//[End Block]
		case "coffin":
			//[Block]
			d = CreateDoor(r.zone, r.x, 0, r.z - 448.0 * RoomScale, 0, r, False, True, 2)
			d.AutoClose = False
			d.open = False
			PositionEntity(d.buttons[0], r.x - 384.0 * RoomScale, 0.7, r.z - 280.0 * RoomScale, True)
			
			sc.SecurityCams = CreateSecurityCam(r.x - 320.0 * RoomScale, r.y + 704 * RoomScale, r.z + 288.0 * RoomScale, r, True)
			sc.angle = 45 + 180
			sc.turn = 45
			sc.CoffinEffect = True
			TurnEntity(sc.CameraObj, 120, 0, 0)
			EntityParent(sc.obj, r.obj)
			
			CoffinCam = sc
			
			PositionEntity(sc.ScrObj, r.x - 800 * RoomScale, 288.0 * RoomScale, r.z - 340.0 * RoomScale)
			EntityParent(sc.ScrObj, r.obj)
			TurnEntity(sc.ScrObj, 0, 180, 0)
			
			r.Objects[2] = CopyEntity(LeverBaseOBJ)
			r.Objects[3] = CopyEntity(LeverOBJ)
				
			r.Levers[0] = r.Objects[3]
				
			for (i of range(2)) {
				ScaleEntity(r.Objects[2 + i], 0.04, 0.04, 0.04)
				PositionEntity (r.Objects[2 + i], r.x - 800.0 * RoomScale, r.y + 180.0 * RoomScale, r.z - 336 * RoomScale, True)
					
				EntityParent(r.Objects[2 + i], r.obj)
			}
			RotateEntity(r.Objects[2], 0, 180, 0)
			RotateEntity(r.Objects[3], 10, 0, 0)
			
			EntityPickMode(r.Objects[3], 1, False)
			EntityRadius(r.Objects[3], 0.1)
			
			r.Objects[0] = CreatePivot()
			PositionEntity(r.Objects[0], r.x, -1320.0 * RoomScale, r.z + 2304.0 * RoomScale)
			EntityParent(r.Objects[0], r.obj)
			
			it = CreateItem("Document SCP-895", "paper", r.x - 688.0 * RoomScale, r.y + 133.0 * RoomScale, r.z - 304.0 * RoomScale)
			EntityParent(it.collider, r.obj)
			
			it = CreateItem("Level 3 Key Card", "key3", r.x + 240.0 * RoomScale, r.y -1456.0 * RoomScale, r.z + 2064.0 * RoomScale)
			EntityParent(it.collider, r.obj)
			
			it = CreateItem("Night Vision Goggles", "nvgoggles", r.x + 280.0 * RoomScale, r.y -1456.0 * RoomScale, r.z + 2164.0 * RoomScale)
			EntityParent(it.collider, r.obj)
			it.state = 400
			
			r.Objects[1] = CreatePivot(r.obj)
			PositionEntity(r.Objects[1], r.x + 96.0*RoomScale, -1532.0 * RoomScale, r.z + 2016.0 * RoomScale,True)
			
		case "room2tesla","room2tesla_lcz","room2tesla_hcz":
			//[Block]
			r.Objects[0] = CreatePivot()
			PositionEntity(r.Objects[0], r.x - 114.0 * RoomScale, 0.0, r.z)
			EntityParent(r.Objects[0], r.obj)
			
			r.Objects[1] = CreatePivot()
			PositionEntity(r.Objects[1], r.x + 114.0 * RoomScale, 0.0, r.z)
			EntityParent(r.Objects[1], r.obj)			
			
			r.Objects[2] = CreatePivot()
			PositionEntity(r.Objects[2], r.x, 0.0, r.z)
			EntityParent(r.Objects[2], r.obj)	
			
			r.Objects[3] = CreateSprite()
			EntityTexture (r.Objects[3], TeslaTexture)
			SpriteViewMode(r.Objects[3],2) 
			EntityBlend (r.Objects[3], 3) 
			EntityFX(r.Objects[3], 1 + 8 + 16)
			
			PositionEntity(r.Objects[3], r.x, 0.8, r.z)
			
			HideEntity(r.Objects[3])
			EntityParent(r.Objects[3], r.obj)
			
			w.waypoints = CreateWaypoint(r.x, r.y + 66.0 * RoomScale, r.z + 292.0 * RoomScale, null, r)
			w2.waypoints = CreateWaypoint(r.x, r.y + 66.0 * RoomScale, r.z - 284.0 * RoomScale, null, r)
			w.connected[0] = w2
			w.dist[0] = EntityDistance(w.obj, w2.obj)
			w2.connected[0] = w
			w2.dist[0] = w.dist[0]
			
			r.Objects[4] = CreateSprite()
			PositionEntity(r.Objects[4], r.x - 32 * RoomScale, 568 * RoomScale, r.z)
			ScaleSprite(r.Objects[4], 0.03, 0.03)
			EntityTexture(r.Objects[4], LightSpriteTex(1))
			EntityBlend (r.Objects[4], 3)
			EntityParent(r.Objects[4], r.obj)
			HideEntity(r.Objects[4])
			
			r.Objects[5] = CreatePivot()
			PositionEntity(r.Objects[5],r.x,0,r.z-800*RoomScale)
			EntityParent(r.Objects[5],r.obj)
			
			r.Objects[6] = CreatePivot()
			PositionEntity(r.Objects[6],r.x,0,r.z+800*RoomScale)
			EntityParent(r.Objects[6],r.obj)
			
			for (r2 of Rooms.each) {
				if (r2 != r) {
					if (r2.RoomTemplate.Name == "room2tesla" || r2.RoomTemplate.Name == "room2tesla_lcz" || r2.RoomTemplate.Name == "room2tesla_hcz") {
						r.Objects[7] = CopyEntity(r2.Objects[7],r.obj) //don't load the mesh again
						break
					}
				}
			}
			if (r.Objects[7] == 0) {
				r.Objects[7] = LoadMesh_Strict("GFX/map/room2tesla_caution.b3d",r.obj)
			}
			
		case "room2doors":
			//[Block]
			d = CreateDoor(r.zone, r.x, 0, r.z + 528.0 * RoomScale, 0, r, True)
			d.AutoClose = False
			PositionEntity (d.buttons[0], r.x - 832.0 * RoomScale, 0.7, r.z + 160.0 * RoomScale, True)
			PositionEntity (d.buttons[1], r.x + 160.0 * RoomScale, 0.7, r.z + 536.0 * RoomScale, True)
			
			d2 = CreateDoor(r.zone, r.x, 0, r.z - 528.0 * RoomScale, 180, r, True)
			d2.AutoClose = False
			FreeEntity (d2.buttons[0])
			d2.buttons[0] = 0
			PositionEntity (d2.buttons[1], r.x +160.0 * RoomScale, 0.7, r.z - 536.0 * RoomScale, True)
			
			r.Objects[0] = CreatePivot()
			PositionEntity(r.Objects[0], r.x - 832.0 * RoomScale, 0.5, r.z)
			EntityParent(r.Objects[0], r.obj)
			
			d2.LinkedDoor = d
			d.LinkedDoor = d2
			
			d.open = False
			d2.open = True
		case "914":
			
			r.RoomDoors[2] = CreateDoor(r.zone,r.x,0,r.z-368.0*RoomScale,0,r,False,True,2)
			r.RoomDoors[2].dir=1
			r.RoomDoors[2].AutoClose=False
			r.RoomDoors[2].open=False
			PositionEntity (r.RoomDoors[2].buttons[0], r.x - 496.0 * RoomScale, 0.7, r.z - 272.0 * RoomScale, True)
			TurnEntity(r.RoomDoors[2].buttons[0], 0, 90, 0)
			
			r.Objects[0] = LoadMesh_Strict("GFX/map/914key.x")
			r.Objects[1] = LoadMesh_Strict("GFX/map/914knob.x")
			
			for (i of range(2)) {
				ScaleEntity(r.Objects[i], RoomScale, RoomScale, RoomScale)
				EntityPickMode(r.Objects[i], 2)
			}
			
			PositionEntity (r.Objects[0], r.x, r.y + 190.0 * RoomScale, r.z + 374.0 * RoomScale)
			PositionEntity (r.Objects[1], r.x, r.y + 230.0 * RoomScale, r.z + 374.0 * RoomScale)
			EntityParent(r.Objects[0], r.obj)
			EntityParent(r.Objects[1], r.obj)
			
			d = CreateDoor(r.zone, r.x - 624.0 * RoomScale, 0.0, r.z + 528.0 * RoomScale, 180, r, True)
			FreeEntity (d.obj2)
			d.obj2 = 0
			FreeEntity (d.buttons[0])
			d.buttons[0] = 0
			FreeEntity (d.buttons[1])
			d.buttons[1] = 0
			d.dir = 4
			r.RoomDoors[0] = d
			d.AutoClose = False
			
			d = CreateDoor(r.zone, r.x + 816.0 * RoomScale, 0.0, r.z + 528.0 * RoomScale, 180, r, True)
			FreeEntity (d.obj2)
			d.obj2 = 0	
			FreeEntity (d.buttons[0])
			d.buttons[0] = 0
			FreeEntity (d.buttons[1])
			d.buttons[1] = 0
			d.dir = 4
			r.RoomDoors[1] = d
			d.AutoClose = False
			
			r.Objects[2] = CreatePivot()
			r.Objects[3] = CreatePivot()
			PositionEntity(r.Objects[2], r.x - 712.0 * RoomScale, 0.5, r.z + 640.0 * RoomScale)
			PositionEntity(r.Objects[3], r.x + 728.0 * RoomScale, 0.5, r.z + 640.0 * RoomScale)
			EntityParent(r.Objects[2], r.obj)
			EntityParent(r.Objects[3], r.obj)
			
			it = CreateItem("Addendum: 5/14 Test Log", "paper", r.x +954.0 * RoomScale, r.y +228.0 * RoomScale, r.z + 127.0 * RoomScale)
			EntityParent(it.collider, r.obj)	
			
			it = CreateItem("First Aid Kit", "firstaid", r.x + 960.0 * RoomScale, r.y + 112.0 * RoomScale, r.z - 40.0 * RoomScale)
			EntityParent(it.collider, r.obj)
			RotateEntity(it.collider, 0, 90, 0)
			
			it = CreateItem("Dr. L's Note", "paper", r.x - 928.0 * RoomScale, 160.0 * RoomScale, r.z - 160.0 * RoomScale)
			EntityParent(it.collider, r.obj)

		case "173":
			//[Block]
			r.Objects[0] = CreatePivot()
			PositionEntity (r.Objects[0], EntityX(r.obj) + 40.0 * RoomScale, 460.0 * RoomScale, EntityZ(r.obj) + 1072.0 * RoomScale)
			r.Objects[1] = CreatePivot()
			PositionEntity (r.Objects[1], EntityX(r.obj) - 80.0 * RoomScale, 100.0 * RoomScale, EntityZ(r.obj) + 526.0 * RoomScale)
			r.Objects[2] = CreatePivot()
			PositionEntity (r.Objects[2], EntityX(r.obj) - 128.0 * RoomScale, 100.0 * RoomScale, EntityZ(r.obj) + 320.0 * RoomScale)
			
			r.Objects[3] = CreatePivot()
			PositionEntity (r.Objects[3], EntityX(r.obj) + 660.0 * RoomScale, 100.0 * RoomScale, EntityZ(r.obj) + 526.0 * RoomScale)
			r.Objects[4] = CreatePivot()
			PositionEntity (r.Objects[4], EntityX(r.obj) + 700 * RoomScale, 100.0 * RoomScale, EntityZ(r.obj) + 320.0 * RoomScale)
			
			r.Objects[5] = CreatePivot()
			PositionEntity (r.Objects[5], EntityX(r.obj) + 1472.0 * RoomScale, 100.0 * RoomScale, EntityZ(r.obj) + 912.0 * RoomScale)
			
			for (i of range(6)) {
				EntityParent(r.Objects[i], r.obj)
			}
			
			r.RoomDoors[1] = CreateDoor(r.zone, EntityX(r.obj) + 288.0 * RoomScale, 0, EntityZ(r.obj) + 384.0 * RoomScale, 90, r, False, True)
			r.RoomDoors[1].AutoClose = False
			r.RoomDoors[1].dir = 1
			r.RoomDoors[1].open = False
			
			FreeEntity(r.RoomDoors[1].buttons[0])
			r.RoomDoors[1].buttons[0] = 0
			FreeEntity(r.RoomDoors[1].buttons[1])
			r.RoomDoors[1].buttons[1] = 0
			
			de.Decals = CreateDecal(Rand(4, 5), EntityX(r.Objects[5], True), 0.002, EntityZ(r.Objects[5], True), 90, Rnd(360), 0)
			de.Size = 1.2
			ScaleSprite(de.obj, de.Size, de.Size)
			
			for (xtemp of range(2)) {
				for (ztemp of range(2)) {
					de.Decals = CreateDecal(Rand(4, 6), r.x + 700.0 * RoomScale + xtemp * 700.0 * RoomScale + Rnd(-0.5, 0.5), Rnd(0.001, 0.0018), r.z + 600 * ztemp * RoomScale + Rnd(-0.5, 0.5), 90, Rnd(360), 0)
					de.Size = Rnd(0.5, 0.8)
					de.Alpha = Rnd(0.8, 1.0)
					ScaleSprite(de.obj, de.Size, de.Size)
				}
			}
						
			r.RoomDoors[2] = CreateDoor(r.zone, r.x - 1008.0 * RoomScale, 0, r.z - 688.0 * RoomScale, 90, r, True, False, False, "", True)
			r.RoomDoors[2].AutoClose = False
			r.RoomDoors[2].open = False
			r.RoomDoors[2].locked = True
			FreeEntity(r.RoomDoors[2].buttons[0])
			r.RoomDoors[2].buttons[0] = 0
			FreeEntity(r.RoomDoors[2].buttons[1])
			r.RoomDoors[2].buttons[1] = 0
			
			r.RoomDoors[3] = CreateDoor(r.zone, r.x - 2320.0 * RoomScale, 0, r.z - 1248.0 * RoomScale, 90, r, True)
			r.RoomDoors[3].AutoClose = False
			r.RoomDoors[3].open = True
			r.RoomDoors[3].locked = True
			
			r.RoomDoors[4] = CreateDoor(r.zone, r.x - 4352.0 * RoomScale, 0, r.z - 1248.0 * RoomScale, 90, r, True)
			r.RoomDoors[4].AutoClose = False
			r.RoomDoors[4].open = True
			r.RoomDoors[4].locked = True	
			
			//the door in the office below the walkway
			r.RoomDoors[7] = CreateDoor(r.zone, r.x - 3712.0 * RoomScale, -385*RoomScale, r.z - 128.0 * RoomScale, 0, r, True)
			r.RoomDoors[7].AutoClose = False
			r.RoomDoors[7].open = True
			
			d.Doors = CreateDoor(r.zone, r.x - 3712 * RoomScale, -385*RoomScale, r.z - 2336 * RoomScale, 0, r, False)
			d.locked = True
			d.DisableWaypoint = True
			
			//the door from the concrete tunnel to the large hall
			d.Doors = CreateDoor(r.zone, r.x - 6864 * RoomScale, 0, r.z - 1248 * RoomScale, 90, r, True)
			d.AutoClose = False
			d.locked = True
			
			//the locked door to the lower level of the hall
			d.Doors = CreateDoor(r.zone, r.x - 5856 * RoomScale, 0, r.z - 1504 * RoomScale, 0, r, False)
			d.locked = True
			d.DisableWaypoint = True
			
			//the door to the staircase in the office room
			d.Doors = CreateDoor(r.zone, r.x - 2432 * RoomScale, 0, r.z - 1000 * RoomScale, 0, r, False)
			PositionEntity(d.buttons[0], r.x - 2592 * RoomScale, EntityY(d.buttons[0],True), r.z - 1016 * RoomScale, True)
			PositionEntity(d.buttons[1], r.x - 2592 * RoomScale, EntityY(d.buttons[0],True), r.z - 984 * RoomScale, True)
			d.locked = True
			d.DisableWaypoint = True
			
			tex = LoadTexture_Strict("GFX/map/Door02.jpg")
			for (ztemp of range(2)) {
				d.Doors = CreateDoor(r.zone, r.x - 5760 * RoomScale, 0, r.z + (320+896*ztemp) * RoomScale, 0, r, False)
				d.locked = True
				d.DisableWaypoint = True
				
				d.Doors = CreateDoor(r.zone, r.x - 8288 * RoomScale, 0, r.z + (320+896*ztemp) * RoomScale, 0, r, False)
				d.locked = True
				if (ztemp = 0) {
					d.open = True
				} else {
					d.DisableWaypoint = True
				}
				
				for (xtemp of range(3)) {
					d.Doors = CreateDoor(r.zone, r.x - (7424.0-512.0*xtemp) * RoomScale, 0, r.z + (1008.0-480.0*ztemp) * RoomScale, 180*(!ztemp), r, False)
					EntityTexture(d.obj, tex)
					d.locked = True
					FreeEntity(d.obj2)
					d.obj2=0
					FreeEntity(d.buttons[0])
					d.buttons[0]=0
					FreeEntity(d.buttons[1])
					d.buttons[1]=0
					d.DisableWaypoint = True
				}					
				for (xtemp of range(5)) {
					d.Doors = CreateDoor(r.zone, r.x - (5120.0-512.0*xtemp) * RoomScale, 0, r.z + (1008.0-480.0*ztemp) * RoomScale, 180*(!ztemp), r, False)
					EntityTexture(d.obj, tex)
					d.locked = True
					FreeEntity(d.obj2)
					d.obj2=0
					FreeEntity(d.buttons[0])
					d.buttons[0]=0
					FreeEntity(d.buttons[1])
					d.buttons[1]=0	
					d.DisableWaypoint = True
					
					if (xtemp == 2 && ztemp == 1) {
						r.RoomDoors[6] = d
					}
				}	
			}
			
			CreateItem("Class D Orientation Leaflet", "paper", r.x-(2914+1024)*RoomScale, 170.0*RoomScale, r.z+40*RoomScale)
			
			sc.SecurityCams = CreateSecurityCam(r.x - 4048.0 * RoomScale, r.y - 32.0 * RoomScale, r.z - 1232.0 * RoomScale, r, True)
			sc.angle = 270
			sc.turn = 45
			sc.room = r
			TurnEntity(sc.CameraObj, 20, 0, 0)
			EntityParent(sc.obj, r.obj)
			
			PositionEntity(sc.ScrObj, r.x - 2256 * RoomScale, 224.0 * RoomScale, r.z - 928.0 * RoomScale)
			TurnEntity(sc.ScrObj, 0, 90, 0)
			EntityParent(sc.ScrObj, r.obj)
			
			r.Objects[9] = LoadMesh_Strict("GFX/map/173_2.b3d",r.obj)
			EntityType(r.Objects[9],HIT_MAP)
			EntityPickMode(r.Objects[9],2)
			
			r.Objects[10] = LoadMesh_Strict("GFX/map/intro_labels.b3d",r.obj)
			
		case "room2ccont":
			//[Block]
			d = CreateDoor(r.zone, r.x + 64.0 * RoomScale, 0.0, r.z + 368.0 * RoomScale, 180, r, False, False, 2)
			d.AutoClose = False
			d.open = False
			
			it = CreateItem("Note from Daniel", "paper", r.x-400.0*RoomScale,1040.0*RoomScale,r.z+115.0*RoomScale)
			EntityParent(it.collider, r.obj)
			
			for (n of range(3)) {
				r.Objects[n * 2] = CopyEntity(LeverBaseOBJ)
				r.Objects[n * 2 + 1] = CopyEntity(LeverOBJ)
				
				r.Levers[n] = r.Objects[n * 2 + 1]
				
				for (i of range(2)) {
					ScaleEntity(r.Objects[n * 2 + i], 0.04, 0.04, 0.04)
					PositionEntity (r.Objects[n * 2 + i], r.x - 240.0 * RoomScale, r.y + 1104.0 * RoomScale, r.z + (632.0 - 64.0 * n) * RoomScale, True)
					
					EntityParent(r.Objects[n * 2 + i], r.obj)
				}
				RotateEntity(r.Objects[n * 2], 0, -90, 0)
				RotateEntity(r.Objects[n * 2 + 1], 10, -90 - 180, 0)
				
				EntityPickMode(r.Objects[n * 2 + 1], 1, False)
				EntityRadius(r.Objects[n * 2 + 1], 0.1)
			}
			
			sc.SecurityCams = CreateSecurityCam(r.x-265.0*RoomScale, r.y+1280.0*RoomScale, r.z+105.0*RoomScale, r)
			sc.angle = 45
			sc.turn = 45
			TurnEntity(sc.CameraObj, 20, 0, 0)
			
		case "room106":
			//[Block]
			it = CreateItem("Level 5 Key Card", "key5", r.x - 752.0 * RoomScale, r.y - 592 * RoomScale, r.z + 3026.0 * RoomScale)
			EntityParent(it.collider, r.obj)
			
			it = CreateItem("Dr. Allok's Note", "paper", r.x - 416.0 * RoomScale, r.y - 576 * RoomScale, r.z + 2492.0 * RoomScale)
			EntityParent(it.collider, r.obj)
			
			it = CreateItem("Recall Protocol RP-106-N", "paper", r.x + 268.0 * RoomScale, r.y - 576 * RoomScale, r.z + 2593.0 * RoomScale)
			EntityParent(it.collider, r.obj)
			
			d = CreateDoor(r.zone, r.x - 968.0 * RoomScale, -764.0 * RoomScale, r.z + 1392.0 * RoomScale, 0, r, False, False, 4)
			d.AutoClose = False
			d.open = False	
			
			d = CreateDoor(r.zone, r.x, 0, r.z - 464.0 * RoomScale, 0, r, False, False, 4)
			d.AutoClose = False
			d.open = False			
			
			d = CreateDoor(r.zone, r.x - 624.0 * RoomScale, -1280.0 * RoomScale, r.z, 90, r, False, False, 4)
			d.AutoClose = False
			d.open = False	
			
			r.Objects[6] = LoadMesh_Strict("GFX/map/room1062.b3d")
			
			ScaleEntity (r.Objects[6],RoomScale,RoomScale,RoomScale)
			EntityType(r.Objects[6], HIT_MAP)
			EntityPickMode(r.Objects[6], 3)
			PositionEntity(r.Objects[6],r.x+784.0*RoomScale,-980.0*RoomScale,r.z+720.0*RoomScale,True)

			
			EntityParent(r.Objects[6], r.obj)
			
			for (n of range(0, 3, 2)) {
				r.Objects[n] = CopyEntity(LeverBaseOBJ)
				r.Objects[n+1] = CopyEntity(LeverOBJ)
				
				r.Levers[n/2] = r.Objects[n+1]
				
				for (i of range(2)) {
					ScaleEntity(r.Objects[n+i], 0.04, 0.04, 0.04)
					PositionEntity (r.Objects[n+i], r.x - (555.0 - 81.0 * (n/2)) * RoomScale, r.y - 576.0 * RoomScale, r.z + 3040.0 * RoomScale, True)
					
					EntityParent(r.Objects[n+i], r.obj)
				}
				RotateEntity(r.Objects[n], 0, 0, 0)
				RotateEntity(r.Objects[n+1], 10, -180, 0)
				
				EntityPickMode(r.Objects[n+1], 1, False)
				EntityRadius(r.Objects[n+1], 0.1)
			}
			
			RotateEntity(r.Objects[1], 81,-180,0)
			RotateEntity(r.Objects[3], -81,-180,0)			
			
			r.Objects[4] = CreateButton(r.x - 146.0*RoomScale, r.y - 576.0 * RoomScale, r.z + 3045.0 * RoomScale, 0,0,0)
			EntityParent (r.Objects[4],r.obj)
			
			sc.SecurityCams = CreateSecurityCam(r.x + 768.0 * RoomScale, r.y + 1392.0 * RoomScale, r.z + 1696.0 * RoomScale, r, True)
			sc.angle = 45 + 90 + 180
			sc.turn = 20
			TurnEntity(sc.CameraObj, 45, 0, 0)
			EntityParent(sc.obj, r.obj)
			
			r.Objects[7] = sc.CameraObj
			r.Objects[8] = sc.obj
			
			PositionEntity(sc.ScrObj, r.x - 272.0 * RoomScale, -544.0 * RoomScale, r.z + 3020.0 * RoomScale)
			TurnEntity(sc.ScrObj, 0, -10, 0)
			EntityParent(sc.ScrObj, r.obj)
			sc.CoffinEffect=0
			
			r.Objects[5] = CreatePivot()
			TurnEntity(r.Objects[5], 0,180,0)
			PositionEntity (r.Objects[5], r.x + 1088.0 * RoomScale, 1104.0 * RoomScale, r.z + 1888.0 * RoomScale) 
			EntityParent(r.Objects[5], r.obj)
			
			r.Objects[9] = CreatePivot(r.obj)
			PositionEntity (r.Objects[9], r.x - 272 * RoomScale, r.y - 672.0 * RoomScale, r.z + 2736.0 * RoomScale, True)
			
			r.Objects[10] = CreatePivot(r.obj)
			PositionEntity (r.Objects[10], r.x, r.y, r.z - 720.0 * RoomScale, True)
			
		case "room1archive":
			//[Block]
			for (xtemp of range(1 + 1)) {
				for (ytemp of range(2 + 1)) {
					for (ztemp of range(2 + 1)) {
						
						tempstr = "9V Battery"
						tempstr2 = "bat"
						chance = Rand(-10,100)
						switch (True) {
							case (chance<0):
								Exit
							case (chance<40): //40: int chance for a document
								tempstr="Document SCP-"
								switch (Rand(1,6)) {
									case 1:
										tempstr=tempstr+"1123"
									case 2:
										tempstr=tempstr+"1048"
									case 3:
										tempstr=tempstr+"939"
									case 4:
										tempstr=tempstr+"682"
									case 5:
										tempstr=tempstr+"079"
									case 6:
										tempstr=tempstr+"096"
									case 6:
										tempstr=tempstr+"966"
								}
								tempstr2="paper"
							case ((chance>=40) && (chance<45)): //5: int chance for a key card
								temp3=Rand(1,2)
								tempstr="Level "+Str(temp3)+" Key Card"
								tempstr2="key"+Str(temp3)
							case ((chance>=45) && (chance<50)): //5 chance for a medkit
								tempstr="First Aid Kit"
								tempstr2="firstaid"
							case ((chance>=50) && (chance<60)): //10 chance for a battery
								tempstr="9V Battery"
								tempstr2="bat"
							case ((chance>=60) && (chance<70)): //10 chance for an SNAV
								tempstr="S-NAV 300 Navigator"
								tempstr2="nav"
							case ((chance>=70) && (chance<85)): //15 chance for a radio
								tempstr="Radio Transceiver"
								tempstr2="radio"
							case ((chance>=85) && (chance<95)): //10 chance for a clipboard
								tempstr="Clipboard"
								tempstr2="clipboard"
							case ((chance>=95) && (chance <= 100)): //5 chance for misc
								temp3 = Rand(1,3)
								switch (temp3) {
									case 1: //playing card
										tempstr="Playing Card"
									case 2: //Mastercard
										tempstr="Mastercard"
									case 3: //origami
										tempstr="Origami"
								}
								tempstr2="misc"
						}
						
						x = (-672.0 + 864.0 * xtemp)* RoomScale
						y = (96.0  + 96.0 * ytemp) * RoomScale
						z = (480.0 - 352.0*ztemp + Rnd(-96.0,96.0)) * RoomScale
						
						it = CreateItem(tempstr,tempstr2,r.x+x,y,r.z+z)
						EntityParent (it.collider,r.obj)
					}
				}
			}
			
			r.RoomDoors[0] = CreateDoor(r.zone,r.x,r.y,r.z - 528.0 * RoomScale,0,r,False,False,6)
			
			sc.SecurityCams = CreateSecurityCam(r.x-256.0*RoomScale, r.y+384.0*RoomScale, r.z+640.0*RoomScale, r)
			sc.angle = 180
			sc.turn = 45
			TurnEntity(sc.CameraObj, 20, 0, 0)
			
		case "room2test1074":
			//[Block]
			r.RoomDoors[0] = CreateDoor(r.zone,r.x,r.y,r.z,0,r,False,False,False,"")
			r.RoomDoors[0].locked = True
			r.RoomDoors[1] = CreateDoor(r.zone,r.x + 336.0 * RoomScale,r.y,r.z + 671.0 * RoomScale,90,r,True,False,3)
			r.RoomDoors[1].AutoClose = False
			r.RoomDoors[2] = CreateDoor(r.zone,r.x + 336.0 * RoomScale,r.y,r.z - 800.0 * RoomScale,90,r,True,False,3)
			r.RoomDoors[2].AutoClose = False
			r.RoomDoors[3] = CreateDoor(r.zone,r.x + 672.0 * RoomScale,r.y,r.z,0,r,False,False)
			
			r.Textures[0] = LoadTexture("GFX/map/1074tex0.jpg") //blank texture (ripped from official article), seen when you put on 714
			r.Textures[1] = LoadTexture("GFX/map/1074tex1.jpg") //texture depicting subject D-9341 (the player)
			TextureBlend (r.Textures[0], 5) //texture
			TextureBlend (r.Textures[1], 5) //blends
			
			it = CreateItem("Document SCP-1074","paper",r.x + 300.0 * RoomScale,r.y+20.0*RoomScale,r.z + 671.0*RoomScale)
			EntityParent(it.collider, r.obj)
			
			r.Objects[0] = CreatePivot() //painting pivot: the player will be attracted when it sees this.
			PositionEntity(r.Objects[0],r.x + 835.0 * RoomScale,r.y + 165.0 * RoomScale,r.z + 540.0 * RoomScale, True)
			EntityParent(r.Objects[0],r.obj)
			r.Objects[1] = CreatePivot() //floor pivot: the player will walk to this point when it sees the painting pivot.
			PositionEntity(r.Objects[1],r.x + 835.0 * RoomScale,r.y + 10.0 * RoomScale,r.z + 300.0 * RoomScale, True)
			EntityParent(r.Objects[1],r.obj)
			//let sf,b,t,msh
			msh = GetChild(r.obj,2) //the second child is the rendered mesh
			r.NonFreeAble[0] = GetSurface(msh,1) //a failsafe if the correct surface isn't found
			for (tempint of range(1, CountSurfaces(msh) + 1)) {
				sf = GetSurface(msh,tempint)
				b = GetSurfaceBrush( sf )
				t = GetBrushTexture(b, 1)
				texname$ = StripPath(TextureName(t))
				DebugLog ("texname: "+texname)
				if (Lower(texname) == "1074tex1.jpg") {
					r.NonFreeAble[0] = sf //the surface holding 1074's texture
					FreeTexture(t)
					FreeBrush(b)
					break
				}
				if (texname != "") {
					FreeTexture(t)
				}
				FreeBrush(b)
			}
			
		case "room1123":
			//[Block]
			it = CreateItem("Document SCP-1123", "paper", r.x + 511.0 * RoomScale, r.y + 125.0 * RoomScale, r.z - 936.0 * RoomScale)
			EntityParent(it.collider, r.obj)
			
			it = CreateItem("SCP-1123", "1123", r.x + 832.0 * RoomScale, r.y + 166.0 * RoomScale, r.z + 784.0 * RoomScale)
			EntityParent(it.collider, r.obj)
			
			it = CreateItem("Leaflet", "paper", r.x - 816.0 * RoomScale, r.y + 704.0 * RoomScale, r.z+ 888.0 * RoomScale)
			EntityParent(it.collider, r.obj)
			
			it = CreateItem("Gas Mask", "gasmask", r.x + 457.0 * RoomScale, r.y + 150.0 * RoomScale, r.z + 960.0 * RoomScale)
			EntityParent(it.collider, r.obj)
			
			d.Doors = CreateDoor(r.zone, r.x + 832.0 * RoomScale, 0.0, r.z + 367.0 * RoomScale, 0, r, False, False, 3)
			PositionEntity(d.buttons[0], r.x + 956.0 * RoomScale, EntityY(d.buttons[0],True), r.z + 352.0 * RoomScale, True)
			PositionEntity(d.buttons[1], r.x + 713.0 * RoomScale, EntityY(d.buttons[1],True), r.z + 384.0 * RoomScale, True)
			FreeEntity(d.obj2)
			d.obj2 = 0
			d.Doors = CreateDoor(r.zone, r.x + 280.0 * RoomScale, 0.0, r.z - 607.0 * RoomScale, 90, r, False, False)
			PositionEntity(d.buttons[0], EntityX(d.buttons[0],True), EntityY(d.buttons[0],True), EntityZ(d.buttons[0],True), True)
			PositionEntity(d.buttons[1], EntityX(d.buttons[1],True), EntityY(d.buttons[1],True), EntityZ(d.buttons[1],True), True)
			
			d.Doors = CreateDoor(r.zone, r.x + 280.0 * RoomScale, 512.0 * RoomScale, r.z - 607.0 * RoomScale, 90, r, False, False)
			PositionEntity(d.buttons[0], EntityX(d.buttons[0],True), EntityY(d.buttons[0],True), EntityZ(d.buttons[0],True), True)
			FreeEntity(d.buttons[1])
			d.buttons[1]=0
			r.RoomDoors[0] = d
			
			r.Objects[3] = CreatePivot(r.obj)
			PositionEntity(r.Objects[3], r.x + 832.0 * RoomScale, r.y + 166.0 * RoomScale, r.z + 784.0 * RoomScale, True)
			r.Objects[4] = CreatePivot(r.obj)
			PositionEntity(r.Objects[4], r.x -648.0 * RoomScale, r.y + 592.0 * RoomScale, r.z + 692.0 * RoomScale, True)
			r.Objects[5] = CreatePivot(r.obj)
			PositionEntity(r.Objects[5], r.x + 828.0 * RoomScale, r.y + 592.0 * RoomScale, r.z + 592.0 * RoomScale, True)
			
			r.Objects[6] = CreatePivot(r.obj)
			PositionEntity(r.Objects[6], r.x - 76.0 * RoomScale, r.y + 620.0 * RoomScale, r.z + 744.0 * RoomScale, True)
			r.Objects[7] = CreatePivot(r.obj)
			PositionEntity(r.Objects[7], r.x - 640.0 * RoomScale, r.y + 620.0 * RoomScale, r.z - 864.0 * RoomScale, True)	
			
			r.Objects[8] = LoadMesh_Strict("GFX/map/forest/door_frame.b3d")
			PositionEntity(r.Objects[8], r.x - 272.0 * RoomScale, 512.0 * RoomScale, r.z + 288.0 * RoomScale,True)
			RotateEntity(r.Objects[8],0,90,0,True)
			ScaleEntity(r.Objects[8],45.0*RoomScale,45.0*RoomScale,80.0*RoomScale,True)
			EntityParent(r.Objects[8],r.obj)
			
			r.Objects[9] =  LoadMesh_Strict("GFX/map/forest/door.b3d")
			PositionEntity(r.Objects[9],r.x - 272.0 * RoomScale, 512.0 * RoomScale, r.z + (288.0-70) * RoomScale,True)
			RotateEntity(r.Objects[9],0,10,0,True)
			EntityType(r.Objects[9], HIT_MAP)
			ScaleEntity(r.Objects[9],46.0*RoomScale,45.0*RoomScale,46.0*RoomScale,True)
			EntityParent(r.Objects[9],r.obj)
			
			r.Objects[10] = CopyEntity(r.Objects[8])
			PositionEntity(r.Objects[10], r.x - 272.0 * RoomScale, 512.0 * RoomScale, r.z + 736.0 * RoomScale,True)
			RotateEntity(r.Objects[10],0,90,0,True)
			ScaleEntity(r.Objects[10],45.0*RoomScale,45.0*RoomScale,80.0*RoomScale,True)
			EntityParent(r.Objects[10],r.obj)
			
			r.Objects[11] =  CopyEntity(r.Objects[9])
			PositionEntity(r.Objects[11],r.x - 272.0 * RoomScale, 512.0 * RoomScale, r.z + (736.0-70) * RoomScale,True)
			RotateEntity(r.Objects[11],0,90,0,True)
			EntityType(r.Objects[11], HIT_MAP)
			ScaleEntity(r.Objects[11],46.0*RoomScale,45.0*RoomScale,46.0*RoomScale,True)
			EntityParent(r.Objects[11],r.obj)
			
			r.Objects[12] = CopyEntity(r.Objects[8])
			PositionEntity(r.Objects[12], r.x - 592.0 * RoomScale, 512.0 * RoomScale, r.z - 704.0 * RoomScale,True)
			RotateEntity(r.Objects[12],0,0,0,True)
			ScaleEntity(r.Objects[12],45.0*RoomScale,45.0*RoomScale,80.0*RoomScale,True)
			EntityParent(r.Objects[12],r.obj)
			
			r.Objects[13] =  CopyEntity(r.Objects[9])
			PositionEntity(r.Objects[13],r.x - (592.0+70.0) * RoomScale, 512.0 * RoomScale, r.z - 704.0 * RoomScale,True)
			RotateEntity(r.Objects[13],0,0,0,True)
			EntityType(r.Objects[13], HIT_MAP)
			ScaleEntity(r.Objects[13],46.0*RoomScale,45.0*RoomScale,46.0*RoomScale,True)
			EntityParent(r.Objects[13],r.obj	)
			
			r.Objects[14] = LoadMesh_Strict("GFX/map/1123_hb.b3d",r.obj)
			EntityPickMode(r.Objects[14],2)
			EntityType(r.Objects[14],HIT_MAP)
			EntityAlpha(r.Objects[14],0.0)
			
		case "pocketdimension":
			//[Block]
			let hallway = LoadMesh_Strict("GFX/map/pocketdimension2.b3d") //the tunnels in the first room
			r.Objects[8]=LoadMesh_Strict("GFX/map/pocketdimension3.b3d")	//the room with the throne, moving pillars etc 
			r.Objects[9]=LoadMesh_Strict("GFX/map/pocketdimension4.b3d") //the flying pillar
			r.Objects[10]=CopyEntity(r.Objects[9])
			
			r.Objects[11]=LoadMesh_Strict("GFX/map/pocketdimension5.b3d") //the pillar room
			
			
			terrain = LoadMesh_Strict("GFX/map/pocketdimensionterrain.b3d")
			ScaleEntity(terrain,RoomScale,RoomScale,RoomScale,True)
			PositionEntity(terrain, 0, 2944, 0, True)
			
			
			
			CreateItem("Burnt Note", "paper", EntityX(r.obj),0.5,EntityZ(r.obj)+3.5)
			
			for (n of range(0)) {//4
				
				switch (n) {
					case 0:
						entity = hallway 					
					case 1:
						entity = r.Objects[8]						
					case 2:
						entity = r.Objects[9]						
					case 3:
						entity = r.Objects[10]							
					case 4:
						entity = r.Objects[11]							
				}
	
				
			}
			
			for (i of range(8, 12)) {
				ScaleEntity (r.Objects[i],RoomScale,RoomScale,RoomScale)
				EntityType(r.Objects[i], HIT_MAP)
				EntityPickMode(r.Objects[i], 2)
				PositionEntity(r.Objects[i],r.x,r.y,r.z+32.0,True)
			}
			
			ScaleEntity (terrain,RoomScale,RoomScale,RoomScale)
			EntityType(terrain, HIT_MAP)
			EntityPickMode(terrain, 3)
			PositionEntity(terrain,r.x,r.y+2944.0*RoomScale,r.z+32.0,True)			
			
			r.RoomDoors[0] = CreateDoor(0, r.x,2048*RoomScale,r.z+32.0-1024*RoomScale,0,r,False)
			r.RoomDoors[1] = CreateDoor(0, r.x,2048*RoomScale,r.z+32.0+1024*RoomScale,180,r,False)
			
			de.Decals = CreateDecal(18, r.x-(1536*RoomScale), 0.02,r.z+608*RoomScale+32.0, 90,0,0)
			EntityParent(de.obj, r.obj)
			de.Size = Rnd(0.8, 0.8)
			de.blendmode = 2
			de.fx = 1+8
			ScaleSprite(de.obj, de.Size, de.Size)
			EntityFX(de.obj, 1+8)
			EntityBlend(de.obj, 2)
			
			ScaleEntity (r.Objects[10],RoomScale*1.5,RoomScale*2.0,RoomScale*1.5,True)			
			PositionEntity(r.Objects[11],r.x,r.y,r.z+64.0,True)			
			
			for (i of range(1, 9)) {
				r.Objects[i-1] = CopyEntity(hallway) //CopyMesh
				ScaleEntity (r.Objects[i-1],RoomScale,RoomScale,RoomScale)
				angle: float = (i-1) * (360.0/8.0)
				
				EntityType(r.Objects[i-1], HIT_MAP)
				EntityPickMode(r.Objects[i-1], 2)
				
				RotateEntity(r.Objects[i-1],0,angle-90,0)
				PositionEntity(r.Objects[i-1],r.x+Cos(angle)*(512.0*RoomScale),0.0,r.z+Sin(angle)*(512.0*RoomScale))
				EntityParent (r.Objects[i-1], r.obj)
				
				if (i < 6) {
					de.Decals = CreateDecal(i+7, r.x+Cos(angle)*(512.0*RoomScale)*3.0, 0.02,r.z+Sin(angle)*(512.0*RoomScale)*3.0, 90,angle-90,0)
					de.Size = Rnd(0.5, 0.5)
					de.blendmode = 2
					de.fx = 1+8
					ScaleSprite(de.obj, de.Size, de.Size)
					EntityFX(de.obj, 1+8)
					EntityBlend(de.obj, 2)
				}				
			}
			
			for (i of range(12, 17)) {
				r.Objects[i] = CreatePivot(r.Objects[11])
				switch (i) {
					case 12:
						PositionEntity(r.Objects[i],r.x,r.y+200*RoomScale,r.z+64.0,True)	
					case 13:
						PositionEntity(r.Objects[i],r.x+390*RoomScale,r.y+200*RoomScale,r.z+64.0+272*RoomScale,True)	
					case 14:
						PositionEntity(r.Objects[i],r.x+838*RoomScale,r.y+200*RoomScale,r.z+64.0-551*RoomScale,True)	
					case 15:
						PositionEntity(r.Objects[i],r.x-139*RoomScale,r.y+200*RoomScale,r.z+64.0+1201*RoomScale,True)	
					case 16:
						PositionEntity(r.Objects[i],r.x-1238*RoomScale,r.y-1664*RoomScale,r.z+64.0+381*RoomScale,True)
				}	
			}
			
			let OldManEyes: int = LoadTexture_Strict("GFX/npcs/oldmaneyes.jpg")
			r.Objects[17] = CreateSprite()
			ScaleSprite(r.Objects[17], 0.03, 0.03)
			EntityTexture(r.Objects[17], OldManEyes)
			EntityBlend (r.Objects[17], 3)
			EntityFX(r.Objects[17], 1 + 8)
			SpriteViewMode(r.Objects[17], 2)
			
			r.Objects[18] = LoadTexture_Strict("GFX/npcs/pdplane.png", 1+2)
			r.Objects[19] = LoadTexture_Strict("GFX/npcs/pdplaneeye.png", 1+2)		
			
			r.Objects[20] = CreateSprite()
			ScaleSprite(r.Objects[20], 8.0, 8.0)
			EntityTexture(r.Objects[20], r.Objects[18])
			EntityOrder(r.Objects[20], 100)
			EntityBlend (r.Objects[20], 2)
			EntityFX(r.Objects[20], 1 + 8)
			SpriteViewMode(r.Objects[20], 2)
			
			FreeTexture(t)
			FreeEntity(hallway)
			
		case "room3z3":
			//[Block]
			sc.SecurityCams = CreateSecurityCam(r.x-320.0*RoomScale, r.y+384.0*RoomScale, r.z+512.25*RoomScale, r)
			sc.angle = 225
			sc.turn = 45
			TurnEntity(sc.CameraObj, 20, 0, 0)
			
		case "room2_3","room3_3":
			//[Block]
			w.waypoints = CreateWaypoint(r.x, r.y + 66.0 * RoomScale, r.z, null, r)
			
		//New rooms (in SCP:CB 1.3) - ENDSHN
		case "room1lifts":
			//[Block]
			r.Objects[0] = CreateButton(r.x + 96.0*RoomScale, r.y + 160.0 * RoomScale, r.z + 64.0 * RoomScale, 0,0,0)
			EntityParent (r.Objects[0],r.obj)
			r.Objects[1] = CreateButton(r.x - 96.0*RoomScale, r.y + 160.0 * RoomScale, r.z + 64.0 * RoomScale, 0,0,0)
			EntityParent (r.Objects[1],r.obj)
			
			sc.SecurityCams = CreateSecurityCam(r.x+384.0*RoomScale, r.y+(448-64)*RoomScale, r.z-960.0*RoomScale, r, True)
			sc.angle = 45
			sc.turn = 45
			sc.room = r
			TurnEntity(sc.CameraObj, 20, 0, 0)
			EntityParent(sc.obj, r.obj)
			
			w.waypoints = CreateWaypoint(r.x, r.y + 66.0 * RoomScale, r.z, null, r)
			//[End Block]
		case "room2servers2":
			//[Block]
			d.Doors = CreateDoor(r.zone, r.x + 264.0 * RoomScale, 0.0, r.z + 672.0 * RoomScale, 270, r, False, False, 3)
			PositionEntity(d.buttons[0], r.x + 224.0 * RoomScale, EntityY(d.buttons[0],True), r.z + 510.0 * RoomScale, True)
			PositionEntity(d.buttons[1], r.x + 304.0 * RoomScale, EntityY(d.buttons[1],True), r.z + 840.0 * RoomScale, True)	
			TurnEntity(d.buttons[1],0,0,0,True)
			d.Doors = CreateDoor(r.zone, r.x -512.0 * RoomScale, -768.0*RoomScale, r.z -336.0 * RoomScale, 0, r, False, False, 3)
			d.Doors = CreateDoor(r.zone, r.x -509.0 * RoomScale, -768.0*RoomScale, r.z -1037.0 * RoomScale, 0, r, False, False, 3)
			d.Doors.locked = True
			d.Doors.DisableWaypoint = True
			it = CreateItem("Night Vision Goggles", "nvgoggles", r.x + 56.0154 * RoomScale, r.y - 648.0 * RoomScale, r.z + 749.638 * RoomScale)
			it.state = 200
			RotateEntity(it.collider, 0, r.angle+Rand(245), 0)
			EntityParent(it.collider, r.obj)
			//[End Block]
		case "room2gw","room2gw_b":
		    //[Block]
			if (r.RoomTemplate.Name == "room2gw_b") {
				r.Objects[2] = CreatePivot(r.obj)
				PositionEntity (r.Objects[2], r.x - 156.825*RoomScale, -37.3458*RoomScale, r.z+121.364*RoomScale, True)
				
				de.Decals = CreateDecal(3,  r.x - 156.825*RoomScale, -37.3458*RoomScale, r.z+121.364*RoomScale,90,Rnd(360),0)
				de.Size = 0.5
				ScaleSprite(de.obj, de.Size,de.Size)
				EntityParent(de.obj, r.obj)
				
				//260 300 -350
				//WIP
				r.Objects[0] = CreatePivot()
				PositionEntity(r.Objects[0],r.x+280.0*RoomScale,r.y+345.0*RoomScale,r.z-340.0*RoomScale,True)
				EntityParent(r.Objects[0],r.obj)
			}
			
			r.RoomDoors[0] = CreateDoor(r.zone, r.x + 336.0 * RoomScale, 0.0, r.z - 382.0 * RoomScale, 0, r, False, False)
			PositionEntity(r.RoomDoors[0].buttons[0], r.x + 580.822 * RoomScale, EntityY(r.RoomDoors[0].buttons[0],True), r.z - 606.679 * RoomScale, True)	
            PositionEntity(r.RoomDoors[0].buttons[1], r.x + 580.822 * RoomScale, EntityY(r.RoomDoors[0].buttons[1],True), r.z - 606.679 * RoomScale, True)
			r.RoomDoors[0].dir = 0
			r.RoomDoors[0].AutoClose = False
			r.RoomDoors[0].open = True 
			r.RoomDoors[0].locked = True	
			r.RoomDoors[0].MTFClose = False
			
			r.RoomDoors[1] = CreateDoor(r.zone, r.x + 336.0 * RoomScale, 0.0, r.z + 462.0 * RoomScale, 180, r, False, False)
			PositionEntity(r.RoomDoors[1].buttons[0], r.x + 580.822 * RoomScale, EntityY(r.RoomDoors[1].buttons[0],True), r.z - 606.679 * RoomScale, True)	
            PositionEntity(r.RoomDoors[1].buttons[1], r.x + 580.822 * RoomScale, EntityY(r.RoomDoors[1].buttons[1],True), r.z - 606.679 * RoomScale, True)
			r.RoomDoors[1].dir = 0
			r.RoomDoors[1].AutoClose = False
			r.RoomDoors[1].open = True 
			r.RoomDoors[1].locked = True
			r.RoomDoors[1].MTFClose = False
			
			for (r2 of Rooms.each) {
				if (r2 != r) {
					if (r2.RoomTemplate.Name == "room2gw" || r2.RoomTemplate.Name == "room2gw_b") {
						r.Objects[3] = CopyEntity(r2.Objects[3],r.obj) //don't load the mesh again
						break
					}
				}
			}
			if (r.Objects[3] == 0) {
				r.Objects[3] = LoadMesh_Strict("GFX/map/room2gw_pipes.b3d",r.obj)
			}
			EntityPickMode(r.Objects[3],2)
			
			if (r.RoomTemplate.Name == "room2gw") {
				r.Objects[0] = CreatePivot()
				PositionEntity(r.Objects[0],r.x+344.0*RoomScale,128.0*RoomScale,r.z)
				EntityParent(r.Objects[0],r.obj)
				
				let bd_temp: boolean = false
				if (room2gw_brokendoor) {
					if (room2gw_x == r.x) {
						if (room2gw_z == r.z) {
							bd_temp = True
						}
					}
				}
				
				if ((room2gw_brokendoor == 0 && Rand(1,2) == 1) || bd_temp) {
					r.Objects[1] = CopyEntity(DoorOBJ)
					ScaleEntity(r.Objects[1], (204.0 * RoomScale) / MeshWidth(r.Objects[1]), 312.0 * RoomScale / MeshHeight(r.Objects[1]), 16.0 * RoomScale / MeshDepth(r.Objects[1]))
					EntityType(r.Objects[1], HIT_MAP)
					PositionEntity(r.Objects[1], r.x + 336.0 * RoomScale, 0.0, r.z + 462.0 * RoomScale)
					RotateEntity(r.Objects[1], 0, 180 + 180, 0)
					EntityParent(r.Objects[1], r.obj)
					MoveEntity(r.Objects[1],120.0,0,5.0)
					room2gw_brokendoor = True
					room2gw_x = r.x
					room2gw_z = r.z
					FreeEntity(r.RoomDoors[1].obj2)
					r.RoomDoors[1].obj2 = 0
				}
			}
			//[End Block]
		case "room3gw":
	        //[Block]
			d = CreateDoor(r.zone, r.x - 728.0 * RoomScale, 0.0, r.z - 458.0 * RoomScale, 0, r, False, False, 3)
			d.AutoClose = False
			d.open = False
			d.locked = False
			
			d = CreateDoor(r.zone, r.x - 223.0 * RoomScale, 0.0, r.z - 736.0 * RoomScale, -90, r, False, False, 3)
			d.AutoClose = False
			d.open = False
			d.locked = False
			
			r.RoomDoors[0] = CreateDoor(r.zone, r.x - 459.0 * RoomScale, 0.0, r.z + 339.0 * RoomScale, 90, r, False, False)
			PositionEntity(r.RoomDoors[0].buttons[0], r.x + 580.822 * RoomScale, EntityY(r.RoomDoors[0].buttons[0],True), r.z - 606.679 * RoomScale, True)	
            PositionEntity(r.RoomDoors[0].buttons[1], r.x + 580.822 * RoomScale, EntityY(r.RoomDoors[0].buttons[1],True), r.z - 606.679 * RoomScale, True)
			r.RoomDoors[0].dir = 0
			r.RoomDoors[0].AutoClose = False
			r.RoomDoors[0].open = True
			r.RoomDoors[0].locked = True	
			r.RoomDoors[0].MTFClose = False
			
			r.RoomDoors[1] = CreateDoor(r.zone, r.x + 385.0 * RoomScale, 0.0, r.z + 339.0 * RoomScale, 270, r, False, False)
			PositionEntity(r.RoomDoors[1].buttons[0], r.x + 580.822 * RoomScale, EntityY(r.RoomDoors[1].buttons[0],True), r.z - 606.679 * RoomScale, True)	
            PositionEntity(r.RoomDoors[1].buttons[1], r.x + 580.822 * RoomScale, EntityY(r.RoomDoors[1].buttons[1],True), r.z - 606.679 * RoomScale, True)
			r.RoomDoors[1].dir = 0
			r.RoomDoors[1].AutoClose = False
			r.RoomDoors[1].open = True
			r.RoomDoors[1].locked = True
			r.RoomDoors[1].MTFClose = False
			FreeEntity(r.RoomDoors[1].obj2)
			r.RoomDoors[1].obj2 = 0
			
			r.Objects[0] = CreatePivot()
			PositionEntity(r.Objects[0],r.x-48.0*RoomScale,128.0*RoomScale,r.z+320.0*RoomScale)
			EntityParent(r.Objects[0],r.obj)
			
			for (r2 of range(Rooms.each)) {
				if (r2 != r) {
					if (r2.RoomTemplate.Name == "room3gw") {
						r.Objects[3] = CopyEntity(r2.Objects[3],r.obj) //don't load the mesh again
						break
					}
				}
			}
			if (r.Objects[3] == 0) {
				r.Objects[3] = LoadMesh_Strict("GFX/map/room3gw_pipes.b3d",r.obj)
			}
			EntityPickMode(r.Objects[3],2)
	        //[End Block]
		case "room1162":
			//[Block]
			d = CreateDoor(r.zone, r.x + 248.0*RoomScale, 0.0, r.z - 736.0*RoomScale, 90, r, False, False, 2)
			r.Objects[0] = CreatePivot()
			PositionEntity(r.Objects[0],r.x+1012.0*RoomScale,r.y+128.0*RoomScale,r.z-640.0*RoomScale)
			EntityParent(r.Objects[0],r.obj)
			EntityPickMode(r.Objects[0],1)
			it = CreateItem("Document SCP-1162", "paper", r.x + 863.227 * RoomScale, r.y + 152.0 * RoomScale, r.z - 953.231 * RoomScale)
			EntityParent(it.collider, r.obj)
			
			sc.SecurityCams = CreateSecurityCam(r.x-192.0*RoomScale, r.y+704.0*RoomScale, r.z+192.0*RoomScale, r)
			sc.angle = 225
			sc.turn = 45
			TurnEntity(sc.CameraObj, 20, 0, 0)
			//[End Block]
		case "room2scps2":
			//[Block]
			r.RoomDoors[0] = CreateDoor(r.zone, r.x + 288.0*RoomScale, r.y, r.z + 576.0*RoomScale, 90, r, False, False, 3)
			r.RoomDoors[0].open = False
			r.RoomDoors[0].locked = True
			d = CreateDoor(r.zone, r.x + 777.0*RoomScale, r.y, r.z + 671.0*RoomScale, 90, r, False, False, 4)
			d = CreateDoor(r.zone, r.x + 556.0*RoomScale, r.y, r.z + 296.0*RoomScale, 0, r, False, False, 3)
			r.Objects[0] = CreatePivot()
			PositionEntity(r.Objects[0],r.x + 576.0*RoomScale,r.y+160.0*RoomScale,r.z+632.0*RoomScale)
			EntityParent(r.Objects[0],r.obj)
			
			it = CreateItem("SCP-1499", "scp1499", r.x + 600.0 * RoomScale, r.y + 176.0 * RoomScale, r.z - 228.0 * RoomScale)
			RotateEntity(it.collider, 0, r.angle, 0)
			EntityParent(it.collider, r.obj)
			
			it = CreateItem("Document SCP-1499", "paper", r.x + 840.0 * RoomScale, r.y + 260.0 * RoomScale, r.z + 224.0 * RoomScale)
			EntityParent(it.collider, r.obj)
			
			it = CreateItem("Document SCP-500", "paper", r.x + 1152.0 * RoomScale, r.y + 224.0 * RoomScale, r.z + 336.0 * RoomScale)
			EntityParent(it.collider, r.obj)
			
			it = CreateItem("Emily Ross' Badge", "badge", r.x + 364.0 * RoomScale, r.y + 5.0 * RoomScale, r.z + 716.0 * RoomScale)
			EntityParent(it.collider, r.obj)
			
			sc.SecurityCams = CreateSecurityCam(r.x + 850.0 * RoomScale, r.y + 350.0 * RoomScale, r.z + 876.0 * RoomScale, r)
            sc.angle = 220
			sc.turn = 30
            TurnEntity(sc.CameraObj, 30, 0, 0)
            EntityParent(sc.obj, r.obj)
			
            sc.SecurityCams = CreateSecurityCam(r.x + 600.0 * RoomScale, r.y + 514.0 * RoomScale, r.z + 150.0 * RoomScale, r)
            sc.angle = 180
			sc.turn = 30
            TurnEntity(sc.CameraObj, 30, 0, 0)
            EntityParent(sc.obj, r.obj)
			//[End Block]
		case "room3offices":
			//[Block]			
			d.Doors = CreateDoor(r.zone, r.x + 736.0 * RoomScale, 0.0, r.z + 240.0 * RoomScale, 0, r, False, False, 3)
			PositionEntity(d.buttons[0], r.x + 892.0 * RoomScale, EntityY(d.buttons[0],True), r.z + 224.0 * RoomScale, True)
			PositionEntity(d.buttons[1], r.x + 892.0 * RoomScale, EntityY(d.buttons[1],True), r.z + 255.0 * RoomScale, True)
			FreeEntity(d.obj2)
			d.obj2 = 0
			
			r.Objects[0] = LoadMesh_Strict("GFX/map/room3offices_hb.b3d",r.obj)
			EntityPickMode(r.Objects[0],2)
			EntityType(r.Objects[0],HIT_MAP)
			EntityAlpha(r.Objects[0],0.0)
			//[End Block]
		case "room2offices4":
			//[Block]
			d.Doors = CreateDoor(0, r.x - 240.0 * RoomScale, 0.0, r.z, 90, r, False)
			PositionEntity(d.buttons[0], r.x - 230.0 * RoomScale, EntityY(d.buttons[0],True), EntityZ(d.buttons[0],True), True)
			PositionEntity(d.buttons[1], r.x - 250.0 * RoomScale, EntityY(d.buttons[1],True), EntityZ(d.buttons[1],True), True)
			d.open = False
			d.AutoClose = False
			
			it = CreateItem("Sticky Note", "paper", r.x - 991.0*RoomScale, r.y - 242.0*RoomScale, r.z + 904.0*RoomScale)
			EntityParent(it.collider, r.obj)
			//[End Block]
		case "room2sl":
			//[Block]
			let scale: float = RoomScale * 4.5 * 0.4
			let screen: int
			
			r.Textures[0] = LoadAnimTexture("GFX/SL_monitors_checkpoint.jpg",1,512,512,0,4)
			r.Textures[1] = LoadAnimTexture("GFX/Sl_monitors.jpg",1,256,256,0,8)
			
			//Monitor Objects
			for (i of range(15)) {
				if (i != 7) {
					r.Objects[i] = CopyEntity(Monitor)
					ScaleEntity(r.Objects[i], scale, scale, scale)
					if (i != 4 && i != 13) {
						screen = CreateSprite()
						EntityFX(screen,17)
						SpriteViewMode(screen,2)
						ScaleSprite(screen, MeshWidth(Monitor) * scale * 0.95 * 0.5, MeshHeight(Monitor) * scale * 0.95 * 0.5)
						switch (i) {
							case 0:
								EntityTexture(screen,r.Textures[1],0)
							case 2:
								EntityTexture(screen,r.Textures[1],2)
							case 3:
								EntityTexture(screen,r.Textures[1],1)
							case 8:
								EntityTexture(screen,r.Textures[1],4)
							case 9:
								EntityTexture(screen,r.Textures[1],5)
							case 10:
								EntityTexture(screen,r.Textures[1],3)
							case 11:
								EntityTexture(screen,r.Textures[1],7)
							default:
								EntityTexture(screen,r.Textures[0],3)
						}
						EntityParent(screen,r.Objects[i])
					} else if (i == 4) {
						r.Objects[20] = CreateSprite()
						EntityFX(r.Objects[20],17)
						SpriteViewMode(r.Objects[20],2)
						ScaleSprite(r.Objects[20], MeshWidth(Monitor) * scale * 0.95 * 0.5, MeshHeight(Monitor) * scale * 0.95 * 0.5)
						EntityTexture(r.Objects[20],r.Textures[0],2)
						EntityParent(r.Objects[20],r.Objects[i])
					} else {
						r.Objects[21] = CreateSprite()
						EntityFX(r.Objects[21],17)
						SpriteViewMode(r.Objects[21],2)
						ScaleSprite(r.Objects[21], MeshWidth(Monitor) * scale * 0.95 * 0.5, MeshHeight(Monitor) * scale * 0.95 * 0.5)
						EntityTexture(r.Objects[21],r.Textures[1],6)
						EntityParent(r.Objects[21],r.Objects[i])
					}
				}
			}
			for (i of range(3)) {
				PositionEntity(r.Objects[i],r.x-207.94*RoomScale,r.y+(648.0+(112*i))*RoomScale,r.z-60.0686*RoomScale)
				RotateEntity(r.Objects[i],0,105+r.angle,0)
				EntityParent(r.Objects[i],r.obj)
				DebugLog(i)
			}
			for (i of range(3, 6)) {
				PositionEntity(r.Objects[i],r.x-231.489*RoomScale,r.y+(648.0+(112*(i-3)))*RoomScale,r.z+95.7443*RoomScale)
				RotateEntity(r.Objects[i],0,90+r.angle,0)
				EntityParent(r.Objects[i],r.obj)
				DebugLog(i)
			}
			for (i of range(6, 9, 2)) {
				PositionEntity(r.Objects[i],r.x-231.489*RoomScale,r.y+(648.0+(112*(i-6)))*RoomScale,r.z+255.744*RoomScale)
				RotateEntity(r.Objects[i],0,90+r.angle,0)
				EntityParent(r.Objects[i],r.obj)
				DebugLog(i)
			}
			for (i of range(9, 12)) {
				PositionEntity(r.Objects[i],r.x-231.489*RoomScale,r.y+(648.0+(112*(i-9)))*RoomScale,r.z+415.744*RoomScale)
				RotateEntity(r.Objects[i],0,90+r.angle,0)
				EntityParent(r.Objects[i],r.obj)
				DebugLog(i)
			}
			for (i of range(12, 15)) {
				PositionEntity(r.Objects[i],r.x-208.138*RoomScale,r.y+(648.0+(112*(i-12)))*RoomScale,r.z+571.583*RoomScale)
				RotateEntity(r.Objects[i],0,75+r.angle,0)
				EntityParent(r.Objects[i],r.obj)
				DebugLog(i)
			}
			
			//Doors for room
			r.RoomDoors[0] = CreateDoor(r.zone,r.x+480.0*RoomScale,r.y,r.z-640.0*RoomScale,90,r,False,False,3)
			r.RoomDoors[0].AutoClose = False
			PositionEntity(r.RoomDoors[0].buttons[0],r.x+576.0*RoomScale,EntityY(r.RoomDoors[0].buttons[0],True),r.z-480*RoomScale,True)
			RotateEntity(r.RoomDoors[0].buttons[0],0,270,0)
			r.RoomDoors[1] = CreateDoor(r.zone,r.x+544.0*RoomScale,r.y+480.0*RoomScale,r.z+256.0*RoomScale,270,r,False,False,3)
			r.RoomDoors[1].AutoClose = False
			FreeEntity(r.RoomDoors[1].obj2)
			r.RoomDoors[1].obj2 = 0
			d = CreateDoor(r.zone,r.x+1504.0*RoomScale,r.y+480.0*RoomScale,r.z+960.0*RoomScale,0,r)
			d.AutoClose = False
			d.locked = True
			
			//PathPoint 1 for SCP-049
			r.Objects[7] = CreatePivot()
			PositionEntity(r.Objects[7],r.x,r.y+100.0*RoomScale,r.z-800.0*RoomScale,True)
			EntityParent(r.Objects[7],r.obj)
			
			//PathPoints for SCP-049
			r.Objects[15] = CreatePivot()
			PositionEntity(r.Objects[15],r.x+700.0*RoomScale,r.y+700.0*RoomScale,r.z+256.0*RoomScale,True)
			EntityParent(r.Objects[15],r.obj)
			r.Objects[16] = CreatePivot()
			PositionEntity(r.Objects[16],r.x-60.0*RoomScale,r.y+700.0*RoomScale,r.z+200.0*RoomScale,True)
			EntityParent(r.Objects[16],r.obj)
			r.Objects[17] = CreatePivot()
			PositionEntity(r.Objects[17],r.x-48.0*RoomScale,r.y+540.0*RoomScale,r.z+656.0*RoomScale,True)
			EntityParent(r.Objects[17],r.obj)
			
			//Faked room409
			
			//-49.0 689.0 912.0
			//Objects [18],[19]
			r.Objects[9 * 2] = CopyEntity(LeverBaseOBJ)
			r.Objects[9 * 2 + 1] = CopyEntity(LeverOBJ)
			
			r.Levers[0] = r.Objects[9 * 2 + 1]
			
			for (i of range(2)) {
				ScaleEntity(r.Objects[9 * 2 + i], 0.04, 0.04, 0.04)
				PositionEntity(r.Objects[9 * 2 + i],r.x-49*RoomScale,r.y+689*RoomScale,r.z+912*RoomScale,True)
				
				EntityParent(r.Objects[9 * 2 + i], r.obj)
			}
			RotateEntity(r.Objects[9 * 2], 0, 0, 0)
			RotateEntity(r.Objects[9 * 2 + 1], 10, 0 - 180, 0)
				
			EntityPickMode(r.Objects[9 * 2 + 1], 1, False)
			EntityRadius(r.Objects[9 * 2 + 1], 0.1)
			
			//Camera in the room itself
			sc.SecurityCams = CreateSecurityCam(r.x-159.0*RoomScale, r.y+384.0*RoomScale, r.z-929.0*RoomScale, r, True)
			sc.angle = 315
			//sc.turn = 45
			sc.room = r
			TurnEntity(sc.CameraObj, 20, 0, 0)
			EntityParent(sc.obj, r.obj)
			
			PositionEntity(sc.ScrObj, r.x-231.489*RoomScale, r.y+760.0*RoomScale, r.z+255.744*RoomScale)
			TurnEntity(sc.ScrObj, 0, 90, 0)
			EntityParent(sc.ScrObj, r.obj)
			
					//[End Block]
		case "room2_4":
			//[Block]
			r.Objects[6] = CreatePivot()
			PositionEntity(r.Objects[6], r.x + 640.0 * RoomScale, 8.0 * RoomScale, r.z - 896.0 * RoomScale)
			EntityParent(r.Objects[6], r.obj)
			//[End Block]
		case "room3z2":
			//[Block]
			for (r2 of Rooms.each) {
				if (r2.RoomTemplate.Name == r.RoomTemplate.Name && r2 != r) {
					r.Objects[0] = CopyEntity(r2.Objects[0],r.obj)
					break
				}
			}
			if (r.Objects[0] == 0) {
				r.Objects[0] = LoadMesh_Strict("GFX/map/room3z2_hb.b3d",r.obj)
			}
			EntityPickMode(r.Objects[0],2)
			EntityType(r.Objects[0],HIT_MAP)
			EntityAlpha(r.Objects[0],0.0)
			//[End Block]
		case "lockroom3":
			//[Block]
			d = CreateDoor(r.zone, r.x - 736.0 * RoomScale, 0, r.z - 104.0 * RoomScale, 0, r, True)
			d.timer = 70 * 5
			d.AutoClose = False
			d.open = False
			d.locked = True
			
			EntityParent(d.buttons[0], 0)
			PositionEntity(d.buttons[0], r.x - 288.0 * RoomScale, 0.7, r.z - 640.0 * RoomScale)
			EntityParent(d.buttons[0], r.obj)
			
			FreeEntity(d.buttons[1])
			d.buttons[1] = 0
			
			d2 = CreateDoor(r.zone, r.x + 104.0 * RoomScale, 0, r.z + 736.0 * RoomScale, 270, r, True)
			d2.timer = 70 * 5
			d2.AutoClose = False
			d2.open = False
			d2.locked = True
			EntityParent(d2.buttons[0], 0)
			PositionEntity(d2.buttons[0], r.x + 640.0 * RoomScale, 0.7, r.z + 288.0 * RoomScale)
			RotateEntity (d2.buttons[0], 0, 90, 0)
			EntityParent(d2.buttons[0], r.obj)
			
			FreeEntity(d2.buttons[1])
			d2.buttons[1] = 0
			
			d.LinkedDoor = d2
			d2.LinkedDoor = d
			
			scale = RoomScale * 4.5 * 0.4
			
			r.Objects[0] = CopyEntity(Monitor)
			ScaleEntity(r.Objects[0],scale,scale,scale)
			PositionEntity(r.Objects[0],r.x+668*RoomScale,1.1,r.z-96.0*RoomScale,True)
			RotateEntity(r.Objects[0],0,90,0)
			EntityParent(r.Objects[0],r.obj)
			
			r.Objects[1] = CopyEntity(Monitor)
			ScaleEntity(r.Objects[1],scale,scale,scale)
			PositionEntity(r.Objects[1],r.x+96.0*RoomScale,1.1,r.z-668.0*RoomScale,True)
			EntityParent(r.Objects[1],r.obj)
			//[End Block]
		case "medibay":
			//[Block]
			r.Objects[0] = LoadMesh_Strict("GFX/map/medibay_props.b3d",r.obj)
			EntityType(r.Objects[0],HIT_MAP)
			EntityPickMode(r.Objects[0],2)
			
			r.Objects[1] = CreatePivot(r.obj)
			PositionEntity(r.Objects[1], r.x - 762.0 * RoomScale, r.y + 0.0 * RoomScale, r.z - 346.0 * RoomScale, True)
			r.Objects[2] = CreatePivot(r.obj)
			PositionEntity(r.Objects[2], (EntityX(r.Objects[1],True)+(126.0 * RoomScale)), EntityY(r.Objects[1],True), EntityZ(r.Objects[1],True), True)
			it = CreateItem("First Aid Kit", "firstaid", r.x - 506.0 * RoomScale, r.y + 192.0 * RoomScale, r.z - 322.0 * RoomScale)
			EntityParent(it.collider, r.obj)
			it = CreateItem("Syringe", "syringe", r.x - 333.0 * RoomScale, r.y + 100.0 * RoomScale, r.z + 97.3 * RoomScale)
			EntityParent(it.collider, r.obj)
			it = CreateItem("Syringe", "syringe", r.x - 340.0 * RoomScale, r.y + 100.0 * RoomScale, r.z + 52.3 * RoomScale)
			EntityParent(it.collider, r.obj)
			r.RoomDoors[0] = CreateDoor(r.zone, r.x - 264.0 * RoomScale, r.y - 0.0 * RoomScale, r.z + 640.0 * RoomScale, 90, r, False, False, 3)
			
			r.Objects[3] = CreatePivot(r.obj)
			PositionEntity(r.Objects[3],r.x-820.0*RoomScale,r.y,r.z-318.399*RoomScale,True)
			//[End Block]
		case "room2cpit":
			//[Block]
			em.Emitters = CreateEmitter(r.x + 512.0 * RoomScale, -76 * RoomScale, r.z - 688 * RoomScale, 0)
            TurnEntity(em.Obj, -90, 0, 0)
            EntityParent(em.Obj, r.obj)
            em.RandAngle = 55
            em.Speed = 0.0005
            em.Achange = -0.015
            em.SizeChange = 0.007
            
            d = CreateDoor(r.zone,r.x-256.0*RoomScale, 0.0, r.z-752.0*RoomScale,90,r,False,2,3)
            d.locked = True
			d.open = False
			d.AutoClose = False
			d.MTFClose = False
			d.DisableWaypoint = True
			PositionEntity (d.buttons[0],r.x-240.0*RoomScale,EntityY(d.buttons[0],True),EntityZ(d.buttons[0],True),True)
			
			it = CreateItem("Dr L's Note", "paper", r.x - 160.0 * RoomScale, 32.0 * RoomScale, r.z - 353.0 * RoomScale)
			EntityParent(it.collider, r.obj)
			//[End Block]
		case "dimension1499":
			//[Block]
			r.Levers[1] = LoadMesh_Strict("GFX/map/dimension1499/1499object0_cull.b3d",r.obj)
			EntityType(r.Levers[1],HIT_MAP)
			EntityAlpha(r.Levers[1],0)
			
			r.Levers[0] = CreatePivot()
			PositionEntity(r.Levers[0],r.x+205.0*RoomScale,r.y+200.0*RoomScale,r.z+2287.0*RoomScale)
			EntityParent(r.Levers[0],r.obj)
			//[End Block]
	}
	
	for (lt of LightTemplates.each) {
		if (lt.roomtemplate == r.RoomTemplate) {
			newlt = AddLight(r, r.x+lt.x, r.y+lt.y, r.z+lt.z, lt.ltype, lt.range, lt.r, lt.g, lt.b)
			if (newlt != 0) {
				if (lt.ltype == 3) {
					LightConeAngles(newlt, lt.innerconeangle, lt.outerconeangle)
					RotateEntity(newlt, lt.pitch, lt.yaw, 0)
				}
			}
		}
	}
	
	for (ts of TempScreens.each) {
		if (ts.roomtemplate == r.RoomTemplate) {
			CreateScreen(r.x+ts.x, r.y+ts.y, r.z+ts.z, ts.imgpath, r)
		}
	}
	
	for (tw of TempWayPoints.each) {
		if (tw.roomtemplate == r.RoomTemplate) {
			CreateWaypoint(r.x+tw.x, r.y+tw.y, r.z+tw.z, null, r)
		}
	}
	
	if (r.RoomTemplate.TempTriggerboxAmount > 0) {
		r.TriggerboxAmount = r.RoomTemplate.TempTriggerboxAmount
		for (i of range(r.TriggerboxAmount)) {
			r.Triggerbox[i] = CopyEntity(r.RoomTemplate.TempTriggerbox[i],r.obj)
			r.TriggerboxName[i] = r.RoomTemplate.TempTriggerboxName[i]
			DebugLog("Triggerbox found: "+i)
			DebugLog("Triggerbox "+i+" name: "+r.TriggerboxName[i])
		}
	}
	
	for (i of range(MaxRoomEmitters)) {
		if (r.RoomTemplate.TempSoundEmitter[i] != 0) {
			r.SoundEmitterObj[i]=CreatePivot(r.obj)
			PositionEntity(r.SoundEmitterObj[i], r.x+r.RoomTemplate.TempSoundEmitterX[i],r.y+r.RoomTemplate.TempSoundEmitterY[i],r.z+r.RoomTemplate.TempSoundEmitterZ[i],True)
			EntityParent(r.SoundEmitterObj[i],r.obj)
			
			r.SoundEmitter[i] = r.RoomTemplate.TempSoundEmitter[i]
			r.SoundEmitterRange[i] = r.RoomTemplate.TempSoundEmitterRange[i]
		}
	}
	
	CatchErrors("FillRoom ("+r.RoomTemplate.Name+")")
}

function UpdateRooms() {
	CatchErrors("Uncaught (UpdateRooms)")
	let dist: float
	let i: int
	let j: int
	let r: Rooms
	
	let x: float
	let z: float
	let hide: boolean = true
	
	//The reason why it is like this:
	//	When the map gets spawned by a seed, it starts from LCZ to HCZ to EZ (bottom to top)
	//	A map loaded by the map creator starts from EZ to HCZ to LCZ (top to bottom) and that's why this little code thing with the (SelectedMap="") needs to be there
	//	- ENDSHN
	if ((EntityZ(Collider)/8.0)<I_Zone.Transition[1]-(SelectedMap == "")) {
		PlayerZone=2
	} else if ((EntityZ(Collider)/8.0)>=I_Zone.Transition[1]-(SelectedMap="") && (EntityZ(Collider)/8.0)<I_Zone.Transition[0]-(SelectedMap == "")) {
		PlayerZone=1
	} else {
		PlayerZone=0
	}
	
	TempLightVolume=0
	let foundNewPlayerRoom: int = False
	if (PlayerRoom != null) {
		if (Abs(EntityY(Collider) - EntityY(PlayerRoom.obj)) < 1.5) {
			x = Abs(PlayerRoom.x-EntityX(Collider,True))
			if (x < 4.0) {
				z = Abs(PlayerRoom.z-EntityZ(Collider,True))
				if (z < 4.0) {
					foundNewPlayerRoom = True
				}
			}
			
			if (!foundNewPlayerRoom) { //it's likely that an adjacent room is the new player room, check for that
				for (i of range(4)) {
					if (PlayerRoom.Adjacent[i] != null) {
						x = Abs(PlayerRoom.Adjacent[i].x-EntityX(Collider,True))
						if (x < 4.0) {
							z = Abs(PlayerRoom.Adjacent[i].z-EntityZ(Collider,True))
							if (z < 4.0) {
								foundNewPlayerRoom = True
								PlayerRoom = PlayerRoom.Adjacent[i]
								break
							}
						}
					}
				}
			}
		} else {
			foundNewPlayerRoom = True //PlayerRoom stays the same when you're high up, or deep down
		}
	}
	
	for (r of Rooms.each) {
		
		x = Abs(r.x-EntityX(Collider,True))
		z = Abs(r.z-EntityZ(Collider,True))
		r.dist = Max(x,z)
		
		
		if (x<16 && z < 16) {
			for (i of range(MaxRoomEmitters)) {
				if (r.SoundEmitter[i] != 0) { 
					dist = EntityDistance(r.SoundEmitterObj[i],Collider)
					if (dist < r.SoundEmitterRange[i]) {
						r.SoundEmitterCHN[i] = LoopSound2(RoomAmbience[r.SoundEmitter[i]],r.SoundEmitterCHN[i], Camera, r.SoundEmitterObj[i],r.SoundEmitterRange[i])
					}
				}
			}
			
			if ((!foundNewPlayerRoom) && (PlayerRoom != r)) {
				if (x < 4.0) {
					if (z < 4.0) {
						if (Abs(EntityY(Collider) - EntityY(r.obj)) < 1.5) {PlayerRoom = r}
						foundNewPlayerRoom = True
					}
				}				
			}
		}
		
		hide = True
		
		if (r == PlayerRoom) {
			hide = False
		}
		if (hide) {
			if (IsRoomAdjacent(PlayerRoom,r)) {hide = False}
		}
		if (hide) {
			for (i of range(4)) {
				if (IsRoomAdjacent(PlayerRoom.Adjacent[i],r)) {
					hide=False
					break
				}
			}
		}
		
		if (hide) {
			HideEntity(r.obj)
		} else {
			ShowEntity(r.obj)
			for (i of range(MaxRoomLights)) {
				if (r.Lights[i] != 0) {
					dist = EntityDistance(Collider,r.Lights[i])
					if (dist < HideDistance) {
						TempLightVolume = TempLightVolume + r.LightIntensity[i]*r.LightIntensity[i]*((HideDistance-dist)/HideDistance)
					}
				} else {
					break
				}
			}
			if (DebugHUD) {
				if (r.TriggerboxAmount>0) {
					for (i of range(r.TriggerboxAmount)) {
						EntityColor(r.Triggerbox[i],255,255,0)
						EntityAlpha(r.Triggerbox[i],0.2)
					}
				}
			} else {
				if (r.TriggerboxAmount>0) {
					for (i of range(r.TriggerboxAmount)) {
						EntityColor(r.Triggerbox[i],255,255,255)
						EntityAlpha(r.Triggerbox[i],0.0)
					}
				}
			}
		}
	}
	
	MapFound(Floor(EntityX(PlayerRoom.obj) / 8.0), Floor(EntityZ(PlayerRoom.obj) / 8.0)) = 1
	PlayerRoom.found = True
	
	TempLightVolume = Max(TempLightVolume / 4.5, 1.0)
	
	if (PlayerRoom != null) {
		EntityAlpha(GetChild(PlayerRoom.obj,2),1)
		for (i of range(4)) {
			if (PlayerRoom.Adjacent[i] != null) {
				if (PlayerRoom.AdjDoor[i] != null) {
					x = Abs(EntityX(Collider,True)-EntityX(PlayerRoom.AdjDoor[i].frameobj,True))
					z = Abs(EntityZ(Collider,True)-EntityZ(PlayerRoom.AdjDoor[i].frameobj,True))
					if (PlayerRoom.AdjDoor[i].openstate == 0) {
						EntityAlpha(GetChild(PlayerRoom.Adjacent[i].obj,2),0)
					} else if (!EntityInView(PlayerRoom.AdjDoor[i].frameobj,Camera)) {
						EntityAlpha(GetChild(PlayerRoom.Adjacent[i].obj,2),0)
					} else {
						EntityAlpha(GetChild(PlayerRoom.Adjacent[i].obj,2),1)
					}
				}
				
				for (j of range(4)) {
					if (PlayerRoom.Adjacent[i].Adjacent[j] != null) {
						if (PlayerRoom.Adjacent[i].Adjacent[j] != PlayerRoom) {
							EntityAlpha(GetChild(PlayerRoom.Adjacent[i].Adjacent[j].obj,2),0)
						}
					}
				}
			}
		}
	}
	
	CatchErrors("UpdateErrors")
}

function IsRoomAdjacent(this: Rooms,that: Rooms) {
	if (this == null) {return False}
	if (this == that) {return True}
	for (i of range(4)) {
		if (that == this.Adjacent[i]) {
			return True
		}
	}
	return False
}

//-------------------------------------------------------------------------------------------------------

var LightVolume: float
var TempLightVolume: float
function AddLight(room: Rooms | null, x: float, y: float, z: float, ltype: int, range: float, r: int, g: int, b: int) : int {
	let i
	
	if (room) {
		for (i of range(MaxRoomLights)) {
			if (room.Lights[i] == 0) {
				room.Lights[i] = CreateLight(ltype)
				LightRange(room.Lights[i],range)
				LightColor(room.Lights[i],r,g,b)
				PositionEntity(room.Lights[i],x,y,z,True)
				EntityParent(room.Lights[i],room.obj)
				
				room.LightIntensity[i] = (r+g+b)/255.0/3.0
				
				room.LightSprites[i]= CreateSprite()
				PositionEntity(room.LightSprites[i], x, y, z)
				ScaleSprite(room.LightSprites[i], 0.13 , 0.13)
				EntityTexture(room.LightSprites[i], LightSpriteTex(0))
				EntityBlend (room.LightSprites[i], 3)
				
				EntityParent(room.LightSprites[i], room.obj)
				
				room.LightSpritesPivot[i] = CreatePivot()
				EntityRadius(room.LightSpritesPivot[i],0.05)
				PositionEntity(room.LightSpritesPivot[i], x, y, z)
				EntityParent(room.LightSpritesPivot[i], room.obj)
				
				room.LightSprites2[i] = CreateSprite()
				PositionEntity(room.LightSprites2[i], x, y, z)
				ScaleSprite(room.LightSprites2[i], 0.6, 0.6)
				EntityTexture(room.LightSprites2[i], LightSpriteTex(2))
				EntityBlend(room.LightSprites2[i], 3)
				EntityOrder(room.LightSprites2[i], -1)
				EntityColor(room.LightSprites2[i], r, g, b)
				EntityParent(room.LightSprites2[i], room.obj)
				EntityFX(room.LightSprites2[i],1)
				RotateEntity(room.LightSprites2[i],0,0,Rand(360))
				SpriteViewMode(room.LightSprites2[i],1)
				room.LightSpriteHidden[i] = True
				HideEntity(room.LightSprites2[i])
				room.LightFlicker[i] = Rand(1,10)
				
				room.LightR[i] = r
				room.LightG[i] = g
				room.LightB[i] = b
				
				HideEntity(room.Lights[i])
				
				room.MaxLights += 1
				
				return room.Lights[i]
			}
		}
	} else {
		let light: int
		let sprite: int
		light=CreateLight(ltype)
		LightRange(light,range)
		LightColor(light,r,g,b)
		PositionEntity(light,x,y,z,True)
		sprite=CreateSprite()
		PositionEntity(sprite, x, y, z)
		ScaleSprite(sprite, 0.13 , 0.13)
		EntityTexture(sprite, LightSpriteTex(0))
		EntityBlend (sprite, 3)
		return light
	}
}

class LightTemplates {
	roomtemplate: RoomTemplates
	ltype: int
	x: float
	y: float
	z: float
	range: float
	r: int
	g: int
	b: int
	
	pitch: float
	yaw: float
	innerconeangle: int
	outerconeangle: float
} 

export function AddTempLight(rt: RoomTemplates, x: float, y: float, z: float, ltype: int, range: float, r: int, g: int, b: int) : LightTemplates {
	let lt: Lighttemplates = new LightTemplates()
	lt.roomtemplate = rt
	lt.x = x
	lt.y = y
	lt.z = z
	lt.ltype = ltype
	lt.range = range
	lt.r = r
	lt.g = g
	lt.b = b
	
	return lt
}

//-------------------------------------------------------------------------------------------------------

export class TempWayPoints {
	x: float
	y: float
	z: float
	roomtemplate: RoomTemplates
} 

export class WayPoints {
	obj: int
	door: Doors
	room: Rooms
	state: int
	connected: WayPoints[] = new Array(5)
	dist: float[] = new Array(5)
	
	Fcost: float
	Gcost: float
	Hcost: float
	
	parent: WayPoints
}

export function CreateWaypoint(x: float, y: float, z: float, door: Doors, room: Rooms) : WayPoints {
	
	let w: WayPoints = new WayPoints()
	
	if (true) {
		w.obj = CreatePivot()
		PositionEntity(w.obj, x,y,z	)
	} else {
		w.obj = CreateSprite()
		PositionEntity(w.obj, x, y, z)
		ScaleSprite(w.obj, 0.15 , 0.15)
		EntityTexture(w.obj, LightSpriteTex(0))
		EntityBlend (w.obj, 3)	
	}
	
	EntityParent(w.obj, room.obj)
	
	w.room = room
	w.door = door
	
	return w
}

export function InitWayPoints(loadingstart=45) {
	
	let d: Doors
	let w: WayPoints
	let w2: WayPoints
	let r: Rooms
	let ClosestRoom: Rooms
	
	let x: float
	let y: float
	let z: float
	
	temper = MilliSecs()
	
	let dist: float
	let dist2: float
	
	for (d of Doors.each) {
		if (d.obj != 0) {HideEntity(d.obj)}
		if (d.obj2 != 0) {HideEntity(d.obj2)}
		if (d.frameobj != 0) {HideEntity(d.frameobj)}
		
		if (d.room == null) { 
			ClosestRoom.Rooms = null
			dist = 30
			for (r of Rooms.each) {
				x = Abs(EntityX(r.obj,True)-EntityX(d.frameobj,True))
				if (x < 20.0) {
					z = Abs(EntityZ(r.obj,True)-EntityZ(d.frameobj,True))
					if (z < 20.0) {
						dist2 = x*x+z*z
						if (dist2 < dist) {
							ClosestRoom = r
							dist = dist2
						}
					}
				}
			}
		} else {
			ClosestRoom = d.room
		}
		
		if (!d.DisableWaypoint) {
			CreateWaypoint(EntityX(d.frameobj, True), EntityY(d.frameobj, True)+0.18, EntityZ(d.frameobj, True), d, ClosestRoom)
		}
	}
	
	amount = 0
	for (w of WayPoints.each) {
		EntityPickMode(w.obj, 1, True)
		EntityRadius(w.obj, 0.2)
		amount=amount+1
	}
		
	number = 0
	iter = 0
	for (w of WayPoints.each) {
		
		number = number + 1
		iter = iter + 1
		if (iter == 20) { 
			DrawLoading(loadingstart+Floor((35.0/amount)*number)) 
			iter = 0
		}
		
		w2.WayPoints = After(w)
		
		let canCreateWayPoint: int = False
		
		while (w2 != null) {
			
			if (w.room == w2.room || w.door != null || w2.door != null) {
				
				dist = EntityDistance(w.obj, w2.obj)
				
				if (w.room.MaxWayPointY == 0.0 || w2.room.MaxWayPointY == 0.0) {
					canCreateWayPoint = True
				} else {
					if (Abs(EntityY(w.obj)-EntityY(w2.obj))<=w.room.MaxWayPointY) {
						canCreateWayPoint = True
					}
				}
				
				if (dist < 7.0) {
					if (canCreateWayPoint) {
						if (EntityVisible(w.obj, w2.obj)) {
							for (i of range(5)) {
								if (w.connected[i] == null) {
									w.connected[i] = w2.WayPoints 
									w.dist[i] = dist
									break
								}
							}
							
							for (n of range(5)) {
								if (w2.connected[n] == null) { 
									w2.connected[n] = w.WayPoints 
									w2.dist[n] = dist
									break
								}					
							}
						}
					}	
				}
			}
			w2 = After(w2)
		}
		
	}
		
	for (d of Doors.each) {
		if (d.obj != 0) {ShowEntity(d.obj)}
		if (d.obj2 != 0) {ShowEntity(d.obj2)}
		if (d.frameobj != 0) {ShowEntity(d.frameobj)}
	}
	
	for (w of WayPoints.each) {
		EntityPickMode(w.obj, 0, 0)
		EntityRadius(w.obj, 0)
		
		for (i of range(5)) {
			if (w.connected[i]) {
				tline = CreateLine(EntityX(w.obj,True),EntityY(w.obj,True),EntityZ(w.obj,True),EntityX(w.connected[i].obj,True),EntityY(w.connected[i].obj,True),EntityZ(w.connected[i].obj,True))
				EntityColor(tline, 255,0,0)
				EntityParent(tline, w.obj)
			}
		}
	}
	
	DebugLog("InitWaypoints() - "+(MilliSecs2()-temper))
	
}

function RemoveWaypoint(w: WayPoints) {
	FreeEntity(w.obj)
	Delete(w)
}


export var MapF: int[] = new Array(MapWidth+1, MapHeight+1)
export var MapG: int[] = new Array(MapWidth+1, MapHeight+1)
export var MapH: int[] = new Array(MapWidth+1, MapHeight+1)
export var MapState: int[] = new Array(MapWidth+1, MapHeight+1)
export var MapParent: int[] = new Array(MapWidth+1, MapHeight+1, 2)

function FindPath(n: NPCs, x: float, y: float, z: float) {
	
	DebugLog("findpath: " + n.NPCtype)
	
	let temp: int
	let dist: float
	let dist2: float
	let xtemp: float
	let ytemp: float
	let ztemp: float
	
	let w: WayPoints
	let StartPoint: WayPoints
	let EndPoint: WayPoints   
	
	let StartX: int = Floor(EntityX(n.Collider,True) / 8.0 + 0.5), StartZ: int = Floor(EntityZ(n.Collider,True) / 8.0 + 0.5)
	
	let EndX: int = Floor(x / 8.0 + 0.5), EndZ: int = Floor(z / 8.0 + 0.5)
	
	
	let CurrX
	let CurrZ

	
	
	for (w of WayPoints.each) {
		w.state = 0
		w.Fcost = 0
		w.Gcost = 0
		w.Hcost = 0
	}
	
	n.PathStatus = 0
	n.PathLocation = 0
	for (i of range(20)) {
		n.Path[i] = null
	}
	
	let pvt = CreatePivot()
	PositionEntity(pvt, x,y,z, True)   
	
	temp = CreatePivot()
	PositionEntity(temp, EntityX(n.Collider,True), EntityY(n.Collider,True)+0.15, EntityZ(n.Collider,True))
	
	dist = 350.0
	for (w of WayPoints.each) {
		xtemp = EntityX(w.obj,True)-EntityX(temp,True)
          
		ztemp = EntityZ(w.obj,True)-EntityZ(temp,True)
             
		ytemp = EntityY(w.obj,True)-EntityY(temp,True)
                
		dist2 = (xtemp*xtemp)+(ytemp*ytemp)+(ztemp*ztemp)
		if (dist2 < dist) {
			//prefer waypoints that are visible
			if (!EntityVisible(w.obj, temp)) {
				dist2 = dist2*3
			}
			if (dist2 < dist) {
				dist = dist2
				StartPoint = w
			}
		}
	}
	DebugLog("DIST: "+dist)
	
	FreeEntity(temp)
	
	if (StartPoint == null) {return 2}
	StartPoint.state = 1      
	
	EndPoint = null
	dist = 400.0
	for (w of WayPoints.each) {
		xtemp = EntityX(pvt,True)-EntityX(w.obj,True)
		ztemp = EntityZ(pvt,True)-EntityZ(w.obj,True)
		ytemp = EntityY(pvt,True)-EntityY(w.obj,True)
		dist2 = (xtemp*xtemp)+(ytemp*ytemp)+(ztemp*ztemp)
		
		if (dist2 < dist) {
			dist = dist2
			EndPoint = w
		}            
	}
    
	
	FreeEntity(pvt)
	
	if (EndPoint == StartPoint) {
		if (dist < 0.4) {
			return 0
		} else {
			n.Path[0] = EndPoint
			return 1               
		}
	}
	if (EndPoint == null) {return 2}
	
	do {
		
		temp = False
		smallest.WayPoints = null
		dist = 10000.0
		for (w of WayPoints.each) {
			if (w.state == 1) {
                temp = True
                if ((w.Fcost) < dist) {
					dist = w.Fcost
					smallest = w
				}
			}
		}
		
		if (smallest != null) {
			
			w = smallest
			w.state = 2
			
			for (i of range(5)) {
                if (w.connected[i] != null) {
					if (w.connected[i].state < 2) {
						
						if (w.connected[i].state == 1) { //open list
							gtemp = w.Gcost+w.dist[i]
							if (n.NPCtype == NPCtypeMTF) {
								if (w.connected[i].door == null) {
									gtemp = gtemp + 0.5
								}
							}
							if (gtemp < w.connected[i].Gcost) { //parempi reitti -> overwrite
								w.connected[i].Gcost = gtemp
								w.connected[i].Fcost = w.connected[i].Gcost + w.connected[i].Hcost
								w.connected[i].parent = w
							}
						} else {
							w.connected[i].Hcost = Abs(EntityX(w.connected[i].obj,True)-EntityX(EndPoint.obj,True))+Abs(EntityZ(w.connected[i].obj,True)-EntityZ(EndPoint.obj,True))
							gtemp = w.Gcost+w.dist[i]
							if (n.NPCtype == NPCtypeMTF) {
								if (w.connected[i].door == null) {
									gtemp = gtemp + 0.5
								}
							}
							w.connected[i].Gcost = gtemp
							w.connected[i].Fcost = w.Gcost+w.Hcost
							w.connected[i].parent = w
							w.connected[i].state=1
						}            
					}
					
				}
			}
		} else {
			if (EndPoint.state > 0) {
                StartPoint.parent = null
                EndPoint.state = 2
                break
			}
		}
		
		if (EndPoint.state > 0) {
			StartPoint.parent = null
			EndPoint.state = 2
			break
		}
		
	} while (temp)
	
	if (EndPoint.state > 0) {
		
		let currpoint: WayPoints = EndPoint
		let twentiethpoint: WayPoints = EndPoint
		
		let length = 0
		do {
			length = length +1
			currpoint = currpoint.parent
			if (length>20) {
                twentiethpoint = twentiethpoint.parent
			}
		} while (currpoint != null)
		
		currpoint.WayPoints = EndPoint
		while (twentiethpoint != null) {
			length=Min(length-1,19)
			twentiethpoint = twentiethpoint.parent
			n.Path[length] = twentiethpoint
		}
		
		return 1
	} else {
		DebugLog("FUNCTION FindPath() - no route found")
		return 2 
	}
	
}
function CreateLine(x1: float,y1: float,z1: float, x2: float,y2: float,z2: float, mesh=0) {
	
	if (mesh == 0) {
		mesh=CreateMesh()
		EntityFX(mesh,16)
		surf=CreateSurface(mesh)	
		verts = 0	
		
		AddVertex (surf,x1,y1,z1,0,0)
	} else {
		surf = GetSurface(mesh,1)
		verts = CountVertices(surf)-1
	}
	
	AddVertex(surf,(x1+x2)/2,(y1+y2)/2,(z1+z2)/2,0,0 )
	// you could skip creating the above vertex and change the line below to
	// AddTriangle surf,verts,verts+1,verts+0
	// so your line mesh would use less vertices, the drawback is that some videocards (like the matrox g400)
	// aren't able to create a triangle with 2 vertices. so, it's your call :)
	AddVertex(surf,x2,y2,z2,1,0)
	
	AddTriangle(surf,verts,verts+2,verts+1)
	
	return mesh
}

//-------------------------------------------------------------------------------------------------------

var SelectedScreen: Screens
class Screens {
	obj: int
	imgpath: string
	img: int
	room: Rooms
}

class TempScreens {
	imgpath: string
	x: float
	y: float
	z: float
	roomtemplate: RoomTemplates
}

function CreateScreen(x: float, y: float, z: float, imgpath: string, r: Rooms) : Screens {
	let s: Screens = new Screens()
	s.obj = CreatePivot()
	EntityPickMode(s.obj, 1)	
	EntityRadius(s.obj, 0.1)
	
	PositionEntity(s.obj, x,y,z)
	s.imgpath = imgpath
	s.room = r
	EntityParent(s.obj, r.obj)
	
	return s
}

function UpdateScreens() {
	if (SelectedScreen != null) {return}
	if (SelectedDoor != null) {return}
	
	for (s of Screens.each) {
		if (s.room == PlayerRoom) {
			if (EntityDistance(Collider,s.obj)<1.2) {
				EntityPick(Camera, 1.2)
				if (PickedEntity() == s.obj && s.imgpath != "") {
					DrawHandIcon=True
					if (MouseUp1) {
						SelectedScreen=s
						s.img = LoadImage_Strict("GFX/screens/"+s.imgpath)
						s.img = ResizeImage2(s.img, ImageWidth(s.img) * MenuScale, ImageHeight(s.img) * MenuScale)
						MaskImage(s.img, 255,0,255)
						PlaySound_Strict(ButtonSFX)
						MouseUp1=False
					}
				}
			}
		}
	}
}

export var MapName: string[][] = new Array(MapWidth, MapHeight)
export var MapRoomID: int[] = new Array(ROOM4 + 1)
export var MapRoom: string[][] = new Array(ROOM4 + 1, 0)

//-------------------------------------------------------------------------------------------------------


export var GorePics: int[] = new Array(10)
export var SelectedMonitor: SecurityCams
export var CoffinCam: SecurityCams
class SecurityCams {
	obj: int
	MonitorObj: int
	
	BaseObj: int
	CameraObj: int
	
	ScrObj: int
	ScrWidth: float
	ScrHeight: float
	Screen: int
	Cam: int
	ScrTexture: int
	ScrOverlay: int
	angle: float
	turn: float
	CurrAngle: float
	State: float
	PlayerState: int
	
	soundCHN: int
	
	InSight: int
	
	RenderInterval: float
	
	room: Rooms
	
	FollowPlayer: int
	CoffinEffect: int
	
	AllowSaving: int
	
	MinAngle: float
	MaxAngle: float
	dir: int
}

export var ScreenTexs: int[] = new Array(2)

export var CurrRoom2slRenderCam: int
export var Room2slCam: int

function CreateSecurityCam(x: float, y: float, z: float, r: Rooms, screen: boolean = false) : SecurityCams {
	let sc: SecurityCams = new SecurityCams()
	
	sc.obj = CopyEntity(CamBaseOBJ)
	ScaleEntity(sc.obj, 0.0015, 0.0015, 0.0015)
	sc.CameraObj = CopyEntity(CamOBJ)
	ScaleEntity(sc.CameraObj, 0.01, 0.01, 0.01)
	
	sc.room = r
	
	sc.Screen = screen
	if (screen) {
		sc.AllowSaving = True
		
		sc.RenderInterval = 12
		
		let scale: float = RoomScale * 4.5 * 0.4
		
		sc.ScrObj = CreateSprite()
		EntityFX(sc.ScrObj, 17)
		SpriteViewMode(sc.ScrObj, 2)
		sc.ScrTexture = 0
		EntityTexture(sc.ScrObj, ScreenTexs[sc.ScrTexture])
		ScaleSprite(sc.ScrObj, MeshWidth(Monitor) * scale * 0.95 * 0.5, MeshHeight(Monitor) * scale * 0.95 * 0.5)
		
		sc.ScrOverlay = CreateSprite(sc.ScrObj)
		ScaleSprite(sc.ScrOverlay, MeshWidth(Monitor) * scale * 0.95 * 0.5, MeshHeight(Monitor) * scale * 0.95 * 0.5)
		MoveEntity(sc.ScrOverlay, 0, 0, -0.0005)
		EntityTexture(sc.ScrOverlay, MonitorTexture)
		SpriteViewMode(sc.ScrOverlay, 2)
		EntityBlend(sc.ScrOverlay , 3)
		
		sc.MonitorObj = CopyEntity(Monitor, sc.ScrObj)
		
		ScaleEntity(sc.MonitorObj, scale, scale, scale)
		
		sc.Cam = CreateCamera()
		CameraViewport(sc.Cam, 0, 0, 512, 512)
		CameraRange(sc.Cam, 0.05, 8.0)
		CameraZoom(sc.Cam, 0.8)
		HideEntity(sc.Cam)	
	}
	
	PositionEntity(sc.obj, x, y, z)
	
	if (r != null) {
		EntityParent(sc.obj, r.obj)
	}
	
	return sc
}

enum CoffinEffect {
	NotAffectedBy895,
	ConstantlyAffectedBy895,
	CanBroadcast895Feed,
	Broadcasts895Feed
}

function UpdateSecurityCams() {
	CatchErrors("Uncaught (UpdateSecurityCams)")
	let sc: SecurityCams

	for (sc of SecurityCams.each) {
		let close = False
		if (sc.room == null) {
			HideEntity(sc.Cam)
		} else {
			if (sc.room.dist < 6.0 || PlayerRoom == sc.room) {
				close = True
			} else if (sc.Cam != 0) {
				HideEntity(sc.Cam)
			}
			
			if (sc.room != null) {
				if (sc.room.RoomTemplate.Name$ == "room2sl") {
					sc.CoffinEffect = 0
				}
			}
			
			if (close || sc == CoffinCam) { 
				if (sc.FollowPlayer) {
					if (sc != CoffinCam) {
						if (EntityVisible(sc.CameraObj,Camera)) {
							if (MTF_CameraCheckTimer>0.0) {
								MTF_CameraCheckDetected=True
							}
						}
					}
					PointEntity(sc.CameraObj, Camera)
					let temp: float = EntityPitch(sc.CameraObj)
					RotateEntity(sc.obj, 0, CurveAngle(EntityYaw(sc.CameraObj), EntityYaw(sc.obj), 75.0), 0)
					
					if (temp < 40.0) {temp = 40}
					if (temp > 70.0) {temp = 70}
					RotateEntity(sc.CameraObj, CurveAngle(temp, EntityPitch(sc.CameraObj), 75.0), EntityYaw(sc.obj), 0)
					
					PositionEntity(sc.CameraObj, EntityX(sc.obj, True), EntityY(sc.obj, True) - 0.083, EntityZ(sc.obj, True))
					RotateEntity(sc.CameraObj, EntityPitch(sc.CameraObj), EntityYaw(sc.obj), 0)
				} else {
					if (sc.turn > 0) {
						if (sc.dir == 0) {
							sc.CurrAngle=sc.CurrAngle+0.2 * FPSfactor
							if (sc.CurrAngle > (sc.turn * 1.3)) {
								sc.dir = 1
							}
						} else {
							sc.CurrAngle=sc.CurrAngle-0.2 * FPSfactor
							if (sc.CurrAngle < (-sc.turn * 1.3)) {
								sc.dir = 0
							}
						}
					}
					RotateEntity(sc.obj, 0, sc.room.angle + sc.angle + Max(Min(sc.CurrAngle, sc.turn), -sc.turn), 0)
					
					PositionEntity(sc.CameraObj, EntityX(sc.obj, True), EntityY(sc.obj, True) - 0.083, EntityZ(sc.obj, True))
					RotateEntity(sc.CameraObj, EntityPitch(sc.CameraObj), EntityYaw(sc.obj), 0)
					
					if (sc.Cam != 0) {
						PositionEntity(sc.Cam, EntityX(sc.CameraObj, True), EntityY(sc.CameraObj, True), EntityZ(sc.CameraObj, True))
						RotateEntity(sc.Cam, EntityPitch(sc.CameraObj), EntityYaw(sc.CameraObj), 0)
						MoveEntity(sc.Cam, 0, 0, 0.1)
					}
					
					if (sc != CoffinCam) {
						if (Abs(DeltaYaw(sc.CameraObj,Camera))<60.0) {
							if (EntityVisible(sc.CameraObj,Camera)) {
								if (MTF_CameraCheckTimer>0.0) {
									MTF_CameraCheckDetected=True
								}
							}
						}
					}
				}
			}
			
			if (close) {
				if (sc.Screen) {
					sc.State = sc.State+FPSfactor
					
					if (BlinkTimer > -5 && EntityInView(sc.ScrObj, Camera)) {
						if (EntityVisible(Camera,sc.ScrObj)) {
							if ((sc.CoffinEffect == 1 || sc.CoffinEffect == 3) && (!Wearing714) && (WearingHazmat<3) && (WearingGasMask<3)) {
								if (BlinkTimer > -5) {
									Sanity=Sanity-FPSfactor
									DebugLog(Sanity)
									RestoreSanity = False
								}
							}
						}
					}
					
					if (Sanity < (-1000)) { 
						DeathMSG = Chr(34)+"What we know is that he died of cardiac arrest. My guess is that it was caused by SCP-895, although it has never been observed affecting video equipment from this far before. "
						DeathMSG = DeathMSG + "Further testing is needed to determine whether SCP-895's "+Chr(34)+"Red Zone"+Chr(34)+" is increasing."+Chr(34)
						
						if (VomitTimer < -10) {
							Kill()
						}
					}
					
					if (VomitTimer < 0 && Sanity < -800) {
						RestoreSanity = False
						Sanity = -1010
					}
					
					if (BlinkTimer > -5 && EntityInView(sc.ScrObj, Camera) && EntityVisible(Camera,sc.ScrObj)) {
						sc.InSight = True
					} else {
						sc.InSight = False
					}
					
					if (sc.State >= sc.RenderInterval) {
						
						if (BlinkTimer > -5 && EntityInView(sc.ScrObj, Camera)) {
							if (EntityVisible(Camera,sc.ScrObj)) {
								
								if (CoffinCam == null || Rand(5) == 5 || sc.CoffinEffect != 3) {
									HideEntity(Camera)
									ShowEntity(sc.Cam)
									Cls()
									
									UpdateRoomLights(sc.Cam)
									
									SetBuffer(BackBuffer())
									RenderWorld()
									CopyRect(0,0,512,512,0,0,BackBuffer(),TextureBuffer(ScreenTexs[sc.ScrTexture]))
									
									HideEntity(sc.Cam)
									ShowEntity(Camera)										
								} else {
									HideEntity(Camera)
									ShowEntity (CoffinCam.room.obj)
									EntityAlpha(GetChild(CoffinCam.room.obj,2),1)
									ShowEntity(CoffinCam.Cam)
									Cls()
									
									UpdateRoomLights(CoffinCam.Cam)
									
									SetBuffer(BackBuffer())
									RenderWorld()
									CopyRect(0,0,512,512,0,0,BackBuffer(),TextureBuffer(ScreenTexs[sc.ScrTexture]))
									
									HideEntity (CoffinCam.room.obj)
									HideEntity(CoffinCam.Cam)
									ShowEntity(Camera)										
								}
							}
						}
						sc.State = 0
					}
					
					if ((sc.CoffinEffect == 1 || sc.CoffinEffect == 3) && (!Wearing714) && (WearingHazmat<3) && (WearingGasMask<3)) {
						if (sc.InSight) {
							let pvt: int = CreatePivot()
							PositionEntity(pvt, EntityX(Camera), EntityY(Camera), EntityZ(Camera))
							PointEntity(pvt, sc.ScrObj)
							
							RotateEntity(Collider, EntityPitch(Collider), CurveAngle(EntityYaw(pvt), EntityYaw(Collider), Min(Max(15000.0 / (-Sanity), 20.0), 200.0)), 0)
							
							TurnEntity(pvt, 90, 0, 0)
							user_camera_pitch = CurveAngle(EntityPitch(pvt), user_camera_pitch + 90.0, Min(Max(15000.0 / (-Sanity), 20.0), 200.0))
							user_camera_pitch=user_camera_pitch-90
							
							FreeEntity (pvt)
							if ((sc.CoffinEffect == 1 || sc.CoffinEffect == 3) && !Wearing714) {
								if (Sanity < - 800) {
									if (Rand(3) == 1) {EntityTexture(sc.ScrOverlay, MonitorTexture)}
									if (Rand(6) < 5) {
										EntityTexture(sc.ScrOverlay, GorePics(Rand(0, 5)))
										if (sc.PlayerState = 1) {PlaySound_Strict(HorrorSFX(1))}
										sc.PlayerState = 2
										if (sc.soundCHN == 0) {
											sc.soundCHN = PlaySound_Strict(HorrorSFX(4))
										} else {
											if (!ChannelPlaying(sc.soundCHN)) {
												sc.soundCHN = PlaySound_Strict(HorrorSFX(4))
											}
										}
										if (sc.CoffinEffect == 3 && Rand(200) == 1) {
											sc.CoffinEffect=2
											sc.PlayerState = Rand(10000, 20000)
										}
									}	
									BlurTimer = 1000
									if (VomitTimer == 0) {
										VomitTimer = 1
									}
								} else if (Sanity < -500) {
									if (Rand(7) == 1) {
										EntityTexture(sc.ScrOverlay, MonitorTexture)
									}
									if (Rand(50) == 1) {
										EntityTexture(sc.ScrOverlay, GorePics(Rand(0, 5)))
										if (sc.PlayerState = 0) {PlaySound_Strict(HorrorSFX(0))}
										sc.PlayerState = Max(sc.PlayerState, 1)
										if (sc.CoffinEffect=3 && Rand(100) == 1) {
											sc.CoffinEffect=2
											sc.PlayerState = Rand(10000, 20000)
										}
									}
								} else {
									EntityTexture(sc.ScrOverlay, MonitorTexture)
								}
							}
						}
					} else {
						if (sc.InSight) {
							if ((Wearing714) || (WearingHazmat == 3) || (WearingGasMask == 3)) {
								EntityTexture(sc.ScrOverlay, MonitorTexture)
							}
						}
					}
					
					if (sc.InSight && sc.CoffinEffect == 0 || sc.CoffinEffect == 2) {
						if (sc.PlayerState == 0) {
							sc.PlayerState = Rand(60000, 65000)
						}
						
						if (Rand(500) == 1) {
							EntityTexture(sc.ScrOverlay, OldAiPics(0))
						}
						
						if ((MilliSecs2() % sc.PlayerState) >= Rand(600)) {
							EntityTexture(sc.ScrOverlay, MonitorTexture)
						} else {
							if (sc.soundCHN == 0) {
								sc.soundCHN = PlaySound_Strict(LoadTempSound("SFX/SCP/079/Broadcast"+Rand(1,3)+".ogg"))
								if (sc.CoffinEffect == 2) {
									sc.CoffinEffect=3
									sc.PlayerState = 0
								}
							} else if (!ChannelPlaying(sc.soundCHN)) {
								sc.soundCHN = PlaySound_Strict(LoadTempSound("SFX/SCP/079/Broadcast"+Rand(1,3)+".ogg"))
								if (sc.CoffinEffect == 2) {
									sc.CoffinEffect=3
									sc.PlayerState = 0
								}
							}
							EntityTexture(sc.ScrOverlay, OldAiPics(0))
						}
						
					}
					
				}
				
				if (!sc.InSight) {
					sc.soundCHN = LoopSound2(CameraSFX, sc.soundCHN, Camera, sc.CameraObj, 4.0)
				}
			}
			
			if (sc != null) {
				if (sc.room != null) {
					CatchErrors("UpdateSecurityCameras ("+sc.room.RoomTemplate.Name+")")
				} else {
					CatchErrors("UpdateSecurityCameras (screen has no room)")
				}
			} else {
				CatchErrors("UpdateSecurityCameras (screen doesn't exist anymore)")
			}
		}
	}
	
	Cls()
}

function UpdateMonitorSaving() {
	let sc: SecurityCams
	let close: int = False
	
	if (SelectedDifficulty.saveType != SAVEONSCREENS) {return}
	
	for (sc of SecurityCams.each) {
		if (sc.AllowSaving && sc.Screen) {
			close = False
			if (sc.room.dist < 6.0 || PlayerRoom == sc.room) {
				close = True
			}
			
			if (close && GrabbedEntity == 0 && ClosestButton == 0) {
				if (EntityInView(sc.ScrObj,Camera) && EntityDistance(sc.ScrObj,Camera)<1.0) {
					if (EntityVisible(sc.ScrObj,Camera)) {
						DrawHandIcon = True
						if (MouseHit1) {SelectedMonitor = sc}
					} else {
						if (SelectedMonitor = sc) {SelectedMonitor = null}
					}
				} else {
					if (SelectedMonitor = sc) {SelectedMonitor = null}
				}
				
				if (SelectedMonitor == sc) {
					if (sc.InSight) {
						let pvt: int = CreatePivot()
						PositionEntity(pvt, EntityX(Camera), EntityY(Camera), EntityZ(Camera))
						PointEntity(pvt, sc.ScrObj)
						RotateEntity(Collider, EntityPitch(Collider), CurveAngle(EntityYaw(pvt), EntityYaw(Collider), Min(Max(15000.0 / (-Sanity), 20.0), 200.0)), 0)
						TurnEntity(pvt, 90, 0, 0)
						user_camera_pitch = CurveAngle(EntityPitch(pvt), user_camera_pitch + 90.0, Min(Max(15000.0 / (-Sanity), 20.0), 200.0))
						user_camera_pitch=user_camera_pitch-90
						FreeEntity(pvt)
					}
				}
			} else {
				if (SelectedMonitor == sc) {SelectedMonitor = null}
			}
		}
	}
}

function UpdateLever(obj, locked=False) {
	
	let dist: float = EntityDistance(Camera, obj)
	if (dist < 8.0) { 
		if (dist < 0.8 && (!locked)) {
			if (EntityInView(obj, Camera)) { 
				
				EntityPick(Camera, 0.65)
				
				if (PickedEntity() == obj) {
					DrawHandIcon = True
					if (MouseHit1) {
						GrabbedEntity = obj
					}
				}
				
				prevpitch = EntityPitch(obj)
				
				if (MouseDown1 || MouseHit1) {
					if (GrabbedEntity != 0) {
						if (GrabbedEntity == obj) {
							DrawHandIcon = True 
							RotateEntity(GrabbedEntity, Max(Min(EntityPitch(obj)+Max(Min(mouse_y_speed_1 * 8,30.0),-30), 80), -80), EntityYaw(obj), 0)
							
							DrawArrowIcon(0) = True
							DrawArrowIcon(2) = True
							
						}
					}
				} 
				
				if (EntityPitch(obj,True) > 75) {
					if (prevpitch <= 75) {
						PlaySound2(LeverSFX, Camera, obj, 1.0)
					}
				} else if (EntityPitch(obj,True) < -75) {
					if (prevpitch >= -75) {
						PlaySound2(LeverSFX, Camera, obj, 1.0)
					}
				}						
			}
		}
		
		if (!MouseDown1 && !MouseHit1) {
			if (EntityPitch(obj,True) > 0) {
				RotateEntity(obj, CurveValue(80, EntityPitch(obj), 10), EntityYaw(obj), 0)
			} else {
				RotateEntity(obj, CurveValue(-80, EntityPitch(obj), 10), EntityYaw(obj), 0)
			}
			GrabbedEntity = 0
		}
		
	}
	
	if (EntityPitch(obj,True) > 0) {
		return True
	} else {
		return False
	}
	
}

function UpdateButton(obj) {
	
	let dist: float = EntityDistance(Collider, obj)
	if (dist < 0.8) {
		let temp: int = CreatePivot()
		PositionEntity(temp, EntityX(Camera), EntityY(Camera), EntityZ(Camera))
		PointEntity(temp,obj)
		
		if (EntityPick(temp, 0.65) == obj) {
			if (ClosestButton == 0) { 
				ClosestButton = obj
			} else {
				if (dist < EntityDistance(Collider, ClosestButton)) {
					ClosestButton = obj
				}
			}							
		}
		
		FreeEntity(temp)
	}
}

function UpdateElevators(State: float, door1: Doors, door2: Doors, room1, room2, event: Events, ignorerotation: boolean = true) : float {
	let x: float
	let z: float
	let sound: int
	let dist: float
	let dir: float
	let n: NPCs
	let it: Items
	
	door1.IsElevatorDoor = 1
	door2.IsElevatorDoor = 1
	if (door1.open && !door2.open && door1.openstate == 180) {
		State = -1
		door1.locked = False
		if ((ClosestButton = door2.buttons[0] || ClosestButton == door2.buttons[1]) && MouseHit1) {
			UseDoor(door1,False)
		}
	} else if (door2.open && !door1.open && door2.openstate == 180) {
		State = 1
		door2.locked = False
		if ((ClosestButton == door1.buttons[0] || ClosestButton == door1.buttons[1]) && MouseHit1) {
			UseDoor(door2,False)
		}
	} else if (Abs(door1.openstate-door2.openstate)<0.2) {
		door1.IsElevatorDoor = 2
		door2.IsElevatorDoor = 2
	}
	
	door1.locked = True
	door2.locked = True
	if (door1.open) {
		door1.IsElevatorDoor = 3
		if (Abs(EntityX(Collider)-EntityX(room1,True))<280.0*RoomScale+(0.015*FPSfactor)) {
			if (Abs(EntityZ(Collider)-EntityZ(room1,True))<280.0*RoomScale+(0.015*FPSfactor)) {
				if (Abs(EntityY(Collider)-EntityY(room1,True))<280.0*RoomScale+(0.015*FPSfactor)) {
					door1.locked = False
					door1.IsElevatorDoor = 1
				}
			}
		}
	}
	if (door2.open) {
		door2.IsElevatorDoor = 3
		if (Abs(EntityX(Collider)-EntityX(room2,True))<280.0*RoomScale+(0.015*FPSfactor)) {
			if (Abs(EntityZ(Collider)-EntityZ(room2,True))<280.0*RoomScale+(0.015*FPSfactor)) {	
				if (Abs(EntityY(Collider)-EntityY(room2,True))<280.0*RoomScale+(0.015*FPSfactor)) {
					door2.locked = False
					door2.IsElevatorDoor = 1
				}
			}
		}	
	}
	
	let inside = False
	
	if (!door1.open && !door2.open) {
		door1.locked = True
		door2.locked = True
		if (door1.openstate == 0 && door2.openstate == 0) {
			if (State < 0) {
				State = State - FPSfactor
				if (Abs(EntityX(Collider)-EntityX(room1,True))<280.0*RoomScale+(0.015*FPSfactor)) {
					if (Abs(EntityZ(Collider)-EntityZ(room1,True))<280.0*RoomScale+(0.015*FPSfactor)) {
						if (Abs(EntityY(Collider)-EntityY(room1,True))<280.0*RoomScale+(0.015*FPSfactor)) {
							inside = True
							
							if (event.SoundCHN == 0) {
								event.SoundCHN = PlaySound_Strict(ElevatorMoveSFX)
							} else {
								if (!ChannelPlaying(event.SoundCHN)) {
									event.SoundCHN = PlaySound_Strict(ElevatorMoveSFX)
								}
							}
							
							CameraShake = Sin(Abs(State)/3.0)*0.3
						}
					}
				}
				
				if (State < -500) {
					door1.locked = True
					door2.locked = False
					State = 0
					
					if (inside) {
						if (!ignorerotation) {
							dist = Distance(EntityX(Collider,True),EntityZ(Collider,True),EntityX(room1,True),EntityZ(room1,True))
							dir = point_direction(EntityX(Collider,True),EntityZ(Collider,True),EntityX(room1,True),EntityZ(room1,True))
							dir=dir+EntityYaw(room2,True)-EntityYaw(room1,True)
							dir=WrapAngle(dir)
							x = Max(Min(Cos(dir)*dist,280*RoomScale-0.22),-280*RoomScale+0.22)
							z = Max(Min(Sin(dir)*dist,280*RoomScale-0.22),-280*RoomScale+0.22)
							RotateEntity(Collider,EntityPitch(Collider,True),EntityYaw(room2,True)+angleDist(EntityYaw(Collider,True),EntityYaw(room1,True)),EntityRoll(Collider,True),True)
						} else {
							x = Max(Min((EntityX(Collider)-EntityX(room1,True)),280*RoomScale-0.22),-280*RoomScale+0.22)
							z = Max(Min((EntityZ(Collider)-EntityZ(room1,True)),280*RoomScale-0.22),-280*RoomScale+0.22)
						}
						
						TeleportEntity(Collider, EntityX(room2,True)+x,(0.1*FPSfactor)+EntityY(room2,True)+(EntityY(Collider)-EntityY(room1,True)),EntityZ(room2,True)+z,0.3,True)
						UpdateDoorsTimer = 0
						DropSpeed = 0
						UpdateDoors()
						UpdateRooms()
						
						sound=Rand(0, 2)
						door2.SoundCHN = PlaySound_Strict(OpenDoorSFX(3, sound))
					}
					
					for (n of NPCs.each) {
						if (Abs(EntityX(n.Collider)-EntityX(room1,True))<280.0*RoomScale+(0.015*FPSfactor)) {
							if (Abs(EntityZ(n.Collider)-EntityZ(room1,True))<280.0*RoomScale+(0.015*FPSfactor)) {
								if (Abs(EntityY(n.Collider)-EntityY(room1,True))<280.0*RoomScale+(0.015*FPSfactor)) {
									if (!ignorerotation) {
										dist = Distance(EntityX(n.Collider,True),EntityZ(n.Collider,True),EntityX(room1,True),EntityZ(room1,True))
										dir = point_direction(EntityX(n.Collider,True),EntityZ(n.Collider,True),EntityX(room1,True),EntityZ(room1,True))
										dir=dir+EntityYaw(room2,True)-EntityYaw(room1,True)
										dir=WrapAngle(dir)
										x = Max(Min(Cos(dir)*dist,280*RoomScale-0.22),-280*RoomScale+0.22)
										z = Max(Min(Sin(dir)*dist,280*RoomScale-0.22),-280*RoomScale+0.22)
										RotateEntity(n.Collider,EntityPitch(n.Collider,True),EntityYaw(room2,True)+angleDist(EntityYaw(n.Collider,True),EntityYaw(room1,True)),EntityRoll(n.Collider,True),True)
									} else {
										x = Max(Min((EntityX(n.Collider)-EntityX(room1,True)),280*RoomScale-0.22),-280*RoomScale+0.22)
										z = Max(Min((EntityZ(n.Collider)-EntityZ(room1,True)),280*RoomScale-0.22),-280*RoomScale+0.22)
									}
									
									TeleportEntity(n.Collider, EntityX(room2,True)+x,(0.1*FPSfactor)+EntityY(room2,True)+(EntityY(n.Collider)-EntityY(room1,True)),EntityZ(room2,True)+z,n.CollRadius,True)
									if (n == Curr173) {
										Curr173.IdleTimer = 10
									}
								}
							}
						}
					}
					for (it of Items.each) {
						if (Abs(EntityX(it.collider)-EntityX(room1,True))<280.0*RoomScale+(0.015*FPSfactor)) {
							if (Abs(EntityZ(it.collider)-EntityZ(room1,True))<280.0*RoomScale+(0.015*FPSfactor)) {
								if (Abs(EntityY(it.collider)-EntityY(room1,True))<280.0*RoomScale+(0.015*FPSfactor)) {
									if (!ignorerotation) {
										dist = Distance(EntityX(it.collider,True),EntityZ(it.collider,True),EntityX(room1,True),EntityZ(room1,True))
										dir = point_direction(EntityX(it.collider,True),EntityZ(it.collider,True),EntityX(room1,True),EntityZ(room1,True))
										dir=dir+EntityYaw(room2,True)-EntityYaw(room1,True)
										dir=WrapAngle(dir)
										x = Max(Min(Cos(dir)*dist,280*RoomScale-0.22),-280*RoomScale+0.22)
										z = Max(Min(Sin(dir)*dist,280*RoomScale-0.22),-280*RoomScale+0.22)
										RotateEntity(it.collider,EntityPitch(it.collider,True),EntityYaw(room2,True)+angleDist(EntityYaw(it.collider,True),EntityYaw(room1,True)),EntityRoll(it.collider,True),True)
									} else {
										x = Max(Min((EntityX(it.collider)-EntityX(room1,True)),280*RoomScale-0.22),-280*RoomScale+0.22)
										z = Max(Min((EntityZ(it.collider)-EntityZ(room1,True)),280*RoomScale-0.22),-280*RoomScale+0.22)
									}
									
									TeleportEntity(it.collider, EntityX(room2,True)+x,(0.1*FPSfactor)+EntityY(room2,True)+(EntityY(it.collider)-EntityY(room1,True)),EntityZ(room2,True)+z,0.01,True)
								}
							}
						}
					}
					
					UseDoor(door2,False,!inside)
					door1.open = False
					
					PlaySound2(ElevatorBeepSFX, Camera, room1, 4.0)
				}
			} else {
				State = State + FPSfactor
				if (Abs(EntityX(Collider)-EntityX(room2,True))<280.0*RoomScale+(0.015*FPSfactor)) {
					if (Abs(EntityZ(Collider)-EntityZ(room2,True))<280.0*RoomScale+(0.015*FPSfactor)) {	
						if (Abs(EntityY(Collider)-EntityY(room2,True))<280.0*RoomScale+(0.015*FPSfactor)) {
							inside = True
							
							if (event.SoundCHN == 0) {
								event.SoundCHN = PlaySound_Strict(ElevatorMoveSFX)
							} else {
								if (!ChannelPlaying(event.SoundCHN)) {event.SoundCHN = PlaySound_Strict(ElevatorMoveSFX)}
							}
							
							CameraShake = Sin(Abs(State)/3.0)*0.3
						}
					}
				}	
				
				if (State > 500) {
					door1.locked = False
					door2.locked = True				
					State = 0
					
					if (inside) {
						if (!ignorerotation) {
							dist = Distance(EntityX(Collider,True),EntityZ(Collider,True),EntityX(room2,True),EntityZ(room2,True))
							dir = point_direction(EntityX(Collider,True),EntityZ(Collider,True),EntityX(room2,True),EntityZ(room2,True))
							dir=dir+EntityYaw(room1,True)-EntityYaw(room2,True)
							x = Max(Min(Cos(dir)*dist,280*RoomScale-0.22),-280*RoomScale+0.22)
							z = Max(Min(Sin(dir)*dist,280*RoomScale-0.22),-280*RoomScale+0.22)
							RotateEntity(Collider,EntityPitch(Collider,True),EntityYaw(room2,True)+angleDist(EntityYaw(Collider,True),EntityYaw(room1,True)),EntityRoll(Collider,True),True)
						} else {
							x = Max(Min((EntityX(Collider)-EntityX(room2,True)),280*RoomScale-0.22),-280*RoomScale+0.22)
							z = Max(Min((EntityZ(Collider)-EntityZ(room2,True)),280*RoomScale-0.22),-280*RoomScale+0.22)
						}
						
						TeleportEntity(Collider, EntityX(room1,True)+x,(0.1*FPSfactor)+EntityY(room1,True)+(EntityY(Collider)-EntityY(room2,True)),EntityZ(room1,True)+z,0.3,True)
						UpdateDoorsTimer = 0
						DropSpeed = 0
						UpdateDoors()
						UpdateRooms()
						
						sound=Rand(0, 2)
						door1.SoundCHN = PlaySound_Strict(OpenDoorSFX(3, sound))
					}
					
					for (n of NPCs.each) {
						if (Abs(EntityX(n.Collider)-EntityX(room2,True))<280.0*RoomScale+(0.015*FPSfactor)) {
							if (Abs(EntityZ(n.Collider)-EntityZ(room2,True))<280.0*RoomScale+(0.015*FPSfactor)) {
								if (Abs(EntityY(n.Collider)-EntityY(room2,True))<280.0*RoomScale+(0.015*FPSfactor)) {
									if (!ignorerotation) {
										dist = Distance(EntityX(n.Collider,True),EntityZ(n.Collider,True),EntityX(room2,True),EntityZ(room2,True))
										dir = point_direction(EntityX(n.Collider,True),EntityZ(n.Collider,True),EntityX(room2,True),EntityZ(room2,True))
										dir=dir+EntityYaw(room1,True)-EntityYaw(room2,True)
										x = Max(Min(Cos(dir)*dist,280*RoomScale-0.22),-280*RoomScale+0.22)
										z = Max(Min(Sin(dir)*dist,280*RoomScale-0.22),-280*RoomScale+0.22)
										RotateEntity(n.Collider,EntityPitch(n.Collider,True),EntityYaw(room2,True)+angleDist(EntityYaw(n.Collider,True),EntityYaw(room1,True)),EntityRoll(n.Collider,True),True)
									} else {
										x = Max(Min((EntityX(n.Collider)-EntityX(room2,True)),280*RoomScale-0.22),-280*RoomScale+0.22)
										z = Max(Min((EntityZ(n.Collider)-EntityZ(room2,True)),280*RoomScale-0.22),-280*RoomScale+0.22)
									}
									
									TeleportEntity(n.Collider, EntityX(room1,True)+x,(0.1*FPSfactor)+EntityY(room1,True)+(EntityY(n.Collider)-EntityY(room2,True)),EntityZ(room1,True)+z,n.CollRadius,True)
									if (n == Curr173) {
										Curr173.IdleTimer = 10
									}
								}
							}
						}
					}
					for (it of Items.each) {
						if (Abs(EntityX(it.collider)-EntityX(room2,True))<280.0*RoomScale+(0.015*FPSfactor)) {
							if (Abs(EntityZ(it.collider)-EntityZ(room2,True))<280.0*RoomScale+(0.015*FPSfactor)) {
								if (Abs(EntityY(it.collider)-EntityY(room2,True))<280.0*RoomScale+(0.015*FPSfactor)) {
									if (!ignorerotation) {
										dist = Distance(EntityX(it.collider,True),EntityZ(it.collider,True),EntityX(room2,True),EntityZ(room2,True))
										dir = point_direction(EntityX(it.collider,True),EntityZ(it.collider,True),EntityX(room2,True),EntityZ(room2,True))
										dir=dir+EntityYaw(room1,True)-EntityYaw(room2,True)
										x = Max(Min(Cos(dir)*dist,280*RoomScale-0.22),-280*RoomScale+0.22)
										z = Max(Min(Sin(dir)*dist,280*RoomScale-0.22),-280*RoomScale+0.22)
										RotateEntity(it.collider,EntityPitch(it.collider,True),EntityYaw(room2,True)+angleDist(EntityYaw(it.collider,True),EntityYaw(room1,True)),EntityRoll(it.collider,True),True)
									} else {
										x = Max(Min((EntityX(it.collider)-EntityX(room2,True)),280*RoomScale-0.22),-280*RoomScale+0.22)
										z = Max(Min((EntityZ(it.collider)-EntityZ(room2,True)),280*RoomScale-0.22),-280*RoomScale+0.22)
									}
									
									TeleportEntity(it.collider, EntityX(room1,True)+x,(0.1*FPSfactor)+EntityY(room1,True)+(EntityY(it.collider)-EntityY(room2,True)),EntityZ(room1,True)+z,0.01,True)
								}
							}
						}
					}
					
					UseDoor(door1,False,!inside)
					door2.open = False
					
					PlaySound2(ElevatorBeepSFX, Camera, room2, 4.0)
				}	
				
			}
		}
	}
	
	return State
	
}
//-------------------------------------------------------------------------------------------------------

class Props {
	file: string
	obj
}

function CreatePropObj(file: string) {
	let p: Props
	for (p of Props.each) {
		if (p.file == file) {
			return CopyEntity(p.obj)
		}
	}
	
	p = new Props()
	p.file = file
	p.obj = LoadMesh(file)
	return p.obj
}

//-------------------------------------------------------------------------------------------------------

function CreateMap() {
	DebugLog ("Generating a map using the seed "+RandomSeed)
	
	I_Zone.Transition[0] = 13
	I_Zone.Transition[1] = 7
	I_Zone.HasCustomForest = False
	I_Zone.HasCustomMT = False
	
	let x: int
	let y: int
	let temp: int
	let i: int
	let x2: int
	let y2: int
	let width: int
	let height: int
	
	let zone: int
	
	SeedRnd(GenerateSeedNumber(RandomSeed))
	
	var MapName: string[][] = new Array(MapWidth, MapHeight)
	
	var MapRoomID: int[] = new Array(ROOM4 + 1)
	
	x = Floor(MapWidth / 2)
	y = MapHeight - 2
	
	for (i of range(y, MapHeight)) {
		MapTemp(x, i) = True
	}
	
	do {
		width = Rand(10, 15)
		
		if (x > MapWidth*0.6) {
			width = -width
		} else if (x > MapWidth*0.4) {
			x = x-width/2
		}
		
		//make sure the hallway doesn't go outside the array
		if (x+width > MapWidth-3) {
			width=MapWidth-3-x
		} else if (x+width < 2) {
			width=-x+2
		}
		
		x = Min(x, x + width)
		width = Abs(width)
		for (i of range(x, x + width + 1)) {
			MapTemp(Min(i,MapWidth), y) = True
		}
		
		height = Rand(3, 4)
		if (y - height < 1) {height = y-1}
		
		yhallways = Rand(4,5)
		
		if (GetZone(y-height) != GetZone(y-height+1)) {
			height -= 1
		}
		
		for (i of range(1, yhallways + 1)) {
			
			x2 = Max(Min(Rand(x, x + width-1),MapWidth-2),2)
			while (MapTemp(x2, y - 1) || MapTemp(x2 - 1, y - 1) || MapTemp(x2 + 1, y - 1)) {
				x2=x2+1
			}
			
			if (x2<x+width) {
				if (i == 1) {
					tempheight = height 
					if (Rand(2)=1) {
						x2 = x
					} else {
						x2 = x+width
					}
				} else {
					tempheight = Rand(1,height)
				}
				
				for (y2 of range(y - tempheight, y + 1)) {
					if (GetZone(y2) != GetZone(y2+1)) { //a room leading from zone to another
						MapTemp(x2, y2) = 255
					} else {
						MapTemp(x2, y2) = True
					}
				}
				
				if (tempheight == height) {temp = x2}
			}
			
		}
		
		x = temp
		y = y - height
	} while (!(y < 2))
	
	
	let ZoneAmount=3
	let Room1Amount: int[3], Room2Amount: int[3],Room2CAmount: int[3],Room3Amount: int[3],Room4Amount: int[3]
	
	//count the amount of rooms
	for (y of range(1, MapHeight)) {
		zone = GetZone(y)
		
		for (x of range(1, MapWidth)) {
			if (MapTemp(x, y) > 0) {
				temp = Min(MapTemp(x + 1, y),1) + Min(MapTemp(x - 1, y),1)
				temp = temp + Min(MapTemp(x, y + 1),1) + Min(MapTemp(x, y - 1),1)			
				if (MapTemp(x,y)<255) {MapTemp(x, y) = temp}
				switch (MapTemp(x,y)) {
					case 1:
						Room1Amount[zone]=Room1Amount[zone]+1
					case 2:
						if (Min(MapTemp(x + 1, y),1) + Min(MapTemp(x - 1, y),1) == 2) {
							Room2Amount[zone]=Room2Amount[zone]+1	
						} else if (Min(MapTemp(x, y + 1),1) + Min(MapTemp(x , y - 1),1) == 2) {
							Room2Amount[zone]=Room2Amount[zone]+1	
						} else {
							Room2CAmount[zone] += 1
						}
					case 3:
						Room3Amount[zone]=Room3Amount[zone]+1
					case 4:
						Room4Amount[zone]=Room4Amount[zone]+1
				}
			}
		}
	}		
	
	//force more room1s (if needed)
	for (i of range(3)) {
		//need more rooms if there are less than 5 of them
		temp = -Room1Amount[i]+5
		
		if (temp > 0) {
			
			for (y of range((MapHeight/ZoneAmount)*(2-i)+1, ((MapHeight/ZoneAmount) * ((2-i)+1.0))-1)) {
				
				for (x of range(2, MapWidth - 1)) {
					if (MapTemp(x, y) == 0) {
						
						if ((Min(MapTemp(x + 1, y),1) + Min(MapTemp(x - 1, y),1) + Min(MapTemp(x, y + 1),1) + Min(MapTemp(x, y - 1),1)) == 1) {
							
							if (MapTemp(x + 1, y)) {
								x2 = x+1
								y2 = y
							} else if (MapTemp(x - 1, y)) {
								x2 = x-1
								y2 = y
							} else if (MapTemp(x, y+1)) {
								x2 = x
								y2 = y+1	
							} else if (MapTemp(x, y-1)) {
								x2 = x
								y2 = y-1
							}
							
							placed = False
							if (MapTemp(x2,y2)>1 && MapTemp(x2,y2)<4) {
								switch (MapTemp(x2,y2)) {
									case 2:
										if (Min(MapTemp(x2 + 1, y2),1) + Min(MapTemp(x2 - 1, y2),1) == 2) {
											Room2Amount[i]=Room2Amount[i]-1
											Room3Amount[i]=Room3Amount[i]+1
											placed = True
										} else if (Min(MapTemp(x2, y2 + 1),1) + Min(MapTemp(x2, y2 - 1),1) == 2) {
											Room2Amount[i]=Room2Amount[i]-1
											Room3Amount[i]=Room3Amount[i]+1
											placed = True
										}
									case 3:
										Room3Amount[i]=Room3Amount[i]-1
										Room4Amount[i]=Room4Amount[i]+1	
										placed = True
								}
								
								if (placed) {
									MapTemp(x2,y2)=MapTemp(x2,y2)+1
									
									MapTemp(x, y) = 1
									Room1Amount[i] = Room1Amount[i]+1	
									
									temp=temp-1
								}
							}
						}
						
					}
					if (temp == 0) {break}
				}
				if (temp == 0) {break}
			}
		}
	}
	
	//force more room4s and room2Cs
	for (i of range(3)) {
		
		switch (i) {
			case 2:
				zone=2
				temp2=MapHeight/3
			case 1:
				zone=MapHeight/3+1
				temp2=MapHeight*(2.0/3.0)-1
			case 0:
				zone=MapHeight*(2.0/3.0)+1
				temp2=MapHeight-2
		}
		
		if (Room4Amount[i]<1) { //we want at least 1 ROOM4
			DebugLog("forcing a ROOM4 into zone "+i)
			temp=0
			
			for (y of range(zone, temp2 + 1)) {
				for (x of range(2, MapWidth - 1)) {
					if (MapTemp(x,y) == 3) {
						switch (0) { //see if adding a ROOM1 is possible
							case (MapTemp(x+1,y) || MapTemp(x+1,y+1) || MapTemp(x+1,y-1) || MapTemp(x+2,y)):
								MapTemp(x+1,y)=1
								temp=1
							case (MapTemp(x-1,y) || MapTemp(x-1,y+1) || MapTemp(x-1,y-1) || MapTemp(x-2,y)):
								MapTemp(x-1,y)=1
								temp=1
							case (MapTemp(x,y+1) || MapTemp(x+1,y+1) || MapTemp(x-1,y+1) || MapTemp(x,y+2)):
								MapTemp(x,y+1)=1
								temp=1
							case (MapTemp(x,y-1) || MapTemp(x+1,y-1) || MapTemp(x-1,y-1) || MapTemp(x,y-2)):
								MapTemp(x,y-1)=1
								temp=1
						}
						if (temp == 1) {
							MapTemp(x,y)=4 //turn this room into a ROOM4
							DebugLog("ROOM4 forced into slot ("+x+", "+y+")")
							Room4Amount[i]=Room4Amount[i]+1
							Room3Amount[i]=Room3Amount[i]-1
							Room1Amount[i]=Room1Amount[i]+1
						}
					}
					if (temp == 1) {break}
				}
				if (temp == 1) {break}
			}
			
			if (temp == 0) {DebugLog("Couldn't place ROOM4 in zone "+i)}
		}
		
		if (Room2CAmount[i] < 1) { //we want at least 1 ROOM2C
			DebugLog("forcing a ROOM2C into zone "+i)
			temp=0
			
			zone=zone+1
			temp2=temp2-1
			
			for (y of range(zone, temp2 + 1)) {
				for (x of range(3, MapWidth - 2)) {
					if (MapTemp(x,y) == 1) {
						switch (true) { //see if adding some rooms is possible
							case MapTemp(x-1,y)>0:
								if ((MapTemp(x,y-1)+MapTemp(x,y+1)+MapTemp(x+2,y)) == 0) {
									if ((MapTemp(x+1,y-2)+MapTemp(x+2,y-1)+MapTemp(x+1,y-1)) == 0) {
										MapTemp(x,y)=2
										MapTemp(x+1,y)=2
										DebugLog("ROOM2C forced into slot ("+(x+1)+", "+(y)+")")
										MapTemp(x+1,y-1)=1
										temp=1
									} else if ((MapTemp(x+1,y+2)+MapTemp(x+2,y+1)+MapTemp(x+1,y+1)) == 0) {
										MapTemp(x,y)=2
										MapTemp(x+1,y)=2
										DebugLog("ROOM2C forced into slot ("+(x+1)+", "+(y)+")")
										MapTemp(x+1,y+1)=1
										temp=1
									}
								}
							case MapTemp(x+1,y) > 0:
								if ((MapTemp(x,y-1)+MapTemp(x,y+1)+MapTemp(x-2,y)) == 0) {
									if ((MapTemp(x-1,y-2)+MapTemp(x-2,y-1)+MapTemp(x-1,y-1)) == 0) {
										MapTemp(x,y)=2
										MapTemp(x-1,y)=2
										DebugLog("ROOM2C forced into slot ("+(x-1)+", "+(y)+")")
										MapTemp(x-1,y-1)=1
										temp=1
									} else if ((MapTemp(x-1,y+2)+MapTemp(x-2,y+1)+MapTemp(x-1,y+1)) == 0) {
										MapTemp(x,y)=2
										MapTemp(x-1,y)=2
										DebugLog("ROOM2C forced into slot ("+(x-1)+", "+(y)+")")
										MapTemp(x-1,y+1)=1
										temp=1
									}
								}
							case MapTemp(x,y-1) > 0:
								if ((MapTemp(x-1,y)+MapTemp(x+1,y)+MapTemp(x,y+2))=0) {
									if ((MapTemp(x-2,y+1)+MapTemp(x-1,y+2)+MapTemp(x-1,y+1))=0) {
										MapTemp(x,y)=2
										MapTemp(x,y+1)=2
										DebugLog("ROOM2C forced into slot ("+(x)+", "+(y+1)+")")
										MapTemp(x-1,y+1)=1
										temp=1
									} else if ((MapTemp(x+2,y+1)+MapTemp(x+1,y+2)+MapTemp(x+1,y+1)) == 0) {
										MapTemp(x,y)=2
										MapTemp(x,y+1)=2
										DebugLog("ROOM2C forced into slot ("+(x)+", "+(y+1)+")")
										MapTemp(x+1,y+1)=1
										temp=1
									}
								}
							case MapTemp(x,y+1) > 0:
								if ((MapTemp(x-1,y)+MapTemp(x+1,y)+MapTemp(x,y-2)) == 0) {
									if ((MapTemp(x-2,y-1)+MapTemp(x-1,y-2)+MapTemp(x-1,y-1)) == 0) {
										MapTemp(x,y)=2
										MapTemp(x,y-1)=2
										DebugLog("ROOM2C forced into slot ("+(x)+", "+(y-1)+")")
										MapTemp(x-1,y-1)=1
										temp=1
									} else if ((MapTemp(x+2,y-1)+MapTemp(x+1,y-2)+MapTemp(x+1,y-1)) == 0) {
										MapTemp(x,y)=2
										MapTemp(x,y-1)=2
										DebugLog("ROOM2C forced into slot ("+(x)+", "+(y-1)+")")
										MapTemp(x+1,y-1)=1
										temp=1
									}
								}
						}
						if (temp == 1) {
							Room2CAmount[i]=Room2CAmount[i]+1
							Room2Amount[i]=Room2Amount[i]+1
						}
					}
					if (temp == 1) {break}
				}
				if (temp == 1) {break}
			}
			
			if (temp == 0) {DebugLog("Couldn't place ROOM2C in zone "+i)}
		}
		
	}
	
	let MaxRooms: int = 55*MapWidth/20
	MaxRooms=Max(MaxRooms,Room1Amount[0]+Room1Amount[1]+Room1Amount[2]+1)
	MaxRooms=Max(MaxRooms,Room2Amount[0]+Room2Amount[1]+Room2Amount[2]+1)
	MaxRooms=Max(MaxRooms,Room2CAmount[0]+Room2CAmount[1]+Room2CAmount[2]+1)
	MaxRooms=Max(MaxRooms,Room3Amount[0]+Room3Amount[1]+Room3Amount[2]+1)
	MaxRooms=Max(MaxRooms,Room4Amount[0]+Room4Amount[1]+Room4Amount[2]+1)
	var MapRoom: string[][] = new Array(ROOM4 + 1, MaxRooms)
	
	
	//zone 1 --------------------------------------------------------------------------------------------------
	
	let min_pos = 1, max_pos = Room1Amount[0]-1
	
	MapRoom(ROOM1, 0) = "start"	
	SetRoom("roompj", ROOM1, Floor(0.1*Float(Room1Amount[0])),min_pos,max_pos)
	SetRoom("914", ROOM1, Floor(0.3*Float(Room1Amount[0])),min_pos,max_pos)
	SetRoom("room1archive",ROOM1,Floor(0.5*Float(Room1Amount[0])),min_pos,max_pos)
	SetRoom("room205", ROOM1, Floor(0.6*Float(Room1Amount[0])),min_pos,max_pos)
	
	MapRoom(ROOM2C, 0) = "lockroom"
	
	min_pos = 1
	max_pos = Room2Amount[0]-1
	
	MapRoom(ROOM2, 0) = "room2closets"
	SetRoom("room2testroom2", ROOM2, Floor(0.1*Float(Room2Amount[0])),min_pos,max_pos)
	SetRoom("room2scps", ROOM2, Floor(0.2*Float(Room2Amount[0])),min_pos,max_pos)
	SetRoom("room2storage", ROOM2, Floor(0.3*Float(Room2Amount[0])),min_pos,max_pos)
	SetRoom("room2gw_b", ROOM2, Floor(0.4*Float(Room2Amount[0])),min_pos,max_pos)
	SetRoom("room2sl", ROOM2, Floor(0.5*Float(Room2Amount[0])),min_pos,max_pos)
	SetRoom("room012", ROOM2, Floor(0.55*Float(Room2Amount[0])),min_pos,max_pos)
	SetRoom("room2scps2",ROOM2,Floor(0.6*Float(Room2Amount[0])),min_pos,max_pos)
	SetRoom("room1123",ROOM2,Floor(0.7*Float(Room2Amount[0])),min_pos,max_pos)
	SetRoom("room2elevator",ROOM2,Floor(0.85*Float(Room2Amount[0])),min_pos,max_pos)
	
	
	MapRoom(ROOM3, Floor(Rnd(0.2,0.8)*Float(Room3Amount[0]))) = "room3storage"
	
	MapRoom(ROOM2C, Floor(0.5*Float(Room2CAmount[0]))) = "room1162"
	
	MapRoom(ROOM4, Floor(0.3*Float(Room4Amount[0]))) = "room4info"
	
	//zone 2 --------------------------------------------------------------------------------------------------
	
	min_pos = Room1Amount[0]
	max_pos = Room1Amount[0]+Room1Amount[1]-1
	
	SetRoom("room079", ROOM1, Room1Amount[0]+Floor(0.15*Float(Room1Amount[1])),min_pos,max_pos)
    SetRoom("room106", ROOM1, Room1Amount[0]+Floor(0.3*Float(Room1Amount[1])),min_pos,max_pos)
    SetRoom("008", ROOM1, Room1Amount[0]+Floor(0.4*Float(Room1Amount[1])),min_pos,max_pos)
    SetRoom("room035", ROOM1, Room1Amount[0]+Floor(0.5*Float(Room1Amount[1])),min_pos,max_pos)
    SetRoom("coffin", ROOM1, Room1Amount[0]+Floor(0.7*Float(Room1Amount[1])),min_pos,max_pos)
	
	min_pos = Room2Amount[0]
	max_pos = Room2Amount[0]+Room2Amount[1]-1
	
	MapRoom(ROOM2, Room2Amount[0]+Floor(0.1*Float(Room2Amount[1]))) = "room2nuke"
	SetRoom("room2tunnel", ROOM2, Room2Amount[0]+Floor(0.25*Float(Room2Amount[1])),min_pos,max_pos)
	SetRoom("room049", ROOM2, Room2Amount[0]+Floor(0.4*Float(Room2Amount[1])),min_pos,max_pos)
	SetRoom("room2shaft",ROOM2,Room2Amount[0]+Floor(0.6*Float(Room2Amount[1])),min_pos,max_pos)
	SetRoom("testroom", ROOM2, Room2Amount[0]+Floor(0.7*Float(Room2Amount[1])),min_pos,max_pos)
	SetRoom("room2servers", ROOM2, Room2Amount[0]+Floor(0.9*Room2Amount[1]),min_pos,max_pos)
	
	MapRoom(ROOM3, Room3Amount[0]+Floor(0.3*Float(Room3Amount[1]))) = "room513"
	MapRoom(ROOM3, Room3Amount[0]+Floor(0.6*Float(Room3Amount[1]))) = "room966"
	
	MapRoom(ROOM2C, Room2CAmount[0]+Floor(0.5*Float(Room2CAmount[1]))) = "room2cpit"
	
	
	//zone 3  --------------------------------------------------------------------------------------------------
	
	MapRoom(ROOM1, Room1Amount[0]+Room1Amount[1]+Room1Amount[2]-2) = "exit1"
	MapRoom(ROOM1, Room1Amount[0]+Room1Amount[1]+Room1Amount[2]-1) = "gateaentrance"
	MapRoom(ROOM1, Room1Amount[0]+Room1Amount[1]) = "room1lifts"
	
	min_pos = Room2Amount[0]+Room2Amount[1]
	max_pos = Room2Amount[0]+Room2Amount[1]+Room2Amount[2]-1		
	
	MapRoom(ROOM2, min_pos+Floor(0.1*Float(Room2Amount[2]))) = "room2poffices"
	SetRoom("room2cafeteria", ROOM2, min_pos+Floor(0.2*Float(Room2Amount[2])),min_pos,max_pos)
	SetRoom("room2sroom", ROOM2, min_pos+Floor(0.3*Float(Room2Amount[2])),min_pos,max_pos)
	SetRoom("room2servers2", ROOM2, min_pos+Floor(0.4*Room2Amount[2]),min_pos,max_pos)	
	SetRoom("room2offices", ROOM2, min_pos+Floor(0.45*Room2Amount[2]),min_pos,max_pos)
	SetRoom("room2offices4", ROOM2, min_pos+Floor(0.5*Room2Amount[2]),min_pos,max_pos)	
	SetRoom("room860", ROOM2, min_pos+Floor(0.6*Room2Amount[2]),min_pos,max_pos)
	SetRoom("medibay", ROOM2, min_pos+Floor(0.7*Float(Room2Amount[2])),min_pos,max_pos)
	SetRoom("room2poffices2", ROOM2, min_pos+Floor(0.8*Room2Amount[2]),min_pos,max_pos)
	SetRoom("room2offices2", ROOM2, min_pos+Floor(0.9*Float(Room2Amount[2])),min_pos,max_pos)
	
	MapRoom(ROOM2C, Room2CAmount[0]+Room2CAmount[1]) = "room2ccont"	
	MapRoom(ROOM2C, Room2CAmount[0]+Room2CAmount[1]+1) = "lockroom2"		
	
	MapRoom(ROOM3, Room3Amount[0]+Room3Amount[1]+Floor(0.3*Float(Room3Amount[2]))) = "room3servers"
	MapRoom(ROOM3, Room3Amount[0]+Room3Amount[1]+Floor(0.7*Float(Room3Amount[2]))) = "room3servers2"
	MapRoom(ROOM3, Room3Amount[0]+Room3Amount[1]+Floor(0.5*Float(Room3Amount[2]))) = "room3offices"
	
	//----------------------- luodaan kartta --------------------------------
	
	temp = 0
	let r: Rooms
	let spacing: float = 8.0
	for (y of range(MapHeight - 1, 2, - 1)) {
				
		if (y < MapHeight/3+1) {
			zone=3
		} else if (y < MapHeight*(2.0/3.0)) {
			zone=2
		} else {
			zone=1
		}
		
		for (x of range(1, MapWidth - 1)) {
			if (MapTemp(x, y) == 255) {
				if (y > MapHeight/2) { //zone = 2
					r = CreateRoom(zone, ROOM2, x * 8, 0, y * 8, "checkpoint1")
				} else { //if zone = 3
					r = CreateRoom(zone, ROOM2, x * 8, 0, y * 8, "checkpoint2")
				}
			} else if (MapTemp(x, y) > 0) {
				
				temp = Min(MapTemp(x + 1, y),1) + Min(MapTemp(x - 1, y),1) + Min(MapTemp(x, y + 1),1) + Min(MapTemp(x, y - 1),1)
				
				switch (temp) {
					case 1:
						if (MapRoomID(ROOM1) < MaxRooms && MapName(x,y) == "") {
							if (MapRoom(ROOM1, MapRoomID(ROOM1)) != "") {
								MapName(x, y) = MapRoom(ROOM1, MapRoomID(ROOM1))
							}
						}
						
						r = CreateRoom(zone, ROOM1, x * 8, 0, y * 8, MapName(x, y))
						if (MapTemp(x, y + 1)) {
							r.angle = 180 
							TurnEntity(r.obj, 0, r.angle, 0)
						} else if (MapTemp(x - 1, y)) {
							r.angle = 270
							TurnEntity(r.obj, 0, r.angle, 0)
						} else if (MapTemp(x + 1, y)) {
							r.angle = 90
							TurnEntity(r.obj, 0, r.angle, 0)
						} else { 
							r.angle = 0
						}
						MapRoomID(ROOM1)=MapRoomID(ROOM1)+1
					case 2:
						if (MapTemp(x - 1, y)>0 && MapTemp(x + 1, y)>0) {
							if (MapRoomID(ROOM2) < MaxRooms && MapName(x,y) == "" ) {
								if (MapRoom(ROOM2, MapRoomID(ROOM2)) != "") {
									MapName(x, y) = MapRoom(ROOM2, MapRoomID(ROOM2))
								}
							}
							r = CreateRoom(zone, ROOM2, x * 8, 0, y * 8, MapName(x, y))
							if (Rand(2) == 1) {
								r.angle = 90
							} else {
								r.angle = 270
							}
							TurnEntity(r.obj, 0, r.angle, 0)
							MapRoomID(ROOM2)=MapRoomID(ROOM2)+1
						} else if (MapTemp(x, y - 1)>0 && MapTemp(x, y + 1)>0) {
							if (MapRoomID(ROOM2) < MaxRooms && MapName(x,y) == "")  {
								if (MapRoom(ROOM2, MapRoomID(ROOM2)) != "") {
									MapName(x, y) = MapRoom(ROOM2, MapRoomID(ROOM2))
								}
							}
							r = CreateRoom(zone, ROOM2, x * 8, 0, y * 8, MapName(x, y))
							if (Rand(2) == 1) {
								r.angle = 180
							} else {
								r.angle = 0
							}
							TurnEntity(r.obj, 0, r.angle, 0)
							MapRoomID(ROOM2)=MapRoomID(ROOM2)+1
						} else {
							if (MapRoomID(ROOM2C) < MaxRooms && MapName(x,y) == "") {
								if (MapRoom(ROOM2C, MapRoomID(ROOM2C)) != "") {
									MapName(x, y) = MapRoom(ROOM2C, MapRoomID(ROOM2C))
								}
							}
							
							if (MapTemp(x - 1, y)>0 && MapTemp(x, y + 1)>0) {
								r = CreateRoom(zone, ROOM2C, x * 8, 0, y * 8, MapName(x, y))
								r.angle = 180
								TurnEntity(r.obj, 0, r.angle, 0)
							} else if (MapTemp(x + 1, y)>0 && MapTemp(x, y + 1)>0) {
								r = CreateRoom(zone, ROOM2C, x * 8, 0, y * 8, MapName(x, y))
								r.angle = 90
								TurnEntity(r.obj, 0, r.angle, 0)
							} else if (MapTemp(x - 1, y)>0 && MapTemp(x, y - 1)>0) {
								r = CreateRoom(zone, ROOM2C, x * 8, 0, y * 8, MapName(x, y))
								TurnEntity(r.obj, 0, 270, 0)
								r.angle = 270
							} else {
								r = CreateRoom(zone, ROOM2C, x * 8, 0, y * 8, MapName(x, y))
							}
							MapRoomID(ROOM2C)=MapRoomID(ROOM2C)+1
						}
					case 3:
						if (MapRoomID(ROOM3) < MaxRooms && MapName(x,y) == "") {
							if (MapRoom(ROOM3, MapRoomID(ROOM3)) != "") {
								MapName(x, y) = MapRoom(ROOM3, MapRoomID(ROOM3))
							}
						}
						
						r = CreateRoom(zone, ROOM3, x * 8, 0, y * 8, MapName(x, y))
						if (!MapTemp(x, y - 1)) {
							TurnEntity(r.obj, 0, 180, 0)
							r.angle = 180
						} else if (!MapTemp(x - 1, y)) {
							TurnEntity(r.obj, 0, 90, 0)
							r.angle = 90
						} else if (!MapTemp(x + 1, y)) {
							TurnEntity(r.obj, 0, -90, 0)
							r.angle = 270
						}
						MapRoomID(ROOM3)=MapRoomID(ROOM3)+1
					case 4:
						if (MapRoomID(ROOM4) < MaxRooms && MapName(x,y) == "") {
							if (MapRoom(ROOM4, MapRoomID(ROOM4)) != "") {
								MapName(x, y) = MapRoom(ROOM4, MapRoomID(ROOM4))
							}
						}
						
						r = CreateRoom(zone, ROOM4, x * 8, 0, y * 8, MapName(x, y))
						MapRoomID(ROOM4)=MapRoomID(ROOM4)+1
				}
				
			}
			
		}
	}		
	
	r = CreateRoom(0, ROOM1, (MapWidth-1) * 8, 500, 8, "gatea")
	MapRoomID(ROOM1)=MapRoomID(ROOM1)+1
	
	r = CreateRoom(0, ROOM1, (MapWidth-1) * 8, 0, (MapHeight-1) * 8, "pocketdimension")
	MapRoomID(ROOM1)=MapRoomID(ROOM1)+1	
	
	if (IntroEnabled) {
		r = CreateRoom(0, ROOM1, 8, 0, (MapHeight-1) * 8, "173")
		MapRoomID(ROOM1)=MapRoomID(ROOM1)+1
	}
	
	r = CreateRoom(0, ROOM1, 8, 800, 0, "dimension1499")
	MapRoomID(ROOM1)=MapRoomID(ROOM1)+1
	
	for (r of Rooms.each) {
		PreventRoomOverlap(r)
	}
	
	for (y of range(MapHeight + 1)) {
		for (x of range(MapWidth + 1)) {
			MapTemp(x, y) = Min(MapTemp(x, y),1)
		}
	}
	
	let d: Doors
	let shouldSpawnDoor: int
	for (y of range(MapHeight + 1, 0, -1)) {
		
		if (y<I_Zone.Transition[1]-1) {
			zone=3
		} else if (y>=I_Zone.Transition[1]-1 && y<I_Zone.Transition[0]-1) {
			zone=2
		} else {
			zone=1
		}
		
		for (x of range(MapWidth + 1, 0, -1)) {
			if (MapTemp(x,y) > 0) {
				if (zone == 2) {
					temp=2
				} else {
					temp=0
				}
                
                for (r of Rooms.each) {
					r.angle = WrapAngle(r.angle)
					if (Int(r.x/8.0) == x && Int(r.z/8.0) == y) {
						shouldSpawnDoor = False
						switch (r.RoomTemplate.Shape) {
							case ROOM1:
								if (r.angle == 90) {
									shouldSpawnDoor = True
								}
							case ROOM2:
								if (r.angle == 90 || r.angle == 270) {
									shouldSpawnDoor = True
								}
							case ROOM2C:
								if (r.angle == 0 || r.angle == 90) {
									shouldSpawnDoor = True
								}
							case ROOM3:
								if (r.angle == 0 || r.angle == 180 || r.angle == 90) {
									shouldSpawnDoor = True
								}
							default:
								shouldSpawnDoor = True
						}
						if (shouldSpawnDoor) {
							if ((x+1)<(MapWidth+1)) {
								if (MapTemp(x + 1, y) > 0) {
									d.Doors = CreateDoor(r.zone, Float(x) * spacing + spacing / 2.0, 0, Float(y) * spacing, 90, r, Max(Rand(-3, 1), 0), temp)
									r.AdjDoor[0] = d
								}
							}
						}
						
						shouldSpawnDoor = False
						switch (r.RoomTemplate.Shape) {
							case ROOM1:
								if (r.angle=180) {
									shouldSpawnDoor = true
								}
							case ROOM2:
								if (r.angle == 0 || r.angle == 180) {
									shouldSpawnDoor = true
								}
							case ROOM2C:
								if (r.angle == 180 || r.angle == 90) {
									shouldSpawnDoor = true
								}
							case ROOM3:
								if (r.angle == 180 || r.angle == 90 || r.angle == 270) {
									shouldSpawnDoor = true
								}
							default:
								shouldSpawnDoor = true
						}
						if (shouldSpawnDoor) {
							if ((y+1)<(MapHeight+1)) {
								if (MapTemp(x, y + 1) > 0) {
									d.Doors = CreateDoor(r.zone, Float(x) * spacing, 0, Float(y) * spacing + spacing / 2.0, 0, r, Max(Rand(-3, 1), 0), temp)
									r.AdjDoor[3] = d
								}
							}
						}
						
						break
					}
                }   
			}
		}
	}
	
	for (r of Rooms.each) {
		r.angle = WrapAngle(r.angle)
		r.Adjacent[0]=null
		r.Adjacent[1]=null
		r.Adjacent[2]=null
		r.Adjacent[3]=null
		for (r2 of Rooms.each) {
			if (r != r2) {
				if (r2.z == r.z) {
					if ((r2.x) == (r.x+8.0)) {
						r.Adjacent[0]=r2
						if (r.AdjDoor[0] == null) {r.AdjDoor[0] = r2.AdjDoor[2]}
					} else if ((r2.x) == (r.x-8.0)) {
						r.Adjacent[2]=r2
						if (r.AdjDoor[2] == null) {r.AdjDoor[2] = r2.AdjDoor[0]}
					}
				} else if (r2.x == r.x) {
					if ((r2.z) == (r.z-8.0)) {
						r.Adjacent[1]=r2
						if (r.AdjDoor[1] == null) {r.AdjDoor[1] = r2.AdjDoor[3]}
					} else if ((r2.z) == (r.z+8.0)) {
						r.Adjacent[3]=r2
						if (r.AdjDoor[3] == null) {
							r.AdjDoor[3] = r2.AdjDoor[1]
						}
					}
				}
			}
			if ((r.Adjacent[0] != null) && (r.Adjacent[1] != null) && (r.Adjacent[2] != null) && (r.Adjacent[3] != null)) {break}
		}
	}
	
}

function SetRoom(room_name$,room_type: int,pos: int,min_pos: int,max_pos: int) {//place a room without overwriting others
	
	if (max_pos < min_pos) {
		DebugLog("Can't place "+room_name)
		return False
	}
	
	DebugLog("--- SETROOM: "+Upper(room_name)+" ---")
	let looped: int
	let can_place: int
	looped = False
	can_place = True
	while (MapRoom(room_type,pos) != "") {
		DebugLog("found "+MapRoom(room_type,pos))
		pos=pos+1
		if (pos>max_pos) {
			if (!looped) {
				pos=min_pos+1
				looped=True
			} else {
				can_place=False
				break
			}
		}
	}
	DebugLog(room_name+" "+Str(pos))
	if (can_place) {
		DebugLog("--------------")
		MapRoom(room_type,pos)=room_name
		return True
	} else {
		DebugLog("couldn't place "+room_name)
		return False
	}
}

function GetZone(y: int) {
	return Min(Floor((Float(MapWidth-y)/MapWidth*ZONEAMOUNT)),ZONEAMOUNT-1)
}

//-------------------------------------------------------------------------------------------------------


function load_terrain(hmap,yscale: float=0.7,t1: int,t2: int,mask: int) {
	
	DebugLog("load_terrain: "+hmap)
	
	// load the heightmap
	if (hmap == 0) {RuntimeError("Heightmap image "+hmap+" does not exist.")}
	
	// store heightmap dimensions
	let x = ImageWidth(hmap)-1, y = ImageHeight(hmap)-1
	let lx,ly,index
	
	// load texture and lightmaps
	if (t1 == 0) {RuntimeError("load_terrain error: invalid texture 1")}
	if (t2 == 0) {RuntimeError("load_terrain error: invalid texture 2")}
	if (mask == 0) {RuntimeError("load_terrain error: invalid texture mask")}
	
	// auto scale the textures to the right size
	if (t1) {ScaleTexture(t1,x/4,y/4)}
	if (t2) {ScaleTexture(t2,x/4,y/4)}
	if (mask) {ScaleTexture(mask,x,y)}
	
	// start building the terrain
	let mesh = CreateMesh()
	let surf = CreateSurface(mesh)
	
	// create some verts for the terrain
	for (ly of range(y + 1)) {
		for (lx of range(x + 1)) {
			AddVertex(surf,lx,0,ly,1.0/lx,1.0/ly)
		}
	}
	RenderWorld()
			
	// connect the verts with faces
	for (ly of range(y)) {
		for (lx of range(x)) {
			AddTriangle(surf,lx+((x+1)*ly),lx+((x+1)*ly)+(x+1),(lx+1)+((x+1)*ly))
			AddTriangle(surf,(lx+1)+((x+1)*ly),lx+((x+1)*ly)+(x+1),(lx+1)+((x+1)*ly)+(x+1))
		}
	}
			
	// position the terrain to center 0,0,0
	let mesh2: int = CopyMesh(mesh,mesh)
	let surf2: int = GetSurface(mesh2,1)
	PositionMesh(mesh, -x/2.0,0,-y/2.0)
	PositionMesh(mesh2, -x/2.0,0.01,-y/2.0)
	
	// alter vertice height to match the heightmap red channel
	LockBuffer(ImageBuffer(hmap))
	LockBuffer(TextureBuffer(mask))
	//SetBuffer 
	for (lx of range(x + 1)) {
		for (ly of range(y + 1)) {
			//using vertex alpha and two meshes instead of FE_ALPHAWHATEVER
			//it doesn't look perfect but it does the job
			//you might get better results by downscaling the mask to the same size as the heightmap
			let maskX: float = Min(lx*Float(TextureWidth(mask))/Float(ImageWidth(hmap)),TextureWidth(mask)-1)
			let maskY: float = TextureHeight(mask)-Min(ly*Float(TextureHeight(mask))/Float(ImageHeight(hmap)),TextureHeight(mask)-1)
			RGB1=ReadPixelFast(Min(lx,x-1),y-Min(ly,y-1),ImageBuffer(hmap))
			r = (RGB1 && 0xFF0000) >> 16 //separate out the red
			let alpha: float=(((ReadPixelFast(Max(maskX-5,5),Max(maskY-5,5),TextureBuffer(mask)) && $FF000000) >> 24)/0xFF)
			alpha = alpha+(((ReadPixelFast(Min(maskX+5,TextureWidth(mask)-5),Min(maskY+5,TextureHeight(mask)-5),TextureBuffer(mask)) && 0xFF000000) >> 24)/0xFF)
			alpha = alpha+(((ReadPixelFast(Max(maskX-5,5),Min(maskY+5,TextureHeight(mask)-5),TextureBuffer(mask)) && 0xFF000000) >> 24)/0xFF)
			alpha = alpha+(((ReadPixelFast(Min(maskX+5,TextureWidth(mask)-5),Max(maskY-5,5),TextureBuffer(mask)) && 0xFF000000) >> 24)/0xFF)
			alpha = alpha*0.25
			alpha = Sqr(alpha)
			
			index = lx + ((x+1)*ly)
			VertexCoords(surf, index , VertexX(surf,index), r*yscale,VertexZ(surf,index))
			VertexCoords(surf2, index , VertexX(surf2,index), r*yscale,VertexZ(surf2,index))
			VertexColor(surf2, index, 255.0,255.0,255.0,alpha)
			// set the terrain texture coordinates
			VertexTexCoords(surf,index,lx,-ly )
			VertexTexCoords(surf2,index,lx,-ly )
		}
	}
	UnlockBuffer(TextureBuffer(mask))
	UnlockBuffer(ImageBuffer(hmap))
	
	UpdateNormals(mesh)
	UpdateNormals(mesh2)
	
	EntityTexture(mesh,t1,0,0)
	EntityTexture(mesh2,t2,0,0)
	
	EntityFX(mesh, 1)
	EntityFX(mesh2, 1+2+32)
	
	return mesh
}


export var UpdateRoomLightsTimer: float = 0.0

function UpdateRoomLights(cam: int) {
	
	let r: Rooms
	let i
	let random: float
	let alpha: float
	let dist: float
	
	for (r of Rooms.each) {
		if (r.dist < HideDistance*0.7 || r == PlayerRoom) {
			for (i of range(r.MaxLights + 1)) {
				if (r.Lights[i] != 0) {
					if (EnableRoomLights && (SecondaryLightOn>0.5) && cam == Camera) {
						EntityOrder(r.LightSprites2[i],-1)
						if (UpdateRoomLightsTimer == 0.0) {
							ShowEntity(r.LightSprites[i])
							
							if (EntityDistance(cam,r.Lights[i])<8.5) {
								if (r.LightHidden[i]) {
									ShowEntity(r.Lights[i])
									r.LightHidden[i] = False
								}
							} else {
								if (!r.LightHidden[i]) {
									HideEntity(r.Lights[i])
									r.LightHidden[i] = True
								}
							}
							
							if (EntityDistance(cam,r.LightSprites2[i])<8.5 || r.RoomTemplate.UseLightCones) {
								if (EntityVisible(cam,r.LightSpritesPivot[i]) || r.RoomTemplate.UseLightCones) {
									if (r.LightSpriteHidden[i]) {
										ShowEntity(r.LightSprites2[i])
										r.LightSpriteHidden[i] = False
									}
									if (PlayerRoom.RoomTemplate.Name == "173") {
										random = Rnd(0.38,0.42)
									} else {
										if (r.LightFlicker[i]<5) {
											random = Rnd(0.38,0.42)
										} else if (r.LightFlicker[i]>4 && r.LightFlicker[i]<10) {
											random = Rnd(0.35,0.45)
										} else {
											random = Rnd(0.3,0.5)
										}
									}
									ScaleSprite(r.LightSprites2[i],random,random)
									
									dist = (EntityDistance(cam,r.LightSpritesPivot[i])+0.5)/7.5
									dist = Max(Min(dist,1.0),0.0)
									alpha = Float(Inverse(dist))
									
									if (alpha > 0.0) {
										EntityAlpha(r.LightSprites2[i],Max(3*(Brightness/255)*(r.LightIntensity[i]/2),1)*alpha)
									} else {
										//Instead of rendering the sprite invisible, just hiding it if the player is far away from it
										if (!r.LightSpriteHidden[i]) {
											HideEntity(r.LightSprites2[i])
											r.LightSpriteHidden[i]=True
										}
									}
									
									if (r.RoomTemplate.UseLightCones) {
										if (EntityDistance(cam,r.LightSprites2[i])>=8.5 || (!EntityVisible(cam,r.LightSpritesPivot[i]))) {
											HideEntity(r.LightSprites2[i])
											r.LightSpriteHidden[i] = True
										}
									}
								} else {
									if (!r.LightSpriteHidden[i]) {
										HideEntity(r.LightSprites2[i])
										r.LightSpriteHidden[i] = True
									}
								}
							} else {
								if (!r.LightSpriteHidden[i]) {
									HideEntity(r.LightSprites2[i])
									r.LightSpriteHidden[i] = True
									if (r.LightCone[i] != 0) {
										HideEntity(r.LightCone[i])
									}
									if (r.LightConeSpark[i] != 0) {
										HideEntity(r.LightConeSpark[i])
									} //TODO: Does this need another close???????
								}
							}
							
							if (r.LightCone[i] != 0) {ShowEntity(r.LightCone[i])}
							
							if (r.LightConeSpark[i] != 0) {
								if (r.LightConeSparkTimer[i]>0 && r.LightConeSparkTimer[i]<10) {
									ShowEntity(r.LightConeSpark[i])
									r.LightConeSparkTimer[i]=r.LightConeSparkTimer[i]+FPSfactor
								} else {
									HideEntity(r.LightConeSpark[i])
									r.LightConeSparkTimer[i]=0
								}
							}
							
							if (r.LightCone[i] != 0) {
								ScaleEntity(r.LightCone[i],0.005+Max(((-0.4+random)*0.025),0),0.005+Max(((-0.4+random)*0.025),0),0.005+Max(((-0.4+random)*0.025),0))
								if (r.LightFlicker[i] > 4) {
									if (Rand(400) == 1) {
										SetEmitter(r.LightSpritesPivot[i],ParticleEffect[0])
										PlaySound2(IntroSFX(Rand(10,12)),cam,r.LightSpritesPivot[i])
										ShowEntity(r.LightConeSpark[i])
										r.LightConeSparkTimer[i] = FPSfactor
									}
								}
							}
						} else {
							if (EntityDistance(cam,r.LightSprites2[i])<8.5 || r.RoomTemplate.UseLightCones) {
								if (PlayerRoom.RoomTemplate.Name == "173") {
									random = Rnd(0.38,0.42)
								} else {
									if (r.LightFlicker[i]<5) {
										random = Rnd(0.38,0.42)
								 	} else if (r.LightFlicker[i]>4 && r.LightFlicker[i]<10) {
										random = Rnd(0.35,0.45)
									} else {
										random = Rnd(0.3,0.5)
									}
								}
								
								if (!r.LightSpriteHidden[i]) {
									ScaleSprite(r.LightSprites2[i],random,random)
								}
							}
							
							if (r.LightCone[i] != 0) {
								ScaleEntity(r.LightCone[i],0.005+Max(((-0.4+random)*0.025),0),0.005+Max(((-0.4+random)*0.025),0),0.005+Max(((-0.4+random)*0.025),0))
							}
							
							if (r.LightConeSpark[i] != 0) {
								if (r.LightConeSparkTimer[i]>0 && r.LightConeSparkTimer[i]<10) {
									ShowEntity(r.LightConeSpark[i])
									r.LightConeSparkTimer[i]=r.LightConeSparkTimer[i]+FPSfactor
								} else {
									HideEntity(r.LightConeSpark[i])
									r.LightConeSparkTimer[i]=0
								}
							}
						}
						UpdateRoomLightsTimer = UpdateRoomLightsTimer + FPSfactor
						if (UpdateRoomLightsTimer >= 8) {
							UpdateRoomLightsTimer = 0.0
						}
					} else if (cam == Camera) {
						if (SecondaryLightOn<=0.5) {
							HideEntity(r.LightSprites[i])
						} else {
							ShowEntity(r.LightSprites[i])
						}
						
						if (!r.LightHidden[i]) {
							HideEntity(r.Lights[i])
							r.LightHidden[i] = True
						}
						if (!r.LightSpriteHidden[i]) {
							HideEntity(r.LightSprites2[i])
							r.LightSpriteHidden[i]=True
						}
						if (r.LightCone[i] != 0) {HideEntity(r.LightCone[i])}
						if (r.LightConeSpark[i] != 0) {HideEntity(r.LightConeSpark[i])}
					} else {
						//This will make the lightsprites not glitch through the wall when they are rendered by the cameras
						EntityOrder(r.LightSprites2[i],0)
					}
				}
			}
		}
	}
}

function UpdateCheckpointMonitors(numb: int) {
	let i
	let sf
	let b
	let t1
	let entity: int
	
	if (numb == 0) {
		entity = Monitor2
		UpdateCheckpoint1 = True
	} else {
		entity = Monitor3
		UpdateCheckpoint2 = True
	}
	
	for (i of range(2, CountSurfaces(entity) + 1)) {
		sf = GetSurface(entity,i)
		b = GetSurfaceBrush(sf)
		if (b != 0) {
			t1 = GetBrushTexture(b,0)
			if (t1 != 0) {
				name$ = StripPath(TextureName(t1))
				if (Lower(name) != "monitortexture.jpg") {
					if (numb == 0) {
						if (MonitorTimer < 50) {
							BrushTexture(b, MonitorTexture2, 0, 0)
						} else {
							BrushTexture(b, MonitorTexture4, 0, 0)
						}
					} else {
						if (MonitorTimer2 < 50) {
							BrushTexture(b, MonitorTexture2, 0, 0)
						} else {
							BrushTexture(b, MonitorTexture3, 0, 0)
						}
					}
					PaintSurface(sf,b)
				}
				if (name != "") {FreeTexture(t1)}
			}
			FreeBrush(b)
		}
	}
}

function TurnCheckpointMonitorsOff(numb: int) {
	let i
	let sf
	let b
	let t1
	let entity: int
	
	if (numb == 0) {
		entity = Monitor2
		UpdateCheckpoint1 = False
		MonitorTimer = 0.0
	} else {
		entity = Monitor3
		UpdateCheckpoint2 = False
		MonitorTimer2 = 0.0
	}
	
	for (i of range(2, CountSurfaces(entity) + 1)) {
		sf = GetSurface(entity,i)
		b = GetSurfaceBrush(sf)
		if (b != 0) {
			t1 = GetBrushTexture(b,0)
			if (t1 != 0) {
				name$ = StripPath(TextureName(t1))
				if (Lower(name) != "monitortexture.jpg") {
					BrushTexture(b, MonitorTextureOff, 0, 0)
					PaintSurface(sf,b)
				}
				if (name != "") {
					FreeTexture(t1)
				}
			}
			FreeBrush(b)
		}
	}
}

function TimeCheckpointMonitors() {
	
	if (UpdateCheckpoint1) {
		if (MonitorTimer < 100.0) {
			MonitorTimer = Min(MonitorTimer + FPSfactor,100.0)
		} else {
			MonitorTimer = 0.0
		}
	}
	if (UpdateCheckpoint2) {
		if (MonitorTimer2 < 100.0) {
			MonitorTimer2 = Min(MonitorTimer2 + FPSfactor,100.0)
		} else {
			MonitorTimer2 = 0.0
		}
	}
}

function AmbientLightRooms(value: int=0) {
	let mesh: int
	let surf: int
	let brush: int
	let tex0: int
	
	if (value == AmbientLightRoomVal) {return}
	AmbientLightRoomVal = value
	
	let oldbuffer: int = BackBuffer() //probably shouldn't make assumptions here but who cares, why wouldn't it use the backbuffer //GetBuffer()
	
	SetBuffer(TextureBuffer(AmbientLightRoomTex))
	
	ClsColor(value,value,value)
	Cls()
	ClsColor(0,0,0)
	
	SetBuffer(oldbuffer)
}

//CHUNKS FOR 1499

export var CHUNKDATA: int[][] = new Array(64,64)

function SetChunkDataValues() {
	let StrTemp: string
	let i: int
	let j: int
	StrTemp = ""
	SeedRnd(GenerateSeedNumber(RandomSeed))
	
	for (i of range(64)) {
		for (j of range(64)) {
			CHUNKDATA(i,j)=Rand(0,GetINIInt("Data/1499chunks.INI","general","count"))
		}
	}
	
	SeedRnd(MilliSecs2())
	
}

class ChunkPart {
	Amount: int
	obj: int[] = new Array(128)
	RandomYaw: float[] = new Array(128)
	ID
}

function CreateChunkParts(r: Rooms) {
	let File: string = "Data/1499chunks.INI"
	let ChunkAmount: int = GetINIInt(File$,"general","count")
	let i: int
	let StrTemp: string = ''
	let j: int
	let chp: ChunkPart
	let chp2: ChunkPart
	let obj: int
	
	SeedRnd(GenerateSeedNumber(RandomSeed))
	
	for (i of range(ChunkAmount + 1)) {
		let loc: int = GetINISectionLocation(File$,"chunk"+i)
		if (loc > 0) {
			StrTemp = GetINIString2(File,loc,"count")
			chp = new ChunkPart()
			chp.Amount = Int(StrTemp$)
			DebugLog("------------------")
			for (j of range(Int(StrTemp) + 1)) {
				let objID: int = GetINIString2(File,loc,"obj"+j)
				let x: string = GetINIString2(File,loc,"obj"+j+"-x")
				let z: string = GetINIString2(File,loc,"obj"+j+"-z")
				let yaw: string = GetINIString2(File,loc,"obj"+j+"-yaw")
				DebugLog("1499 chunk X/Z/Yaw: "+x+"|"+z+"|"+yaw)
				chp.obj[j] = CopyEntity(r.Objects[objID])
				if (Lower(yaw) == "random") {
					chp.RandomYaw[j] = Rnd(360)
					RotateEntity(chp.obj[j],0,chp.RandomYaw[j],0)
				} else {
					RotateEntity(chp.obj[j],0,Float(yaw),0)
				}
				PositionEntity(chp.obj[j],Float(x),0,Float(z))
				ScaleEntity(chp.obj[j],RoomScale,RoomScale,RoomScale)
				EntityType(chp.obj[j],HIT_MAP)
				EntityPickMode(chp.obj[j],2)
				HideEntity(chp.obj[j])
			}
			chp2 = Before(chp)
			if (chp2 != null) {
				chp.ID = chp2.ID+1
			}
			DebugLog("<<<<<<<<<<<<<<<<")
			DebugLog("Generated 1499 chunk "+chp.ID+" sucessfully")
		}
	}
	
	SeedRnd(MilliSecs2())
}

class Chunk {
	obj: int[] = new Array(128)
	x: float
	z: float
	y: float
	Amount: int
	IsSpawnChunk: int
	ChunkPivot: int
	PlatForm: int
}

function CreateChunk(obj: int,x: float,y: float,z: float,isSpawnChunk: int=False) : Chunk {
	let ch: Chunk = new Chunk()
	let i: int
	let chp: ChunkPart
	
	ch.ChunkPivot = CreatePivot()
	ch.x = x
	ch.y = y
	ch.z = z
	PositionEntity(ch.ChunkPivot,ch.x+20.0,ch.y,ch.z+20.0,True)
	
	ch.IsSpawnChunk = isSpawnChunk
	
	if (obj > -1) {
		ch.Amount = GetINIInt("Data/1499chunks.INI","chunk"+obj,"count")
		for (chp of ChunkPart.each) {
			if (chp.ID == obj) {
				for (i of range(ch.Amount + 1)) {
					ch.obj[i] = CopyEntity(chp.obj[i],ch.ChunkPivot)
				}
			}
		}
	}
	
	ch.PlatForm = CopyEntity(PlayerRoom.Objects[0],ch.ChunkPivot)
	EntityType(ch.PlatForm,HIT_MAP)
	EntityPickMode(ch.PlatForm,2)
	
	return ch
}

function UpdateChunks(r: Rooms, ChunkPartAmount: int, spawnNPCs: boolean = True) {
	let ch: Chunk
	let StrTemp: string
	let i: int
	let x: float
	let z: float
	let ch2: Chunk
	let y: float
	let n: NPCs
	let j: int
	let ChunkX: float
	let ChunkZ: float
	let ChunkMaxDistance: float = 3*40
	
	ChunkX = Int(EntityX(Collider)/40)
	ChunkZ = Int(EntityZ(Collider)/40)
	
	y = EntityY(PlayerRoom.obj)
	x = -ChunkMaxDistance+(ChunkX*40)
	z = -ChunkMaxDistance+(ChunkZ*40)
	
	let CurrChunkData: int = 0, MaxChunks: int = GetINIInt("Data/1499chunks.INI","general","count")
	
	do {
		let chunkfound: boolean = False
		for (ch of Chunk.each) {
			if (ch.x == x) {
				if (ch.z == z) {
					chunkfound = True
					break
				}
			}
		}
		if (!chunkfound) {
			CurrChunkData = CHUNKDATA(Abs(((x+32)/40) % 64),Abs(((z+32)/40) % 64))
			ch2 = CreateChunk(CurrChunkData,x,y,z)
			ch2.IsSpawnChunk = False
		}
		x=x+40.0
		if (x > (ChunkMaxDistance+(ChunkX*40))) {
			z=z+40.0
			x = -ChunkMaxDistance+(ChunkX*40)
		}
	} while (!(z > (ChunkMaxDistance+(ChunkZ*40))))
	
	for (ch of Chunk.each) {
		if (!ch.IsSpawnChunk) {
			if (Distance(EntityX(Collider),EntityZ(Collider),EntityX(ch.ChunkPivot),EntityZ(ch.ChunkPivot))>ChunkMaxDistance) {
				FreeEntity(ch.ChunkPivot)
				Delete(ch)
			}
		}
	}
	
	let currNPCNumb: int = 0
	for (n of NPCs.each) {
		if (n.NPCtype == NPCtype1499) {
			currNPCNumb = currNPCNumb + 1
		}
	}
	
	let MaxNPCs: int = 64 //<---- the maximum amount of NPCs in dimension1499
	let e: Events
	for (e of Events.each) {
		if (e.room == PlayerRoom) {
			if (e.room.NPC[0] != null) {
				MaxNPCs = 16
				break
			}
		}
	}
	
	if (currNPCNumb < MaxNPCs) {
		switch (Rand(1,8)) {
			case 1:
				n.NPCs = CreateNPC(NPCtype1499,EntityX(Collider)+Rnd(40,80),EntityY(PlayerRoom.obj)+0.5,EntityZ(Collider)+Rnd(40,80))
			case 2:
				n.NPCs = CreateNPC(NPCtype1499,EntityX(Collider)+Rnd(40,80),EntityY(PlayerRoom.obj)+0.5,EntityZ(Collider)+Rnd(-40,40))
			case 3:
				n.NPCs = CreateNPC(NPCtype1499,EntityX(Collider)+Rnd(40,80),EntityY(PlayerRoom.obj)+0.5,EntityZ(Collider)+Rnd(-40,-80))
			case 4:
				n.NPCs = CreateNPC(NPCtype1499,EntityX(Collider)+Rnd(-40,40),EntityY(PlayerRoom.obj)+0.5,EntityZ(Collider)+Rnd(-40,-80))
			case 5:
				n.NPCs = CreateNPC(NPCtype1499,EntityX(Collider)+Rnd(-40,-80),EntityY(PlayerRoom.obj)+0.5,EntityZ(Collider)+Rnd(-40,-80))
			case 6:
				n.NPCs = CreateNPC(NPCtype1499,EntityX(Collider)+Rnd(-40,-80),EntityY(PlayerRoom.obj)+0.5,EntityZ(Collider)+Rnd(-40,40))
			case 7:
				n.NPCs = CreateNPC(NPCtype1499,EntityX(Collider)+Rnd(-40,-80),EntityY(PlayerRoom.obj)+0.5,EntityZ(Collider)+Rnd(40,80))
			case 8:
				n.NPCs = CreateNPC(NPCtype1499,EntityX(Collider)+Rnd(-40,40),EntityY(PlayerRoom.obj)+0.5,EntityZ(Collider)+Rnd(40,80))
		}
		if (Rand(2) == 1) {n.State2 = 500*3}
		n.Angle = Rnd(360)
	} else {
		for (n of NPCs.each) {
			if (n.NPCtype == NPCtype1499) {
				if (n.PrevState == 0) {
					if (EntityDistance(n.Collider,Collider)>ChunkMaxDistance || EntityY(n.Collider)<EntityY(PlayerRoom.obj)-5) {
						//This will be updated like this so that new NPCs can spawn for the player
						RemoveNPC(n)
					}
				}
			}
		}
	}
	
}

function HideChunks() {
	let ch: Chunk
	let i
	
	for (ch of Chunk.each) {
		if (!ch.IsSpawnChunk) {
			for (i of range(ch.Amount + 1)) {
				FreeEntity(ch.obj[i])
			}
			FreeEntity(ch.PlatForm)
			FreeEntity(ch.ChunkPivot)
			Delete(ch)
		}
	}
	
}

function DeleteChunks() {
	
	Delete(Chunk.each)
	Delete(ChunkPart.each)
	
}

class Dummy1499 {
	anim: int
	obj: int
}

class ElevatorObj {
	obj: int
	InFacility: int
	door: Doors
}

function AssignElevatorObj(obj: int,door: Doors,in_facility: int) : ElevatorObj {
	let eo: ElevatorObj = new ElevatorObj()
	
	eo.obj = obj
	eo.door = door
	eo.InFacility = in_facility
	
	return eo
}

function DeleteElevatorObjects() {
	
	Delete(ElevatorObj.each)
	
}

function ValidRoom2slCamRoom(r: Rooms) {
	if (r == null) {
		return False
	}
	
	let RN: string = r.RoomTemplate.Name$
	
	if (RN == "room2closets") {return true}
	if (RN == "room1archive") {return true}
	if (RN == "room3z3") {return true}
	if (RN == "room1lifts") {return true}
	if (RN == "checkpoint1") {return true}
	if (RN == "room2nuke") {return true}
	if (RN == "008") {return true}
	if (RN == "room1162") {return true}
	if (RN == "room966") {return true}
	if (RN == "room2ccont") {return true}
	
	return False
	
}

function FindAndDeleteFakeMonitor(r: Rooms,x: float,y: float,z: float,Amount: int) {
	let i: int
	
	for (i of range(Amount + 1)) {
		if (r.Objects[i] != 0) {
			if (EntityX(r.Objects[i],True) == x) {
				if (EntityY(r.Objects[i],True) == y) {
					if (EntityZ(r.Objects[i],True) == z) {
						FreeEntity(r.Objects[i])
						r.Objects[i]=0
						DebugLog("Deleted Fake Monitor: "+i)
						break
					}
				}
			}
		}
	}
}

function AddLightCones(room: Rooms) {
	let i
	
	for (i of range(MaxRoomLights)) {
		if (room.Lights[i] != 0) {
			room.LightCone[i] = CopyEntity(LightConeModel)
			ScaleEntity(room.LightCone[i],0.01,0.01,0.01)
			EntityColor(room.LightCone[i],room.LightR[i],room.LightG[i],room.LightB[i])
			EntityAlpha(room.LightCone[i],0.15)
			EntityBlend(room.LightCone[i],3)
			PositionEntity(room.LightCone[i],EntityX(room.LightSpritesPivot[i],True),EntityY(room.LightSpritesPivot[i],True),EntityZ(room.LightSpritesPivot[i],True),True)
			EntityParent(room.LightCone[i],room.LightSpritesPivot[i])
			
			if (room.LightFlicker[i] > 4) {
				room.LightConeSpark[i] = CreateSprite()
				ScaleSprite(room.LightConeSpark[i],1.0,1.0)
				EntityTexture(room.LightConeSpark[i],ParticleTextures(8))
				SpriteViewMode(room.LightConeSpark[i],2)
				EntityFX(room.LightConeSpark[i],1)
				RotateEntity(room.LightConeSpark[i],-90,0,0)
				EntityBlend(room.LightConeSpark[i],3)
				EntityAlpha(room.LightConeSpark[i],1.0)
				PositionEntity(room.LightConeSpark[i],EntityX(room.LightSpritesPivot[i],True),EntityY(room.LightSpritesPivot[i],True)+0.05,EntityZ(room.LightSpritesPivot[i],True),True)
				EntityParent(room.LightConeSpark[i],room.LightSpritesPivot[i])
			}
		}
	}
}

function CalculateRoomTemplateExtents(r: RoomTemplates) {
	if (r.DisableOverlapCheck) {return}
	
	GetMeshExtents(GetChild(r.obj,2))
	r.MinX = Mesh_MinX
	r.MinY = Mesh_MinY
	r.MinZ = Mesh_MinZ
	r.MaxX = Mesh_MaxX
	r.MaxY = Mesh_MaxY
	r.MaxZ = Mesh_MaxZ
	
	DebugLog("roomtemplateextents: "+r.MinX+", "+r.MinY	+", "+r.MinZ	+", "+r.MaxX	+", "+r.MaxY+", "+r.MaxZ)
}

function CalculateRoomExtents(r: Rooms) {
	if (r.RoomTemplate.DisableOverlapCheck) {return}
	
	//shrink the extents slightly - we don't care if the overlap is smaller than the thickness of the walls
	let shrinkAmount: float = 0.05
	
	//convert from the rooms local space to world space
	TFormVector(r.RoomTemplate.MinX, r.RoomTemplate.MinY, r.RoomTemplate.MinZ, r.obj, 0)
	r.MinX = TFormedX() + shrinkAmount + r.x
	r.MinY = TFormedY() + shrinkAmount
	r.MinZ = TFormedZ() + shrinkAmount + r.z
	
	//convert from the rooms local space to world space
	TFormVector(r.RoomTemplate.MaxX, r.RoomTemplate.MaxY, r.RoomTemplate.MaxZ, r.obj, 0)
	r.MaxX = TFormedX() - shrinkAmount + r.x
	r.MaxY = TFormedY() - shrinkAmount
	r.MaxZ = TFormedZ() - shrinkAmount + r.z
	
	if (r.MinX > r.MaxX) Then
		let tempX: float = r.MaxX
		r.MaxX = r.MinX
		r.MinX = tempX
	EndIf
	if (r.MinZ > r.MaxZ) Then
		let tempZ: float = r.MaxZ
		r.MaxZ = r.MinZ
		r.MinZ = tempZ
	EndIf
	
	DebugLog("roomextents: "+r.MinX+", "+r.MinY	+", "+r.MinZ	+", "+r.MaxX	+", "+r.MaxY+", "+r.MaxZ)
}

function CheckRoomOverlap(r1: Rooms, r2: Rooms) {
	if (r1.MaxX	<= r2.MinX || r1.MaxY <= r2.MinY || r1.MaxZ <= r2.MinZ) {return false}
	if (r1.MinX	>= r2.MaxX || r1.MinY >= r2.MaxY || r1.MinZ >= r2.MaxZ) {return false}
	
	return True
}

function PreventRoomOverlap(r: Rooms) {
	if (r.RoomTemplate.DisableOverlapCheck) {return}
	
	let r2: Rooms
	let r3: Rooms
	
	let isIntersecting: boolean = False
	
	//Just skip it when it would try to check for the checkpoints
	if (r.RoomTemplate.Name == "checkpoint1" || r.RoomTemplate.Name == "checkpoint2" || r.RoomTemplate.Name == "start") {return true}
	
	//First, check if the room is actually intersecting at all
	for (r2 of Rooms.each) {
		if (r2 != r && (!r2.RoomTemplate.DisableOverlapCheck)) {
			if (CheckRoomOverlap(r, r2)) {
				isIntersecting = True
				Exit
			}
		}
	}
	
	//if not, then simply return it as True
	if (!isIntersecting) {
		return True
	}
	
	//Room is interseting: First, check if the given room is a ROOM2, so we could potentially just turn it by 180 degrees
	isIntersecting = False
	let x: int = r.x/8.0
	let y: int = r.z/8.0
	if (r.RoomTemplate.Shape == ROOM2) {
		//Room is a ROOM2, let's check if turning it 180 degrees fixes the overlapping issue
		r.angle = r.angle + 180
		RotateEntity(r.obj,0,r.angle,0)
		CalculateRoomExtents(r)
		
		for (r2 of Rooms.each) {
			if (r2 != r && (!r2.RoomTemplate.DisableOverlapCheck)) {
				if (CheckRoomOverlap(r, r2)) {
					//didn't work -> rotate the room back and move to the next step
					isIntersecting = True
					r.angle = r.angle - 180
					RotateEntity(r.obj,0,r.angle,0)
					CalculateRoomExtents(r)
					break
				}
			}
		}
	} else {
		isIntersecting = True
	}
	
	//room is ROOM2 and was able to be turned by 180 degrees
	if (!isIntersecting) {
		DebugLog("ROOM2 turning succesful! "+r.RoomTemplate.Name)
		return True
	}
	
	//Room is either not a ROOM2 or the ROOM2 is still intersecting, now trying to swap the room with another of the same type
	isIntersecting = True
	let temp2,x2: int,y2: int,rot: int,rot2: int
	for (r2 of Rooms.each) {
		if (r2 != r && (!r2.RoomTemplate.DisableOverlapCheck)) {
			if (r.RoomTemplate.Shape == r2.RoomTemplate.Shape && r.zone == r2.zone && (r2.RoomTemplate.Name != "checkpoint1" && r2.RoomTemplate.Name != "checkpoint2" && r2.RoomTemplate.Name != "start")) {
				x = r.x/8.0
				y = r.z/8.0
				rot = r.angle
				
				x2 = r2.x/8.0
				y2 = r2.z/8.0
				rot2 = r2.angle
				
				isIntersecting = False
				
				r.x = x2*8.0
				r.z = y2*8.0
				r.angle = rot2
				PositionEntity(r.obj,r.x,r.y,r.z)
				RotateEntity(r.obj,0,r.angle,0)
				CalculateRoomExtents(r)
				
				r2.x = x*8.0
				r2.z = y*8.0
				r2.angle = rot
				PositionEntity(r2.obj,r2.x,r2.y,r2.z)
				RotateEntity(r2.obj,0,r2.angle,0)
				CalculateRoomExtents(r2)
				
				//make sure neither room overlaps with anything after the swap
				for (r3 of Rooms.each) {
					if (!r3.RoomTemplate.DisableOverlapCheck) {
						if (r3 != r) {
							if (CheckRoomOverlap(r, r3)) {
								isIntersecting = True
								break
							}
						}
						if (r3 != r2) {
							if (CheckRoomOverlap(r2, r3)) {
								isIntersecting = True
								break
							}
						}	
					}
				}
				
				//Either the original room or the "reposition" room is intersecting, reset the position of each room to their original one
				if (isIntersecting) {
					r.x = x*8.0
					r.z = y*8.0
					r.angle = rot
					PositionEntity(r.obj,r.x,r.y,r.z)
					RotateEntity(r.obj,0,r.angle,0)
					CalculateRoomExtents(r)
					
					r2.x = x2*8.0
					r2.z = y2*8.0
					r2.angle = rot2
					PositionEntity(r2.obj,r2.x,r2.y,r2.z)
					RotateEntity(r2.obj,0,r2.angle,0)
					CalculateRoomExtents(r2)
					
					isIntersecting = False
				}
			}
		}
	}
	
	//room was able to the placed in a different spot
	if (!isIntersecting) {
		DebugLog("Room re-placing successful! "+r.RoomTemplate.Name)
		return True
	}
	
	DebugLog("Couldn't fix overlap issue for room "+r.RoomTemplate.Name)
	return False
}

DrawLoading(80,true)

//[Block]
export var Curr173: NPCs
export var Curr106: NPCs
export var Curr096: NPCs
export var Curr5131: NPCs
export const NPCtype173: int = 1
export const NPCtypeOldMan: int = 2
export const NPCtypeGuard: int = 3
export const NPCtypeD: int = 4
export const NPCtype372: int = 6
export const NPCtypeApache: int = 7
export const NPCtypeMTF: int = 8
export const NPCtype096 = 9
export const NPCtype049: int = 10
export const NPCtypeZombie: int = 11
export const NPCtype5131: int = 12
export const NPCtypeTentacle: int = 13
export const NPCtype860: int = 14
export const NPCtype939: int = 15
export const NPCtype066: int = 16
export const NPCtypePdPlane: int = 17
export const NPCtype966: int = 18
export const NPCtype1048a = 19
export const NPCtype1499: int = 20
export const NPCtype008: int = 21
export const NPCtypeClerk: int = 22
//[End Block]

enum PathStatus {
	NotSearched,
	Found,
	Unreachable
}

export class NPCs {
	obj: int
	obj2: int
	obj3: int
	obj4: int
	Collider: int
	NPCtype: int
	ID: int
	DropSpeed: float
	Gravity: int
	State: float
	State2: float
	State3: float
	PrevState: int
	MakingNoise: int
	
	Frame: float
	
	Angle: float
	Sound: int
	SoundChn: int
	SoundTimer: float
	Sound2: int
	SoundChn2: int
	
	Speed: float
	CurrSpeed: float
	
	texture$
	
	Idle: float
	
	Reload: float
	
	LastSeen: int
	LastDist: float
	
	PrevX: float
	PrevY: float
	PrevZ: float
	
	Target: NPCs
	TargetID: int
	EnemyX: float
	EnemyY: float
	EnemyZ: float
	
	Path: WayPoints[] = new Array(20)
	pathstatus: PathStatus
	PathTimer: float
	PathLocation: int
	
	NVX: float
	NVY: float
	NVZ: float
	NVName: string
	
	GravityMult: float = 1.0
	MaxGravity: float = 0.2
	
	MTFVariant: int
	MTFLeader: NPCs
	IsDead: int
	BlinkTimer: float = 1.0
	IgnorePlayer: int
	
	ManipulateBone: int
	ManipulationType: int
	BoneToManipulate$
	BonePitch: float
	BoneYaw: float
	BoneRoll: float
	NPCNameInSection$
	InFacility: boolean = True
	CanUseElevator: boolean = False
	CurrElevator: ElevatorObj
	HP: int
	PathX: float
	PathZ: float
	Model$
	ModelScaleX: float
	ModelScaleY: float
	ModelScaleZ: float
	HideFromNVG
	TextureID: int = -1
	CollRadius: float
	IdleTimer: float
	SoundChn_IsStream: int
	SoundChn2_IsStream: int
	FallingPickDistance: float
}

function CreateNPC(NPCtype: int, x: float, y: float, z: float) : NPCs {
	let n: NPCs = new NPCs()
	let n2: NPCs
	let temp: float
	let i: int
	let diff1
	let bump1
	let spec1
	let sf
	let b
	let t1
	
	n.NPCtype = NPCtype
	n.GravityMult = 1.0
	n.MaxGravity = 0.2
	n.CollRadius = 0.2
	n.FallingPickDistance = 10
	switch (NPCtype) {
		case NPCtype173:
			//[Block]
			n.NVName = "SCP-173"
			n.Collider = CreatePivot()
			EntityRadius(n.Collider, 0.23, 0.32)
			EntityType(n.Collider, HIT_PLAYER)
			n.Gravity = True
			
			n.obj = LoadMesh_Strict("GFX/npcs/173_2.b3d")
			
			//On Halloween set jack-o-latern texture.
			if (Left(CurrentDate(), 7) == "31 Oct ") {
				HalloweenTex = True
				let texFestive = LoadTexture_Strict("GFX/npcs/173h.pt", 1)
				EntityTexture(n.obj, texFestive, 0, 0)
				FreeTexture(texFestive)
			}
			
			temp = (GetINIFloat("DATA/NPCs.ini", "SCP-173", "scale") / MeshDepth(n.obj))			
			ScaleEntity(n.obj, temp,temp,temp)
			
			n.Speed = (GetINIFloat("DATA/NPCs.ini", "SCP-173", "speed") / 100.0)
			
			n.obj2 = LoadMesh_Strict("GFX/173box.b3d")
			ScaleEntity(n.obj2, RoomScale, RoomScale, RoomScale)
			HideEntity(n.obj2)
			
			n.CollRadius = 0.32
			//[End Block]
		case NPCtypeOldMan:
			//[Block]
			n.NVName = "SCP-106"
			n.Collider = CreatePivot()
			n.GravityMult = 0.0
			n.MaxGravity = 0.0
			EntityRadius(n.Collider, 0.2)
			EntityType(n.Collider, HIT_PLAYER)
			n.obj = LoadAnimMesh_Strict("GFX/npcs/106_2.b3d")
			
			temp = (GetINIFloat("DATA/NPCs.ini", "SCP-106", "scale") / 2.2)		
			ScaleEntity(n.obj, temp, temp, temp)
			
			let OldManEyes: int = LoadTexture_Strict("GFX/npcs/oldmaneyes.jpg")
			
			n.Speed = (GetINIFloat("DATA/NPCs.ini", "SCP-106", "speed") / 100.0)
			
			n.obj2 = CreateSprite()
			ScaleSprite(n.obj2, 0.03, 0.03)
			EntityTexture(n.obj2, OldManEyes)
			EntityBlend (n.obj2, 3)
			EntityFX(n.obj2, 1 + 8)
			SpriteViewMode(n.obj2, 2)
			
			FreeTexture(OldManEyes)
			//[End Block]
		case NPCtypeGuard:
			//[Block]
			n.NVName = "Human"
			n.Collider = CreatePivot()
			EntityRadius(n.Collider, 0.2)
			
			EntityType(n.Collider, HIT_PLAYER)
			n.obj = CopyEntity(GuardObj)
			
			n.Speed = (GetINIFloat("DATA/NPCs.ini", "Guard", "speed") / 100.0)
			temp = (GetINIFloat("DATA/NPCs.ini", "Guard", "scale") / 2.5)
			
			ScaleEntity(n.obj, temp, temp, temp)
			
			MeshCullBox (n.obj, -MeshWidth(GuardObj), -MeshHeight(GuardObj), -MeshDepth(GuardObj), MeshWidth(GuardObj)*2, MeshHeight(GuardObj)*2, MeshDepth(GuardObj)*2)
			//[End Block]
		case NPCtypeMTF:
			//[Block]
			n.NVName = "Human"
			n.Collider = CreatePivot()
			EntityRadius(n.Collider, 0.2)
			EntityType(n.Collider, HIT_PLAYER)
			n.obj = CopyEntity(MTFObj)
			
			n.Speed = (GetINIFloat("DATA/NPCs.ini", "MTF", "speed") / 100.0)
			
			temp = (GetINIFloat("DATA/NPCs.ini", "MTF", "scale") / 2.5)
			
			ScaleEntity(n.obj, temp, temp, temp)
			
			MeshCullBox (n.obj, -MeshWidth(MTFObj), -MeshHeight(MTFObj), -MeshDepth(MTFObj), MeshWidth(MTFObj)*2, MeshHeight(MTFObj)*2, MeshDepth(MTFObj)*2) 
			
			if (MTFSFX(0) == 0) {
				MTFSFX(0)=LoadSound_Strict("SFX/Character/MTF/ClassD1.ogg")
				MTFSFX(1)=LoadSound_Strict("SFX/Character/MTF/ClassD2.ogg")
				MTFSFX(2)=LoadSound_Strict("SFX/Character/MTF/ClassD3.ogg")			
				MTFSFX(3)=LoadSound_Strict("SFX/Character/MTF/ClassD4.ogg")
				MTFSFX(5)=LoadSound_Strict("SFX/Character/MTF/Beep.ogg")
				MTFSFX(6)=LoadSound_Strict("SFX/Character/MTF/Breath.ogg")
			}
			if (MTFrooms[6] == Null) {
				for (r of Rooms.each) {
					switch (Lower(r.RoomTemplate.Name)) {
						case "room106":
							MTFrooms[0]=r
						case "roompj":
							MTFrooms[1]=r	
						case "room079":
							MTFrooms[2]=r	
						case "room2poffices":
							MTFrooms[3]=r	
						case "914":
							MTFrooms[4]=r	
						case "coffin":
							MTFrooms[5]=r	
						case "start":
							MTFrooms[6]=r
					}
				}
			}
			//[End Block]
		case NPCtypeD:
			//[Block]
			n.NVName = "Human"
			n.Collider = CreatePivot()
			EntityRadius(n.Collider, 0.32)
			EntityType(n.Collider, HIT_PLAYER)
			
			n.obj = CopyEntity(ClassDObj)
			
			temp = 0.5 / MeshWidth(n.obj)
			ScaleEntity(n.obj, temp, temp, temp)
			
			n.Speed = 2.0 / 100
			
			MeshCullBox (n.obj, -MeshWidth(ClassDObj), -MeshHeight(ClassDObj), -MeshDepth(ClassDObj), MeshWidth(ClassDObj)*2, MeshHeight(ClassDObj)*2, MeshDepth(ClassDObj)*2)
			
			n.CollRadius = 0.32
			//[End Block]
		case NPCtype372:
			//[Block]
			n.Collider = CreatePivot()
			EntityRadius(n.Collider, 0.2)
			n.obj = LoadAnimMesh_Strict("GFX/npcs/372.b3d")
			
			temp = 0.35 / MeshWidth(n.obj)
			ScaleEntity(n.obj, temp, temp, temp)
			//[End Block]
		case NPCtype5131:
			//[Block]
			n.NVName = "SCP-513-1"
			n.Collider = CreatePivot()
			EntityRadius(n.Collider, 0.2)
			n.obj = LoadAnimMesh_Strict("GFX/npcs/bll.b3d")
			
			n.obj2 = CopyEntity (n.obj)
			EntityAlpha(n.obj2, 0.6)
			
			temp = 1.8 / MeshWidth(n.obj)
			ScaleEntity(n.obj, temp, temp, temp)
			ScaleEntity(n.obj2, temp, temp, temp)
			//[End Block]
		case NPCtype096:
			//[Block]
			n.NVName = "SCP-096"
			n.Collider = CreatePivot()
			EntityRadius(n.Collider, 0.26)
			EntityType(n.Collider, HIT_PLAYER)
			n.obj = LoadAnimMesh_Strict("GFX/npcs/scp096.b3d")
			
			n.Speed = (GetINIFloat("DATA/NPCs.ini", "SCP-096", "speed") / 100.0)
			
			temp = (GetINIFloat("DATA/NPCs.ini", "SCP-096", "scale") / 3.0)
			ScaleEntity(n.obj, temp, temp, temp	)
			
			MeshCullBox (n.obj, -MeshWidth(n.obj)*2, -MeshHeight(n.obj)*2, -MeshDepth(n.obj)*2, MeshWidth(n.obj)*2, MeshHeight(n.obj)*4, MeshDepth(n.obj)*4)
			
			n.CollRadius = 0.26
			//[End Block]
		case NPCtype049:
			//[Block]
			n.NVName = "SCP-049"
			n.Collider = CreatePivot()
			EntityRadius(n.Collider, 0.2)
			EntityType(n.Collider, HIT_PLAYER)
			n.obj = CopyEntity(NPC049OBJ)
			
			n.Speed = (GetINIFloat("DATA/NPCs.ini", "SCP-049", "speed") / 100.0)
			
			temp = GetINIFloat("DATA/NPCs.ini", "SCP-049", "scale")
			ScaleEntity(n.obj, temp, temp, temp	)
			
			n.Sound = LoadSound_Strict("SFX/Horror/Horror12.ogg")
			
			if (HorrorSFX(13) == 0) {
				HorrorSFX(13)=LoadSound_Strict("SFX/Horror/Horror13.ogg")
			}
			
			n.CanUseElevator = True
			//[End Block]
		case NPCtypeZombie:
			//[Block]
			n.NVName = "Human"
			n.Collider = CreatePivot()
			EntityRadius(n.Collider, 0.2)
			EntityType(n.Collider, HIT_PLAYER)
						
			if (n.obj == 0) {
				n.obj = CopyEntity(NPC0492OBJ)
				
				temp = (GetINIFloat("DATA/NPCs.ini", "SCP-049-2", "scale") / 2.5)
				ScaleEntity(n.obj, temp, temp, temp)
				
				MeshCullBox (n.obj, -MeshWidth(n.obj), -MeshHeight(n.obj), -MeshDepth(n.obj), MeshWidth(n.obj)*2, MeshHeight(n.obj)*2, MeshDepth(n.obj)*2)
			}
			
			n.Speed = (GetINIFloat("DATA/NPCs.ini", "SCP-049-2", "speed") / 100.0)
			
			SetAnimTime(n.obj, 107)
			
			n.Sound = LoadSound_Strict("SFX/SCP/049/0492Breath.ogg")
			
			n.HP = 100
			//[End Block]
		case NPCtypeApache:
			//[Block]
			n.NVName = "Human"
			n.GravityMult = 0.0
			n.MaxGravity = 0.0
			n.Collider = CreatePivot()
			EntityRadius(n.Collider, 0.2)
			n.obj = CopyEntity(ApacheObj)
			
			n.obj2 = CopyEntity(ApacheRotorObj)
			EntityParent(n.obj2,n.obj)
			
			for (i of range(-1, 2, 2)) {
				let rotor2 = CopyEntity(n.obj2,n.obj2)
				RotateEntity(rotor2,0,4.0*i,0)
				EntityAlpha(rotor2, 0.5)
			}
			
			n.obj3 = LoadAnimMesh_Strict("GFX/apacherotor2.b3d",n.obj)
			PositionEntity(n.obj3, 0.0, 2.15, -5.48)
			
			EntityType(n.Collider, HIT_APACHE)
			EntityRadius(n.Collider, 3.0)
			
			for (i of range(-1, 2, 2)) {
				let Light1 = CreateLight(2,n.obj)
				LightRange(Light1,2.0)
				LightColor(Light1,255,255,255)
				PositionEntity(Light1, 1.65*i, 1.17, -0.25)
				
				let lightsprite = CreateSprite(n.obj)
				PositionEntity(lightsprite, 1.65*i, 1.17, 0, -0.25)
				ScaleSprite(lightsprite, 0.13, 0.13)
				EntityTexture(lightsprite, LightSpriteTex(0))
				EntityBlend (lightsprite, 3)
				EntityFX(lightsprite, 1+8)
			}
			
			temp = 0.6
			ScaleEntity(n.obj, temp, temp, temp)
			//[End Block]
		case NPCtypeTentacle:
			//[Block]
			n.NVName = "Unidentified"
			
			n.Collider = CreatePivot()
			
			for (n2 of NPCs.each) {
				if (n.NPCtype == n2.NPCtype && n != n2) {
					n.obj = CopyEntity (n2.obj)
					break
				}
			}
			
			if (n.obj == 0) {
				n.obj = LoadAnimMesh_Strict("GFX/NPCs/035tentacle.b3d")
				ScaleEntity(n.obj, 0.065,0.065,0.065)
			}
			
			SetAnimTime(n.obj, 283)
			//[End Block]
		case NPCtype860:
			//[Block]
			n.NVName = "Unidentified"
			
			n.Collider = CreatePivot()
			EntityRadius(n.Collider, 0.25)
			EntityType(n.Collider, HIT_PLAYER)
			n.obj = LoadAnimMesh_Strict("GFX/npcs/forestmonster.b3d")
			
			EntityFX(n.obj, 1)
			
			tex = LoadTexture_Strict("GFX/npcs/860_eyes.png",1+2)
			
			n.obj2 = CreateSprite()
			ScaleSprite(n.obj2, 0.1, 0.1)
			EntityTexture(n.obj2, tex)
			FreeTexture(tex)
			
			EntityFX(n.obj2, 1 + 8)
			EntityBlend(n.obj2, BLEND_ADD)
			SpriteViewMode(n.obj2, 2)
			
			n.Speed = (GetINIFloat("DATA/NPCs.ini", "forestmonster", "speed") / 100.0)
			
			temp = (GetINIFloat("DATA/NPCs.ini", "forestmonster", "scale") / 20.0)
			ScaleEntity(n.obj, temp, temp, temp	)
			
			MeshCullBox (n.obj, -MeshWidth(n.obj)*2, -MeshHeight(n.obj)*2, -MeshDepth(n.obj)*2, MeshWidth(n.obj)*2, MeshHeight(n.obj)*4, MeshDepth(n.obj)*4)
			
			n.CollRadius = 0.25
			//[End Block]
		case NPCtype939:
			let amount939: int = 0
			for (n2 of NPCs.each) {
				if ((n.NPCtype == n2.NPCtype) && (n != n2)) {
					amount939 += 1
				}
			}
			if (amount939 == 0) {i = 53}
			if (amount939 == 1) {i = 89}
			if (amount939 == 2) {i = 96}
			n.NVName = "SCP-939-"+i
			
			n.Collider = CreatePivot()
			EntityRadius(n.Collider, 0.3)
			EntityType(n.Collider, HIT_PLAYER)
			for (n2 of NPCs.each) {
				if (n.NPCtype == n2.NPCtype && n != n2) {
					n.obj = CopyEntity (n2.obj)
					break
				}
			}
			
			if (n.obj == 0) {
				n.obj = LoadAnimMesh_Strict("GFX/NPCs/scp-939.b3d")
								
				temp = GetINIFloat("DATA/NPCs.ini", "SCP-939", "scale")/2.5
				ScaleEntity(n.obj, temp, temp, temp)
			}
			
			n.Speed = (GetINIFloat("DATA/NPCs.ini", "SCP-939", "speed") / 100.0)
			
			n.CollRadius = 0.3
			//[End Block]
		case NPCtype066:
			//[Block]
			n.NVName = "SCP-066"
			n.Collider = CreatePivot()
			EntityRadius(n.Collider, 0.2)
			EntityType(n.Collider, HIT_PLAYER)
			
			n.obj = LoadAnimMesh_Strict("GFX/NPCs/scp-066.b3d")
			temp = GetINIFloat("DATA/NPCs.ini", "SCP-066", "scale")/2.5
			ScaleEntity(n.obj, temp, temp, temp		)
			
			n.Speed = (GetINIFloat("DATA/NPCs.ini", "SCP-066", "speed") / 100.0)
			//[End Block]
		case NPCtype966:
			//[Block]
			i = 1
			for (n2 of NPCs.each) {
				if ((n.NPCtype == n2.NPCtype) && (n != n2)) {i=i+1}
			}
			n.NVName = "SCP-966-"+i
			
			n.Collider = CreatePivot()
			EntityRadius(n.Collider,0.2)
			
			for (n2 of NPCs.each) {
				if ((n.NPCtype == n2.NPCtype) && (n != n2)) {
					n.obj = CopyEntity (n2.obj)
					break
				}
			}
			
			if (n.obj == 0) { 
				n.obj = LoadAnimMesh_Strict("GFX/npcs/scp-966.b3d")
			}
			
			EntityFX(n.obj,1)
			
			temp = GetINIFloat("DATA/NPCs.ini", "SCP-966", "scale")/40.0
			ScaleEntity(n.obj, temp, temp, temp		)
			
			
			SetAnimTime(n.obj,15.0)
			
			EntityType(n.Collider,HIT_PLAYER)
			
			n.Speed = (GetINIFloat("DATA/NPCs.ini", "SCP-966", "speed") / 100.0)
			//[End Block]
		case NPCtype1048a:
			//[Block]
			n.NVName = "SCP-1048-A"
			n.obj =	LoadAnimMesh_Strict("GFX/npcs/scp-1048a.b3d")
			ScaleEntity(n.obj, 0.05,0.05,0.05)
			SetAnimTime(n.obj, 2)
			
			n.Sound = LoadSound_Strict("SFX/SCP/1048A/Shriek.ogg")
			n.Sound2 = LoadSound_Strict("SFX/SCP/1048A/Growth.ogg")
			//[End Block]
		case NPCtype1499:
			//[Block]
			n.NVName = "Unidentified"
			n.Collider = CreatePivot()
			EntityRadius(n.Collider, 0.2)
			EntityType(n.Collider, HIT_PLAYER)
			for (n2 of NPCs.each) {
				if ((n.NPCtype == n2.NPCtype) && (n != n2)) {
					n.obj = CopyEntity (n2.obj)
					break
				}
			}
			
			if (n.obj == 0) {
				n.obj = LoadAnimMesh_Strict("GFX/npcs/1499-1.b3d")
			}
			
			n.Speed = (GetINIFloat("DATA/NPCs.ini", "SCP-1499-1", "speed") / 100.0) * Rnd(0.9,1.1)
			temp = (GetINIFloat("DATA/NPCs.ini", "SCP-1499-1", "scale") / 4.0) * Rnd(0.8,1.0)
			
			ScaleEntity(n.obj, temp, temp, temp)
			
			EntityFX(n.obj,1)
			
			EntityAutoFade(n.obj,HideDistance*2.5,HideDistance*2.95)
			//[End Block]
		case NPCtype008:
			//[Block]
			n.NVName = "Human"
			n.Collider = CreatePivot()
			EntityRadius(n.Collider, 0.2)
			EntityType(n.Collider, HIT_PLAYER)
			
			n.obj = LoadAnimMesh_Strict("GFX/npcs/zombiesurgeon.b3d")
			
			temp = 0.5 / MeshWidth(n.obj)
			ScaleEntity(n.obj, temp, temp, temp)
			
			n.Speed = 2.0 / 100
			
			MeshCullBox (n.obj, -MeshWidth(n.obj), -MeshHeight(n.obj), -MeshDepth(n.obj), MeshWidth(n.obj)*2, MeshHeight(n.obj)*2, MeshDepth(n.obj)*2)
			
			SetNPCFrame(n,11)
			
			n.Sound = LoadSound_Strict("SFX/SCP/049/0492Breath.ogg")
			
			n.HP = 120
			//[End Block]
		case NPCtypeClerk:
			//[Block]
			n.NVName = "Human"
			n.Collider = CreatePivot()
			EntityRadius(n.Collider, 0.32)
			EntityType(n.Collider, HIT_PLAYER)
			
			n.obj = CopyEntity(ClerkOBJ)
			
			temp = 0.5 / MeshWidth(n.obj)
			ScaleEntity(n.obj, temp, temp, temp)
			
			n.Speed = 2.0 / 100
			
			MeshCullBox (n.obj, -MeshWidth(ClerkOBJ), -MeshHeight(ClerkOBJ), -MeshDepth(ClerkOBJ), MeshWidth(ClerkOBJ)*2, MeshHeight(ClerkOBJ)*2, MeshDepth(ClerkOBJ)*2)
			
			n.CollRadius = 0.32
			//[End Block]
	}
	
	PositionEntity(n.Collider, x, y, z, True)
	PositionEntity(n.obj, x, y, z, True)
	
	ResetEntity(n.Collider)
	
	n.ID = 0
	n.ID = FindFreeNPCID()
	
	DebugLog ("Created NPC " + n.NVName + " (ID: " + n.ID + ")")
	
	NPCSpeedChange(n)
	
	return n
}

function RemoveNPC(n: NPCs) {
	
	if (n == Null) {return}
	
	if (n.obj2 != 0) {
		FreeEntity(n.obj2)
		n.obj2 = 0
	}
	if (n.obj3 != 0) {
		FreeEntity(n.obj3)
		n.obj3 = 0
	}
	if (n.obj4 != 0) {
		FreeEntity(n.obj4)
		n.obj4 = 0
	}
	
	if (!n.SoundChn_IsStream) {
		if (n.SoundChn != 0 && ChannelPlaying(n.SoundChn)) {
			StopChannel(n.SoundChn)
		}
	} else {
		if (n.SoundChn != 0) {
			StopStream_Strict(n.SoundChn)
		}
	}
	
	if (!n.SoundChn2_IsStream) {
		if (n.SoundChn2 != 0 && ChannelPlaying(n.SoundChn2)) {
			StopChannel(n.SoundChn2)
		}
	} else {
		if (n.SoundChn2 != 0) {
			StopStream_Strict(n.SoundChn2)
		}
	}
	
	if (n.Sound!=0) {FreeSound_Strict(n.Sound)}
	if (n.Sound2!=0) {FreeSound_Strict(n.Sound2)}
	
	FreeEntity(n.obj)
	n.obj = 0
	FreeEntity(n.Collider)
	n.Collider = 0	
	
	Delete(n)
}


function UpdateNPCs() {
	CatchErrors("Uncaught (UpdateNPCs)")
	let n: NPCs
	let n2: NPCs
	let d: Doors
	let de: Decals
	let r: Rooms
	let eo: ElevatorObj
	let eo2: ElevatorObj
	let i: int
	let dist: float
	let dist2: float
	let angle: float
	let x: float
	let y: float
	let z: float
	let prevFrame: float
	let PlayerSeeAble: int
	let RN: string
	
	let target
	
	for (n of NPCs.each) {
		//A variable to determine if the NPC is in the facility or not
		n.InFacility = CheckForNPCInFacility(n)
		
		switch (n.NPCtype) {
			case NPCtype173:
				//[Block]
				
				if (Curr173.Idle != 3) {
					dist = EntityDistance(n.Collider, Collider)		
					
					n.State3 = 1
					
					if (n.Idle < 2) {
						if (n.IdleTimer > 0.1) {
							n.Idle = 1
							n.IdleTimer = Max(n.IdleTimer-FPSfactor,0.1)
						} else if (n.IdleTimer == 0.1) {
							n.Idle = 0
							n.IdleTimer = 0
						}
						
						PositionEntity(n.obj, EntityX(n.Collider), EntityY(n.Collider) - 0.32, EntityZ(n.Collider))
						RotateEntity (n.obj, 0, EntityYaw(n.Collider)-180, 0)
						
						if (!n.Idle) {
							let temp: boolean = False
							let move: boolean = True
							if (dist < 15) {
								if (dist < 10.0) {
									if (EntityVisible(n.Collider, Collider)) {
										temp = True
										n.EnemyX = EntityX(Collider, True)
										n.EnemyY = EntityY(Collider, True)
										n.EnemyZ = EntityZ(Collider, True)
									}
								}										
								
								let SoundVol: float = Max(Min((Distance(EntityX(n.Collider), EntityZ(n.Collider), n.PrevX, n.PrevZ) * 2.5), 1.0), 0.0)
								n.SoundChn = LoopSound2(StoneDragSFX, n.SoundChn, Camera, n.Collider, 10.0, n.State)
								
								n.PrevX = EntityX(n.Collider)
								n.PrevZ = EntityZ(n.Collider)				
								
								if ((BlinkTimer < -16 || BlinkTimer > -6) && !IsNVGBlinking) {
									if (EntityInView(n.obj, Camera)) {
										move = False
									}
								}
							}
							
							if (NoTarget) {
								move = True
							}
							
							//player is looking at it -> doesn't move
							if (!move) {
								BlurVolume = Max(Max(Min((4.0 - dist) / 6.0, 0.9), 0.1), BlurVolume)
								CurrCameraZoom = Max(CurrCameraZoom, (Sin(Float(MilliSecs2())/20.0)+1.0)*15.0*Max((3.5-dist)/3.5,0.0))								
								
								if (dist < 3.5 && MilliSecs2() - n.LastSeen > 60000 && temp) {
									PlaySound_Strict(HorrorSFX(Rand(3,4)))
									
									n.LastSeen = MilliSecs2()
								}
								
								if (dist < 1.5 && Rand(700) == 1) {
									PlaySound2(Scp173SFX(Rand(0, 2)), Camera, n.obj)
								}
								
								if (dist < 1.5 && n.LastDist > 2.0 && temp) {
									CurrCameraZoom = 40.0
									HeartBeatRate = Max(HeartBeatRate, 140)
									HeartBeatVolume = 0.5
									
									switch (Rand(5)) {
										case 1:
											PlaySound_Strict(HorrorSFX(1))
										case 2:
											PlaySound_Strict(HorrorSFX(2))
										case 3:
											PlaySound_Strict(HorrorSFX(9))
										case 4:
											PlaySound_Strict(HorrorSFX(10))
										case 5:
											PlaySound_Strict(HorrorSFX(14))
									}
								}									
									
								n.LastDist = dist
								
								n.State = Max(0, n.State - FPSfactor / 20)
							} else {
								//more than 6 room lengths away from the player -> teleport to a room closer to the player
								if (dist > 50) {
									if (Rand(70)=1) {
										if (PlayerRoom.RoomTemplate.Name != "exit1" && PlayerRoom.RoomTemplate.Name != "gatea" && PlayerRoom.RoomTemplate.Name != "pocketdimension") {
											for (w of WayPoints.each) {
												if (w.door=Null && Rand(5) == 1) {
													x = Abs(EntityX(Collider)-EntityX(w.obj,True))
													if (x < 25.0 && x > 15.0) {
														z = Abs(EntityZ(Collider)-EntityZ(w.obj,True))
														if (z < 25 && z > 15.0) {
															DebugLog("MOVING 173 TO "+w.room.roomtemplate.name)
															PositionEntity(n.Collider, EntityX(w.obj,True), EntityY(w.obj,True)+0.25,EntityZ(w.obj,True))
															ResetEntity(n.Collider)
															break
														}
													}
														
												}
											}
										}
									}
								} else if (dist > HideDistance*0.8) { //3-6 rooms away from the player -> move randomly from waypoint to another
									if (Rand(70) == 1) {
										TeleportCloser(n)
									}
								} else { //less than 3 rooms away -> actively move towards the player
									n.State = CurveValue(SoundVol, n.State, 3)
									
									//try to open doors
									if (Rand(20) == 1) {
										for (d of Doors.each) {
											if (!d.locked && !d.open && d.Code == "" && d.KeyCard == 0) {
												for (i of range(2)) {
													if (d.buttons[i] != 0) {
														if (Abs(EntityX(n.Collider) - EntityX(d.buttons[i])) < 0.5) {
															if (Abs(EntityZ(n.Collider) - EntityZ(d.buttons[i])) < 0.5) {
																if (d.openstate >= 180 || d.openstate <= 0) {
																	pvt = CreatePivot()
																	PositionEntity(pvt, EntityX(n.Collider), EntityY(n.Collider) + 0.5, EntityZ(n.Collider))
																	PointEntity(pvt, d.buttons[i])
																	MoveEntity(pvt, 0, 0, n.Speed * 0.6)
																	
																	if (EntityPick(pvt, 0.5) == d.buttons[i]) {
																		PlaySound_Strict (LoadTempSound("SFX/Door/DoorOpen173.ogg"))
																		UseDoor(d,False)
																	}
																	
																	FreeEntity(pvt)
																}
															}
														}
													}
												}
											}
										}
									}
									
									if (NoTarget) {
										temp = False
										n.EnemyX = 0
										n.EnemyY = 0
										n.EnemyZ = 0
									}
									
									//player is not looking and is visible from 173's position -> attack
									if (temp) {
										if (dist < 0.65) {
											if (KillTimer >= 0 && !GodMode) {
												
												switch (PlayerRoom.RoomTemplate.Name) {
													case "lockroom", "room2closets", "coffin":
														DeathMSG = "Subject D-9341. Cause of death: Fatal cervical fracture. The surveillance tapes confirm that the subject was killed by SCP-173."	
													case "173":
														DeathMSG = "Subject D-9341. Cause of death: Fatal cervical fracture. According to Security Chief Franklin who was present at SCP-173's containment "
														DeathMSG = DeathMSG + "chamber during the breach, the subject was killed by SCP-173 as soon as the disruptions in the electrical network started."
													case "room2doors":
														DeathMSG = Chr(34)+"If I'm not mistaken, one of the main purposes of these rooms was to stop SCP-173 from moving further in the event of a containment breach. "
														DeathMSG = DeathMSG + "So, who's brilliant idea was it to put A GODDAMN MAN-SIZED VENTILATION DUCT in there?"+Chr(34)
													default:
														DeathMSG = "Subject D-9341. Cause of death: Fatal cervical fracture. Assumed to be attacked by SCP-173."
												}
												
												if (!GodMode) {
													n.Idle = True
												}
												PlaySound_Strict(NeckSnapSFX(Rand(0,2)))
												if (Rand(2) == 1) {
													TurnEntity(Camera, 0, Rand(80,100), 0)
												} else {
													TurnEntity(Camera, 0, Rand(-100,-80), 0)
												}
												Kill()
												
											}
										} else {
											PointEntity(n.Collider, Collider)
											RotateEntity(n.Collider, 0, EntityYaw(n.Collider), EntityRoll(n.Collider))
											TranslateEntity(n.Collider,Cos(EntityYaw(n.Collider)+90.0)*n.Speed*FPSfactor,0.0,Sin(EntityYaw(n.Collider)+90.0)*n.Speed*FPSfactor)
										}
										
									} else { //player is not visible -> move to the location where he was last seen							
										if (n.EnemyX != 0) {
											if (Distance(EntityX(n.Collider), EntityZ(n.Collider), n.EnemyX, n.EnemyZ) > 0.5) {
												AlignToVector(n.Collider, n.EnemyX-EntityX(n.Collider), 0, n.EnemyZ-EntityZ(n.Collider), 3)
												MoveEntity(n.Collider, 0, 0, n.Speed * FPSfactor)
												if (Rand(500) == 1) {
													n.EnemyX = 0
													n.EnemyY = 0
													n.EnemyZ = 0
												}
											} else {
												n.EnemyX = 0
												n.EnemyY = 0
												n.EnemyZ = 0
											}
										} else {
											if (Rand(400) == 1) {
												RotateEntity (n.Collider, 0, Rnd(360), 10)
											}
											TranslateEntity(n.Collider,Cos(EntityYaw(n.Collider)+90.0)*n.Speed*FPSfactor,0.0,Sin(EntityYaw(n.Collider)+90.0)*n.Speed*FPSfactor)
											
										}
									}
									
								} // less than 2 rooms away from the player
								
							}
							
						} //idle = false
						
						PositionEntity(n.Collider, EntityX(n.Collider), Min(EntityY(n.Collider),0.35), EntityZ(n.Collider))
						
					} else {
						
						if (n.Target != Null) {
							let tmp: boolean = false
							if (dist > HideDistance*0.7) {
								if (!EntityVisible(n.obj,Collider)) {
									tmp = True
								}
							}
							if (!tmp) {
								PointEntity(n.obj, n.Target.Collider)
								RotateEntity(n.Collider, 0, CurveAngle(EntityYaw(n.obj),EntityYaw(n.Collider),10.0), 0, True)
								dist = EntityDistance(n.Collider, n.Target.Collider)
								
								MoveEntity(n.Collider, 0, 0, 0.016*FPSfactor*Max(Min((dist*2-1.0)*0.5,1.0),-0.5))
								n.GravityMult = 1.0
							} else {
								PositionEntity(n.Collider,EntityX(n.Target.Collider),EntityY(n.Target.Collider)+0.3,EntityZ(n.Target.Collider))
								ResetEntity(n.Collider)
								n.DropSpeed = 0
								n.GravityMult = 0.0
							}
							
						}
						
						PositionEntity(n.obj, EntityX(n.Collider), EntityY(n.Collider) + 0.05 + Sin(MilliSecs2()*0.08)*0.02, EntityZ(n.Collider))
						RotateEntity (n.obj, 0, EntityYaw(n.Collider)-180, 0)
						
						ShowEntity(n.obj2)
						
						PositionEntity(n.obj2, EntityX(n.Collider), EntityY(n.Collider) - 0.05 + Sin(MilliSecs2()*0.08)*0.02, EntityZ(n.Collider))
						RotateEntity (n.obj2, 0, EntityYaw(n.Collider)-180, 0)
					}
				}
				
				//[End block]
			case NPCtypeOldMan: //------------------------------------------------------------------------------------------------------------------
				//[Block]
				if (Contained106) {
					n.Idle = True
					HideEntity(n.obj)
					HideEntity(n.obj2)
					PositionEntity(n.obj, 0,500.0,0, True)
				} else {
					
					dist = EntityDistance(n.Collider, Collider)
					
					let spawn106: boolean = True
					//checking if 106 is allowed to spawn
					if (PlayerRoom.RoomTemplate.Name == "dimension1499") {spawn106 = False}
					for (e of Events.each) {
						if (e.EventName == "room860") {
							if (e.EventState == 1) {
								spawn106 = False
							}
							break
						}
					}
					if (PlayerRoom.RoomTemplate.Name == "room049" && EntityY(Collider) <= -2848*RoomScale) {
						spawn106 = False
					}
					//GateA event has been triggered - don't make 106 disapper!
					//The reason why this is a seperate For loop is because we need to make sure that room860 would not be able to overwrite the "spawn106%" variable
					for (e of Events.each) {
						if (e.EventName == "gatea") {
							if (e.EventState != 0) {
								spawn106 = True
								if (PlayerRoom.RoomTemplate.Name == "dimension1499") {
									n.Idle = True
								} else {
									n.Idle = False
								}
							}
							break
						}
					}
					if ((!spawn106) && n.State <= 0) {
						n.State = Rand(22000, 27000)
						PositionEntity(n.Collider,0,500,0)
					}
					
					if ((!n.Idle) && spawn106) {
						if (n.State <= 0) {	//attacking	
							if (EntityY(n.Collider) < EntityY(Collider) - 20.0 - 0.55) {
								if (!PlayerRoom.RoomTemplate.DisableDecals) {
									de.Decals = CreateDecal(0, EntityX(Collider), 0.01, EntityZ(Collider), 90, Rand(360), 0)
									de.Size = 0.05
									de.SizeChange = 0.001
									EntityAlpha(de.obj, 0.8)
									UpdateDecals
								}
								
								n.PrevY = EntityY(Collider)
								
								SetAnimTime(n.obj, 110)
								
								if (PlayerRoom.RoomTemplate.Name != "coffin") {
									PositionEntity(n.Collider, EntityX(Collider), EntityY(Collider) - 15, EntityZ(Collider))
								}
								
								PlaySound_Strict(DecaySFX(0))
							}
							
							if (Rand(500) == 1) {PlaySound2(OldManSFX(Rand(0, 2)), Camera, n.Collider)}
							n.SoundChn = LoopSound2(OldManSFX(4), n.SoundChn, Camera, n.Collider, 8.0, 0.8)
							
							if (n.State > -10) {
								ShouldPlay = 66
								if (n.Frame<259) {
									PositionEntity(n.Collider, EntityX(n.Collider), n.PrevY-0.15, EntityZ(n.Collider))
									PointEntity(n.obj, Collider)
									RotateEntity (n.Collider, 0, CurveValue(EntityYaw(n.obj),EntityYaw(n.Collider),100.0), 0, True)
									
									AnimateNPC(n, 110, 259, 0.15, False)
								} else {
									n.State = -10
								}
							} else {
								if (PlayerRoom.RoomTemplate.Name != "gatea") {ShouldPlay = 10}
								
								let Visible: boolean = false
								if (dist < 8.0) {
									Visible = EntityVisible(n.Collider, Collider)
								}
								
								if (NoTarget) {Visible = False}
								
								if (Visible) {
									if (PlayerRoom.RoomTemplate.Name != "gatea") {
										n.PathTimer = 0
									}
									if (EntityInView(n.Collider, Camera)) {
										GiveAchievement(Achv106)
																				
										BlurVolume = Max(Max(Min((4.0 - dist) / 6.0, 0.9), 0.1), BlurVolume)
										CurrCameraZoom = Max(CurrCameraZoom, (Sin(Float(MilliSecs2())/20.0)+1.0) * 20.0 * Max((4.0-dist)/4.0,0))
										
										if (MilliSecs2() - n.LastSeen > 60000) {
											CurrCameraZoom = 40
											PlaySound_Strict(HorrorSFX(6))
											n.LastSeen = MilliSecs2()
										}
									}
								} else {
									n.State -= FPSfactor
								}
								
								if (dist > 0.8) {
									if ((dist > 25.0 || PlayerRoom.RoomTemplate.Name == "pocketdimension" || Visible || n.PathStatus != 1) && PlayerRoom.RoomTemplate.Name != "gatea") {
										
										if (dist > 40 || PlayerRoom.RoomTemplate.Name == "pocketdimension") {
											TranslateEntity(n.Collider, 0, ((EntityY(Collider) - 0.14) - EntityY(n.Collider)) / 50.0, 0)
										}
										
										n.CurrSpeed = CurveValue(n.Speed,n.CurrSpeed,10.0)
										
										PointEntity(n.obj, Collider)
										RotateEntity(n.Collider, 0, CurveAngle(EntityYaw(n.obj), EntityYaw(n.Collider), 10.0), 0)
										
										if (KillTimer >= 0) {
											prevFrame = n.Frame
											AnimateNPC(n, 284, 333, n.CurrSpeed*43)
											
											if (prevFrame <= 286 && n.Frame>286) {
												PlaySound2(Step2SFX(Rand(0,2)),Camera, n.Collider, 6.0, Rnd(0.8,1.0))	
											} else if (prevFrame <= 311 && n.Frame>311.0) {
												PlaySound2(Step2SFX(Rand(0,2)),Camera, n.Collider, 6.0, Rnd(0.8,1.0))
											}
										} else { 
											n.CurrSpeed = 0
										}
										
										n.PathTimer = Max(n.PathTimer-FPSfactor,0)
										if (n.PathTimer <= 0) {
											n.PathStatus = FindPath (n, EntityX(Collider,True), EntityY(Collider,True), EntityZ(Collider,True))
											n.PathTimer = 70*10
										}
									} else {
										if (n.PathTimer <= 0) {
											n.PathStatus = FindPath (n, EntityX(Collider,True), EntityY(Collider,True), EntityZ(Collider,True))
											n.PathTimer = 70*10
											n.CurrSpeed = 0
										} else {
											n.PathTimer = Max(n.PathTimer-FPSfactor,0)
											
											if (n.PathStatus == 2) {
												n.CurrSpeed = 0
											} else if (n.PathStatus == 1) {
												while (n.Path[n.PathLocation] == Null) {
													if (n.PathLocation > 19) {
														n.PathLocation = 0
														n.PathStatus = 0
														break
													} else {
														n.PathLocation = n.PathLocation + 1
													}
												}
												
												if (n.Path[n.PathLocation]) {
													TranslateEntity(n.Collider, 0, ((EntityY(n.Path[n.PathLocation].obj,True) - 0.11) - EntityY(n.Collider)) / 50.0, 0)
													
													PointEntity(n.obj, n.Path[n.PathLocation].obj)
													
													dist2 = EntityDistance(n.Collider,n.Path[n.PathLocation].obj)
													
													RotateEntity(n.Collider, 0, CurveAngle(EntityYaw(n.obj), EntityYaw(n.Collider), Min(20.0,dist2*10.0)), 0)
													n.CurrSpeed = CurveValue(n.Speed,n.CurrSpeed,10.0)
													
													prevFrame = AnimTime(n.obj)
													AnimateNPC(n, 284, 333, n.CurrSpeed*43)
													if (prevFrame <= 286 && n.Frame>286) {
														PlaySound2(Step2SFX(Rand(0,2)),Camera, n.Collider, 6.0, Rnd(0.8,1.0))	
													} else if (prevFrame <= 311 && n.Frame>311.0) {
														PlaySound2(Step2SFX(Rand(0,2)),Camera, n.Collider, 6.0, Rnd(0.8,1.0))
													}
													
													if (dist2 < 0.2) {n.PathLocation += 1}
												}
											} else if (n.PathStatus == 0) {
												if (n.State3 == 0) {AnimateNPC(n, 334, 494, 0.3)}
												n.CurrSpeed = CurveValue(0,n.CurrSpeed,10.0)
											}
										}
									}
									
								} else if (PlayerRoom.RoomTemplate.Name != "gatea" && !NoTarget) {
									
									if (dist > 0.5) {
										n.CurrSpeed = CurveValue(n.Speed * 2.5,n.CurrSpeed,10.0)
									} else {
										n.CurrSpeed = 0
									}
									AnimateNPC(n, 105, 110, 0.15, False)
									
									if (KillTimer >= 0 && FallTimer >= 0) {
										PointEntity()
										RotateEntity(n.Collider, 0, CurveAngle(EntityYaw(n.obj), EntityYaw(n.Collider), 10.0), 0)
										
										if (Ceil(n.Frame) == 110 && (!GodMode)) {
											PlaySound_Strict(DamageSFX(1))
											PlaySound_Strict(HorrorSFX(5))											
											if (PlayerRoom.RoomTemplate.Name = "pocketdimension") {
												DeathMSG = "Subject D-9341. Body partially decomposed by what is assumed to be SCP-106's "+Chr(34)+"corrosion"+Chr(34)+" effect. Body disposed of via incineration."
												Kill()
											} else {
												PlaySound_Strict(OldManSFX(3))
												FallTimer = Min(-1, FallTimer)
												PositionEntity(Head, EntityX(Camera, True), EntityY(Camera, True), EntityZ(Camera, True), True)
												ResetEntity (Head)
												RotateEntity(Head, 0, EntityYaw(Camera) + Rand(-45, 45), 0)
											}
										}
									}
									
								}
								
							} 
							
							MoveEntity(n.Collider, 0, 0, n.CurrSpeed * FPSfactor)
							
							if (n.State <= Rand(-3500, -3000)) {
								if (!EntityInView(n.obj,Camera) && dist > 5) {
									n.State = Rand(22000, 27000)
									PositionEntity(n.Collider,0,500,0)
								}
							}
							
							if (FallTimer < -250.0) {
								MoveToPocketDimension()
								n.State = 250 //make 106 idle for a while
							}
							
							if (n.Reload == 0) {
                                if (dist > 10 && PlayerRoom.RoomTemplate.Name != "pocketdimension" && PlayerRoom.RoomTemplate.Name != "gatea" && n.State < -5) { //timer idea by Juanjpro
                                    if (!EntityInView(n.obj,Camera)) {
                                        TurnEntity(Collider,0,180,0)
                                        pick = EntityPick(Collider,5)
                                        TurnEntity(Collider,0,180,0)
                                        if (pick != 0) {
											TeleportEntity(n.Collider,PickedX(),PickedY(),PickedZ(),n.CollRadius)
                                            PointEntity(n.Collider,Collider)
                                            RotateEntity(n.Collider,0,EntityYaw(n.Collider),0)
                                            MoveEntity(n.Collider,0,0,-2)
                                            PlaySound2(OldManSFX(3),Camera,n.Collider)
											n.SoundChn2 = PlaySound2(OldManSFX(6+Rand(0,2)),Camera,n.Collider)
                                            n.PathTimer = 0
                                            n.Reload = (70*10.0)/(SelectedDifficulty.otherFactors+1)
                                            DebugLog("Teleported 106 (Distance: "+EntityDistance(n.Collider,Collider)+")")
										}
									}
                                }
                            }
                            n.Reload = Max(0, n.Reload - FPSfactor)
                            DebugLog("106 in... "+n.Reload )
							
							UpdateSoundOrigin(n.SoundChn2,Camera,n.Collider)
						} else { //idling outside the map
							n.CurrSpeed = 0
							MoveEntity(n.Collider, 0, ((EntityY(Collider) - 30) - EntityY(n.Collider)) / 200.0, 0)
							n.DropSpeed = 0
							n.Frame = 110
							
							if (!PlayerRoom.RoomTemplate.DisableDecals) {
								if (PlayerRoom.RoomTemplate.Name != "gatea") {
									if (SelectedDifficulty.aggressiveNPCs) {
										n.State=n.State-FPSfactor*2
									} else {
										n.State=n.State-FPSfactor
									}
								}
							}
						}
						
						ResetEntity(n.Collider)
						n.DropSpeed = 0
						PositionEntity(n.obj, EntityX(n.Collider), EntityY(n.Collider) - 0.15, EntityZ(n.Collider))
						
						RotateEntity(n.obj, 0, EntityYaw(n.Collider), 0)
						
						PositionEntity(n.obj2, EntityX(n.obj), EntityY(n.obj) , EntityZ(n.obj))
						RotateEntity(n.obj2, 0, EntityYaw(n.Collider) - 180, 0)
						MoveEntity(n.obj2, 0, 8.6 * 0.11, -1.5 * 0.11)
						
						if (PlayerRoom.RoomTemplate.Name == "pocketdimension" || PlayerRoom.RoomTemplate.Name == "gatea") {
							HideEntity (n.obj2)
						} else {
							if (dist < CameraFogFar*LightVolume*0.6) {
								HideEntity(n.obj2)
							} else {
								ShowEntity(n.obj2)
								EntityAlpha (n.obj2, Min(dist-CameraFogFar*LightVolume*0.6,1.0))
							}
						}						
					} else {
						HideEntity(n.obj2)
					}
				}
				
				//[End Block]
			case NPCtype096:
				//[Block]
				dist = EntityDistance(Collider, n.Collider)
				
				switch (n.State) {
					case 0:
						//[Block]
						if (dist<8.0) {
							GiveAchievement(Achv096)
							if (n.SoundChn == 0) {
								n.SoundChn = StreamSound_Strict("SFX/Music/096.ogg",0)
								n.SoundChn_IsStream = True
							} else {
								UpdateStreamSoundOrigin(n.SoundChn,Camera,n.Collider,8.0,1.0)
							}
							
							if (n.State3 == -1) {
								AnimateNPC(n,936,1263,0.1,False)
								if (n.Frame >= 1262.9) {
									n.State = 5
									n.State3 = 0
									n.Frame = 312
								}
							} else {
								AnimateNPC(n,936,1263,0.1)
								if (n.State3 < 70*6) {
									n.State3=n.State3+FPSfactor
								} else {
									if (Rand(1,5) == 1) {
										n.State3 = -1
									} else {
										n.State3=70*(Rand(0,3))
									}
								}
							}
							
							angle = WrapAngle(DeltaYaw(n.Collider, Collider))
							
							if (!NoTarget) {
								if (angle<90 || angle>270) {
									CameraProject(Camera,EntityX(n.Collider), EntityY(n.Collider)+0.25, EntityZ(n.Collider))
									
									if (ProjectedX()>0 && ProjectedX()<GraphicWidth) {
										if (ProjectedY()>0 && ProjectedY()<GraphicHeight) {
											if (EntityVisible(Collider, n.Collider)) {
												if (BlinkTimer < -16 || BlinkTimer > -6) {
													PlaySound_Strict(LoadTempSound("SFX/SCP/096/Triggered.ogg"))
													
													CurrCameraZoom = 10
													
													n.Frame = 194
													StopStream_Strict(n.SoundChn)
													n.SoundChn=0
													n.Sound = 0
													n.State = 1
													n.State3 = 0
												}
											}									
										}
									}								
									
								}
							}
						}
						//[End Block]
					case 4:
						//[Block]
						CurrCameraZoom = CurveValue(Max(CurrCameraZoom, (Sin(Float(MilliSecs2())/20.0)+1.0) * 10.0),CurrCameraZoom,8.0)
						
						if (n.Target == Null) {
							if (n.SoundChn == 0) {
								n.SoundChn = StreamSound_Strict("SFX/SCP/096/Scream.ogg",0)
								n.SoundChn_IsStream = True
							} else {
								UpdateStreamSoundOrigin(n.SoundChn,Camera,n.Collider,7.5,1.0)
							}
							
							if (n.SoundChn2 == 0) {
								n.SoundChn2 = StreamSound_Strict("SFX/Music/096Chase.ogg",0)
								n.SoundChn2_IsStream = 2
							} else {
								SetStreamVolume_Strict(n.SoundChn2,Min(Max(8.0-dist,0.6),1.0)*SFXVolume)
							}
						}
						
						if (NoTarget && n.Target == Null) {
							n.State = 5
						}
						
						if (KillTimer >= 0) {
							
							if (MilliSecs2() > n.State3) {
								n.LastSeen=0
								if (n.Target=Null) {
									if (EntityVisible(Collider, n.Collider)) {n.LastSeen=1}
								} else {
									if (EntityVisible(n.Target.Collider, n.Collider)) {n.LastSeen=1}
								}
								n.State3=MilliSecs2()+3000
							}
							
							if (n.LastSeen == 1) {
								n.PathTimer=Max(70*3, n.PathTimer)
								n.PathStatus=0
								
								if (n.Target!= Null) {dist = EntityDistance(n.Target.Collider, n.Collider)}
								
								if (dist < 2.8 || n.Frame<150) {
									if (n.Frame>193) {n.Frame = 2.0} //go to the start of the jump animation
									
									AnimateNPC(n, 2, 193, 0.7)
									
									if (dist > 1.0) {
										n.CurrSpeed = CurveValue(n.Speed*2.0,n.CurrSpeed,15.0)
									} else {
										n.CurrSpeed = 0
										
										if (n.Target == Null) {
											if (!GodMode) {
												PlaySound_Strict(DamageSFX(4))
												
												pvt = CreatePivot()
												CameraShake = 30
												BlurTimer = 2000
												DeathMSG = "A large amount of blood found in [DATA REDACTED]. DNA indentified as Subject D-9341. Most likely [DATA REDACTED] by SCP-096."
												Kill()
												KillAnim = 1
												for (i of range(7)) {
													PositionEntity(pvt, EntityX(Collider)+Rnd(-0.1,0.1),EntityY(Collider)-0.05,EntityZ(Collider)+Rnd(-0.1,0.1))
													TurnEntity(pvt, 90, 0, 0)
													EntityPick(pvt,0.3)
													
													de.Decals = CreateDecal(Rand(15,16), PickedX(), PickedY()+0.005, PickedZ(), 90, Rand(360), 0)
													de.Size = Rnd(0.2,0.6)
													EntityAlpha(de.obj, 1.0)
													ScaleSprite(de.obj, de.Size, de.Size)
												}
												FreeEntity(pvt)
											}
										}				
									}
									
									if (n.Target == Null) {
										PointEntity(n.Collider, Collider)
									} else {
										PointEntity(n.Collider, n.Target.Collider)
									}
									
								} else {
									if (n.Target == Null) {
										PointEntity(n.obj, Collider)
									} else {
										PointEntity(n.obj, n.Target.Collider)
									}
									
									RotateEntity(n.Collider, 0, CurveAngle(EntityYaw(n.obj), EntityYaw(n.Collider), 5.0), 0)
									
									//1000
									if (n.Frame>847) {
										n.CurrSpeed = CurveValue(n.Speed,n.CurrSpeed,20.0)
									}
									
									if (n.Frame<906) { //1058
										AnimateNPC(n,737,906,n.Speed*8,False)
									} else {
										AnimateNPC(n,907,935,n.CurrSpeed*8)
									}
								}
								
								RotateEntity(n.Collider, 0, EntityYaw(n.Collider), 0, True)
								MoveEntity(n.Collider, 0,0,n.CurrSpeed*FPSfactor)
								
							} else {
								if (n.PathStatus == 1) {
									
									if (n.Path[n.PathLocation]=Null) { 
										if (n.PathLocation > 19) { 
											n.PathLocation = 0
											n.PathStatus = 0
										} else {
											n.PathLocation = n.PathLocation + 1
										}
									} else {
										PointEntity(n.obj, n.Path[n.PathLocation].obj)
										
										RotateEntity(n.Collider, 0, CurveAngle(EntityYaw(n.obj), EntityYaw(n.Collider), 5.0), 0)
										
										//1000
										if (n.Frame>847) {n.CurrSpeed = CurveValue(n.Speed*1.5,n.CurrSpeed,15.0)}
										MoveEntity(n.Collider, 0,0,n.CurrSpeed*FPSfactor)
										
										if (n.Frame<906) { //1058
											AnimateNPC(n,737,906,n.Speed*8,False)
										} else {
											AnimateNPC(n,907,935,n.CurrSpeed*8)
										}
										
										dist2 = EntityDistance(n.Collider,n.Path[n.PathLocation].obj)
										if (dist2 < 0.8) {
											if (n.Path[n.PathLocation].door) {
												if (!n.Path[n.PathLocation].door.open) {
													n.Path[n.PathLocation].door.open = True
													n.Path[n.PathLocation].door.fastopen = 1
													PlaySound2(OpenDoorFastSFX, Camera, n.Path[n.PathLocation].door.obj)
												}
											}							
											if (dist2 < 0.7) {n.PathLocation = n.PathLocation + 1}
										} 
									}
									
								} else {
									//AnimateNPC(n, 892,972, 0.2)
									AnimateNPC(n,737,822,0.2)
									
									n.PathTimer = Max(0, n.PathTimer-FPSfactor)
									if (n.PathTimer<=0) {
										if (n.Target!=Null) {
											n.PathStatus = FindPath(n, EntityX(n.Target.Collider),EntityY(n.Target.Collider)+0.2,EntityZ(n.Target.Collider))	
										} else {
											n.PathStatus = FindPath(n, EntityX(Collider),EntityY(Collider)+0.2,EntityZ(Collider))	
										}
										n.PathTimer = 70*5
									}
								}
							}
							
							if (dist > 32.0 || EntityY(n.Collider) < -50) {
								if (Rand(50) == 1) {TeleportCloser(n)}
							}
						} else { //play the eating animation if killtimer < 0 
							AnimateNPC(n, Min(27,AnimTime(n.obj)), 193, 0.5)
						}
						
						
						//[End Block]
					case 1,2,3:
						if (n.SoundChn == 0) {
							n.SoundChn = StreamSound_Strict("SFX/Music/096Angered.ogg",0)
							n.SoundChn_IsStream = True
						} else {
							UpdateStreamSoundOrigin(n.SoundChn,Camera,n.Collider,10.0,1.0)
						}
						
						if (n.State == 1) { // get up
							if (n.Frame<312) {
								AnimateNPC(n,193,311,0.3,False)
								if (n.Frame > 310.9) {
									n.State = 2
									n.Frame = 737
								}
							} else if (n.Frame >= 312 && n.Frame <= 422) {
								AnimateNPC(n,312,422,0.3,False)
								if (n.Frame > 421.9) {
									n.Frame = 677
								}
							} else {
								AnimateNPC(n,677,736,0.3,False)
								if (n.Frame > 735.9) {
									n.State = 2
									n.Frame = 737
								}
							}
						} else if (n.State == 2) {
							AnimateNPC(n,737,822,0.3,False)
							if (n.Frame >= 822) {
								n.State=3
								n.State2=0
							}
						} else if (n.State == 3) {
							n.State2 = n.State2+FPSfactor
							if (n.State2 > 70*18) {
								AnimateNPC(n,823,847,n.Speed*8,False)
								if (n.Frame>846.9) { //1000.9 
									n.State = 4
									StopStream_Strict(n.SoundChn)
									n.SoundChn=0
								}
							} else {
								AnimateNPC(n,737,822,0.3)
							}
						}
						//[End Block]
					case 5:
						//[Block]
						if (dist < 16.0) {
							
							if (dist < 4.0) {
								GiveAchievement(Achv096)
							}
							
							if (n.SoundChn == 0) {
								n.SoundChn = StreamSound_Strict("SFX/Music/096.ogg",0)
								n.SoundChn_IsStream = True
							} else {
								UpdateStreamSoundOrigin(n.SoundChn,Camera,n.Collider,14.0,1.0)
							}
							
							if (n.Frame>=422) {
								n.State2=n.State2+FPSfactor
								if (n.State2>1000) { //walking around
									if (n.State2>1600) {
										n.State2=Rand(0,500)
									}
									
									//1652
									if (n.Frame<1382) { //idle to walk
										n.CurrSpeed = CurveValue(n.Speed*0.1,n.CurrSpeed,5.0)
										AnimateNPC(n,1369,1382,n.CurrSpeed*45,False)
									} else {
										n.CurrSpeed = CurveValue(n.Speed*0.1,n.CurrSpeed,5.0)
										AnimateNPC(n,1383,1456,n.CurrSpeed*45)
									}
									
									if (MilliSecs2() > n.State3) {
										n.LastSeen=0
										if (EntityVisible(Collider, n.Collider)) {
											n.LastSeen=1
										} else {
											HideEntity(n.Collider)
											EntityPick(n.Collider, 1.5)
											if (PickedEntity() != 0) {
												n.Angle = EntityYaw(n.Collider)+Rnd(80,110)
											}
											ShowEntity(n.Collider)
										}
										n.State3=MilliSecs2()+3000
									}
									
									if (n.LastSeen) {
										PointEntity(n.obj, Collider)
										RotateEntity(n.Collider, 0, CurveAngle(EntityYaw(n.obj),EntityYaw(n.Collider),130.0),0)
										if (dist < 1.5) {
											n.State2=0
										}
									} else {
										RotateEntity(n.Collider, 0, CurveAngle(n.Angle,EntityYaw(n.Collider),50.0),0)
									}
								} else {
									//1638
									if (n.Frame>472) { //walk to idle
										n.CurrSpeed = CurveValue(n.Speed*0.05,n.CurrSpeed,8.0)
										AnimateNPC(n,1383,1469,n.CurrSpeed*45,False)
										if (n.Frame>=1468.9) {n.Frame=423}
									} else { //idle
										n.CurrSpeed = CurveValue(0,n.CurrSpeed,4.0)	
										AnimateNPC(n,423,471,0.2)
									}
								}
								
								MoveEntity(n.Collider,0,0,n.CurrSpeed*FPSfactor)
							} else {
								AnimateNPC(n,312,422,0.3,False)
							}
							
							angle = WrapAngle(DeltaYaw(n.Collider, Camera))
							if (!NoTarget) {
								if (angle<55 || angle>360-55) {
									CameraProject(Camera,EntityX(n.Collider), EntityY(Collider)+5.8*0.2-0.25, EntityZ(n.Collider))
									
									if (ProjectedX()>0 && ProjectedX()<GraphicWidth) {
										if (ProjectedY()>0 && ProjectedY()<GraphicHeight) {
											if (EntityVisible(Collider, n.Collider)) {
												if (BlinkTimer < - 16 || BlinkTimer > - 6) {
													PlaySound_Strict(LoadTempSound("SFX/SCP/096/Triggered.ogg"))
													
													CurrCameraZoom = 10
													
													if (n.Frame >= 422) {
														n.Frame = 677 //833
													}
													StopStream_Strict(n.SoundChn)
													n.SoundChn=0
													n.Sound = 0
													n.State = 2
												}
											}									
										}
									}
								}
							}
						}
						//[End Block]
				}
				
				PositionEntity(n.obj, EntityX(n.Collider), EntityY(n.Collider)-0.03, EntityZ(n.Collider)) //-0.07
				
				RotateEntity(n.obj, EntityPitch(n.Collider), EntityYaw(n.Collider), 0)
				//[End Block]
			case NPCtype049:
				//[Block]
				//n.state = the "main state" of the NPC
				//n.state2 = attacks the player when the value is above 0.0
				//n.state3 = timer for updating the path again
				
				prevFrame = n.Frame
				
				dist  = EntityDistance(Collider, n.Collider)
				
				n.BlinkTimer = 1.0
				
				if (n.Idle > 0.1) {
					if (PlayerRoom.RoomTemplate.Name != "room049") {
						n.Idle = Max(n.Idle-(1+SelectedDifficulty.aggressiveNPCs)*FPSfactor,0.1)
					}
					n.DropSpeed = 0
					if (ChannelPlaying(n.SoundChn)) {StopChannel(n.SoundChn)}
					if (ChannelPlaying(n.SoundChn2)) {StopChannel(n.SoundChn2)}
					PositionEntity(n.Collider,0,-500,0)
					PositionEntity(n.obj,0,-500,0)
				} else {
					if (n.Idle == 0.1) {
						if (PlayerInReachableRoom()) {
							for (i of range(4)) {
								if (PlayerRoom.Adjacent[i] != Null) {
									for (j of range(4)) {
										if (PlayerRoom.Adjacent[i].Adjacent[j] != Null) {
											TeleportEntity(n.Collider,PlayerRoom.Adjacent[i].Adjacent[j].x,0.5,PlayerRoom.Adjacent[i].Adjacent[j].z,n.CollRadius,True)
											break
										}
									}
									break
								}
							}
							n.Idle = 0.0
							DebugLog("SCP-049 not idle")
						}
					}
					
					switch (n.State) {
						case 1: //looking around before getting active
							//[Block]
							if (n.Frame>=538) {
								AnimateNPC(n, 659, 538, -0.45, False)
								if (n.Frame > 537.9) {
									n.Frame = 37
								}
							} else {
								AnimateNPC(n, 37, 269, 0.7, False)
								if (n.Frame>268.9) {
									n.State = 2
								}	
							}
							//[End Block]
						case 2: //being active
							//[Block]
							if ((dist < HideDistance*2) && !n.Idle && PlayerInReachableRoom(True)) {
								n.SoundChn = LoopSound2(n.Sound, n.SoundChn, Camera, n.Collider)
								PlayerSeeAble = MeNPCSeesPlayer(n)
								if (PlayerSeeAble || n.State2 > 0) { //Player is visible for 049's sight - attacking
									GiveAchievement(Achv049)
									
									//Playing a sound after detecting the player
									if (n.PrevState <= 1 && !ChannelPlaying(n.SoundChn2)) {
										if (n.Sound2 != 0) {FreeSound_Strict(n.Sound2)}
										n.Sound2 = LoadSound_Strict("SFX/SCP/049/Spotted"+Rand(1,7)+".ogg")
										n.SoundChn2 = LoopSound2(n.Sound2,n.SoundChn2,Camera,n.obj)
										n.PrevState = 2
									}
									n.PathStatus = 0
									n.PathTimer = 0.0
									n.PathLocation = 0
									if (PlayerSeeAble) {
										n.State2 = 70*2
									}
									
									PointEntity(n.obj,Collider)
									RotateEntity(n.Collider,0,CurveAngle(EntityYaw(n.obj),EntityYaw(n.Collider),10.0),0)
									
									if (dist < 0.5) {
										if (WearingHazmat>0) {
											BlurTimer = BlurTimer+FPSfactor*2.5
											if (BlurTimer>250 && BlurTimer-FPSfactor*2.5 <= 250 && n.PrevState!=3) {
												if (n.SoundChn2 != 0) {StopChannel(n.SoundChn2)}
												n.SoundChn2 = PlaySound_Strict(LoadTempSound("SFX/SCP/049/TakeOffHazmat.ogg"))
												n.PrevState=3
											} else if (BlurTimer >= 500) {
												for (i of range(MaxItemAmount)) {
													if (Inventory(i) != Null) {
														if (Instr(Inventory(i).itemtemplate.tempname,"hazmatsuit") && WearingHazmat<3) {
															if (Inventory(i).state2 < 3) {
																Inventory(i).state2 = Inventory(i).state2 + 1
																BlurTimer = 260.0
																CameraShake = 2.0
															} else {
																RemoveItem(Inventory(i))
																WearingHazmat = False
															}
															break
														}
													}
												}
											}
										} else if (Wearing714) {
											BlurTimer = BlurTimer+FPSfactor*2.5
											if (BlurTimer>250 && BlurTimer-FPSfactor*2.5 <= 250 && n.PrevState!=3) {
												if (n.SoundChn2 != 0) {StopChannel(n.SoundChn2)}
												n.SoundChn2 = PlaySound_Strict(LoadTempSound("SFX/SCP/049/714Equipped.ogg"))
												n.PrevState=3
											} else if (BlurTimer >= 500) {
												Wearing714=False
											}
										} else {
											CurrCameraZoom = 20.0
											BlurTimer = 500.0
											
											if (!GodMode) {
												if (PlayerRoom.RoomTemplate.Name == "room049") {
													DeathMSG = "Three (3) active instances of SCP-049-2 discovered in the tunnel outside SCP-049's containment chamber. Terminated by Nine-Tailed Fox."
													for (e of Events.each) {
														if (e.EventName == "room049") {
															e.EventState=-1
															break
														}
													}
												} else {
													DeathMSG = "An active instance of SCP-049-2 was discovered in [REDACTED]. Terminated by Nine-Tailed Fox."
													Kill()
												}
												PlaySound_Strict(HorrorSFX(13))
												if (n.Sound2 != 0) {FreeSound_Strict(n.Sound2)}
												n.Sound2 = LoadSound_Strict("SFX/SCP/049/Kidnap"+Rand(1,2)+".ogg")
												n.SoundChn2 = LoopSound2(n.Sound2,n.SoundChn2,Camera,n.obj)
												n.State = 3
											}										
										}
									} else {
										n.CurrSpeed = CurveValue(n.Speed, n.CurrSpeed, 20.0)
										MoveEntity(n.Collider, 0, 0, n.CurrSpeed * FPSfactor)
										
										if (n.PrevState == 3) {n.PrevState = 2}
										
										if (dist < 3.0) {
											AnimateNPC(n, Max(Min(AnimTime(n.obj),428.0),387), 463.0, n.CurrSpeed*38)
										} else {
											if (n.Frame>428.0) {
												AnimateNPC(n, Min(AnimTime(n.obj),463.0), 498.0, n.CurrSpeed*38,False)
												if (n.Frame>497.9) {
													n.Frame = 358
												}
											} else {
												AnimateNPC(n, Max(Min(AnimTime(n.obj),358.0),346), 393.0, n.CurrSpeed*38)
											}
										}
									}
								} else { //Finding a path to the player
									if (n.PathStatus == 1) { //Path to player found
										while (n.Path[n.PathLocation] == Null) {
											if (n.PathLocation > 19) {
												n.PathLocation = 0
												n.PathStatus = 0
												break
											} else {
												n.PathLocation = n.PathLocation + 1
											}
										}
										if (n.Path[n.PathLocation]!=Null) {
											//closes doors behind him
											if (n.PathLocation>0) {
												if (n.Path[n.PathLocation-1] != Null) {
													if (n.Path[n.PathLocation-1].door != Null) {
														if (!n.Path[n.PathLocation-1].door.IsElevatorDoor) {
															if (EntityDistance(n.Path[n.PathLocation-1].obj,n.Collider)>0.3) {
																if ((n.Path[n.PathLocation-1].door.MTFClose) && (n.Path[n.PathLocation-1].door.open) && (n.Path[n.PathLocation-1].door.buttons[0] != 0 || n.Path[n.PathLocation-1].door.buttons[1] != 0)) {
																	UseDoor(n.Path[n.PathLocation-1].door, False)
																}
															}
														}
													}
												}
											}
											
											n.CurrSpeed = CurveValue(n.Speed, n.CurrSpeed, 20.0)
											PointEntity(n.obj,n.Path[n.PathLocation].obj)
											RotateEntity(n.Collider,0,CurveAngle(EntityYaw(n.obj),EntityYaw(n.Collider),10.0),0)
											MoveEntity(n.Collider,0,0,n.CurrSpeed*FPSfactor)
											
											//opens doors in front of him
											dist2 = EntityDistance(n.Collider,n.Path[n.PathLocation].obj)
											if (dist2 < 0.6) {
												temp = True
												if (n.Path[n.PathLocation].door != Null) {
													if (!n.Path[n.PathLocation].door.IsElevatorDoor) {
														if ((n.Path[n.PathLocation].door.locked || n.Path[n.PathLocation].door.KeyCard!=0 || n.Path[n.PathLocation].door.Code!="") && !n.Path[n.PathLocation].door.open) {
															temp = False
														} else {
															if (!n.Path[n.PathLocation].door.open && (n.Path[n.PathLocation].door.buttons[0]!=0 || n.Path[n.PathLocation].door.buttons[1]!=0)) {
																UseDoor(n.Path[n.PathLocation].door, False)
															}
														}
													}
												}
												if (dist2 < 0.2 && temp) {
													n.PathLocation = n.PathLocation + 1
												} else if (dist2 < 0.5 && !temp) {
													//Breaking up the path when the door in front of 049 cannot be operated by himself
													n.PathStatus = 0
													n.PathTimer = 0.0
												}
											}
											
											AnimateNPC(n, Max(Min(AnimTime(n.obj),358.0),346), 393.0, n.CurrSpeed*38)
											
											//Playing a sound if he hears the player
											if (n.PrevState == 0 && !ChannelPlaying(n.SoundChn2)) {
												if (n.Sound2 != 0) {FreeSound_Strict(n.Sound2)}
												if (Rand(30) == 1) {
													n.Sound2 = LoadSound_Strict("SFX/SCP/049/Searching7.ogg")
												} else {
													n.Sound2 = LoadSound_Strict("SFX/SCP/049/Searching"+Rand(1,6)+".ogg")
												}
												n.SoundChn2 = LoopSound2(n.Sound2,n.SoundChn2,Camera,n.obj)
												n.PrevState = 1
											}
											
											//Resetting the "PrevState" value randomly, to make 049 talking randomly 
											if (Rand(600)=1 && !ChannelPlaying(n.SoundChn2)) {n.PrevState = 0}
											
											if (n.PrevState > 1) {
												n.PrevState = 1
											}
										}
									} else { //No Path to the player found - stands still and tries to find a path
										//[Block]
										n.PathTimer = n.PathTimer + FPSfactor
										if (n.PathTimer > 70*(5-(2*SelectedDifficulty.aggressiveNPCs))) {
											n.PathStatus = FindPath(n, EntityX(Collider),EntityY(Collider),EntityZ(Collider))
											n.PathTimer = 0.0
											n.State3 = 0
											
											//Attempt to find a room (the Playerroom or one of it's adjacent rooms) for 049 to go to but select the one closest to him
											if (n.PathStatus != 1) {
												let closestdist: float = EntityDistance(PlayerRoom.obj,n.Collider)
												let closestRoom: Rooms = PlayerRoom
												let currdist: float = 0.0
												for (i of range(4)) {
													if (PlayerRoom.Adjacent[i]!=Null) {
														currdist = EntityDistance(PlayerRoom.Adjacent[i].obj,n.Collider)
														if (currdist < closestdist) {
															closestdist = currdist
															closestRoom = PlayerRoom.Adjacent[i]
														}
													}
												}
												n.PathStatus = FindPath(n,EntityX(closestRoom.obj),0.5,EntityZ(closestRoom.obj))
												DebugLog("Find path for 049 in another room (pathstatus: "+n.PathStatus+")")
											}
											
											//Making 3 attempts at finding a path
											while (Int(n.State3) < 3) {
												//Breaking up the path if no "real" path has been found (only 1 waypoint and it is too close)
												if (n.PathStatus = 1) {
													if (n.Path[1] != Null) {
														if (n.Path[2]=Null && EntityDistance(n.Path[1].obj,n.Collider)<0.4) {
															n.PathLocation = 0
															n.PathStatus = 0
															DebugLog("Breaking up path for 049 because no waypoint number 2 has been found and waypoint number 1 is too close.")
														}
													}
													if (n.Path[0] != Null && n.Path[1] == Null) {
														n.PathLocation = 0
														n.PathStatus = 0
														DebugLog("Breaking up path for 049 because no waypoint number 1 has been found.")
													}
												}
												
												//No path could still be found, just make 049 go to a room (further away than the very first attempt)
												if (n.PathStatus != 1) {
													closestdist = 100.0 //Prevent the PlayerRoom to be considered the closest, so 049 wouldn't try to find a path there
													closestRoom.Rooms = PlayerRoom
													currdist = 0.0
													for (let i of range(4)) {
														if (PlayerRoom.Adjacent[i]!=Null) {
															currdist = EntityDistance(PlayerRoom.Adjacent[i].obj,n.Collider)
															if (currdist < closestdist) {
																closestdist = currdist
																for (let j of range(4)) {
																	if (PlayerRoom.Adjacent[i].Adjacent[j]!=Null) {
																		if (PlayerRoom.Adjacent[i].Adjacent[j]!=PlayerRoom) {
																			closestRoom = PlayerRoom.Adjacent[i].Adjacent[j]
																			break
																		}
																	}
																}
															}
														}
													}
													n.PathStatus = FindPath(n,EntityX(closestRoom.obj),0.5,EntityZ(closestRoom.obj))
													DebugLog("Find path for 049 in another further away room (pathstatus: "+n.PathStatus+")")
												}
												
												//Making 049 skip waypoints for doors he can't interact with, but only if the actual path is behind him
												if (n.PathStatus == 1) {
													if (n.Path[1]!=Null) {
														if (n.Path[1].door!=Null) {
															if ((n.Path[1].door.locked || n.Path[1].door.KeyCard!=0 || n.Path[1].door.Code!="") && (!n.Path[1].door.open)) {
																while (true) {
																	if (n.PathLocation > 19) {
																		n.PathLocation = 0
																		n.PathStatus = 0
																		break
																	} else {
																		n.PathLocation = n.PathLocation + 1
																	}
																	if (n.Path[n.PathLocation]!=Null) {
																		if (Abs(DeltaYaw(n.Collider,n.Path[n.PathLocation].obj))>(45.0-Abs(DeltaYaw(n.Collider,n.Path[1].obj)))) {
																			DebugLog("Skip until waypoint number "+n.PathLocation)
																			n.State3 = 3
																			break
																		}
																	}
																}
															} else {
																n.State3 = 3
															}
														} else {
															n.State3 = 3
														}
													}
												}
												n.State3 = n.State3 + 1
											}
										}
										AnimateNPC(n, 269, 345, 0.2)
										
									}
								}
								
								if (n.CurrSpeed > 0.005) {
									if ((prevFrame < 361 && n.Frame>=361) || (prevFrame < 377 && n.Frame>=377)) {
										PlaySound2(StepSFX(3,0,Rand(0,2)),Camera, n.Collider, 8.0, Rnd(0.8,1.0))						
									} else if ((prevFrame < 431 && n.Frame>=431) || (prevFrame < 447 && n.Frame>=447)) {
										PlaySound2(StepSFX(3,0,Rand(0,2)),Camera, n.Collider, 8.0, Rnd(0.8,1.0))
									}
								}
								
								if (ChannelPlaying(n.SoundChn2)) {
									UpdateSoundOrigin(n.SoundChn2,Camera,n.obj)
								}
							} else if (!n.Idle) {
								if (ChannelPlaying(n.SoundChn)) {
									StopChannel(n.SoundChn)
								}
								if (PlayerInReachableRoom(True) && InFacility == 1) { //Player is in a room where SCP-049 can teleport to
									if (Rand(1,3-SelectedDifficulty.otherFactors) == 1) {
										TeleportCloser(n)
										DebugLog("SCP-049 teleported closer due to distance")
									} else {
										n.Idle = 60*70
										DebugLog("SCP-049 is now idle")
									}
								}
							}
							
						case 3: //The player was killed by SCP-049
							
							AnimateNPC(n, 537, 660, 0.7, False)
							
							PositionEntity(n.Collider, CurveValue(EntityX(Collider),EntityX(n.Collider),20.0),EntityY(n.Collider),CurveValue(EntityZ(Collider),EntityZ(n.Collider),20.0))
							RotateEntity(n.Collider, 0, CurveAngle(EntityYaw(Collider)-180.0,EntityYaw(n.Collider),40), 0)
							
						case 4: //Standing on catwalk in room4
							
							if (dist < 8.0) {
								AnimateNPC(n, 18, 19, 0.05)
								
								//Animate2(n.obj, AnimTime(n.obj), 18, 19, 0.05)
								PointEntity(n.obj, Collider)
								RotateEntity(n.Collider, 0, CurveAngle(EntityYaw(n.obj), EntityYaw(n.Collider), 45.0), 0)
								
								n.State3 = 1
							} else if (dist > HideDistance*0.8 && n.State3 > 0) {
								n.State = 2
								n.State3 = 0
								for (r of Rooms.each) {
									if (EntityDistance(r.obj,n.Collider)<4.0) {
										TeleportEntity(n.Collider,EntityX(r.obj),0.1,EntityZ(r.obj),n.CollRadius,True)
										break
									}
								}
							}
							
						case 5: //used for "room2sl"
							
							n.SoundChn = LoopSound2(n.Sound, n.SoundChn, Camera, n.Collider)
							PlayerSeeAble = MeNPCSeesPlayer(n,True)
							if (PlayerSeeAble) {
								n.State = 2
								n.PathStatus = 0
								n.PathLocation = 0
								n.PathTimer = 0
								n.State3 = 0
								n.State2 = 70*2
								n.PrevState = 0
								PlaySound_Strict(LoadTempSound("SFX/Room/Room2SL049Spawn.ogg"))
							} else if (PlayerSeeAble == 2 && n.State3 > 0.0) {
								n.PathStatus = FindPath(n,EntityX(Collider),EntityY(Collider),EntityZ(Collider))
							} else {
								if (n.State3 == 6.0) {
									if (EntityDistance(n.Collider,Collider)>HideDistance) {
										n.State = 2
										n.PathStatus = 0
										n.PathLocation = 0
										n.PathTimer = 0
										n.State3 = 0
										n.PrevState = 0
									} else {
										if (n.PathStatus != 1) {
											n.PathStatus = FindPath(n,EntityX(Collider),EntityY(Collider),EntityZ(Collider))
										}
									}
								}
								
								if (n.PathStatus == 1) {
									if (n.Path[n.PathLocation] == Null) {
										if (n.PathLocation > 19) {
											n.PathLocation = 0
											n.PathStatus = 0
										} else {
											n.PathLocation = n.PathLocation + 1
										}
									} else {
										n.CurrSpeed = CurveValue(n.Speed, n.CurrSpeed, 20.0)
										PointEntity(n.obj,n.Path[n.PathLocation].obj)
										RotateEntity(n.Collider,0,CurveAngle(EntityYaw(n.obj),EntityYaw(n.Collider),10.0),0)
										MoveEntity(n.Collider,0,0,n.CurrSpeed*FPSfactor)
										
										//closes doors behind him
										if (n.PathLocation>0) {
											if (n.Path[n.PathLocation-1] != Null) {
												if (n.Path[n.PathLocation-1].door != Null) {
													if (n.Path[n.PathLocation-1].door.KeyCard=0) {
														if (EntityDistance(n.Path[n.PathLocation-1].obj,n.Collider)>0.3) {
															if (n.Path[n.PathLocation-1].door.open) {
																UseDoor(n.Path[n.PathLocation-1].door, False)
															}
														}
													}
												}
											}
										}
										
										//opens doors in front of him
										dist2 = EntityDistance(n.Collider,n.Path[n.PathLocation].obj)
										if (dist2 < 0.6) {
											if (n.Path[n.PathLocation].door != Null) {
												if (!n.Path[n.PathLocation].door.open) {
													UseDoor(n.Path[n.PathLocation].door, False)
												}
											}
										}
										
										if (dist2 < 0.2) {
											n.PathLocation += 1
										}
										
										AnimateNPC(n, Max(Min(AnimTime(n.obj),358.0),346), 393.0, n.CurrSpeed*38)
									}
								} else {
									switch (n.PrevState) {
										case 0:
											AnimateNPC(n, 269, 345, 0.2)
										case 1:
											AnimateNPC(n, 661, 891, 0.4, False)
										case 2:
											AnimateNPC(n, 892, 1119, 0.4, False)
									}
								}
							}
							
							if (PlayerRoom.RoomTemplate.Name == "room2sl") {
								ShouldPlay = 20
							}
							
							if (n.CurrSpeed > 0.005) {
								if ((prevFrame < 361 && n.Frame>=361) || (prevFrame < 377 && n.Frame>=377)) {
									PlaySound2(StepSFX(3,0,Rand(0,2)),Camera, n.Collider, 8.0, Rnd(0.8,1.0))						
						 		} else if ((prevFrame < 431 && n.Frame>=431) || (prevFrame < 447 && n.Frame>=447)) {
									PlaySound2(StepSFX(3,0,Rand(0,2)),Camera, n.Collider, 8.0, Rnd(0.8,1.0))
								}
							}
							
							if (ChannelPlaying(n.SoundChn2)) {
								UpdateSoundOrigin(n.SoundChn2,Camera,n.obj)
							}
							
					}
				}
				
				PositionEntity(n.obj, EntityX(n.Collider), EntityY(n.Collider)-0.22, EntityZ(n.Collider))
				
				RotateEntity(n.obj, 0, EntityYaw(n.Collider), 0)
				
				n.LastSeen = Max(n.LastSeen-FPSfactor,0)
				
				n.State2 = Max(n.State2-FPSfactor,0)
				
				
			case NPCtypeZombie:
				
				
				if (Abs(EntityY(Collider)-EntityY(n.Collider))<4.0) {
					
					prevFrame = n.Frame
					
					if (!n.IsDead) {
						switch (n.State) {
							case 0:
								
								AnimateNPC(n, 719, 777, 0.2, False)
								
								if (n.Frame == 777) {
									if (Rand(700) == 1) {
										if (EntityDistance(Collider, n.Collider) < 5.0) {
											n.Frame = 719
										}
									}
								}
								//[End Block]
							case 1: //stands up
								
								if (n.Frame >= 682) {
									AnimateNPC(n, 926, 935, 0.3, False)
									if (n.Frame == 935) {n.State = 2}
									
								} else {
									AnimateNPC(n, 155, 682, 1.5, False)
								}
								
							case 2: //following the player
								
								if (n.State3 < 0) { //check if the player is visible every three seconds
									if (EntityDistance(Collider, n.Collider)<5.0) { 
										if (EntityVisible(Collider, n.Collider)) {
											n.State2 = 70*5
										}
									}
									n.State3=70*3
								} else {
									n.State3=n.State3-FPSfactor
								}
								
								if (n.State2 > 0 && (!NoTarget)) { //player is visible -> attack
									n.SoundChn = LoopSound2(n.Sound, n.SoundChn, Camera, n.Collider, 6.0, 0.6)
									
									n.PathStatus = 0
									
									dist = EntityDistance(Collider, n.Collider)
									
									PointEntity(n.obj, Collider)
									RotateEntity(n.Collider, 0, CurveAngle(EntityYaw(n.obj), EntityYaw(n.Collider), 30.0), 0)
									
									if (dist < 0.7) {
										n.State = 3
										if (Rand(2) == 1) {
											n.Frame = 2
										} else {
											n.Frame = 66
										}
									} else {
										n.CurrSpeed = CurveValue(n.Speed, n.CurrSpeed, 20.0)
										MoveEntity(n.Collider, 0, 0, n.CurrSpeed * FPSfactor)
										
										AnimateNPC(n, 936, 1017, n.CurrSpeed*60)
									}
									
									n.State2=n.State2-FPSfactor
								} else {
									if (n.PathStatus == 1) { //path found
										if (n.Path[n.PathLocation] == Null) { 
											if (n.PathLocation > 19) { 
												n.PathLocation = 0
												n.PathStatus = 0
											} else {
												n.PathLocation = n.PathLocation + 1
											}
										} else {
											PointEntity(n.obj, n.Path[n.PathLocation].obj)
											
											RotateEntity(n.Collider, 0, CurveAngle(EntityYaw(n.obj), EntityYaw(n.Collider), 30.0), 0)
											n.CurrSpeed = CurveValue(n.Speed, n.CurrSpeed, 20.0)
											MoveEntity(n.Collider, 0, 0, n.CurrSpeed * FPSfactor)
											
											AnimateNPC(n, 936, 1017, n.CurrSpeed*60)
											
											if (EntityDistance(n.Collider,n.Path[n.PathLocation].obj) < 0.2) {
												n.PathLocation = n.PathLocation + 1
											} 
										}
									} else { //no path to the player, stands still
										n.CurrSpeed = 0
										AnimateNPC(n, 778, 926, 0.1)
										
										n.PathTimer = n.PathTimer-FPSfactor
										if (n.PathTimer <= 0) {
											n.PathStatus = FindPath(n, EntityX(Collider),EntityY(Collider)+0.1,EntityZ(Collider))
											n.PathTimer = n.PathTimer+70*5
										}
									}
								}
								
								//65, 80, 93, 109, 123
								if (n.CurrSpeed > 0.005) {
									if ((prevFrame < 977 && n.Frame>=977) || (prevFrame > 1010 && n.Frame<940)) {
										PlaySound2(StepSFX(2,0,Rand(0,2)),Camera, n.Collider, 8.0, Rnd(0.3,0.5))
									}
								}
								//[End Block]
							case 3:
								
								if (NoTarget) {n.State = 2}
								if (n.Frame < 66) {
									AnimateNPC(n, 2, 65, 0.7, False)
									
									if (prevFrame < 23 && n.Frame>=23) {
										if (EntityDistance(n.Collider,Collider)<1.1) {
											if (Abs(DeltaYaw(n.Collider,Collider))<=60.0) {
												PlaySound_Strict(DamageSFX(Rand(5,8)))
												Injuries = Injuries+Rnd(0.4,1.0)
												DeathMSG = "Subject D-9341. Cause of death: multiple lacerations and severe blunt force trauma caused by an instance of SCP-049-2."
											}
										}
									} else if (n.Frame == 65) {
										n.State = 2
									}	
								} else {
									AnimateNPC(n, 66, 132, 0.7, False)
									if (prevFrame < 90 && n.Frame>=90) {
										if (EntityDistance(n.Collider,Collider)<1.1) {
											if ((Abs(DeltaYaw(n.Collider,Collider))<=60.0)) {
												PlaySound_Strict(DamageSFX(Rand(5,8)))
												Injuries = Injuries+Rnd(0.4,1.0)
												DeathMSG = "Subject D-9341. Cause of death: multiple lacerations and severe blunt force trauma caused by an instance of SCP-049-2."
											}
										}
									} else if (n.Frame == 132) {
										n.State = 2
									}		
								}
						}
					} else {
						AnimateNPC(n, 133, 157, 0.5, False)
					}
					
					PositionEntity(n.obj, EntityX(n.Collider), EntityY(n.Collider) - 0.2, EntityZ(n.Collider))
					
					RotateEntity(n.obj, -90, EntityYaw(n.Collider), 0)
				}
				
				//[End Block]
			case NPCtypeGuard: //------------------------------------------------------------------------------------------------------------------
				
				prevFrame = n.Frame
				
				n.BoneToManipulate = ""
				n.ManipulateBone = False
				n.ManipulationType = 0
				n.NPCNameInSection = "Guard"
				
				switch (n.State) {
					case 1: //aims and shoots at the player
						
						if (n.Frame < 39 || (n.Frame > 76 && n.Frame < 245) || (n.Frame > 248 && n.Frame < 302) || n.Frame > 344) {
							AnimateNPC(n,345,357,0.2,False)
							if (n.Frame >= 356) {SetNPCFrame(n,302)}
						}
						
						if (KillTimer >= 0) {
							dist = EntityDistance(n.Collider,Collider)
							let ShootAccuracy: float = 0.4+0.5*SelectedDifficulty.aggressiveNPCs
							let DetectDistance: float = 11.0
							
							//If at Gate B increase his distance so that he can shoot the player from a distance after they are spotted.
							if (PlayerRoom.RoomTemplate.Name == "exit1") {
								DetectDistance = 21.0
								ShootAccuracy = 0.0
								if (Rand(1,8-SelectedDifficulty.aggressiveNPCs*4)<2) {
									ShootAccuracy = 0.03
								}
								
								//increase accuracy if the player is going slow
								ShootAccuracy = ShootAccuracy + (0.5 - CurrSpeed*20)
							}
							
							if (dist < DetectDistance) {
								pvt = CreatePivot()
								PositionEntity(pvt, EntityX(n.Collider), EntityY(n.Collider), EntityZ(n.Collider))
								PointEntity(pvt, Collider)
								RotateEntity(pvt, Min(EntityPitch(pvt), 20), EntityYaw(pvt), 0)
								
								RotateEntity(n.Collider, CurveAngle(EntityPitch(pvt), EntityPitch(n.Collider), 10), CurveAngle(EntityYaw(pvt), EntityYaw(n.Collider), 10), 0, True)
								
								PositionEntity(pvt, EntityX(n.Collider), EntityY(n.Collider)+0.8, EntityZ(n.Collider))
								PointEntity(pvt, Collider)
								RotateEntity(pvt, Min(EntityPitch(pvt), 40), EntityYaw(n.Collider), 0)
								
								if (n.Reload == 0) {
									DebugLog("entitypick")
									EntityPick(pvt, dist)
									if (PickedEntity() == Collider || n.State3 == 1) {
										let instaKillPlayer: boolean = false
										
										if (PlayerRoom.RoomTemplate.Name == "start") {
											DeathMSG = "Subject D-9341. Cause of death: Gunshot wound to the head. The surveillance tapes confirm that the subject was terminated by Agent Ulgrin shortly after the site lockdown was initiated."
											instaKillPlayer = True
										} else if (PlayerRoom.RoomTemplate.Name = "exit1") {
											DeathMSG = Chr(34)+"Agent G. to control. Eliminated a Class D escapee in Gate B's courtyard."+Chr(34)
										} else {
											DeathMSG = ""
										}
										
										PlaySound2(GunshotSFX, Camera, n.Collider, 35)
										
										RotateEntity(pvt, EntityPitch(n.Collider), EntityYaw(n.Collider), 0, True)
										PositionEntity(pvt, EntityX(n.obj), EntityY(n.obj), EntityZ(n.obj))
										MoveEntity (pvt,0.8*0.079, 10.75*0.079, 6.9*0.079)
										
										PointEntity(pvt, Collider)
										Shoot(EntityX(pvt), EntityY(pvt), EntityZ(pvt), ShootAccuracy, False, instaKillPlayer)
										n.Reload = 7
									} else {
										n.CurrSpeed = n.Speed
									}
								}
								
								if (n.Reload > 0 && n.Reload <= 7) {
									AnimateNPC(n,245,248,0.35,True)
								} else {
									if (n.Frame < 302) {
										AnimateNPC(n,302,344,0.35,True)
									}
								}
								
								FreeEntity(pvt)
							} else {
								AnimateNPC(n,302,344,0.35,True)
							}
							
							n.ManipulateBone = True
							
							if (n.State2 == 10) { //Hacky way of applying spine pitch to specific guards.
								n.BoneToManipulate = "Chest"
								n.ManipulationType = 3
							} else {
								n.BoneToManipulate = "Chest"
								n.ManipulationType = 0
							}
						} else {
							n.State = 0
						}
						
					case 2: //shoots
						
						AnimateNPC(n,245,248,0.35,True)
						if (n.Reload == 0) {
							PlaySound2(GunshotSFX, Camera, n.Collider, 20)
							p.Particles = CreateParticle(EntityX(n.obj, True), EntityY(n.obj, True), EntityZ(n.obj, True), 1, 0.2, 0.0, 5)
							PositionEntity(p.pvt, EntityX(n.obj), EntityY(n.obj), EntityZ(n.obj))
							RotateEntity(p.pvt, EntityPitch(n.Collider), EntityYaw(n.Collider), 0, True)
							MoveEntity (p.pvt,0.8*0.079, 10.75*0.079, 6.9*0.079)
							n.Reload = 7
						}
						
					case 3: //follows a path
						
						if (n.PathStatus == 2) {
							n.State = 0
							n.CurrSpeed = 0
						} else if (n.PathStatus == 1) {
							if (n.Path[n.PathLocation] == Null) {
								if (n.PathLocation > 19) {
									n.PathLocation = 0
									n.PathStatus = 0
								} else {
									n.PathLocation = n.PathLocation + 1
								}
							} else {
								PointEntity(n.obj, n.Path[n.PathLocation].obj)
								
								RotateEntity(n.Collider, 0, CurveAngle(EntityYaw(n.obj), EntityYaw(n.Collider), 20.0), 0)
								
								AnimateNPC(n,1,38,n.CurrSpeed*40)
								n.CurrSpeed = CurveValue(n.Speed*0.7, n.CurrSpeed, 20.0)
								
								MoveEntity(n.Collider, 0, 0, n.CurrSpeed * FPSfactor)
								
								if (EntityDistance(n.Collider,n.Path[n.PathLocation].obj) < 0.2) {
									n.PathLocation = n.PathLocation + 1
								} 
							}
						} else {
							n.CurrSpeed = 0
							n.State = 4
						}
						//[End Block]
					case 4:
						
						AnimateNPC(n,77,201,0.2)
						
						if (Rand(400) == 1) {
							n.Angle = Rnd(-180, 180)
						}
						
						RotateEntity(n.Collider, 0, CurveAngle(n.Angle + Sin(MilliSecs2() / 50) * 2, EntityYaw(n.Collider), 150.0), 0, True)
						
						dist = EntityDistance(n.Collider, Collider)
						if (dist < 15.0) {
							if (WrapAngle(EntityYaw(n.Collider)-DeltaYaw(n.Collider, Collider))<90) {
								if (EntityVisible(pvt,Collider)) {
									n.State = 1
								}
							}	
						}
						
						//[End Block]
					case 5: //following a target
						
						
						RotateEntity(n.Collider, 0, CurveAngle(VectorYaw(n.EnemyX-EntityX(n.Collider), 0, n.EnemyZ-EntityZ(n.Collider))+n.Angle, EntityYaw(n.Collider), 20.0), 0)
						
						dist = Distance(EntityX(n.Collider),EntityZ(n.Collider),n.EnemyX,n.EnemyZ)
						
						AnimateNPC(n,1,38,n.CurrSpeed*40)
						
						if (dist > 2.0 || dist < 1.0) {
							n.CurrSpeed = CurveValue(n.Speed*Sgn(dist-1.5)*0.75, n.CurrSpeed, 10.0)
						} else {
							n.CurrSpeed = CurveValue(0, n.CurrSpeed, 10.0)
						}
						
						MoveEntity(n.Collider, 0, 0, n.CurrSpeed * FPSfactor)
						//[End Block]
					case 7:
						AnimateNPC(n,77,201,0.2)
						//[End Block]						
					case 9:
						
						AnimateNPC(n,77,201,0.2)
						n.BoneToManipulate = "head"
						n.ManipulateBone = True
						n.ManipulationType = 0
						n.Angle = EntityYaw(n.Collider)
						//[End Block]
					case 10:
						
						AnimateNPC(n, 1, 38, n.CurrSpeed*40)
						
						n.CurrSpeed = CurveValue(n.Speed*0.7, n.CurrSpeed, 20.0)
						
						MoveEntity(n.Collider, 0, 0, n.CurrSpeed * FPSfactor)
						//[End Block]
					case 11:
						
						if (n.Frame < 39 || (n.Frame > 76 && n.Frame < 245) || (n.Frame > 248 && n.Frame < 302) || n.Frame > 344) {
							AnimateNPC(n,345,357,0.2,False)
							if (n.Frame >= 356) {SetNPCFrame(n,302)}
						}
						
						if (KillTimer >= 0) {
							dist = EntityDistance(n.Collider,Collider)
							
							let SearchPlayer: boolean = false
							if (dist < 11.0) {
								if (EntityVisible(n.Collider,Collider)) {
									SearchPlayer = True
								}
							}
							
							if (SearchPlayer) {
								pvt = CreatePivot()
								PositionEntity(pvt, EntityX(n.Collider), EntityY(n.Collider), EntityZ(n.Collider))
								PointEntity(pvt, Collider)
								RotateEntity(pvt, Min(EntityPitch(pvt), 20), EntityYaw(pvt), 0)
								
								RotateEntity(n.Collider, CurveAngle(EntityPitch(pvt), EntityPitch(n.Collider), 10), CurveAngle(EntityYaw(pvt), EntityYaw(n.Collider), 10), 0, True)
								
								PositionEntity(pvt, EntityX(n.Collider), EntityY(n.Collider)+0.8, EntityZ(n.Collider))
								PointEntity(pvt, Collider)
								RotateEntity(pvt, Min(EntityPitch(pvt), 40), EntityYaw(n.Collider), 0)
								
								if (n.Reload == 0) {
									DebugLog("entitypick")
									EntityPick(pvt, dist)
									if (PickedEntity() == Collider || n.State3 == 1) {
										instaKillPlayer = False
										
										DeathMSG = ""
										
										PlaySound2(GunshotSFX, Camera, n.Collider, 35)
										
										RotateEntity(pvt, EntityPitch(n.Collider), EntityYaw(n.Collider), 0, True)
										PositionEntity(pvt, EntityX(n.obj), EntityY(n.obj), EntityZ(n.obj))
										MoveEntity (pvt,0.8*0.079, 10.75*0.079, 6.9*0.079)
										
										PointEntity(pvt, Collider)
										Shoot(EntityX(pvt), EntityY(pvt), EntityZ(pvt), 1.0, False, instaKillPlayer)
										n.Reload = 7
									} else {
										n.CurrSpeed = n.Speed
									}
								}
								
								if (n.Reload > 0 && n.Reload <= 7) {
									AnimateNPC(n,245,248,0.35,True)
								} else {
									if (n.Frame < 302) {
										AnimateNPC(n,302,344,0.35,True)
									}
								}
								
								FreeEntity(pvt)
							} else {
								if (n.PathStatus == 1) {
									if (n.Path[n.PathLocation] == Null) {
										if (n.PathLocation > 19) {
											n.PathLocation = 0
											n.PathStatus = 0
										} else {
											n.PathLocation = n.PathLocation + 1
										}
									} else {
										AnimateNPC(n,39,76,n.CurrSpeed*40)
										n.CurrSpeed = CurveValue(n.Speed*0.7, n.CurrSpeed, 20.0)
										MoveEntity(n.Collider, 0, 0, n.CurrSpeed * FPSfactor)
										
										PointEntity(n.obj, n.Path[n.PathLocation].obj)
										
										RotateEntity(n.Collider, 0, CurveAngle(EntityYaw(n.obj), EntityYaw(n.Collider), 20.0), 0)
										
										if (EntityDistance(n.Collider,n.Path[n.PathLocation].obj) < 0.2) {
											n.PathLocation = n.PathLocation + 1
										}
									}
								} else {
									if (n.PathTimer == 0) {
										n.PathStatus = FindPath(n,EntityX(Collider),EntityY(Collider)+0.5,EntityZ(Collider))
									}
									
									let wayPointCloseToPlayer: WayPoints
									wayPointCloseToPlayer = Null
									
									for (wp of WayPoints.each) {
										if (EntityDistance(wp.obj,Collider)<2.0) {
											wayPointCloseToPlayer = wp
											break
										}
									}
									
									if (wayPointCloseToPlayer!=Null) {
										n.PathTimer = 1
										if (EntityVisible(wayPointCloseToPlayer.obj,n.Collider)) {
											if (Abs(DeltaYaw(n.Collider,wayPointCloseToPlayer.obj))>0) {
												PointEntity(n.obj, wayPointCloseToPlayer.obj)
												RotateEntity(n.Collider, 0, CurveAngle(EntityYaw(n.obj), EntityYaw(n.Collider), 20.0), 0)
											}
										}
									} else {
										n.PathTimer = 0
									}
									
									if (n.PathTimer == 1) {
										AnimateNPC(n,39,76,n.CurrSpeed*40)
										n.CurrSpeed = CurveValue(n.Speed*0.7, n.CurrSpeed, 20.0)
										MoveEntity(n.Collider, 0, 0, n.CurrSpeed * FPSfactor)
									}
								}
								
								if (prevFrame < 43 && n.Frame>=43) {
									PlaySound2(StepSFX(2,0,Rand(0,2)),Camera, n.Collider, 8.0, Rnd(0.5,0.7))						
								} else if (prevFrame < 61 && n.Frame>=61) {
									PlaySound2(StepSFX(2,0,Rand(0,2)),Camera, n.Collider, 8.0, Rnd(0.5,0.7))
								}
							}
							
						} else {
							n.State = 0
						}
						//[End Block]
					case 12:
						
						if (n.Frame < 39 || (n.Frame > 76 && n.Frame < 245) || (n.Frame > 248 && n.Frame < 302) || n.Frame > 344) {
							AnimateNPC(n,345,357,0.2,False)
							if (n.Frame >= 356) {
								SetNPCFrame(n,302)
							}
						}
						if (n.Frame < 345) {
							AnimateNPC(n,302,344,0.35,True)
						}
						
						pvt = CreatePivot()
						PositionEntity(pvt, EntityX(n.Collider), EntityY(n.Collider), EntityZ(n.Collider))
						if (n.State2 == 1.0) {
							PointEntity(pvt, Collider)
						} else {
							RotateEntity(pvt,0,n.Angle,0)
						}
						RotateEntity(pvt, Min(EntityPitch(pvt), 20), EntityYaw(pvt), 0)
						
						RotateEntity(n.Collider, CurveAngle(EntityPitch(pvt), EntityPitch(n.Collider), 10), CurveAngle(EntityYaw(pvt), EntityYaw(n.Collider), 10), 0, True)
						
						PositionEntity(pvt, EntityX(n.Collider), EntityY(n.Collider)+0.8, EntityZ(n.Collider))
						if (n.State2 == 1.0) {
							PointEntity(pvt, Collider)
							n.ManipulateBone = True
							n.BoneToManipulate = "Chest"
							n.ManipulationType = 0
						} else {
							RotateEntity(pvt,0,n.Angle,0)
						}
						RotateEntity(pvt, Min(EntityPitch(pvt), 40), EntityYaw(n.Collider), 0)
						
						FreeEntity(pvt)
						
						UpdateSoundOrigin(n.SoundChn,Camera,n.Collider,20)
						
					case 13:
						
						AnimateNPC(n,202,244,0.35,True)
						
					case 14:
						
						if (n.PathStatus == 2) {
							n.State = 13
							n.CurrSpeed = 0
						} else if (n.PathStatus == 1) {
							if (n.Path[n.PathLocation] == Null) {
								if (n.PathLocation > 19) {
									n.PathLocation = 0
									n.PathStatus = 0
								} else {
									n.PathLocation = n.PathLocation + 1
								}
							} else {
								PointEntity(n.obj, n.Path[n.PathLocation].obj)
								
								RotateEntity(n.Collider, 0, CurveAngle(EntityYaw(n.obj), EntityYaw(n.Collider), 20.0), 0)
								
								AnimateNPC(n,39,76,n.CurrSpeed*40)
								n.CurrSpeed = CurveValue(n.Speed*0.7, n.CurrSpeed, 20.0)
								
								MoveEntity(n.Collider, 0, 0, n.CurrSpeed * FPSfactor)
								
								if (EntityDistance(n.Collider,n.Path[n.PathLocation].obj) < 0.2) {
									n.PathLocation = n.PathLocation + 1
								} 
							}
						} else {
							n.CurrSpeed = 0
							n.State = 13
						}
						
						if (prevFrame < 43 && n.Frame>=43) {
							PlaySound2(StepSFX(2,0,Rand(0,2)),Camera, n.Collider, 8.0, Rnd(0.5,0.7))						
						} else if (prevFrame < 61 && n.Frame>=61) {
							PlaySound2(StepSFX(2,0,Rand(0,2)),Camera, n.Collider, 8.0, Rnd(0.5,0.7))
						}
						
					default:
						
						if (Rand(400) == 1) {
							n.PrevState = Rnd(-30, 30)
						}
						n.PathStatus = 0
						AnimateNPC(n,77,201,0.2)
						
						RotateEntity(n.Collider, 0, CurveAngle(n.Angle + n.PrevState + Sin(MilliSecs2() / 50) * 2, EntityYaw(n.Collider), 50), 0, True)
						
				}
				
				if (n.CurrSpeed > 0.01) {
					if (prevFrame < 5 && n.Frame>=5) {
						PlaySound2(StepSFX(2,0,Rand(0,2)),Camera, n.Collider, 8.0, Rnd(0.5,0.7))						
					} else if (prevFrame < 23 && n.Frame>=23) {
						PlaySound2(StepSFX(2,0,Rand(0,2)),Camera, n.Collider, 8.0, Rnd(0.5,0.7))						
					}
				}
				
				if (n.Frame > 286.5 && n.Frame < 288.5) {
					n.IsDead = True
				}
				
				n.Reload = Max(0, n.Reload - FPSfactor)
				PositionEntity(n.obj, EntityX(n.Collider), EntityY(n.Collider) - 0.2, EntityZ(n.Collider))
				
				RotateEntity(n.obj, 0, EntityYaw(n.Collider)+180, 0)
				
			case NPCtypeMTF:
				
				UpdateMTFUnit(n)
				
				
			case NPCtypeD,NPCtypeClerk :
				
				RotateEntity(n.Collider, 0, EntityYaw(n.Collider), EntityRoll(n.Collider), True)
				
				prevFrame = AnimTime(n.obj)
				
				switch (n.State) {
					case 0: //idle
						n.CurrSpeed = CurveValue(0.0, n.CurrSpeed, 5.0)
						Animate2(n.obj, AnimTime(n.obj), 210, 235, 0.1)
					case 1: //walking
						if (n.State2 == 1.0) {
							n.CurrSpeed = CurveValue(n.Speed*0.7, n.CurrSpeed, 20.0)
						} else {
							n.CurrSpeed = CurveValue(0.015, n.CurrSpeed, 5.0)
						}
						Animate2(n.obj, AnimTime(n.obj), 236, 260, n.CurrSpeed * 18)
					case 2: //running
						n.CurrSpeed = CurveValue(0.03, n.CurrSpeed, 5.0)
						Animate2(n.obj, AnimTime(n.obj), 301, 319, n.CurrSpeed * 18)
				}
				
				if (n.State2 != 2) {
					if (n.State == 1) {
						if (n.CurrSpeed > 0.01) {
							if (prevFrame < 244 && AnimTime(n.obj)>=244) {
								PlaySound2(StepSFX(GetStepSound(n.Collider),0,Rand(0,2)),Camera, n.Collider, 8.0, Rnd(0.3,0.5))						
							} else if (prevFrame < 256 && AnimTime(n.obj)>=256) {
								PlaySound2(StepSFX(GetStepSound(n.Collider),0,Rand(0,2)),Camera, n.Collider, 8.0, Rnd(0.3,0.5))
							}
						}
					} else if (n.State == 2) {
						if (n.CurrSpeed > 0.01) {
							if (prevFrame < 309 && AnimTime(n.obj)>=309) {
								PlaySound2(StepSFX(GetStepSound(n.Collider),1,Rand(0,2)),Camera, n.Collider, 8.0, Rnd(0.3,0.5))
							} else if (prevFrame <= 319 && AnimTime(n.obj)<=301) {
								PlaySound2(StepSFX(GetStepSound(n.Collider),1,Rand(0,2)),Camera, n.Collider, 8.0, Rnd(0.3,0.5))
							}
						}
					}
				}
				
				if (n.Frame == 19 || n.Frame == 60) {
					n.IsDead = True
				}
				if (AnimTime(n.obj) == 19 || AnimTime(n.obj) == 60) {
					n.IsDead = True
				}
				
				MoveEntity(n.Collider, 0, 0, n.CurrSpeed * FPSfactor)
				
				PositionEntity(n.obj, EntityX(n.Collider), EntityY(n.Collider) - 0.32, EntityZ(n.Collider))
				
				RotateEntity(n.obj, EntityPitch(n.Collider), EntityYaw(n.Collider)-180.0, 0)
				
			case NPCtype5131:

				if (PlayerRoom.RoomTemplate.Name != "pocketdimension") {
					if (n.Idle) {
						HideEntity(n.obj)
						HideEntity(n.obj2)
						if (Rand(200) == 1) {
							for (w of WayPoints.each) {
								if (w.room!=PlayerRoom) {
									x = Abs(EntityX(Collider)-EntityX(w.obj,True))
									if (x>3 && x < 9) {
										z = Abs(EntityZ(Collider)-EntityZ(w.obj,True))
										if (z>3 && z < 9) {
											PositionEntity(n.Collider, EntityX(w.obj,True), EntityY(w.obj,True), EntityZ(w.obj,True))
											PositionEntity(n.obj, EntityX(w.obj,True), EntityY(w.obj,True), EntityZ(w.obj,True))
											ResetEntity(n.Collider)
											ShowEntity(n.obj)
											ShowEntity(n.obj2)
											
											n.LastSeen = 0
											
											n.Path[0]=w
											
											n.Idle = False
											n.State2 = Rand(15,20)*70
											n.State = Max(Rand(-1,2),0)
											n.PrevState = Rand(0,1)
											break
										}
									}
								}
							}
						}
					} else {
						dist = EntityDistance(Collider, n.Collider)
						
						//use the prev-values to do a "twitching" effect
						n.PrevX = CurveValue(0.0, n.PrevX, 10.0)
						n.PrevZ = CurveValue(0.0, n.PrevZ, 10.0)
						
						if (Rand(100) == 1) {
							if (Rand(5) == 1) {
								n.PrevX = (EntityX(Collider)-EntityX(n.Collider))*0.9
								n.PrevZ = (EntityZ(Collider)-EntityZ(n.Collider))*0.9
							} else {
								n.PrevX = Rnd(0.1,0.5)
								n.PrevZ = Rnd(0.1,0.5)						
							}
						}
						
						temp = Rnd(-1.0,1.0)
						PositionEntity(n.obj2, EntityX(n.Collider)+n.PrevX*temp, EntityY(n.Collider) - 0.2 + Sin((MilliSecs2()/8-45) % 360)*0.05, EntityZ(n.Collider)+n.PrevZ*temp)
						RotateEntity(n.obj2, 0, EntityYaw(n.obj), 0)
						if (Floor(AnimTime(n.obj2))!=Floor(n.Frame)) {
							SetAnimTime(n.obj2, n.Frame)
						}
						
						if (n.State == 0) {
							if (n.PrevState == 0) {
								AnimateNPC(n,2,74,0.2)
							} else {
								AnimateNPC(n,75,124,0.2)
							}
							
							if (n.LastSeen) {
								PointEntity(n.obj2, Collider)
								RotateEntity(n.obj, 0, CurveAngle(EntityYaw(n.obj2),EntityYaw(n.obj),40), 0)
								if (dist < 4) {
									n.State = Rand(1,2)
								}
							} else {
								if (dist < 6 && Rand(5) == 1) {
									if (EntityInView(n.Collider,Camera)) {
										if (EntityVisible(Collider, n.Collider)) {
											n.LastSeen = 1
											PlaySound_Strict(LoadTempSound("SFX/SCP/513/Bell"+Rand(2,3)+".ogg"))
										}
									}
								}								
							}
							
						} else {
							if (n.Path[0] == Null) {
								
								//move towards a waypoint that is:
								//1. max 8 units away from 513-1
								//2. further away from the player than 513-1's current position 
								for (w of WayPoints.each) {
									x = Abs(EntityX(n.Collider,True)-EntityX(w.obj,True))
									if (x < 8.0 && x > 1.0) {
										z = Abs(EntityZ(n.Collider,True)-EntityZ(w.obj,True))
										if (z < 8.0 && z > 1.0) {
											if (EntityDistance(Collider, w.obj) > dist) {
												n.Path[0]=w
												break
											}
										}
									}
								}
								
								//no suitable path found -> 513-1 simply disappears
								if (n.Path[0] == Null) {
									n.Idle = True
									n.State2 = 0
								}
							} else {
								
								if (EntityDistance(n.Collider, n.Path[0].obj) > 1.0) {
									PointEntity(n.obj, n.Path[0].obj)
									RotateEntity(n.Collider, CurveAngle(EntityPitch(n.obj),EntityPitch(n.Collider),15.0), CurveAngle(EntityYaw(n.obj),EntityYaw(n.Collider),15.0), 0, True)
									n.CurrSpeed = CurveValue(0.05*Max((7.0-dist)/7.0,0.0),n.CurrSpeed,15.0)
									MoveEntity(n.Collider, 0,0,n.CurrSpeed*FPSfactor)
									if (Rand(200) == 1) {MoveEntity(n.Collider, 0, 0, 0.5)}
									RotateEntity(n.Collider, 0, EntityYaw(n.Collider), 0, True)
								} else {
									for (i of range(5)) {
										if (n.Path[0].connected[i] != Null) {
											if (EntityDistance(Collider, n.Path[0].connected[i].obj) > dist) {
												
												if (n.LastSeen == 0) {
													if (EntityInView(n.Collider,Camera)) {
														if (EntityVisible(Collider, n.Collider)) {
															n.LastSeen = 1
															PlaySound_Strict(LoadTempSound("SFX/SCP/513/Bell"+Rand(2,3)+".ogg"))
														}
													}
												}
												
												n.Path[0]=n.Path[0].connected[i]
												break
											}
										}
									}
									
									if (!n.Path[0]) {n.State2 = 0}
								}
							}
						}
						
						PositionEntity(n.obj, EntityX(n.Collider), EntityY(n.Collider) - 0.2 + Sin((MilliSecs2()/8) % 360)*0.1, EntityZ(n.Collider))
						
						switch (n.State) {
							case 1:
								if (n.PrevState == 0) {
									AnimateNPC(n,125,194,n.CurrSpeed*20)
								} else {
									AnimateNPC(n,195,264,n.CurrSpeed*20)
								}
								RotateEntity(n.obj, 0, EntityYaw(n.Collider), 0)
							case 2:
								if (n.PrevState == 0) {
									AnimateNPC(n,2,74,0.2)
								} else {
									AnimateNPC(n,75,124,0.2)
								}
								RotateEntity(n.obj, 0, EntityYaw(n.Collider), 0)
						}
						
						if (n.State2 > 0) {
							if (dist < 4.0) {
								n.State2 = n.State2-FPSfactor*4
							}
							n.State2 = n.State2-FPSfactor
						} else {
							n.Path[0]=Null
							n.Idle = True
							n.State2=0
						}	
					}
				}
				
				n.DropSpeed = 0
				ResetEntity(n.Collider)						
				
			case NPCtype372:
				
				RN = PlayerRoom.RoomTemplate.Name
				if (RN != "pocketdimension" && RN != "dimension1499") {
					if (n.Idle) {
						HideEntity(n.obj)
						if (Rand(50) = 1 && (BlinkTimer < -5 && BlinkTimer > -15)) {
							ShowEntity(n.obj)
							angle = EntityYaw(Collider)+Rnd(-90,90)
							
							dist = Rnd(1.5, 2.0)
							PositionEntity(n.Collider, EntityX(Collider) + Sin(angle) * dist, EntityY(Collider)+0.2, EntityZ(Collider) + Cos(angle) * dist)
							n.Idle = False
							n.State = Rand(20, 60)
							
							if (Rand(300) == 1) {
								PlaySound2(RustleSFX(Rand(0,2)),Camera, n.obj, 8, Rnd(0.0,0.2))
							}
						}
					} else {
						PositionEntity(n.obj, EntityX(n.Collider) + Rnd(-0.005, 0.005), EntityY(n.Collider)+0.3+0.1*Sin(MilliSecs2()/2), EntityZ(n.Collider) + Rnd(-0.005, 0.005))
						RotateEntity(n.obj, 0, EntityYaw(n.Collider), ((MilliSecs2()/5) % 360))
						
						AnimateNPC(n, 32, 113, 0.4)
						
						if (EntityInView(n.obj, Camera)) {
							GiveAchievement(Achv372)
							
							if (Rand(30) == 1) {
								if (!ChannelPlaying(n.SoundChn)) {
									if (EntityVisible(Camera, n.obj)) {
										n.SoundChn = PlaySound2(RustleSFX(Rand(0,2)),Camera, n.obj, 8, 0.3)
									}
								}
							}
							
							temp = CreatePivot()
							PositionEntity(temp, EntityX(Collider), EntityY(Collider), EntityZ(Collider))
							PointEntity(temp, n.Collider)
							
							angle =  WrapAngle(EntityYaw(Collider)-EntityYaw(temp))
							if (angle < 180) {
								RotateEntity(n.Collider, 0, EntityYaw(Collider)-80, 0)
							} else {
								RotateEntity(n.Collider, 0, EntityYaw(Collider)+80, 0)
							}
							FreeEntity(temp)
							
							MoveEntity(n.Collider, 0, 0, 0.03*FPSfactor)
							
							n.State = n.State-FPSfactor
						}
						n.State=n.State-(FPSfactor/80.0)
						if (n.State <= 0) {n.Idle = True}
					}
				}
				
				n.DropSpeed = 0
				ResetEntity(n.Collider)						
				
			case NPCtypeApache: //------------------------------------------------------------------------------------------------------------------
				
				dist = EntityDistance(Collider, n.Collider)
				if (dist<60.0) {
					if (PlayerRoom.RoomTemplate.Name == "exit1") {
						dist2 = Max(Min(EntityDistance(n.Collider, PlayerRoom.Objects[3])/(8000.0*RoomScale),1.0),0.0)
					} else { 
						dist2 = 1.0
					}
					
					n.SoundChn = LoopSound2(ApacheSFX, n.SoundChn, Camera, n.Collider, 25.0, dist2)
				}
				
				n.DropSpeed = 0
				
				switch (n.State) {
					case 0,1:
						TurnEntity(n.obj2,0,20.0*FPSfactor,0)
						TurnEntity(n.obj3,20.0*FPSfactor,0,0)
						
						if (n.State == 1 && !NoTarget) {
							if (Abs(EntityX(Collider)-EntityX(n.Collider))< 30.0) {
								if (Abs(EntityZ(Collider)-EntityZ(n.Collider))<30.0) {
									if (Abs(EntityY(Collider)-EntityY(n.Collider))<20.0) {
										if (Rand(20) == 1) { 
											if (EntityVisible(Collider, n.Collider)) {
												n.State = 2
												PlaySound2(AlarmSFX(2), Camera, n.Collider, 50, 1.0)
											}
										}									
									}
								}
							}							
						}
					case 2,3: //player located -> attack
						
						if (n.State == 2) {
							target = Collider
			 			} else if (n.State == 3) {
							target=CreatePivot()
							PositionEntity(target, n.EnemyX, n.EnemyY, n.EnemyZ, True)
						}
						
						if (NoTarget && n.State == 2) {n.State = 1}
						
						TurnEntity(n.obj2,0,20.0*FPSfactor,0)
						TurnEntity(n.obj3,20.0*FPSfactor,0,0)
						
						if (Abs(EntityX(target)-EntityX(n.Collider)) < 55.0) {
							if (Abs(EntityZ(target)-EntityZ(n.Collider)) < 55.0) {
								if (Abs(EntityY(target)-EntityY(n.Collider))< 20.0) {
									PointEntity(n.obj, target)
									RotateEntity(n.Collider, CurveAngle(Min(WrapAngle(EntityPitch(n.obj)),40.0),EntityPitch(n.Collider),40.0), CurveAngle(EntityYaw(n.obj),EntityYaw(n.Collider),90.0), EntityRoll(n.Collider), True)
									PositionEntity(n.Collider, EntityX(n.Collider), CurveValue(EntityY(target)+8.0,EntityY(n.Collider),70.0), EntityZ(n.Collider))
									
									dist = Distance(EntityX(target),EntityZ(target),EntityX(n.Collider),EntityZ(n.Collider))
									
									n.CurrSpeed = CurveValue(Min(dist-6.5,6.5)*0.008, n.CurrSpeed, 50.0)
									
									MoveEntity(n.Collider, 0,0,n.CurrSpeed*FPSfactor)
									
									
									if (n.PathTimer == 0) {
										n.PathStatus = EntityVisible(n.Collider,target)
										n.PathTimer = Rand(100,200)
									} else {
										n.PathTimer = Min(n.PathTimer-FPSfactor,0.0)
									}
									
									if (n.PathStatus == 1) { //player visible
										RotateEntity(n.Collider, EntityPitch(n.Collider), EntityYaw(n.Collider), CurveAngle(0, EntityRoll(n.Collider),40), True)
										
										if (n.Reload <= 0) {
											if (dist<20.0) {
												pvt = CreatePivot()
												
												PositionEntity(pvt, EntityX(n.Collider),EntityY(n.Collider), EntityZ(n.Collider))
												RotateEntity(pvt, EntityPitch(n.Collider), EntityYaw(n.Collider),EntityRoll(n.Collider))
												MoveEntity(pvt, 0, 8.87*(0.21/9.0), 8.87*(1.7/9.0))
												PointEntity(pvt, target)
												
												if (WrapAngle(EntityYaw(pvt)-EntityYaw(n.Collider))<10) {
													PlaySound2(Gunshot2SFX, Camera, n.Collider, 20)
													
													if (PlayerRoom.RoomTemplate.Name == "exit1") {
														DeathMSG = Chr(34)+"CH-2 to control. Shot down a runaway Class D at Gate B."+Chr(34)
													} else {
														DeathMSG = Chr(34)+"CH-2 to control. Shot down a runaway Class D at Gate A."+Chr(34)
													}
													
													Shoot( EntityX(pvt),EntityY(pvt), EntityZ(pvt),((10/dist)*(1/dist))*(n.State=2),(n.State=2))
													
													n.Reload = 5
												}
												
												FreeEntity(pvt)
											}
										}
									} else { 
										RotateEntity(n.Collider, EntityPitch(n.Collider), EntityYaw(n.Collider), CurveAngle(-20, EntityRoll(n.Collider),40), True)
									}
									MoveEntity(n.Collider, -EntityRoll(n.Collider)*0.002,0,0)
									n.Reload=n.Reload-FPSfactor
								}
							}
						}		
						
						if (n.State == 3) {FreeEntity(target)}
					case 4: //crash
						if (n.State2 < 300) {
							
							TurnEntity(n.obj2,0,20.0*FPSfactor,0)
							TurnEntity(n.obj3,20.0*FPSfactor,0,0)
							
							TurnEntity(n.Collider,0,-FPSfactor*7,0)
							n.State2=n.State2+FPSfactor*0.3
							
							target=CreatePivot()
							PositionEntity(target, n.EnemyX, n.EnemyY, n.EnemyZ, True)
							
							PointEntity(n.obj, target)
							MoveEntity(n.obj, 0,0,FPSfactor*0.001*n.State2)
							PositionEntity(n.Collider, EntityX(n.obj), EntityY(n.obj), EntityZ(n.obj))
							
							if (EntityDistance(n.obj, target) < 0.3) {
								CameraShake = Max(CameraShake, 3.0)
								PlaySound_Strict(LoadTempSound("SFX/Character/Apache/Crash"+Rand(1,2)+".ogg"))
								n.State = 5
							}
							
							FreeEntity(target)
						}
				}
				
				PositionEntity(n.obj, EntityX(n.Collider), EntityY(n.Collider), EntityZ(n.Collider))
				RotateEntity(n.obj, EntityPitch(n.Collider), EntityYaw(n.Collider), EntityRoll(n.Collider), True)
				
			case NPCtypeTentacle:
				
				dist = EntityDistance(n.Collider,Collider)
				
				if (dist < HideDistance) {
					
					switch (n.State) {
						case 0: //spawn
							
							if (n.Frame>283) {
								HeartBeatVolume = Max(CurveValue(1.0, HeartBeatVolume, 50),HeartBeatVolume)
								HeartBeatRate = Max(CurveValue(130, HeartBeatRate, 100),HeartBeatRate)
								
								PointEntity(n.obj, Collider)
								RotateEntity(n.Collider, 0, CurveAngle(EntityYaw(n.obj),EntityYaw(n.Collider),25.0), 0)
								
								AnimateNPC(n, 283, 389, 0.3, False)
								
								if (n.Frame>388) {
									n.State = 1
									FreeSound_Strict(n.Sound2)
									n.Sound2 = 0
								}
							} else {
								if (dist < 2.5) {
									SetNPCFrame(n, 284)
									n.Sound2 = LoadSound_Strict("SFX/Room/035Chamber/TentacleSpawn.ogg")
									PlaySound_Strict(n.Sound2)
								}
							}
							//spawn 283,389
							//attack 2, 32
							//idle 33, 174
						case 1: //idle
							if (n.Sound2 == 0) {
								FreeSound_Strict(n.Sound2)
								n.Sound2=0
								n.Sound2 = LoadSound_Strict("SFX/Room/035Chamber/TentacleIdle.ogg")
							}
							n.SoundChn2 = LoopSound2(n.Sound2,n.SoundChn2,Camera,n.Collider)
							
							if (dist < 1.8) {
								if (Abs(DeltaYaw(n.Collider, Collider))<20) {
									n.State = 2
									if (n.Sound!=0) {
										FreeSound_Strict(n.Sound)
										n.Sound = 0 
									}
								}
							}
							
							PointEntity(n.obj, Collider)
							RotateEntity(n.Collider, 0, CurveAngle(EntityYaw(n.obj),EntityYaw(n.Collider),25.0), 0)
							
							AnimateNPC(n, 33, 174, 0.3, True)
						case 2:
							
							//finish the idle animation before playing the attack animation
							if (n.Frame>33 && n.Frame<174) {
								AnimateNPC(n, 33, 174, 2.0, False)
							} else {
								PointEntity(n.obj, Collider)
								RotateEntity(n.Collider, 0, CurveAngle(EntityYaw(n.obj),EntityYaw(n.Collider),10.0), 0)
								
								if (n.Frame>33) {
									if (n.Sound2!=0) {
										FreeSound_Strict(n.Sound2)
										n.Sound2 = 0
									}
									n.Frame = 2
									n.Sound = LoadSound_Strict("SFX/Room/035Chamber/TentacleAttack"+Rand(1,2)+".ogg")
									PlaySound_Strict(n.Sound)
								}
								AnimateNPC(n, 2, 32, 0.3, False)
								
								if (n.Frame>=5 && n.Frame<6) {
									if (dist < 1.8) {
										if (Abs(DeltaYaw(n.Collider, Collider))<20) {
											if (WearingHazmat) {
												Injuries = Injuries+Rnd(0.5)
												PlaySound_Strict(LoadTempSound("SFX/General/BodyFall.ogg"))
											} else {
												BlurTimer = 100
												Injuries = Injuries+Rnd(1.0,1.5)
												PlaySound_Strict(DamageSFX(Rand(2,3)))
												
												if (Injuries > 3.0) {
													if (PlayerRoom.RoomTemplate.Name == "room2offices") {
														DeathMSG = Chr(34)+"One large and highly active tentacle-like appendage seems "
														DeathMSG = DeathMSG + "to have grown outside the dead body of a scientist within office area [REDACTED]. Its level of aggression is "
														DeathMSG = DeathMSG + "unlike anything we've seen before - it looks like it has "
														DeathMSG = DeathMSG + "beaten some unfortunate Class D to death at some point during the breach."+Chr(34)
													} else {
														DeathMSG = Chr(34)+"We will need more than the regular cleaning team to take care of this. "
														DeathMSG = DeathMSG + "Two large and highly active tentacle-like appendages seem "
														DeathMSG = DeathMSG + "to have formed inside the chamber. Their level of aggression is "
														DeathMSG = DeathMSG + "unlike anything we've seen before - it looks like they have "
														DeathMSG = DeathMSG + "beaten some unfortunate Class D to death at some point during the breach."+Chr(34)
													}
													Kill()
												}
											}
										}
									}
									
									n.Frame = 6
								} else if (n.Frame == 32) {
									n.State = 1
									n.Frame = 173
								}
							}		
					}	
				}
			
				PositionEntity(n.obj, EntityX(n.Collider), EntityY(n.Collider), EntityZ(n.Collider))
				RotateEntity(n.obj, EntityPitch(n.Collider)-90, EntityYaw(n.Collider)-180, EntityRoll(n.Collider), True)
				
				n.DropSpeed = 0
				
				ResetEntity(n.Collider)
				
			case NPCtype860:
				
				if (PlayerRoom.RoomTemplate.Name == "room860") {
					let fr: Forest=PlayerRoom.fr
					
					dist = EntityDistance(Collider,n.Collider)
					
					if (ForestNPC!=0) {
						if (ForestNPCData[2] == 1) {
							ShowEntity(ForestNPC)
							if (n.State!=1) {
								if ((BlinkTimer < -8 && BlinkTimer > -12) || !EntityInView(ForestNPC,Camera)) {
									ForestNPCData[2]=0
									HideEntity(ForestNPC)
								}
							}
						} else {
							HideEntity(ForestNPC)
						}
					}
					
					switch (n.State) {
						case 0: //idle (hidden)
							
							HideEntity(n.Collider)
							HideEntity(n.obj)
							HideEntity(n.obj2)
							
							n.State2 = 0
							PositionEntity(n.Collider, 0, -100, 0)
						case 1: //appears briefly behind the trees
							n.DropSpeed = 0
							
							if (EntityY(n.Collider)<= -100) {
								//transform the position of the player to the local coordinates of the forest
								TFormPoint(EntityX(Collider),EntityY(Collider),EntityZ(Collider),0,fr.Forest_Pivot)
								
								//calculate the indices of the forest cell the player is in
								x = Floor((TFormedX()+6.0)/12.0)
								z = Floor((TFormedZ()+6.0)/12.0)
								
								//step through nearby cells
								for (x2 of range(Max(x-1,1), Min(x+1,gridsize) + 1, 2)) {
									for (z2 of range(Max(z-1,1), Min(z+1,gridsize) + 1, 2)) {
										//choose an empty cell (not on the path)
										if (fr.grid[(z2*gridsize)+x2] == 0) {
											//spawn the monster between the empty cell and the cell the player is in
											TFormPoint(((x2+x)/2)*12.0,0,((z2+z)/2)*12.0,fr.Forest_Pivot,0)
											
											//in view -> nope, keep searching for a more suitable cell
											if (EntityInView(n.Collider, Camera)) {
												PositionEntity(n.Collider, 0, -110, 0)
												DebugLog("spawned monster in view -> hide")
											} else { // not in view -> all good
												DebugLog("spawned monster successfully")
												
												PositionEntity(n.Collider, TFormedX(), EntityY(fr.Forest_Pivot,True)+2.3, TFormedZ())
												
												x2 = gridsize
												break												
											}
										}
									}
								}
								
								if (EntityY(n.Collider)> -100) {
									PlaySound2(Step2SFX(Rand(3,5)), Camera, n.Collider, 15.0, 0.5)
									
									if (ForestNPCData[2]!=1) {
										ForestNPCData[2]=0
									}
									
									switch (Rand(3)) {
										case 1:
											PointEntity(n.Collider, Collider)
											n.Frame = 2
											
										case 2:
											PointEntity(n.Collider, Collider)
											n.Frame = 201
											
										case 3:
											PointEntity(n.Collider, Collider)
											TurnEntity(n.Collider, 0, 90, 0)
											n.Frame = 299
											
									}
									
									n.State2 = 0
								}
							} else {
								
								ShowEntity(n.obj)
								ShowEntity(n.Collider)
								
								PositionEntity(n.Collider, EntityX(n.Collider), EntityY(fr.Forest_Pivot,True)+2.3, EntityZ(n.Collider))
								
								//[TODO]
								if (ForestNPC!=0) {
									if (ForestNPCData[2] == 0) {
										let docchance: int = 0
										let docamount: int = 0
										for (i of range(MaxItemAmount)) {
											if (Inventory(i)!=Null) {
												let docname: string = Inventory(i).itemtemplate.name
												if (docname == "Log #1" || docname == "Log #2" || docname == "Log #3") {
													//860,850,830,800
													docamount = docamount + 1
													docchance = docchance + 10*docamount
												}
											}
										}
										
										if (Rand(1,860-docchance) == 1) {
											ShowEntity(ForestNPC)
											ForestNPCData[2]=1
											if (Rand(2) == 1) {
												ForestNPCData[0]=0
											} else {
												ForestNPCData[0]=2
											}
											ForestNPCData[1]=0
											PositionEntity(ForestNPC,EntityX(n.Collider),EntityY(n.Collider)+0.5,EntityZ(n.Collider))
											RotateEntity(ForestNPC,0,EntityYaw(n.Collider),0)
											MoveEntity(ForestNPC,0.75,0,0)
											RotateEntity(ForestNPC,0,0,0)
											EntityTexture(ForestNPC,ForestNPCTex,ForestNPCData[0])
										} else {
											ForestNPCData[2]=2
										}
									} else if (ForestNPCData[2] == 1) {
										if (ForestNPCData[1] == 0.0) {
											if (Rand(200) == 1) {
												ForestNPCData[1]=FPSfactor
												EntityTexture(ForestNPC,ForestNPCTex,ForestNPCData[0]+1)
											}
										} else if (ForestNPCData[1]>0.0 && ForestNPCData[1]<5.0) {
											ForestNPCData[1] = Min(ForestNPCData[1]+FPSfactor,5.0)
										} else {
											ForestNPCData[1]=0
											EntityTexture(ForestNPC,ForestNPCTex,ForestNPCData[0])
										}
									}
								}
								
								if (n.State2 == 0) { //don't start moving until the player is looking
									if (EntityInView(n.Collider, Camera)) { 
										n.State2 = 1
										if (Rand(8) == 1) {
											PlaySound2(LoadTempSound("SFX/SCP/860/Cancer"+Rand(0,2)+".ogg"), Camera, n.Collider, 20.0)
										}										
									}
								} else {
									if (n.Frame<=199) {
										AnimateNPC(n, 2, 199, 0.5,False)
										if (n.Frame == 199) {
											n.Frame = 298
											PlaySound2(Step2SFX(Rand(3,5)), Camera, n.Collider, 15.0)
										}
									} else if (n.Frame <= 297) {
										PointEntity(n.Collider, Collider)
										
										AnimateNPC(n, 200, 297, 0.5, False)
										if (n.Frame == 297) {
											n.Frame=298
											PlaySound2(Step2SFX(Rand(3,5)), Camera, n.Collider, 15.0)
										}
									} else {
										angle = CurveAngle(point_direction(EntityX(n.Collider),EntityZ(n.Collider),EntityX(Collider),EntityZ(Collider)),EntityYaw(n.Collider)+90,20.0)
										
										RotateEntity(n.Collider, 0, angle-90, 0, True)
										
										AnimateNPC(n, 298, 316, n.CurrSpeed*10)

										n.CurrSpeed = CurveValue(n.Speed, n.CurrSpeed, 10.0)
										MoveEntity(n.Collider, 0,0,n.CurrSpeed*FPSfactor)
										
										if (dist>15.0) {
											PositionEntity(n.Collider, 0,-110,0)
											n.State = 0
											n.State2 = 0
										}
									}									
								}
							}
							
							ResetEntity(n.Collider)
						case 2: //appears on the path and starts to walk towards the player
							ShowEntity(n.obj)
							ShowEntity(n.Collider)
							
							prevFrame = n.Frame
							
							if (EntityY(n.Collider)<= -100) {
								//transform the position of the player to the local coordinates of the forest
								TFormPoint(EntityX(Collider),EntityY(Collider),EntityZ(Collider),0,fr.Forest_Pivot)
								
								//calculate the indices of the forest cell the player is in
								x = Floor((TFormedX()+6.0)/12.0)
								z = Floor((TFormedZ()+6.0)/12.0)
								
								for (x2 of range(Max(x-1,1), Min(x+1,gridsize) + 1)) {
									for (z2 of range(Max(z-1,1), Min(z+1,gridsize) + 1)) {
										//find a nearby cell that's on the path and NOT the cell the player is in
										if (fr.grid[(z2*gridsize)+x2]>0 && (x2!=x || z2!=z) && (x2 == x || z2 == z)) {
											
											//transform the position of the cell back to world coordinates
											TFormPoint(x2*12.0, 0,z2*12.0, fr.Forest_Pivot,0)
											
											PositionEntity(n.Collider, TFormedX(), EntityY(fr.Forest_Pivot,True)+1.0,TFormedZ())
											
											DebugLog(TFormedX()+", "+TFormedZ())
											
											if (EntityInView(n.Collider, Camera)) {
												BlinkTimer=-10
											} else {
												x2 = gridsize
												break
											}
										}
									}
								}
							} else {
								angle = CurveAngle(Find860Angle(n, fr),EntityYaw(n.Collider)+90,80.0)
								
								RotateEntity(n.Collider, 0, angle-90, 0, True)
								
								n.CurrSpeed = CurveValue(n.Speed*0.3, n.CurrSpeed, 50.0)
								MoveEntity(n.Collider, 0,0,n.CurrSpeed*FPSfactor)
								
								AnimateNPC(n, 494, 569, n.CurrSpeed*25)
								
								if (n.State2 == 0) {
									if (dist<8.0) {
										if (EntityInView(n.Collider,Camera)) {
											PlaySound_Strict(LoadTempSound("SFX/SCP/860/Chase"+Rand(1,2)+".ogg"))
											
											PlaySound2(LoadTempSound("SFX/SCP/860/Cancer"+Rand(0,2)+".ogg"), Camera, n.Collider)	
											n.State2 = 1
										}										
									}
								}
								
								if (CurrSpeed > 0.03) { //the player is running
									n.State3 = n.State3 + FPSfactor
									if (Rnd(5000)<n.State3) {
										temp = True
										if (n.SoundChn != 0) {
											if (ChannelPlaying (n.SoundChn)) {temp = False}
										}
										if (temp) {
											n.SoundChn = PlaySound2(LoadTempSound("SFX/SCP/860/Cancer"+Rand(0,2)+".ogg"), Camera, n.Collider)
										}
									}
								} else {
									n.State3 = Max(n.State3 - FPSfactor,0)
								}
								
								if (dist<4.5 || n.State3 > Rnd(200,250)) {
									n.SoundChn = PlaySound2(LoadTempSound("SFX/SCP/860/Cancer"+Rand(3,5)+".ogg"), Camera, n.Collider)
									n.State = 3
								}
								
								if (dist > 20.0) {
									n.State = 0
									n.State2 = 0
									PositionEntity(n.Collider, 0,-110,0)
								}
							}
							
							//535, 568
							if ((prevFrame < 533 && n.Frame>=533) || (prevFrame > 568 && n.Frame<2)) {
								PlaySound2(Step2SFX(Rand(3,5)), Camera, n.Collider, 15.0, 0.6)
							}
							
						case 3: //runs towards the player and attacks
							ShowEntity(n.obj)
							ShowEntity(n.Collider)
							
							prevFrame = n.Frame
							
							angle = CurveAngle(Find860Angle(n, fr),EntityYaw(n.Collider)+90,40.0)
							
							RotateEntity(n.Collider, 0, angle-90, 0, True)
							
							if (n.Sound == 0) {
								n.Sound = LoadSound_Strict("SFX/General/Slash1.ogg")
							}
							if (n.Sound2 == 0) {
								n.Sound2 = LoadSound_Strict("SFX/General/Slash2.ogg")
							}
							
							//if close enough to attack OR already attacking, play the attack anim
							if (dist<1.1 || (n.Frame>451 && n.Frame<493) || KillTimer < 0) {
								DeathMSG = ""
								
								n.CurrSpeed = CurveValue(0.0, n.CurrSpeed, 5.0)
								
								AnimateNPC(n, 451,493, 0.5, False)
								
								if (prevFrame < 461 && n.Frame>=461) {
									if (KillTimer >= 0) {
										Kill()
										KillAnim = 0
									}
									PlaySound_Strict(n.Sound)
								}
								if (prevFrame < 476 && n.Frame>=476) {
									PlaySound_Strict(n.Sound2)
								}
								if (prevFrame < 486 && n.Frame>=486) {
									PlaySound_Strict(n.Sound2)
								}
							} else {
								n.CurrSpeed = CurveValue(n.Speed*0.8, n.CurrSpeed, 10.0)
								
								AnimateNPC(n, 298, 316, n.CurrSpeed*10)
								
								if (prevFrame < 307 && n.Frame>=307) {
									PlaySound2(Step2SFX(Rand(3,5)), Camera, n.Collider, 10.0)
								}
							}
							
							MoveEntity(n.Collider, 0,0,n.CurrSpeed*FPSfactor)
					}
					
					if (n.State != 0) {
						RotateEntity(n.Collider, 0, EntityYaw(n.Collider), 0, True	)
						
						PositionEntity(n.obj, EntityX(n.Collider), EntityY(n.Collider)-0.1, EntityZ(n.Collider))
						RotateEntity(n.obj, EntityPitch(n.Collider)-90, EntityYaw(n.Collider), EntityRoll(n.Collider), True)
						
						if (dist > 8.0) {
							ShowEntity(n.obj2)
							EntityAlpha(n.obj2, Min(dist-8.0,1.0))
							
							PositionEntity(n.obj2, EntityX(n.obj), EntityY(n.obj) , EntityZ(n.obj))
							RotateEntity(n.obj2, 0, EntityYaw(n.Collider) - 180, 0)
							MoveEntity(n.obj2, 0, 30.0*0.025, -33.0*0.025)
							
							//render distance is set to 8.5 inside the forest,
							//so we need to cheat a bit to make the eyes visible if they're further than that
							pvt = CreatePivot()
							PositionEntity(pvt, EntityX(Camera),EntityY(Camera),EntityZ(Camera))
							PointEntity(pvt, n.obj2)
							MoveEntity(pvt, 0,0,8.0)
							PositionEntity(n.obj2, EntityX(pvt),EntityY(pvt),EntityZ(pvt))
							FreeEntity(pvt)
						} else {
							HideEntity(n.obj2)
						}
					}
				}
				 
			case NPCtype939:
				
				
				if (PlayerRoom.RoomTemplate.Name != "room3storage") {
					n.State = 66
				}
				
				//state is set to 66 in the room3storage-event if player isn't inside the room
				if (n.State < 66) {
					switch (n.State) {
						case 0:
							AnimateNPC(n, 290,405,0.1)
						case 1:
							
							if (n.Frame>=644 && n.Frame<683) { //finish the walking animation
								n.CurrSpeed = CurveValue(n.Speed*0.05, n.CurrSpeed, 10.0)
								AnimateNPC(n, 644,683,28*n.CurrSpeed*4,False)
								if (n.Frame>=682) {
									n.Frame = 175
								}
							} else {
								n.CurrSpeed = CurveValue(0, n.CurrSpeed, 5.0)
								AnimateNPC(n, 175,297,0.22,False)
								if (n.Frame>=296) {n.State = 2}
							}
							
							n.LastSeen = 0
							
							MoveEntity(n.Collider, 0,0,n.CurrSpeed*FPSfactor)
							
						case 2:
							n.State2 = Max(n.State2, (n.PrevState-3))
							
							dist = EntityDistance(n.Collider, PlayerRoom.Objects[n.State2])
							
							n.CurrSpeed = CurveValue(n.Speed*0.3*Min(dist,1.0), n.CurrSpeed, 10.0)
							MoveEntity(n.Collider, 0,0,n.CurrSpeed*FPSfactor)
							
							prevFrame = n.Frame
							AnimateNPC(n, 644,683,28*n.CurrSpeed) //walk
														
							if ((prevFrame < 664 && n.Frame >= 664) || (prevFrame > 673 && n.Frame < 654)) {
								PlaySound2(StepSFX(4, 0, Rand(0,3)), Camera, n.Collider, 12.0)
								if (Rand(10) == 1) {
									temp = False
									if (n.SoundChn = 0) { 
										temp = true
									} else if (!ChannelPlaying(n.SoundChn)) {
										temp = true
									}
									if (temp) {
										if (n.Sound != 0) {
											FreeSound_Strict(n.Sound)
											n.Sound = 0
										}
										n.Sound = LoadSound_Strict("SFX/SCP/939/"+(n.ID % 3)+"Lure"+Rand(1,10)+".ogg")
										n.SoundChn = PlaySound2(n.Sound, Camera, n.Collider)
									}
								}
							}
							
							PointEntity(n.obj, PlayerRoom.Objects[n.State2])
							RotateEntity(n.Collider, 0, CurveAngle(EntityYaw(n.obj),EntityYaw(n.Collider),20.0), 0)
							
							if (dist<0.4) {
								n.State2 = n.State2 + 1
								if (n.State2 > n.PrevState) {
									n.State2 = (n.PrevState-3)
								}
								n.State = 1
							}
							
						case 3:
							if (EntityVisible(Collider, n.Collider)) {
								if (n.Sound2 == 0) {
									n.Sound2 = LoadSound_Strict("SFX/General/Slash1.ogg")
								}
								
								n.EnemyX = EntityX(Collider)
								n.EnemyZ = EntityZ(Collider)
								n.LastSeen = 10*7
							}
							
							if (n.LastSeen > 0 && (!NoTarget)) {
								prevFrame = n.Frame
								
								if ((n.Frame>=18.0 && n.Frame<68.0)) {
									n.CurrSpeed = CurveValue(0, n.CurrSpeed, 5.0)
									AnimateNPC(n, 18,68,0.5,True)
									
									//hasn't hit
									temp = False
									
									if (prevFrame < 24 && n.Frame>=24) {
										temp = True
									} else if (prevFrame < 57 && n.Frame>=57) {
										temp = True
									}
									
									if (temp) {
										if (Distance(n.EnemyX, n.EnemyZ, EntityX(n.Collider), EntityZ(n.Collider))<1.5) {
											PlaySound_Strict(n.Sound2)
											Injuries = Injuries + Rnd(1.5, 2.5)-WearingVest*0.5
											BlurTimer = 500		
										} else {
											n.Frame	 = 449
										}
									}
									
									if (Injuries>4.0) {
										DeathMSG=Chr(34)+"All four (4) escaped SCP-939 specimens have been captured and recontained successfully. "
										DeathMSG=DeathMSG+"Three (3) of them made quite a mess at Storage Area 6. A cleaning team has been dispatched."+Chr(34)
										Kill()
										if (!GodMode) {
											n.State = 5
										}
									}								
								} else {
									if (n.LastSeen == 10*7) {
										n.CurrSpeed = CurveValue(n.Speed, n.CurrSpeed, 20.0)
										
										AnimateNPC(n, 449,464,6*n.CurrSpeed) //run
										
										if ((prevFrame<452 && n.Frame>=452) || (prevFrame<459 && n.Frame>=459)) {
											PlaySound2(StepSFX(1, 1, Rand(0,7)), Camera, n.Collider, 12.0)
										}										
										
										if (Distance(n.EnemyX, n.EnemyZ, EntityX(n.Collider), EntityZ(n.Collider))<1.1) { //player is visible
											n.Frame = 18
										}
									} else {
										n.CurrSpeed = CurveValue(0, n.CurrSpeed, 5.0)
										AnimateNPC(n, 175,297,5*n.CurrSpeed,True)	
									}
								}
								
								angle = VectorYaw(n.EnemyX-EntityX(n.Collider), 0.0, n.EnemyZ-EntityZ(n.Collider))
								RotateEntity(n.Collider, 0, CurveAngle(angle,EntityYaw(n.Collider),15.0), 0)
								
								MoveEntity(n.Collider, 0,0,n.CurrSpeed*FPSfactor)
								
								n.LastSeen = n.LastSeen - FPSfactor
							} else {
								n.State = 2
							}
							
						case 5:
							if (n.Frame<68) {
								AnimateNPC(n, 18,68,0.5,False) //finish the attack animation
							} else {
								AnimateNPC(n, 464,473,0.5,False) //attack to idle
							}
							
					}
					
					if (n.State < 3 && (!NoTarget) && (!n.IgnorePlayer)) {
						dist = EntityDistance(n.Collider, Collider)
						
						if (dist < 4.0) {
							dist = dist - EntityVisible(Collider, n.Collider)
						}
						if (PlayerSoundVolume*1.2>dist || dist < 1.5) {
							if (n.State3 == 0) {
								if (n.Sound != 0) {
									FreeSound_Strict(n.Sound)
									n.Sound = 0
								}
								n.Sound = LoadSound_Strict("SFX/SCP/939/"+(n.ID % 3)+"Attack"+Rand(1,3)+".ogg")
								n.SoundChn = PlaySound2(n.Sound, Camera, n.Collider)										
								
								PlaySound_Strict(LoadTempSound("SFX/SCP/939/attack.ogg"))
								n.State3 = 1
							}
							
							n.State = 3
						} else if (PlayerSoundVolume*1.6>dist) {
							if (n.State!=1 && n.Reload <= 0) {
								if (n.Sound != 0) {
									FreeSound_Strict(n.Sound)
									n.Sound = 0
								}
								n.Sound = LoadSound_Strict("SFX/SCP/939/"+(n.ID % 3)+"Alert"+Rand(1,3)+".ogg")
								n.SoundChn = PlaySound2(n.Sound, Camera, n.Collider)	
								
								n.Frame = 175
								n.Reload = 70 * 3
							}
							
							n.State = 1
							
						}
						
						n.Reload = n.Reload - FPSfactor
						
					}				
					
					RotateEntity(n.Collider, 0, EntityYaw(n.Collider), 0, True	)
					
					PositionEntity(n.obj, EntityX(n.Collider), EntityY(n.Collider)-0.28, EntityZ(n.Collider))
					RotateEntity(n.obj, EntityPitch(n.Collider)-90, EntityYaw(n.Collider), EntityRoll(n.Collider), True)
				}
				
			case NPCtype066:
				
				dist = Distance(EntityX(Collider),EntityZ(Collider),EntityX(n.Collider),EntityZ(n.Collider))
				
				switch (n.State) {
					case 0: 
						//idle: moves around randomly from waypoint to another if the player is far enough
						//starts staring at the player when the player is close enough
						
						if (dist > 20.0) {
							AnimateNPC(n, 451, 612, 0.2, True)
							
							if (n.State2 < MilliSecs2()) {
								for (w of WayPoints.each) {
									if (w.door == Null) {
										if (Abs(EntityX(w.obj,True)-EntityX(n.Collider))<4.0) {
											if (Abs(EntityZ(w.obj,True)-EntityZ(n.Collider))<4.0) {
												PositionEntity(n.Collider, EntityX(w.obj,True), EntityY(w.obj,True)+0.3, EntityZ(w.obj,True))
												ResetEntity(n.Collider)
												break
											}
										}
									}
								}
								n.State2 = MilliSecs2()+5000
							}
						} else if (dist < 8.0) {
							n.LastDist = Rnd(1.0, 2.5)
							n.State = 1
						}
					case 1: //staring at the player
						
						if (n.Frame<451) {
							angle = WrapAngle(CurveAngle(DeltaYaw(n.Collider, Collider)-180, (AnimTime(n.obj)-2.0)/1.2445, 15.0))
							//0->360 = 2->450
							SetNPCFrame(n,angle*1.2445+2.0)
						} else {
							AnimateNPC(n, 636, 646, 0.4, False)
							if (n.Frame == 646) {SetNPCFrame(n,2)}
						}
						dist = Distance(EntityX(Collider),EntityZ(Collider),EntityX(n.Collider),EntityZ(n.Collider))
						
						if (Rand(700) == 1) {
							PlaySound2(LoadTempSound("SFX/SCP/066/Eric"+Rand(1,3)+".ogg"),Camera, n.Collider, 8.0)
						}
						
						if (dist < 1.0+n.LastDist) {
							n.State = Rand(2,3)
						}
					case 2: //roll towards the player and make a sound, and then escape	
						if (n.Frame < 647) {
							angle = CurveAngle(0, (AnimTime(n.obj)-2.0)/1.2445, 5.0)
							
							if (angle < 5 || angle > 355) {
								SetNPCFrame(n,647)
							} else {
								SetNPCFrame(n,angle*1.2445+2.0)
							}
						} else {
							if (n.Frame == 683) {
								if (n.State2 == 0) {
									if (Rand(2) == 1) {
										PlaySound2(LoadTempSound("SFX/SCP/066/Eric"+Rand(1,3)+".ogg"),Camera, n.Collider, 8.0)
									} else {
										PlaySound2(LoadTempSound("SFX/SCP/066/Notes"+Rand(1,6)+".ogg"), Camera, n.Collider, 8.0)
									}									
									
									switch (Rand(1,6)) {
										case 1:
											if (n.Sound2 == 0) {
												n.Sound2=LoadSound_Strict("SFX/SCP/066/Beethoven.ogg")
											}
											n.SoundChn2 = PlaySound2(n.Sound2, Camera, n.Collider)
											DeafTimer = 70*(45+(15*SelectedDifficulty.aggressiveNPCs))
											DeafPlayer = True
											CameraShake = 10.0
										case 2:
											n.State3 = Rand(700,1400)
										case 3:
											for (d of Doors.each) {
												if (!d.locked && d.KeyCard == 0 && d.Code == "") {
													if (Abs(EntityX(d.frameobj)-EntityX(n.Collider))<16.0) {
														if (Abs(EntityZ(d.frameobj)-EntityZ(n.Collider))<16.0) {
															UseDoor(d, False)
														}
													}
												}
											}
										case 4:
											if (!PlayerRoom.RoomTemplate.DisableDecals) {
												CameraShake = 5.0
												de.Decals = CreateDecal(1, EntityX(n.Collider), 0.01, EntityZ(n.Collider), 90, Rand(360), 0)
												de.Size = 0.3
												UpdateDecals
												PlaySound_Strict(LoadTempSound("SFX/General/BodyFall.ogg"))
												if (Distance(EntityX(Collider),EntityZ(Collider),EntityX(n.Collider),EntityZ(n.Collider))<0.8) {
													Injuries = Injuries + Rnd(0.3,0.5)
												}
											}
									}
								}
								
								n.State2 = n.State2+FPSfactor
								if (n.State2>70) {
									n.State = 3
									n.State2 = 0
								}
							} else {
								n.CurrSpeed = CurveValue(n.Speed*1.5, n.CurrSpeed, 10.0)
								PointEntity(n.obj, Collider)
								RotateEntity(n.Collider, 0, CurveAngle(EntityYaw(n.obj)-180, EntityYaw(n.Collider), 10), 0)
								
								AnimateNPC(n, 647, 683, n.CurrSpeed*25, False)
								
								MoveEntity(n.Collider, 0,0,-n.CurrSpeed*FPSfactor)
								
							}
						}
					case 3:
						PointEntity(n.obj, Collider)
						angle = CurveAngle(EntityYaw(n.obj)+n.Angle-180, EntityYaw(n.Collider), 10)
						RotateEntity(n.Collider, 0, angle, 0)
						
						n.CurrSpeed = CurveValue(n.Speed, n.CurrSpeed, 10.0)
						MoveEntity(n.Collider, 0,0,n.CurrSpeed*FPSfactor)
												
						if (Rand(100)=1) {
							n.Angle = Rnd(-20,20)
						}
						
						n.State2 = n.State2 + FPSfactor
						if (n.State2>250) {
							AnimateNPC(n, 684, 647, -n.CurrSpeed*25, False)
							if (n.Frame=647) {
								n.State = 0
								n.State2=0
							}
						} else {
							AnimateNPC(n, 684, 647, -n.CurrSpeed*25)
						}		
				}
				
				if (n.State > 1) {
					if (n.Sound == 0) {
						n.Sound = LoadSound_Strict("SFX/SCP/066/Rolling.ogg")
					}
					if (n.SoundChn!=0) {
						if (ChannelPlaying(n.SoundChn)) {
							n.SoundChn = LoopSound2(n.Sound, n.SoundChn, Camera, n.Collider, 20)
						}
					} else {
						n.SoundChn = PlaySound2(n.Sound, Camera, n.Collider, 20)
					}					
				}
				
				if (n.State3 > 0) {
					n.State3 = n.State3-FPSfactor
					LightVolume = TempLightVolume-TempLightVolume*Min(Max(n.State3/500,0.01),0.6)
					HeartBeatRate = Max(HeartBeatRate, 130)
					HeartBeatVolume = Max(HeartBeatVolume,Min(n.State3/1000,1.0))
				}
				
				if (ChannelPlaying(n.SoundChn2)) {
					UpdateSoundOrigin2(n.SoundChn2,Camera,n.Collider,20)
					BlurTimer = Max((5.0-dist)*300,0)
				}
				
				PositionEntity(n.obj, EntityX(n.Collider), EntityY(n.Collider) - 0.2, EntityZ(n.Collider))
				
				RotateEntity(n.obj, EntityPitch(n.Collider)-90, EntityYaw(n.Collider), 0)
				
			case NPCtype966:
				
				dist = EntityDistance(n.Collider,Collider)
				
				if (dist<HideDistance) {
					
					//n.state = the "general" state (idle/wander/attack/echo etc)
					//n.state2 = timer for doing raycasts
					
					prevFrame = n.Frame
					
					if (n.Sound > 0) {
						temp = 0.5
						//the ambient sound gets louder when the npcs are attacking
						if (n.State > 0) {
							temp = 1.0
						}
						
						n.SoundChn = LoopSound2(n.Sound, n.SoundChn, Camera, Camera, 10.0,temp)
					}
					
					temp = Rnd(-1.0,1.0)
					PositionEntity(n.obj,EntityX(n.Collider,True),EntityY(n.Collider,True)-0.2,EntityZ(n.Collider,True))
					RotateEntity(n.obj,-90.0,EntityYaw(n.Collider),0.0)
					
					if (WearingNightVision=0) {
						HideEntity(n.obj)
						if (dist<1 && n.Reload <= 0 && MsgTimer <= 0) {
							switch (Rand(6)) {
								case 1:
									Msg="You feel something breathing right next to you."
								case 2:
									Msg=Chr(34)+"It feels like something's in this room with me."+Chr(34)
								case 3:
									Msg="You feel like something is here with you, but you do not see anything."
								case 4:
									Msg=Chr(34)+"Is my mind playing tricks on me or is there someone else here?"+Chr(34)
								case 5:
									Msg="You feel like something is following you."
								case 6:
									Msg="You can feel something near you, but you are unable to see it. Perhaps its time is now."
							}
                            n.Reload = 20*70
							MsgTimer=8*70
						}
						n.Reload = n.Reload - FPSfactor
						
					} else {
						ShowEntity(n.obj)
					}
					
					if (n.State3>5*70) {
						if (n.State3<1000.0) {
							for (n2 of NPCs.each) {
								if (n2.NPCtype == n.NPCtype) {
									n2.State3=1000.0
								}
							}
						}
						
						n.State = Max(n.State,8)
						n.State3 = 1000.0					
						
					}
					
					if (Stamina<10) {
						n.State3=n.State3+FPSfactor
					} else if (n.State3 < 900.0) {
						n.State3=Max(n.State3-FPSfactor*0.2,0.0)
					}
					
					if (n.State != 10) {
						n.LastSeen = 0
					}
					
					switch (n.State) {
						case 0: //idle, standing
							//If n.Frame>2300.0 Then
							if (n.Frame>556.0) {
								AnimateNPC(n, 628, 652, 0.25, False)
								if (n.Frame>651.0) {
									SetNPCFrame(n, 2)
								}
							} else {
								//AnimateNPC(n, 201, 1015, 1.0, False)
								AnimateNPC(n, 2, 214, 0.25, False)
								
								//echo/stare/walk around periodically
								//If n.Frame>1014.0 Then
								if (n.Frame>213.0) {
									if (Rand(3) == 1 && dist<4) {
										n.State = Rand(1,4)
									} else {
										n.State = Rand(5,6)								
									}
								}
								
								//echo if player gets close
								if (dist<2.0) {
									n.State=Rand(1,4)
								} 							
							}
							
							n.CurrSpeed = CurveValue(0.0, n.CurrSpeed, 10.0)
							
							MoveEntity(n.Collider,0,0,n.CurrSpeed)
							
						case 1,2: //echo
							AnimateNPC(n, 214, 257, 0.25, False)
							if (n.Frame > 256.0) {n.State = 0}
							
							if (n.Frame>228.0 && prevFrame<=228.0) {
								PlaySound2(LoadTempSound("SFX/SCP/966/Echo"+Rand(1,3)+".ogg"), Camera, n.Collider)
							}
							
							angle = VectorYaw(EntityX(Collider)-EntityX(n.Collider),0,EntityZ(Collider)-EntityZ(n.Collider))
							RotateEntity(n.Collider,0.0,CurveAngle(angle,EntityYaw(n.Collider),20.0),0.0)
							
							if (n.State3<900) {
								BlurTimer = ((Sin(MilliSecs2()/50)+1.0)*200)/dist
								
								if (WearingNightVision>0) {GiveAchievement(Achv966)}
								
								if ((!Wearing714) && (WearingGasMask<3) && (WearingHazmat<3) && dist<16) {
									BlinkEffect = Max(BlinkEffect, 1.5)
									BlinkEffectTimer = 1000
									
									StaminaEffect = 2.0
									StaminaEffectTimer = 1000
									
									if (MsgTimer<=0 && StaminaEffect<1.5) {
										switch (Rand(4)) {
											case 1:
												Msg = "You feel exhausted."
											case 2:
												Msg = Chr(34)+"Could really go for a nap now..."+Chr(34)
											case 3:
												Msg = Chr(34)+"If I wasn't in this situation I would take a nap somewhere."+Chr(34)
											case 4:
												Msg = "You feel restless."
										}
										
										MsgTimer = 7*70
									}
								}							
							}
							
						case 3,4: //stare at player
							if (n.State == 3) {
								AnimateNPC(n, 257, 332, 0.25, False)
								if (n.Frame > 331.0) {
									n.State = 0
								}
							} else {
								AnimateNPC(n, 332, 457, 0.25, False)
								if (n.Frame > 456.0) {
									n.State = 0
								}
							}
							
							if (n.Frame>271.0 && prevFrame<=271.0 || n.Frame>354 || n.Frame>314.0 && prevFrame<=314.0 || n.Frame>301.0 && prevFrame<=301.0) {
								PlaySound2(LoadTempSound("SFX/SCP/966/Idle"+Rand(1,3)+".ogg"), Camera, n.Collider)
							}
							
							angle = VectorYaw(EntityX(Collider)-EntityX(n.Collider),0,EntityZ(Collider)-EntityZ(n.Collider))
							RotateEntity(n.Collider,0.0,CurveAngle(angle,EntityYaw(n.Collider),20.0),0.0)
						case 5,6,8: //walking or chasing
							if (n.Frame<580.0 && n.Frame>214.0) { //start walking
								AnimateNPC(n, 556, 580, 0.25, False)
							} else {
								if (n.CurrSpeed >= 0.005) {
									AnimateNPC(n, 580, 628, n.CurrSpeed*25.0)
								} else {
									AnimateNPC(n, 2, 214, 0.25)
								}
								
								//chasing the player
								if (n.State = 8 && dist<32) {
									if (n.PathTimer <= 0) {
										n.PathStatus = FindPath (n, EntityX(Collider,True), EntityY(Collider,True), EntityZ(Collider,True))
										n.PathTimer = 40*10
										n.CurrSpeed = 0
									}
									n.PathTimer = Max(n.PathTimer-FPSfactor,0)
									
									if (!EntityVisible(n.Collider,Collider)) {
										if (n.PathStatus = 2) {
											n.CurrSpeed = 0
											SetNPCFrame(n,2)
										} else if (n.PathStatus == 1) {
											if (n.Path[n.PathLocation]=Null) { 
												if (n.PathLocation > 19) { 
													n.PathLocation = 0
													n.PathStatus = 0
												} else {
													n.PathLocation = n.PathLocation + 1
												}
											} else {
												n.Angle = VectorYaw(EntityX(n.Path[n.PathLocation].obj,True)-EntityX(n.Collider),0,EntityZ(n.Path[n.PathLocation].obj,True)-EntityZ(n.Collider))
												
												dist2 = EntityDistance(n.Collider,n.Path[n.PathLocation].obj)
												
												temp = True
												if (dist2 < 0.8) { 
													if (n.Path[n.PathLocation].door!=Null) {
														if (!n.Path[n.PathLocation].door.IsElevatorDoor) {
															if ((n.Path[n.PathLocation].door.locked || n.Path[n.PathLocation].door.KeyCard!=0 || n.Path[n.PathLocation].door.Code!="") && (!n.Path[n.PathLocation].door.open)) {
																temp = False
															} else {
																if (n.Path[n.PathLocation].door.open = False && (n.Path[n.PathLocation].door.buttons[0]!=0 || n.Path[n.PathLocation].door.buttons[1]!=0)) {
																	UseDoor(n.Path[n.PathLocation].door, False)
																}
															}
														}
													}
													if (dist2 < 0.3) {
														n.PathLocation = n.PathLocation + 1
													}
												}
												
												if (!temp) {
													n.PathStatus = 0
													n.PathLocation = 0
													n.PathTimer = 40*10
												}
											}
											
											n.CurrSpeed = CurveValue(n.Speed,n.CurrSpeed,10.0)
										} else if (n.PathStatus == 0) {
											n.CurrSpeed = CurveValue(0,n.CurrSpeed,10.0)
										}
									} else {
										n.Angle = VectorYaw(EntityX(Collider)-EntityX(n.Collider),0,EntityZ(Collider)-EntityZ(n.Collider))
										n.CurrSpeed = CurveValue(n.Speed,n.CurrSpeed,10.0)
										
										if (dist<1.0) {n.State=10}
										
									}
								} else {
									if (MilliSecs2() > n.State2 && dist<16.0) {
										HideEntity(n.Collider)
										EntityPick(n.Collider, 1.5)
										if (PickedEntity() != 0) {
											n.Angle = EntityYaw(n.Collider)+Rnd(80,110)
										}
										ShowEntity(n.Collider)
										
										n.State2=MilliSecs2()+1000
										
										if (Rand(5)=1) {n.State=0}
									}	
									
									n.CurrSpeed = CurveValue(n.Speed*0.5, n.CurrSpeed, 20.0)
									
								}
								
								if ((prevFrame < 604 && n.Frame>=604) || (prevFrame < 627 && n.Frame>=627)) {
                                    PlaySound2(StepSFX(4,0,Rand(0,3)),Camera, n.Collider, 7.0, Rnd(0.5,0.7))
                                }
								
								RotateEntity(n.Collider, 0, CurveAngle(n.Angle,EntityYaw(n.Collider),10.0),0)
								
								MoveEntity(n.Collider,0,0,n.CurrSpeed*FPSfactor)
							}
						case 10: //attack
							if (n.LastSeen=0) {
								PlaySound2(LoadTempSound("SFX/SCP/966/Echo"+Rand(1,3)+".ogg"), Camera, n.Collider)
								n.LastSeen = 1
							}
							
							if (n.Frame>557.0) {
								AnimateNPC(n, 628, 652, 0.25, False)
								if (n.Frame>651.0) {
									switch (Rand(3)) {
										case 1:
											SetNPCFrame(n, 458)
										case 2:
											SetNPCFrame(n, 488)
										case 3:
											SetNPCFrame(n, 518)
									}
								}
							} else {								
								if (n.Frame <= 487) {
									AnimateNPC(n, 458, 487, 0.3, False)
									if (n.Frame > 486.0) {
										n.State = 8
									}
								} else if (n.Frame <= 517) {
									AnimateNPC(n, 488, 517, 0.3, False)
									if (n.Frame > 516.0) {
										n.State = 8
									}
								} else if (n.Frame <= 557) {
									AnimateNPC(n, 518, 557, 0.3, False)
									if (n.Frame > 556.0) {
										n.State = 8
									}
								}
							}
							
							if (dist<1.0) {
								if (n.Frame>470.0 && prevFrame<=470.0 || n.Frame>500.0 && prevFrame<=500.0 || n.Frame>527.0 && prevFrame<=527.0) {
									PlaySound2(LoadTempSound("SFX/General/Slash"+Rand(1,2)+".ogg"), Camera, n.Collider)
									Injuries = Injuries + Rnd(0.5,1.0)								
								}
							}
							
							n.Angle = VectorYaw(EntityX(Collider)-EntityX(n.Collider),0,EntityZ(Collider)-EntityZ(n.Collider))
							RotateEntity(n.Collider, 0, CurveAngle(n.Angle,EntityYaw(n.Collider),30.0),0)
							
					}
				} else {
					HideEntity(n.obj)
					if (Rand(600)=1) {
						TeleportCloser(n)
					}
				}
				
				
			case NPCtype1048a:
				
				switch (n.State) {
						
					case 1:
						n.PathStatus = FindPath(n, n.EnemyX,n.EnemyY+0.1,n.EnemyZ)
						//649, 677
				}
				//[End block]
			case NPCtype1499:
				
				//n.State: Current State of the NPC
				//n.State2: A second state variable (dependend on the current NPC's n.State)
				//n.State3: Determines if the NPC will always be aggressive against the player
				//n.PrevState: Determines the type/behaviour of the NPC
				//	0 = Normal / Citizen
				//	1 = Stair guard / Guard next to king
				//	2 = King
				//	3 = Front guard
				
				prevFrame = n.Frame
				
				if ((!n.Idle) && EntityDistance(n.Collider,Collider)<HideDistance*3) {
					if (n.PrevState = 0) {
						if (n.State == 0 || n.State == 2) {
							for (let n2 of NPCs.each) {
								if (n2.NPCtype = n.NPCtype && n2 != n) {
									if (n2.State != 0 && n2.State != 2) {
										if (n2.PrevState = 0) {
											n.State = 1
											n.State2 = 0
											break
										}
									}
								}
							}
						}
					}
					
					switch (n.State) {
						case 0:
							
							if (n.PrevState=0) {
								if (n.CurrSpeed = 0.0) {
									if (n.Reload=0) {
										if (n.State2 < 500.0*Rnd(1,3)) {
											n.CurrSpeed = 0.0
											n.State2 = n.State2 + FPSfactor
										} else {
											if (n.CurrSpeed = 0.0) {
												n.CurrSpeed = n.CurrSpeed + 0.0001
											}
										}
									} else {
										if (n.State2 < 1500) {
											n.CurrSpeed = 0.0
											n.State2 = n.State2 + FPSfactor
										} else {
											if (n.Target != Null) {
												if (n.Target.Target != Null) {
													n.Target.Target = Null
												}
												n.Target.Reload = 0
												n.Target.Angle = n.Target.Angle+Rnd(-45,45)
												n.Target = Null
												n.Reload = 0
												n.Angle = n.Angle+Rnd(-45,45)
											}
											if (n.CurrSpeed == 0.0) {
												n.CurrSpeed = n.CurrSpeed + 0.0001
											}
										}
									}
								} else {
									if (n.Target!=Null) {
										n.State2 = 0.0
									}
									
									if (n.State2 < 10000.0*Rnd(1,3)) {
										n.CurrSpeed = CurveValue(n.Speed,n.CurrSpeed,10.0)
										n.State2 = n.State2 + FPSfactor
									} else {
										n.CurrSpeed = CurveValue(0.0,n.CurrSpeed,50.0)
									}
									
									RotateEntity(n.Collider,0,CurveAngle(n.Angle,EntityYaw(n.Collider),10.0),0)
									
									if (n.Target=Null) {
										if (Rand(200) = 1) {
											n.Angle = n.Angle + Rnd(-45,45)
										}
										
										HideEntity(n.Collider)
										EntityPick(n.Collider, 1.5)
										if (PickedEntity() != 0) {
											n.Angle = EntityYaw(n.Collider)+Rnd(80,110)
										}
										ShowEntity(n.Collider)
									} else {
										n.Angle = EntityYaw(n.Collider) + DeltaYaw(n.Collider,n.Target.Collider)
										if (EntityDistance(n.Collider,n.Target.Collider)<1.5) {
											n.CurrSpeed = 0.0
											n.Target.CurrSpeed = 0.0
											n.Reload = 1
											n.Target.Reload = 1
											temp = Rand(0,2)
											if (temp == 0) {
												SetNPCFrame(n,296)
											} else if (temp == 1) {
												SetNPCFrame(n,856)
											} else {
												SetNPCFrame(n,905)
											}
											temp = Rand(0,2)
											if (temp == 0) {
												SetNPCFrame(n.Target,296)
											} else if (temp == 1) {
												SetNPCFrame(n.Target,856)
											} else {
												SetNPCFrame(n.Target,905)
											}
										}
									}
								}
							} else {
								RotateEntity(n.Collider,0,CurveAngle(n.Angle,EntityYaw(n.Collider),10.0),0)
							}
							
							if (n.CurrSpeed == 0.0) {
								if (n.Reload = 0 && n.PrevState!=2) {
									AnimateNPC(n,296,320,0.2)
								} else if (n.Reload == 0 && n.PrevState == 2) {
									//509-533
									//534-601
									if (n.Frame <= 532.5) {
										AnimateNPC(n,509,533,0.2,False)
									} else if (n.Frame > 533.5 && n.Frame <= 600.5) {
										AnimateNPC(n,534,601,0.2,False)
									} else {
										temp = Rand(0,1)
										if (temp == 0) {
											SetNPCFrame(n,509)
										} else {
											SetNPCFrame(n,534)
										}
									}
								} else {
									if (n.PrevState == 2) {
										AnimateNPC(n,713,855,0.2,False)
										if (n.Frame > 833.5) {
											PointEntity(n.obj,Collider)
											RotateEntity(n.Collider,0,CurveAngle(n.Angle,EntityYaw(n.Collider),10.0),0)
										}
									} else if (n.PrevState == 1) {
										AnimateNPC(n,602,712,0.2,False)
										if (n.Frame > 711.5) {
											n.Reload = 0
										}
									} else {
										if (n.Frame <= 319.5) {
											AnimateNPC(n,296,320,0.2,False)
										//856-904
										} else if (n.Frame > 320.5 && n.Frame < 903.5) {
											AnimateNPC(n,856,904,0.2,False)
										//905-953
										} else if (n.Frame > 904.5 && n.Frame < 952.5) {
											AnimateNPC(n,905,953,0.2,False)
										} else {
											temp = Rand(0,2)
											if (temp == 0) {
												SetNPCFrame(n,296)
											} else if (temp == 1) {
												SetNPCFrame(n,856)
											} else {
												SetNPCFrame(n,905)
											}
										}
									}
								}
							} else {
								if (n.ID % 2 == 0) {
									AnimateNPC(n,1,62,(n.CurrSpeed*28))
								} else {
									AnimateNPC(n,100,167,(n.CurrSpeed*28))
								}
								if (n.PrevState == 0) {
									if (n.Target == Null) {
										if (Rand(1,1200) == 1) {
											for (n2 of NPCs.each) {
												if (n2!=n) {
													if (n2.NPCtype == n.NPCtype) {
														if (n2.Target = Null) {
															if (n2.PrevState=0) {
																if (EntityDistance(n.Collider,n2.Collider)<20.0) {
																	n.Target = n2
																	n2.Target = n
																	n.Target.CurrSpeed = n.Target.CurrSpeed + 0.0001
																	break
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
							
							//randomly play the "screaming animation" and revert back to state 0
							if (n.Target == Null && n.PrevState == 0) {
								if (Rand(5000)=1) {
									n.State = 2
									n.State2 = 0
									
									if (!ChannelPlaying(n.SoundChn)) {
										dist = EntityDistance(n.Collider,Collider)
										if (dist < 20.0) {
											if (n.Sound != 0) {
												FreeSound_Strict(n.Sound)
												n.Sound = 0
											}
											n.Sound = LoadSound_Strict("SFX/SCP/1499/Idle"+Rand(1,4)+".ogg")
											n.SoundChn = PlaySound2(n.Sound, Camera, n.Collider, 20.0)
										}
									}
								}
								
								if ((n.ID % 2 == 0) && (!NoTarget)) {
									dist = EntityDistance(n.Collider,Collider)
									if (dist < 10.0) {
										if (EntityVisible(n.Collider,Collider)) {
											//play the "screaming animation"
											n.State = 2
											if (dist < 5.0) {
												if (n.Sound != 0) {
													FreeSound_Strict(n.Sound)
													n.Sound = 0
												}
												n.Sound = LoadSound_Strict("SFX/SCP/1499/Triggered.ogg")
												n.SoundChn = PlaySound2(n.Sound, Camera, n.Collider,20.0)
												
												n.State2 = 1 //if player is too close, switch to attack after screaming
												
												for (n2 of NPCs.each) {
													if (n2.NPCtype == n.NPCtype && n2 != n) {
														if (n2.PrevState == 0) {
															n2.State = 1
															n2.State2 = 0
														}
													}
												}
											} else {
												n.State2 = 0 //otherwise keep idling
											}
											
											n.Frame = 203
										}
									}
								}
							} else if (n.PrevState=1) {
								dist = EntityDistance(n.Collider,Collider)
								if ((!NoTarget)) {
									if (dist < 4.0) {
										if (EntityVisible(n.Collider,Collider)) {
											if (n.Sound != 0) {
												FreeSound_Strict(n.Sound)
												n.Sound = 0
											}
											n.Sound = LoadSound_Strict("SFX/SCP/1499/Triggered.ogg")
											n.SoundChn = PlaySound2(n.Sound, Camera, n.Collider,20.0)
											
											n.State = 1
											
											n.Frame = 203
										}
									}
								}
							}
							
						case 1: //attacking the player
							
							if (NoTarget) {n.State = 0}
							
							if (PlayerRoom.RoomTemplate.Name == "dimension1499" && n.PrevState == 0) {
								ShouldPlay = 19
							}
							
							PointEntity(n.obj,Collider)
							RotateEntity(n.Collider,0,CurveAngle(EntityYaw(n.obj),EntityYaw(n.Collider),20.0),0)
							
							dist = EntityDistance(n.Collider,Collider)
							
							if (n.State2 = 0.0) {
								if (n.PrevState=1) {
									n.CurrSpeed = CurveValue(n.Speed*2.0,n.CurrSpeed,10.0)
									if (n.Target!=Null) {
										n.Target.State = 1
									}
								} else {
									n.CurrSpeed = CurveValue(n.Speed*1.75,n.CurrSpeed,10.0)
								}
								
								if (n.ID % 2 == 0) {
									AnimateNPC(n,1,62,(n.CurrSpeed*28))
								} else {
									AnimateNPC(n,100,167,(n.CurrSpeed*28))
								}
							}
							
							if (dist < 0.75) {
								if ((n.ID % 2 == 0) || n.State3 == 1 || n.PrevState==1 || n.PrevState==3 || n.PrevState==4) {
									n.State2 = Rand(1,2)
									n.State = 3
									if (n.State2 = 1) {
										SetNPCFrame(n,63)
									} else {
										SetNPCFrame(n,168)
									}
								} else {
									n.State = 4
								}
							}
							
						case 2: //play the "screaming animation" and switch to n.state2 after it's finished
							
							n.CurrSpeed = 0.0
							AnimateNPC(n,203,295,0.1,False)
							
							if (n.Frame > 294.0) {
								n.State = n.State2
							}
							
						case 3: //slashing at the player
							
							n.CurrSpeed = CurveValue(0.0,n.CurrSpeed,5.0)
							dist = EntityDistance(n.Collider,Collider)
							if (n.State2 = 1) {
								AnimateNPC(n,63,100,0.6,False)
								if (prevFrame < 89 && n.Frame>=89) {
									if (dist > 0.85 || Abs(DeltaYaw(n.Collider,Collider))>60.0) {
										//Miss
									} else {
										Injuries = Injuries + Rnd(0.75,1.5)
										PlaySound2(LoadTempSound("SFX/General/Slash"+Rand(1,2)+".ogg"), Camera, n.Collider)
										if (Injuries > 10.0) {
											Kill()
											if (PlayerRoom.RoomTemplate.Name$ = "dimension1499") {
												DeathMSG = "All personnel situated within Evacuation Shelter LC-2 during the breach have been administered "
												DeathMSG = DeathMSG + "Class-B amnestics due to Incident 1499-E. The Class D subject involved in the event "
												DeathMSG = DeathMSG + "died shortly after being shot by Agent [REDACTED]."
											} else {
												DeathMSG = "An unidentified male and a deceased Class D subject were discovered in [REDACTED] by the Nine-Tailed Fox. "
												DeathMSG = DeathMSG + "The man was described as highly agitated and seemed to only speak Russian. "
												DeathMSG = DeathMSG + "He's been taken into a temporary holding area at [REDACTED] while waiting for a translator to arrive."
											}
										}
									}
								} else if (n.Frame >= 99) {
									n.State2 = 0.0
									n.State = 1
								}
							} else {
								AnimateNPC(n,168,202,0.6,False)
								if (prevFrame < 189 && n.Frame>=189) {
									if (dist > 0.85 || Abs(DeltaYaw(n.Collider,Collider))>60.0) {
										//Miss
									} else {
										Injuries = Injuries + Rnd(0.75,1.5)
										PlaySound2(LoadTempSound("SFX/General/Slash"+Rand(1,2)+".ogg"), Camera, n.Collider)
										if (Injuries > 10.0) {
											Kill()
											if (PlayerRoom.RoomTemplate.Name$ = "dimension1499") {
												DeathMSG = "All personnel situated within Evacuation Shelter LC-2 during the breach have been administered "
												DeathMSG = DeathMSG + "Class-B amnestics due to Incident 1499-E. The Class D subject involved in the event "
												DeathMSG = DeathMSG + "died shortly after being shot by Agent [REDACTED]."
											} else {
												DeathMSG = "An unidentified male and a deceased Class D subject were discovered in [REDACTED] by the Nine-Tailed Fox. "
												DeathMSG = DeathMSG + "The man was described as highly agitated and seemed to only speak Russian. "
												DeathMSG = DeathMSG + "He's been taken into a temporary holding area at [REDACTED] while waiting for a translator to arrive."
											}
										}
									}
								} else if (n.Frame >= 201) {
									n.State2 = 0.0
									n.State = 1
								}
							}
							
						case 4: //standing in front of the player
							
							dist = EntityDistance(n.Collider,Collider)
							n.CurrSpeed = CurveValue(0.0,n.CurrSpeed,5.0)
							AnimateNPC(n,296,320,0.2)
							
							PointEntity(n.obj,Collider)
							RotateEntity(n.Collider,0,CurveAngle(EntityYaw(n.obj),EntityYaw(n.Collider),20.0),0)
							
							if (dist > 0.85) {
								n.State = 1
							}
							
					}
					
					if (n.SoundChn != 0 && ChannelPlaying(n.SoundChn)) {
						UpdateSoundOrigin(n.SoundChn,Camera,n.Collider,20.0)
					}
					
					MoveEntity(n.Collider,0,0,n.CurrSpeed*FPSfactor)
					
					RotateEntity(n.obj,0,EntityYaw(n.Collider)-180,0)
					PositionEntity(n.obj,EntityX(n.Collider),EntityY(n.Collider)-0.2,EntityZ(n.Collider))
					
					ShowEntity(n.obj)
				} else {
					HideEntity(n.obj)
				}
				
				
			case NPCtype008:
				
				//n.State: Main State
				//n.State2: A timer used for the player detection
				//n.State3: A timer for making the NPC idle (if the player escapes during that time)
				
				if (!n.IsDead) {
					if (n.State == 0) {
						EntityType(n.Collider,HIT_DEAD)
					} else {
						EntityType(n.Collider,HIT_PLAYER)
					}
					
					prevFrame = n.Frame
					
					n.BlinkTimer = 1
					
					switch (n.State) {
						case 0: //Lying next to the wall
							SetNPCFrame(n,11)
						case 1: //Standing up
							AnimateNPC(n,11,32,0.1,False)
							if (n.Frame >= 29) {
								n.State = 2
							}
						case 2: //Being active
							PlayerSeeAble = MeNPCSeesPlayer(n)
							if (PlayerSeeAble == 1 || n.State2 > 0.0) {
								if (PlayerSeeAble == 1) {
									n.State2 = 70*2
								} else {
									n.State2 = Max(n.State2-FPSfactor,0)
								}
								PointEntity(n.obj, Collider)
								RotateEntity(n.Collider, 0, CurveAngle(EntityYaw(n.obj), EntityYaw(n.Collider), 20.0), 0)
								
								AnimateNPC(n, 64, 93, n.CurrSpeed*30)
								n.CurrSpeed = CurveValue(n.Speed*0.7, n.CurrSpeed, 20.0)
								MoveEntity(n.Collider, 0, 0, n.CurrSpeed * FPSfactor)
								
								if (EntityDistance(n.Collider,Collider)<1.0) {
									if (Abs(DeltaYaw(n.Collider,Collider))<=60.0) {
										n.State = 3
									}
								}
								
								n.PathTimer = 0
								n.PathStatus = 0
								n.PathLocation = 0
								n.State3 = 0
							} else {
								if (n.PathStatus == 1) {
									if (n.Path[n.PathLocation]=Null) { 
										if (n.PathLocation > 19) { 
											n.PathLocation = 0
											n.PathStatus = 0
										} else {
											n.PathLocation = n.PathLocation + 1
										}
									} else {
										PointEntity(n.obj, n.Path[n.PathLocation].obj)
										RotateEntity(n.Collider, 0, CurveAngle(EntityYaw(n.obj), EntityYaw(n.Collider), 20.0), 0)
										
										AnimateNPC(n, 64, 93, n.CurrSpeed*30)
										n.CurrSpeed = CurveValue(n.Speed*0.7, n.CurrSpeed, 20.0)
										MoveEntity(n.Collider, 0, 0, n.CurrSpeed * FPSfactor)
										
										//opens doors in front of him
										dist2 = EntityDistance(n.Collider,n.Path[n.PathLocation].obj)
										if (dist2 < 0.6) {
											temp = True
											if (n.Path[n.PathLocation].door != Null) {
												if (!n.Path[n.PathLocation].door.IsElevatorDoor) {
													if (n.Path[n.PathLocation].door.locked || n.Path[n.PathLocation].door.KeyCard>0 || n.Path[n.PathLocation].door.Code!="") {
														temp = False
													} else {
														if (!n.Path[n.PathLocation].door.open) {
															UseDoor(n.Path[n.PathLocation].door, False)
														}
													}
												}
											}
											if (dist2 < 0.2 && temp) {
												n.PathLocation = n.PathLocation + 1
											} else if (dist2 < 0.5 && (!temp)) {
												n.PathStatus = 0
												n.PathTimer = 0.0
											}
										}
									}
								} else {
									AnimateNPC(n, 323, 344, 0.2, True)
									n.CurrSpeed = 0
									if (n.PathTimer < 70*5) {
										n.PathTimer = n.PathTimer + Rnd(1,2+(2*SelectedDifficulty.aggressiveNPCs))*FPSfactor
									} else {
										n.PathStatus = FindPath(n,EntityX(Collider),EntityY(Collider),EntityZ(Collider))
										n.PathTimer = 0
									}
								}
								
								if (EntityDistance(n.Collider,Collider)>HideDistance) {
									if (n.State3 < 70*(15+(10*SelectedDifficulty.aggressiveNPCs))) {
										n.State3 = n.State3+FPSfactor
									} else {
										DebugLog("SCP-008-1 IDLE")
										n.State3 = 70*(6*60)
										n.State = 4
									}
								}
							}
							
							if (n.CurrSpeed > 0.005) {
								if ((prevFrame < 80 && n.Frame>=80) || (prevFrame > 92 && n.Frame<65)) {
									PlaySound2(StepSFX(0,0,Rand(0,7)),Camera, n.Collider, 8.0, Rnd(0.3,0.5))
								}
							}
							
							n.SoundChn = LoopSound2(n.Sound,n.SoundChn,Camera,n.Collider)
						case 3: //Attacking
							AnimateNPC(n, 126, 165, 0.4, False)
							if (n.Frame >= 146 && prevFrame < 146) {
								if (EntityDistance(n.Collider,Collider)<1.1) {
									if (Abs(DeltaYaw(n.Collider,Collider))<=60.0) {
										PlaySound_Strict(DamageSFX(Rand(5,8)))
										Injuries = Injuries+Rnd(0.4,1.0)
										Infect = Infect + (1+(1*SelectedDifficulty.aggressiveNPCs))
										DeathMSG = "Subject D-9341. Cause of death: multiple lacerations and severe blunt force trauma caused by [DATA EXPUNGED], who was infected with SCP-008. Said subject was located by Nine-Tailed Fox and terminated."
									}
								}
							} else if (n.Frame >= 164) {
								if (EntityDistance(n.Collider,Collider)<1.1) {
									if (Abs(DeltaYaw(n.Collider,Collider))<=60.0) {
										SetNPCFrame(n,126)
									} else {
										n.State = 2
									}
								} else {
									n.State = 2
								}
							}
						case 4: //Idling
							HideEntity(n.obj)
							HideEntity(n.Collider)
							n.DropSpeed = 0
							PositionEntity(n.Collider,0,500,0)
							ResetEntity(n.Collider)
							if (n.Idle > 0) {
								n.Idle = Max(n.Idle-(1+(1*SelectedDifficulty.aggressiveNPCs))*FPSfactor,0)
							} else {
								if (PlayerInReachableRoom()) { //Player is in a room where SCP-008-1 can teleport to
									if (Rand(50-(20*SelectedDifficulty.aggressiveNPCs)) == 1) {
										ShowEntity(n.Collider)
										ShowEntity(n.obj)
										for (w of WayPoints.each) {
											if (w.door=Null && w.room.dist < HideDistance && Rand(3) == 1) {
												if (EntityDistance(w.room.obj,n.Collider)<EntityDistance(Collider,n.Collider)) {
													x = Abs(EntityX(n.Collider)-EntityX(w.obj,True))
													if (x < 12.0 && x > 4.0) {
														z = Abs(EntityZ(n.Collider)-EntityZ(w.obj,True))
														if (z < 12 && z > 4.0) {
															if (w.room.dist > 4) {
																DebugLog("MOVING 008-1 TO "+w.room.roomtemplate.name)
																PositionEntity(n.Collider, EntityX(w.obj,True), EntityY(w.obj,True)+0.25,EntityZ(w.obj,True))
																ResetEntity(n.Collider)
																n.PathStatus = 0
																n.PathTimer = 0.0
																n.PathLocation = 0
																break
															}
														}
													}
												}
											}
										}
										n.State = 2
										n.State3 = 0
									}
								}
							}
					}
				} else {
					if (n.SoundChn != 0) {
						StopChannel(n.SoundChn)
						n.SoundChn = 0
						FreeSound_Strict(n.Sound)
						n.Sound = 0
					}
					AnimateNPC(n, 344, 363, 0.5, False)
				}
				
				RotateEntity(n.obj,0,EntityYaw(n.Collider)-180,0)
				PositionEntity(n.obj,EntityX(n.Collider),EntityY(n.Collider)-0.2,EntityZ(n.Collider))
				
		}
		
		if (n.IsDead) {
			EntityType(n.Collider,HIT_DEAD)
		}
		
		let gravityDist = Distance(EntityX(Collider),EntityZ(Collider),EntityX(n.Collider),EntityZ(n.Collider))
		
		if (gravityDist<HideDistance*0.7 || n.NPCtype == NPCtype1499) {
			if (n.InFacility == InFacility) {
				TranslateEntity(n.Collider, 0, n.DropSpeed, 0)
				
				let CollidedFloor: boolean = false
				for (i of range(1, CountCollisions(n.Collider) + 1)) {
					if (CollisionY(n.Collider, i) < EntityY(n.Collider) - 0.01) {
						CollidedFloor = True
						break
					}
				}
				
				if (CollidedFloor) {
					n.DropSpeed = 0
				} else {
					if (ShouldEntitiesFall) {
						let UpdateGravity: boolean = False
						let MaxX: float
						let MinX: float
						let MaxZ: float
						let MinZ: float
						if (n.InFacility=1) {
							if (PlayerRoom.RoomTemplate.Name$ != "173") {
								for (e of Events.each) {
									if (e.EventName = "room860") {
										if (e.EventState = 1.0) {
											UpdateGravity = True
											break
										}
									}
								}
							} else {
								UpdateGravity = True
							}
							if (!UpdateGravity) {
								for (r of Rooms.each) {
									if (r.MaxX!=0 || r.MinX!=0 || r.MaxZ!=0 || r.MinZ!=0) {
										MaxX = r.MaxX
										MinX = r.MinX
										MaxZ = r.MaxZ
										MinZ = r.MinZ
									} else {
										MaxX = 4.0
										MinX = 0.0
										MaxZ = 4.0
										MinZ = 0.0
									}
									if (Abs(EntityX(n.Collider)-EntityX(r.obj))<=Abs(MaxX-MinX)) {
										if (Abs(EntityZ(n.Collider)-EntityZ(r.obj))<=Abs(MaxZ-MinZ)) {
											if (r == PlayerRoom) {
												UpdateGravity = True
												break
											}
											if (IsRoomAdjacent(PlayerRoom,r)) {
												UpdateGravity = True
												break
											}
											for (i of range(4)) {
												if (IsRoomAdjacent(PlayerRoom.Adjacent[i],r)) {
													UpdateGravity = True
													break
												}
											}
										}
									}
								}
							}
						} else {
							UpdateGravity = True
						}
						if (UpdateGravity) {
							n.DropSpeed = Max(n.DropSpeed - 0.005*FPSfactor*n.GravityMult,-n.MaxGravity)
						} else {
							if (n.FallingPickDistance>0) {
								n.DropSpeed = 0.0
							} else {
								n.DropSpeed = Max(n.DropSpeed - 0.005*FPSfactor*n.GravityMult,-n.MaxGravity)
							}
						}
					} else {
						n.DropSpeed = 0.0
					}
				}
			} else {
				n.DropSpeed = 0
			}
		} else {
			n.DropSpeed = 0
		}
		
		CatchErrors(Chr(34)+n.NVName+Chr(34)+" NPC")
		
	}
	
	if (MTF_CameraCheckTimer>0.0 && MTF_CameraCheckTimer<70*90) {
		MTF_CameraCheckTimer=MTF_CameraCheckTimer+FPSfactor
	} else if (MTF_CameraCheckTimer>=70*90) {
		MTF_CameraCheckTimer=0.0
		if (!PlayerDetected) {
			if (MTF_CameraCheckDetected) {
				PlayAnnouncement("SFX/Character/MTF/AnnouncCameraFound"+Rand(1,2)+".ogg")
				PlayerDetected=True
				MTF_CameraCheckTimer=70*60
			} else {
				PlayAnnouncement("SFX/Character/MTF/AnnouncCameraNoFound.ogg")
			}
		}
		MTF_CameraCheckDetected=False
		if (MTF_CameraCheckTimer == 0.0) {
			PlayerDetected=False
		}
	}
}

function TeleportCloser(n: NPCs) {
	let closestDist: float = 0
	let closestWaypoint: WayPoints
	let w: WayPoints
	
	let xtemp: float
	let ztemp: float
	
	for (w of WayPoints.each) {
		if (w.door = Null) {
			xtemp = Abs(EntityX(w.obj,True)-EntityX(n.Collider,True))
			if (xtemp < 10.0 && xtemp > 1.0) { 
				ztemp = Abs(EntityZ(w.obj,True)-EntityZ(n.Collider,True))
				if (ztemp < 10.0 && ztemp > 1.0) {
					if (EntityDistance(Collider, w.obj)>16-(8*SelectedDifficulty.aggressiveNPCs)) {
						//teleports to the nearby waypoint that takes it closest to the player
						let newDist: float = EntityDistance(Collider, w.obj)
						if (newDist < closestDist || closestWaypoint == Null) {
							closestDist = newDist	
							closestWaypoint = w
						}						
					}
				}
			}
		}
	}
	
	let shouldTeleport: boolean = False
	if (closestWaypoint!=Null) {
		if (n.InFacility != 1 || SelectedDifficulty.aggressiveNPCs) {
			shouldTeleport = True
		} else if (EntityY(closestWaypoint.obj,True)<=7.0 && EntityY(closestWaypoint.obj,True)>=-10.0) {
			shouldTeleport = True
		}
		
		if (shouldTeleport) {
			PositionEntity(n.Collider, EntityX(closestWaypoint.obj,True), EntityY(closestWaypoint.obj,True)+0.15, EntityZ(closestWaypoint.obj,True), True)
			ResetEntity(n.Collider)
			n.PathStatus = 0
			n.PathTimer = 0.0
			n.PathLocation = 0
		}
	}
}

function OtherNPCSeesMeNPC(me: NPCs,other: NPCs) : int {
	if (other.BlinkTimer<=0.0) {return False}
	
	if (EntityDistance(other.Collider,me.Collider)<6.0) {
		if (Abs(DeltaYaw(other.Collider,me.Collider))<60.0) {
			return True
		}
	}
	return False
}

function MeNPCSeesPlayer(me: NPCs,disablesoundoncrouch: boolean = False) : int {
	//Return values:
		//False (=0): Player is not detected anyhow
		//True (=1): Player is detected by vision
		//2: Player is detected by emitting a sound
		//3: Player is detected by a camera (only for MTF Units!)
		//4: Player is detected through glass
	
	if (NoTarget) {return False}
	
	if ((!PlayerDetected) || me.NPCtype != NPCtypeMTF) {
		if (me.BlinkTimer<=0.0) {return False}
		if (EntityDistance(Collider,me.Collider)>(8.0-CrouchState+PlayerSoundVolume)) {return False}
		
		//spots the player if he's either in view or making a loud sound
		if (PlayerSoundVolume>1.0) {
			if ((Abs(DeltaYaw(me.Collider,Collider))>60.0) && EntityVisible(me.Collider,Collider)) {
				return 1
			} else if (!EntityVisible(me.Collider,Collider)) {
				if (disablesoundoncrouch && Crouch) {
					return False
				} else {
					return 2
				}
			}
		} else {
			if (Abs(DeltaYaw(me.Collider,Collider))>60.0) {return False}
		}
		return EntityVisible(me.Collider,Collider)
	} else {
		if (EntityDistance(Collider,me.Collider)>(8.0-CrouchState+PlayerSoundVolume)) {return 3}
		if (EntityVisible(me.Collider, Camera)) {return True}
		
		//spots the player if he's either in view or making a loud sound
		if (PlayerSoundVolume>1.0) {return 2}
		return 3
	}
}

function TeleportMTFGroup(n: NPCs) {
	let n2: NPCs
	
	if (n.MTFLeader != Null) {return}
	
	TeleportCloser(n)
	
	for (n2 of  NPCs.each) {
		if (n2.NPCtype == NPCtypeMTF) {
			if (n2.MTFLeader != Null) {
				PositionEntity(n2.Collider,EntityX(n2.MTFLeader.Collider),EntityY(n2.MTFLeader.Collider)+0.1,EntityZ(n2.MTFLeader.Collider))
			}
		}
	}
	
	DebugLog("Teleported MTF Group (dist:"+EntityDistance(n.Collider,Collider)+")")
}

function UpdateMTFUnit(n: NPCs) {
	
	
	if (n.NPCtype!=NPCtypeMTF) {
		let realType: string = ""
		switch (n.NPCtype) {
			case NPCtype173:
                realType = "173"
			case NPCtypeOldMan:
                realType = "106"
			case NPCtypeGuard:
                realType = "guard"
			case NPCtypeD:
                realType = "d"
			case NPCtype372:
                realType = "372"
			case NPCtypeApache:
                realType = "apache"
			case NPCtype096:
                realType = "096"
			case NPCtype049:
                realType = "049"
			case NPCtypeZombie:
                realType = "zombie"
			case NPCtype5131:
                realType = "513-1"
			case NPCtypeTentacle:
                realType = "tentacle"
			case NPCtype860:
                realType = "860"
			case NPCtype939:
                realType = "939"
			case NPCtype066:
                realType = "066"
			case NPCtypePdPlane:
                realType = "PDPlane"
			case NPCtype966:
                realType = "966"
			case NPCtype1048a:
                realType = "1048-A"
			case NPCtype1499:
				realType = "1499-1"
		}
		RuntimeError("Called UpdateMTFUnit on "+realType)
	}
	
	
	let x: float
	let y: float
	let z: float
	let r: Rooms
	let prevDist: float
	let newDist: float
	let n2: NPCs
	
	let p: Particles
	let target
	let dist: float
	let dist2: float
	
	if (n.IsDead) {
		n.BlinkTimer = -1.0
		SetNPCFrame(n, 532)
		if (ChannelPlaying(n.SoundChn2)) {
			StopChannel(n.SoundChn2)
		}
		return
	}
	
	n.MaxGravity = 0.03
	
	n.BlinkTimer = n.BlinkTimer - FPSfactor
	if (n.BlinkTimer<=-5.0) {
		//only play the "blinking" sound clip if searching/containing 173
		if (n.State = 2) {
			if (OtherNPCSeesMeNPC(Curr173,n)) {
				PlayMTFSound(LoadTempSound("SFX/Character/MTF/173/BLINKING.ogg"),n)
			}
		}
		n.BlinkTimer = 70.0*Rnd(10.0,15.0)
	}	
	
	n.Reload = n.Reload - FPSfactor
	
	let prevFrame: float = n.Frame
	
	n.BoneToManipulate = ""
	//n.BoneToManipulate2 = ""
	n.ManipulateBone = False
	n.ManipulationType = 0
	n.NPCNameInSection = "MTF"
	
	if (Int(n.State) != 1) {n.PrevState = 0}
	
	n.SoundChn2 = LoopSound2(MTFSFX(6),n.SoundChn2,Camera,n.Collider)
	
	if (n.Idle>0.0) {
		FinishWalking(n,488,522,0.015*26)
		n.Idle=n.Idle-FPSfactor
		if (n.Idle<=0.0) {n.Idle = 0.0}
	} else {
		switch (Int(n.State)) { //what is this MTF doing
			case 0: //wandering around
                
                n.Speed = 0.015
                if (n.PathTimer<=0.0) { //update path
					if (n.MTFLeader!=Null) { //i'll follow the leader
						n.PathStatus = FindPath(n,EntityX(n.MTFLeader.Collider,True),EntityY(n.MTFLeader.Collider,True)+0.1,EntityZ(n.MTFLeader.Collider,True)) //whatever you say boss
					} else { //i am the leader
						if (Curr173.Idle!=2) {
							for (r of Rooms.each) {
								if (((Abs(r.x-EntityX(n.Collider,True))>12.0) || (Abs(r.z-EntityZ(n.Collider,True))>12.0)) && (Rand(1,Max(4-Int(Abs(r.z-EntityZ(n.Collider,True)/8.0)),2))=1)) {
									x = r.x
									y = 0.1
									z = r.z
									DebugLog(r.RoomTemplate.Name)
									break
								}
							}
						} else {
							let tmp = False
							if (EntityDistance(n.Collider,Curr173.Collider)>4.0) {
								if (!EntityVisible(n.Collider,Curr173.Collider)) {
									tmp = True
								}
							}
							
							if (!tmp) {
								for (r of Rooms.each) {
									if (r.RoomTemplate.Name$ = "start") {
										let foundChamber: boolean = False
										let pvt: int = CreatePivot()
										PositionEntity(pvt,EntityX(r.obj,True)+4736*RoomScale,0.5,EntityZ(r.obj,True)+1692*RoomScale)
										
										if (Distance(EntityX(pvt),EntityZ(pvt),EntityX(n.Collider),EntityZ(n.Collider))<3.5) {
											foundChamber = True
											DebugLog(Distance(EntityX(pvt),EntityZ(pvt),EntityX(n.Collider),EntityZ(n.Collider)))
										}
										
										if (Curr173.Idle = 3 && Distance(EntityX(pvt),EntityZ(pvt),EntityX(n.Collider),EntityZ(n.Collider)) > 4.0) {
											if (r.RoomDoors[1].open) {UseDoor(r.RoomDoors[1],False)}
										}
										
										FreeEntity (pvt)
										
										if (Distance(EntityX(n.Collider),EntityZ(n.Collider),EntityX(r.obj,True)+4736*RoomScale,EntityZ(r.obj,True)+1692*RoomScale)>1.6 && (!foundChamber)) {
											x = EntityX(r.obj,True)+4736*RoomScale
											y = 0.1
											z = EntityZ(r.obj,True)+1692*RoomScale
											DebugLog("Move to 173's chamber")
											break
										} else if (Distance(EntityX(n.Collider),EntityZ(n.Collider),EntityX(r.obj,True)+4736*RoomScale,EntityZ(r.obj,True)+1692*RoomScale)>1.6 && foundChamber) {
											n.PathX = EntityX(r.obj,True)+4736*RoomScale
											n.PathZ = EntityZ(r.obj,True)+1692*RoomScale
											DebugLog("Move inside 173's chamber")
											break
										} else {
											Curr173.Idle = 3
											Curr173.Target = Null
											Curr173.IsDead = True
											if (n.Sound != 0) {
												FreeSound_Strict(n.Sound)
												n.Sound = 0
											}
											n.Sound = LoadSound_Strict("SFX/Character/MTF/173/Cont"+Rand(1,4)+".ogg")
											PlayMTFSound(n.Sound, n)
											PlayAnnouncement("SFX/Character/MTF/Announc173Contain.ogg")
											DebugLog("173 contained")
											break
										}
									}
								}
							} else {
								x = EntityX(Curr173.Collider)
								y = 0.1
								z = EntityZ(Curr173.Collider)
								DebugLog("Going back to 173's cage")
							}
						}
						if (n.PathX=0) {n.PathStatus = FindPath(n,x,y,z)} //we're going to this room for no particular reason
					}
					if (n.PathStatus = 1) {
						while (n.Path[n.PathLocation]=Null) {
							if (n.PathLocation>19) {break}
							n.PathLocation=n.PathLocation+1
						}
						if (n.PathLocation<19) {
							if ((n.Path[n.PathLocation]!=Null) && (n.Path[n.PathLocation+1]!=Null)) {
								if (n.Path[n.PathLocation].door=Null) {
									if (Abs(DeltaYaw(n.Collider,n.Path[n.PathLocation].obj))>Abs(DeltaYaw(n.Collider,n.Path[n.PathLocation+1].obj))) {
										n.PathLocation=n.PathLocation+1
									}
								}
							}
						}
					}
					n.PathTimer = 70.0 * Rnd(6.0,10.0) //search again after 6-10 seconds
                } else if ((n.PathTimer<=70.0 * 2.5) && (n.MTFLeader=Null)) {
					n.PathTimer=n.PathTimer-FPSfactor
					n.CurrSpeed = 0.0
					if (Rand(1,35)=1) {
						RotateEntity(n.Collider,0.0,Rnd(360.0),0.0,True)
					}
					FinishWalking(n,488,522,n.Speed*26)
					n.Angle = CurveAngle(EntityYaw(n.Collider,True),n.Angle,20.0)
					RotateEntity(n.obj,-90.0,n.Angle,0.0,True)
				} else {
					if (n.PathStatus=2) {
						n.PathTimer=n.PathTimer-(FPSfactor*2.0) //timer goes down fast
						n.CurrSpeed = 0.0
						if (Rand(1,35)=1) {
							RotateEntity(n.Collider,0.0,Rnd(360.0),0.0,True)
						}
						FinishWalking(n,488,522,n.Speed*26)
						n.Angle = CurveAngle(EntityYaw(n.Collider,True),n.Angle,20.0)
						RotateEntity(n.obj,-90.0,n.Angle,0.0,True)
					} else if (n.PathStatus=1) {
						if (n.Path[n.PathLocation]=Null) {
							if (n.PathLocation > 19) {
								n.PathLocation = 0
								n.PathStatus = 0
							} else {
								n.PathLocation = n.PathLocation + 1
							}
						} else {
							prevDist = EntityDistance(n.Collider,n.Path[n.PathLocation].obj)
							
							PointEntity(n.Collider,n.Path[n.PathLocation].obj)
							RotateEntity(n.Collider,0.0,EntityYaw(n.Collider,True),0.0,True)
							
							n.Angle = CurveAngle(EntityYaw(n.Collider,True),n.Angle,20.0)
							
							RotateEntity(n.obj,-90.0,n.Angle,0.0,True)
							
							n.CurrSpeed = CurveValue(n.Speed,n.CurrSpeed,20.0)
							
							TranslateEntity(n.Collider, Cos(EntityYaw(n.Collider,True)+90.0)*n.CurrSpeed * FPSfactor, 0, Sin(EntityYaw(n.Collider,True)+90.0)*n.CurrSpeed * FPSfactor, True)
							AnimateNPC(n,488, 522, n.CurrSpeed*26)
							
							newDist = EntityDistance(n.Collider,n.Path[n.PathLocation].obj)
							
							if (newDist<1.0 && n.Path[n.PathLocation].door!=Null) {
								//open the door and make it automatically close after 5 seconds
								if (!n.Path[n.PathLocation].door.open) {
									let sound = 0
									if (n.Path[n.PathLocation].door.dir = 1) {sound = 0} else {sound=Rand(0, 2)}
									PlaySound2(OpenDoorSFX(n.Path[n.PathLocation].door.dir,sound),Camera,n.Path[n.PathLocation].door.obj)
									PlayMTFSound(MTFSFX(5),n)
								}
								n.Path[n.PathLocation].door.open = True
								if (n.Path[n.PathLocation].door.MTFClose) {
									n.Path[n.PathLocation].door.timerstate = 70.0*5.0
								}
							}
                            
							if ((newDist<0.2) || ((prevDist<newDist) && (prevDist<1.0))) {
								n.PathLocation=n.PathLocation+1
							}
						}
						n.PathTimer=n.PathTimer-FPSfactor //timer goes down slow
					} else if (n.PathX != 0.0) {
						pvt = CreatePivot()
						PositionEntity(pvt,n.PathX,0.5,n.PathZ)
						
						PointEntity(n.Collider,pvt)
						RotateEntity(n.Collider,0.0,EntityYaw(n.Collider,True),0.0,True)
						n.Angle = CurveAngle(EntityYaw(n.Collider,True),n.Angle,20.0)
						RotateEntity(n.obj,-90.0,n.Angle,0.0,True)
						
						n.CurrSpeed = CurveValue(n.Speed,n.CurrSpeed,20.0)
						TranslateEntity(n.Collider, Cos(EntityYaw(n.Collider,True)+90.0)*n.CurrSpeed * FPSfactor, 0, Sin(EntityYaw(n.Collider,True)+90.0)*n.CurrSpeed * FPSfactor, True)
						AnimateNPC(n,488, 522, n.CurrSpeed*26)
						
						if (Distance(EntityX(n.Collider),EntityZ(n.Collider),n.PathX,n.PathZ)<0.2) {
							n.PathX = 0.0
							n.PathZ = 0.0
							n.PathTimer = 70.0 * Rnd(6.0,10.0)
						}
						
						FreeEntity(pvt)
					} else {
						n.PathTimer=n.PathTimer-(FPSfactor*2.0) //timer goes down fast
						if (n.MTFLeader = Null) {
							if (Rand(1,35)=1) {
								RotateEntity(n.Collider,0.0,Rnd(360.0),0.0,True)
							}
							FinishWalking(n,488,522,n.Speed*26)
							n.CurrSpeed = 0.0
						} else if (EntityDistance(n.Collider,n.MTFLeader.Collider)>1.0) {
							PointEntity(n.Collider,n.MTFLeader.Collider)
							RotateEntity(n.Collider,0.0,EntityYaw(n.Collider,True),0.0,True)
							
							n.CurrSpeed = CurveValue(n.Speed,n.CurrSpeed,20.0)
							TranslateEntity(n.Collider, Cos(EntityYaw(n.Collider,True)+90.0)*n.CurrSpeed * FPSfactor, 0, Sin(EntityYaw(n.Collider,True)+90.0)*n.CurrSpeed * FPSfactor, True)
							AnimateNPC(n,488, 522, n.CurrSpeed*26)
						} else {
							if (Rand(1,35)=1) {
								RotateEntity(n.Collider,0.0,Rnd(360.0),0.0,True)
							}
							FinishWalking(n,488,522,n.Speed*26)
							n.CurrSpeed = 0.0
						}
						n.Angle = CurveAngle(EntityYaw(n.Collider,True),n.Angle,20.0)
						RotateEntity(n.obj,-90.0,n.Angle,0.0,True)
					}
                }
                
				let temp = MeNPCSeesPlayer(n)
				
				if (NoTarget) {temp = False}
				
                if (temp) {
					if (n.LastSeen > 0 && n.LastSeen < 70*15) {
						if (temp < 2) {
							if (n.Sound != 0) {
								FreeSound_Strict(n.Sound)
								n.Sound = 0
							}
							n.Sound = LoadSound_Strict("SFX/Character/MTF/ThereHeIs"+Rand(1,6)+".ogg")
							PlayMTFSound(n.Sound, n)
						}
					} else {
						if (temp) {
							if (n.Sound != 0) {
								FreeSound_Strict(n.Sound)
								n.Sound = 0
							}
							n.Sound = LoadSound_Strict("SFX/Character/MTF/Stop"+Rand(1,6)+".ogg")
							PlayMTFSound(n.Sound, n)
					 	} else if (temp == 2) {
							PlayMTFSound(MTFSFX(Rand(0,3)),n)
						}
					}
					
					n.LastSeen = (70*Rnd(30,40))
					n.LastDist = 1
					
					n.State = 1
					n.EnemyX = EntityX(Collider,True)
					n.EnemyY = EntityY(Collider,True)
					n.EnemyZ = EntityZ(Collider,True)
					n.State2 = 70.0*(15.0*temp) //give up after 15 seconds (30 seconds if detected by loud noise, over camera: 45)
					DebugLog("player spotted :"+n.State2)
					n.PathTimer=0.0
					n.PathStatus=0
					n.Reload = 200-(100*SelectedDifficulty.aggressiveNPCs)
				}
				
				//B3D doesn't do short-circuit evaluation, so this retarded nesting is an optimization
                if (Curr173.Idle<2) {
					let SoundVol173: float = Max(Min((Distance(EntityX(Curr173.Collider), EntityZ(Curr173.Collider), Curr173.PrevX, Curr173.PrevZ) * 2.5), 1.0), 0.0)
					if (OtherNPCSeesMeNPC(Curr173,n) || (SoundVol173>0.0 && EntityDistance(n.Collider,Curr173.Collider)<6.0)) {
						if (EntityVisible(n.Collider,Curr173.Collider) || SoundVol173>0.0) {
							n.State = 2
							n.EnemyX = EntityX(Curr173.Collider,True)
							n.EnemyY = EntityY(Curr173.Collider,True)
							n.EnemyZ = EntityZ(Curr173.Collider,True)
							n.State2 = 70.0*15.0 //give up after 15 seconds
							n.State3 = 0.0
							n.PathTimer=0.0
							n.PathStatus=0
							DebugLog("173 spotted :"+n.State2)
							if (n.Sound != 0) {
								FreeSound_Strict(n.Sound)
								n.Sound = 0
							}
							n.Sound = LoadSound_Strict("SFX/Character/MTF/173/Spotted"+Rand(1,2)+".ogg")
							PlayMTFSound(n.Sound, n)
						}
					}
				}
				
				if (Curr106.State <= 0) {
					if (OtherNPCSeesMeNPC(Curr106,n) || EntityDistance(n.Collider,Curr106.Collider)<3.0) {
						if (EntityVisible(n.Collider,Curr106.Collider)) {
							n.State = 4
							n.EnemyX = EntityX(Curr106.Collider,True)
							n.EnemyY = EntityY(Curr106.Collider,True)
							n.EnemyZ = EntityZ(Curr106.Collider,True)
							n.State2 = 70*15.0
							n.State3 = 0.0
							n.PathTimer = 0.0
							n.PathStatus = 0
							n.Target = Curr106
							DebugLog("106 spotted :"+n.State2)
							if (n.Sound != 0) {
								FreeSound_Strict(n.Sound)
								n.Sound = 0
							}
							n.Sound = LoadSound_Strict("SFX/Character/MTF/106/Spotted"+Rand(1,3)+".ogg")
							PlayMTFSound(n.Sound, n)
						}
					}
				}
				
				if (Curr096 != Null) {
					if (OtherNPCSeesMeNPC(Curr096,n)) {
						if (EntityVisible(n.Collider,Curr096.Collider)) {
							n.State = 8
							n.EnemyX = EntityX(Curr096.Collider,True)
							n.EnemyY = EntityY(Curr096.Collider,True)
							n.EnemyZ = EntityZ(Curr096.Collider,True)
							n.State2 = 70*15.0
							n.State3 = 0.0
							n.PathTimer = 0.0
							n.PathStatus = 0
							DebugLog("096 spotted :"+n.State2)
							if (n.Sound != 0) {
								FreeSound_Strict(n.Sound)
								n.Sound = 0
							}
							n.Sound = LoadSound_Strict("SFX/Character/MTF/096/Spotted"+Rand(1,2)+".ogg")
							PlayMTFSound(n.Sound, n)
						}
					}
				}
				
				for (n2 of NPCs.each) {
					if (n2.NPCtype = NPCtype049) {
						if (OtherNPCSeesMeNPC(n2,n)) {
							if (EntityVisible(n.Collider,n2.Collider)) {
								n.State = 4
								n.EnemyX = EntityX(n2.Collider,True)
								n.EnemyY = EntityY(n2.Collider,True)
								n.EnemyZ = EntityZ(n2.Collider,True)
								n.State2 = 70*15.0
								n.State3 = 0.0
								n.PathTimer = 0.0
								n.PathStatus = 0
								n.Target = n2
								DebugLog("049 spotted :"+n.State2)
								if (n.Sound != 0) {
									FreeSound_Strict(n.Sound)
									n.Sound = 0
								}
								n.Sound = LoadSound_Strict("SFX/Character/MTF/049/Spotted"+Rand(1,5)+".ogg")
								PlayMTFSound(n.Sound, n)
								break
							}
						}
					} else if (n2.NPCtype == NPCtypeZombie && !n2.IsDead) {
						if (OtherNPCSeesMeNPC(n2,n)) {
							if (EntityVisible(n.Collider,n2.Collider)) {
								n.State = 9
								n.EnemyX = EntityX(n2.Collider,True)
								n.EnemyY = EntityY(n2.Collider,True)
								n.EnemyZ = EntityZ(n2.Collider,True)
								n.State2 = 70*15.0
								n.State3 = 0.0
								n.PathTimer = 0.0
								n.PathStatus = 0
								n.Target = n2
								n.Reload = 70*5
								DebugLog("049-2 spotted :"+n.State2)
								if (n.Sound != 0) {
									FreeSound_Strict(n.Sound)
									n.Sound = 0
								}
								n.Sound = LoadSound_Strict("SFX/Character/MTF/049/Player0492_1.ogg")
								PlayMTFSound(n.Sound, n)
								break
							}
						}
					} else if (n2.NPCtype = NPCtype008 && !n2.IsDead) {
						if (OtherNPCSeesMeNPC(n2,n)) {
							if (EntityVisible(n.Collider,n2.Collider)) {
								n.State = 9
								n.EnemyX = EntityX(n2.Collider,True)
								n.EnemyY = EntityY(n2.Collider,True)
								n.EnemyZ = EntityZ(n2.Collider,True)
								n.State2 = 70*15.0
								n.State3 = 0.0
								n.PathTimer = 0.0
								n.PathStatus = 0
								n.Target = n2
								n.Reload = 70*5
								DebugLog("008 spotted :"+n.State2)
								break
							}
						}
					}
				}
                
			case 1: //searching for player
                
                n.Speed = 0.015
                n.State2=n.State2-FPSfactor
                if (MeNPCSeesPlayer(n)) {
					
					//if close enough, start shooting at the player
					if (playerDist < 4.0) {
						
						let angle: float = VectorYaw(EntityX(Collider)-EntityX(n.Collider),0,EntityZ(Collider)-EntityZ(n.Collider))
						
						RotateEntity(n.Collider, 0, CurveAngle(angle, EntityYaw(n.Collider), 10.0), 0, True)
						n.Angle = EntityYaw(n.Collider)
						
						if (n.Reload <= 0 && KillTimer == 0) {
							if (EntityVisible(n.Collider, Camera)) {
								angle = WrapAngle(angle - EntityYaw(n.Collider))
								if (angle < 5 || angle > 355) {
									prev = KillTimer
									
									PlaySound2(GunshotSFX, Camera, n.Collider, 15)
									
									pvt = CreatePivot()
									
									RotateEntity(pvt, EntityPitch(n.Collider), EntityYaw(n.Collider), 0, True)
									PositionEntity(pvt, EntityX(n.obj), EntityY(n.obj), EntityZ(n.obj))
									MoveEntity (pvt,0.8*0.079, 10.75*0.079, 6.9*0.079)
									
									Shoot(EntityX(pvt),EntityY(pvt),EntityZ(pvt),5.0/playerDist, False)
									n.Reload = 7
									
									FreeEntity(pvt)
									
									DeathMSG="Subject D-9341. Died of blood loss after being shot by Nine-Tailed Fox."
									
									//player killed -> "target terminated"
									if (prev >= 0 && KillTimer < 0) {
										DeathMSG="Subject D-9341. Terminated by Nine-Tailed Fox."
										PlayMTFSound(LoadTempSound("SFX/Character/MTF/Targetterminated"+Rand(1,4)+".ogg"),n)
									}
								}	
							}
						}
						
						for (n2 of NPCs.each) {
							if (n2.NPCtype == NPCtypeMTF && n2 != n) {
								if (n2.State == 0) {
									if (EntityDistance(n.Collider,n2.Collider)<6.0) {
										n.PrevState = 1
										n2.LastSeen = (70*Rnd(30,40))
										n2.LastDist = 1
										
										n2.State = 1
										n2.EnemyX = EntityX(Collider,True)
										n2.EnemyY = EntityY(Collider,True)
										n2.EnemyZ = EntityZ(Collider,True)
										n2.State2 = n.State2
										n2.PathTimer=0.0
										n2.PathStatus=0
										n2.Reload = 200-(100*SelectedDifficulty.aggressiveNPCs)
										n2.PrevState = 0
									}
								}
							}
						}
						
						if (n.PrevState = 1) {
							SetNPCFrame(n,423)
							n.PrevState = 2
						} else if (n.PrevState=2) {
							if (n.Frame>200) {
								n.CurrSpeed = CurveValue(0, n.CurrSpeed, 20.0)
								AnimateNPC(n, 423, 463, 0.4, False)
								if (n.Frame>462.9) {n.Frame = 78}
							} else {
								AnimateNPC(n, 78, 193, 0.2, False)
								n.CurrSpeed = CurveValue(0, n.CurrSpeed, 20.0)
							}
						} else {
							if (n.Frame>958) {
								AnimateNPC(n, 1374, 1383, 0.3, False)
								n.CurrSpeed = CurveValue(0, n.CurrSpeed, 20.0)
								if (n.Frame>1382.9) { n.Frame = 78}
							} else {
								AnimateNPC(n, 78, 193, 0.2, False)
								n.CurrSpeed = CurveValue(0, n.CurrSpeed, 20.0)
							}
						}
					} else {
						PositionEntity(n.obj,n.EnemyX,n.EnemyY,n.EnemyZ,True)
						PointEntity(n.Collider,n.obj)
						RotateEntity(n.Collider,0.0,EntityYaw(n.Collider,True),0.0,True)
						n.Angle = CurveAngle(EntityYaw(n.Collider,True),n.Angle,20.0)
						RotateEntity(n.obj,-90.0,n.Angle,0.0,True)
						
						n.CurrSpeed = CurveValue(n.Speed,n.CurrSpeed,20.0)
						TranslateEntity(n.Collider, Cos(EntityYaw(n.Collider,True)+90.0)*n.CurrSpeed * FPSfactor, 0, Sin(EntityYaw(n.Collider,True)+90.0)*n.CurrSpeed * FPSfactor, True)
						AnimateNPC(n,488, 522, n.CurrSpeed*26)
					}
				} else {
					n.LastSeen = n.LastSeen - FPSfactor
					
					if (n.Reload <= 7) {
						n.Reload = 7
					}
					
					if (n.PathTimer<=0.0) { //update path
						n.PathStatus = FindPath(n,n.EnemyX,n.EnemyY+0.1,n.EnemyZ)
						n.PathTimer = 70.0 * Rnd(6.0,10.0) //search again after 6 seconds
					} else if (n.PathTimer<=70.0 * 2.5) {
						n.PathTimer=n.PathTimer-FPSfactor
						n.CurrSpeed = 0.0
						if (Rand(1,35)=1) {
							RotateEntity(n.Collider,0.0,Rnd(360.0),0.0,True)
						}
						FinishWalking(n,488,522,n.Speed*26)
						n.Angle = CurveAngle(EntityYaw(n.Collider,True),n.Angle,20.0)
						RotateEntity(n.obj,-90.0,n.Angle,0.0,True)
					} else {
						if (n.PathStatus=2) {
							n.PathTimer=n.PathTimer-(FPSfactor*2.0) //timer goes down fast
							n.CurrSpeed = 0.0
							if (Rand(1,35)=1) {
								RotateEntity(n.Collider,0.0,Rnd(360.0),0.0,True)
							}
							FinishWalking(n,488,522,n.Speed*26)
							n.Angle = CurveAngle(EntityYaw(n.Collider,True),n.Angle,20.0)
							RotateEntity(n.obj,-90.0,n.Angle,0.0,True)
						} else if (n.PathStatus=1) {
							if (n.Path[n.PathLocation]=Null) {
								if (n.PathLocation > 19) {
									n.PathLocation = 0
									n.PathStatus = 0
								} else {
									n.PathLocation = n.PathLocation + 1
								}
							} else {
								prevDist = EntityDistance(n.Collider,n.Path[n.PathLocation].obj)
								
								PointEntity(n.Collider,n.Path[n.PathLocation].obj)
								RotateEntity(n.Collider,0.0,EntityYaw(n.Collider,True),0.0,True)
								n.Angle = CurveAngle(EntityYaw(n.Collider,True),n.Angle,20.0)
								RotateEntity(n.obj,-90.0,n.Angle,0.0,True)
								
								n.CurrSpeed = CurveValue(n.Speed,n.CurrSpeed,20.0)
								
								TranslateEntity(n.Collider, Cos(EntityYaw(n.Collider,True)+90.0)*n.CurrSpeed * FPSfactor, 0, Sin(EntityYaw(n.Collider,True)+90.0)*n.CurrSpeed * FPSfactor, True)
								AnimateNPC(n,488, 522, n.CurrSpeed*26)
								
								newDist = EntityDistance(n.Collider,n.Path[n.PathLocation].obj)
								
								if (newDist<1.0 && n.Path[n.PathLocation].door!=Null) {
									//open the door and make it automatically close after 5 seconds
									if (!n.Path[n.PathLocation].door.open) {
										sound = 0
										if (n.Path[n.PathLocation].door.dir = 1) {sound = 0} else {sound=Rand(0, 2)}
										PlaySound2(OpenDoorSFX(n.Path[n.PathLocation].door.dir,sound),Camera,n.Path[n.PathLocation].door.obj)
										PlayMTFSound(MTFSFX(5),n)
									}
									n.Path[n.PathLocation].door.open = True
									if (n.Path[n.PathLocation].door.MTFClose) {
										n.Path[n.PathLocation].door.timerstate = 70.0*5.0
									}
								}
								
								if ((newDist<0.2) || ((prevDist<newDist) && (prevDist<1.0))) {
									n.PathLocation=n.PathLocation+1
								}
							}
							n.PathTimer=n.PathTimer-FPSfactor //timer goes down slow
						} else {
							PositionEntity(n.obj,n.EnemyX,n.EnemyY,n.EnemyZ,True)
							if ((Distance(EntityX(n.Collider,True),EntityZ(n.Collider,True),n.EnemyX,n.EnemyZ)<0.2) || (!EntityVisible(n.obj,n.Collider))) {
								if (Rand(1,35)=1) {
									RotateEntity(n.Collider,0.0,Rnd(360.0),0.0,True)
								}
								FinishWalking(n,488,522,n.Speed*26)
								if (Rand(1,35)=1) {
									for (wp of WayPoints.each) {
										if ((Rand(1,3)=1)) {
											if ((EntityDistance(wp.obj,n.Collider)<6.0)) {
												n.EnemyX = EntityX(wp.obj,True)
												n.EnemyY = EntityY(wp.obj,True)
												n.EnemyZ = EntityZ(wp.obj,True)
												n.PathTimer = 0.0
												break
											}											
										}
									}
								}
								n.PathTimer=n.PathTimer-FPSfactor //timer goes down slow
							} else {
								PointEntity(n.Collider,n.obj)
								RotateEntity(n.Collider,0.0,EntityYaw(n.Collider,True),0.0,True)
								n.Angle = CurveAngle(EntityYaw(n.Collider,True),n.Angle,20.0)
								RotateEntity(n.obj,-90.0,n.Angle,0.0,True)
								
								n.CurrSpeed = CurveValue(n.Speed,n.CurrSpeed,20.0)
								TranslateEntity(n.Collider, Cos(EntityYaw(n.Collider,True)+90.0)*n.CurrSpeed * FPSfactor, 0, Sin(EntityYaw(n.Collider,True)+90.0)*n.CurrSpeed * FPSfactor, True)
								AnimateNPC(n,488, 522, n.CurrSpeed*26)
							}
						}
					}
					
					if (n.MTFLeader=Null && n.LastSeen<70*30 && n.LastSeen+FPSfactor>=70*30) {
						if (Rand(2)=1) {
							PlayMTFSound(LoadTempSound("SFX/Character/MTF/Searching"+Rand(1,6)+".ogg"),n)
						}
					}
                }
                
                if (n.State2<=0.0 && n.State2+FPSfactor >0.0) {
					if (n.MTFLeader = Null) {
						DebugLog("targetlost: "+n.State2)
						PlayMTFSound(LoadTempSound("SFX/Character/MTF/Targetlost"+Rand(1,3)+".ogg"),n)
						if (MTF_CameraCheckTimer=0.0) {
							if (Rand(15-(7*SelectedDifficulty.aggressiveNPCs))=1) { //Maybe change this to another chance - ENDSHN
								PlayAnnouncement("SFX/Character/MTF/AnnouncCameraCheck.ogg")
								MTF_CameraCheckTimer = FPSfactor
							}
						}
					}
					n.State = 0
                }
                
				//B3D doesn't do short-circuit evaluation, so this retarded nesting is an optimization
                if (Curr173.Idle<2) {
					SoundVol173 = Max(Min((Distance(EntityX(Curr173.Collider), EntityZ(Curr173.Collider), Curr173.PrevX, Curr173.PrevZ) * 2.5), 1.0), 0.0)
					if (OtherNPCSeesMeNPC(Curr173,n) || (SoundVol173 > 0.0 && EntityDistance(n.Collider,Curr173.Collider)<6.0)) {
						if (EntityVisible(n.Collider,Curr173.Collider) || SoundVol173 > 0.0) {
							n.State = 2
							n.EnemyX = EntityX(Curr173.Collider,True)
							n.EnemyY = EntityY(Curr173.Collider,True)
							n.EnemyZ = EntityZ(Curr173.Collider,True)
							n.State2 = 70.0*15.0 //give up after 15 seconds
							DebugLog("173 spotted :"+n.State2)
							if (n.Sound != 0) {
								FreeSound_Strict(n.Sound)
								n.Sound = 0
							}
							n.Sound = LoadSound_Strict("SFX/Character/MTF/173/Spotted3.ogg")
							PlayMTFSound(n.Sound, n)
							n.State3 = 0.0
							n.PathTimer=0.0
							n.PathStatus=0
						}
					}
				}
				
				if (Curr106.State <= 0) {
					if (OtherNPCSeesMeNPC(Curr106,n) || EntityDistance(n.Collider,Curr106.Collider)<3.0) {
						if (EntityVisible(n.Collider,Curr106.Collider)) {
							n.State = 4
							n.EnemyX = EntityX(Curr106.Collider,True)
							n.EnemyY = EntityY(Curr106.Collider,True)
							n.EnemyZ = EntityZ(Curr106.Collider,True)
							n.State2 = 70*15.0
							n.State3 = 0.0
							n.PathTimer = 0.0
							n.PathStatus = 0
							n.Target = Curr106
							DebugLog("106 spotted :"+n.State2)
							if (n.MTFLeader=Null) {
								if (n.Sound != 0) {
									FreeSound_Strict(n.Sound)
									n.Sound = 0
								}
								n.Sound = LoadSound_Strict("SFX/Character/MTF/106/Spotted4.ogg")
								PlayMTFSound(n.Sound, n)
							}
						}
					}
				}
				
				if (Curr096 != Null) {
					if (OtherNPCSeesMeNPC(Curr096,n)) {
						if (EntityVisible(n.Collider,Curr096.Collider)) {
							n.State = 8
							n.EnemyX = EntityX(Curr096.Collider,True)
							n.EnemyY = EntityY(Curr096.Collider,True)
							n.EnemyZ = EntityZ(Curr096.Collider,True)
							n.State2 = 70*15.0
							n.State3 = 0.0
							n.PathTimer = 0.0
							n.PathStatus = 0
							DebugLog("096 spotted :"+n.State2)
							if (n.MTFLeader=Null) {
								if (n.Sound != 0) {
									FreeSound_Strict(n.Sound)
									n.Sound = 0
								}
								n.Sound = LoadSound_Strict("SFX/Character/MTF/096/Spotted"+Rand(1,2)+".ogg")
								PlayMTFSound(n.Sound, n)
							}
						}
					}
				}
				
				for (n2 of NPCs.each) {
					if (n2.NPCtype = NPCtype049) {
						if (OtherNPCSeesMeNPC(n2,n)) {
							if (EntityVisible(n.Collider,n2.Collider)) {
								n.State = 4
								n.EnemyX = EntityX(n2.Collider,True)
								n.EnemyY = EntityY(n2.Collider,True)
								n.EnemyZ = EntityZ(n2.Collider,True)
								n.State2 = 70*15.0
								n.State3 = 0.0
								n.PathTimer = 0.0
								n.PathStatus = 0
								n.Target = n2
								DebugLog("049 spotted :"+n.State2)
								if (n.Sound != 0) {
									FreeSound_Strict(n.Sound)
									n.Sound = 0
								}
								n.Sound = LoadSound_Strict("SFX/Character/MTF/049/Spotted"+Rand(1,5)+".ogg")
								PlayMTFSound(n.Sound, n)
								break
							}
						}
					} else if (n2.NPCtype = NPCtypeZombie && !n2.IsDead) {
						if (OtherNPCSeesMeNPC(n2,n)) {
							if (EntityVisible(n.Collider,n2.Collider)) {
								n.State = 9
								n.EnemyX = EntityX(n2.Collider,True)
								n.EnemyY = EntityY(n2.Collider,True)
								n.EnemyZ = EntityZ(n2.Collider,True)
								n.State2 = 70*15.0
								n.State3 = 0.0
								n.PathTimer = 0.0
								n.PathStatus = 0
								n.Target = n2
								n.Reload = 70*5
								DebugLog("049-2 spotted :"+n.State2)
								
								if (n.Sound != 0) {
									FreeSound_Strict(n.Sound)
									n.Sound = 0
								}
								n.Sound = LoadSound_Strict("SFX/Character/MTF/049/Player0492_1.ogg")
								PlayMTFSound(n.Sound, n)
								
								break
							}
						}
					}
				}
				
			case 2: //searching for/looking at 173
                
                if (Curr173.Idle = 2) {
					n.State = 0
				} else {
					for (n2 of NPCs.each) {
						if (n2!=n) {
							if (n2.NPCtype = NPCtypeMTF) {
								n2.State = 2
							}
						}
					}
					
					let curr173Dist: float = Distance(EntityX(n.Collider,True),EntityZ(n.Collider,True),EntityX(Curr173.Collider,True),EntityZ(Curr173.Collider,True))
					
					if (curr173Dist<5.0) {
						if (Curr173.Idle != 2) {Curr173.Idle = True}
						n.State2 = 70.0*15.0
						n.PathTimer = 0.0
						let tempDist: float = 1.0
						if (n.MTFLeader!=Null) {tempDist = 2.0}
						if (curr173Dist<tempDist) {
							if (n.MTFLeader = Null) {
								n.State3=n.State3+FPSfactor
								DebugLog("CONTAINING 173: "+n.State3)
								if (n.State3>=70.0*15.0) {
									Curr173.Idle = 2
									if (n.MTFLeader = Null) {Curr173.Target = n}
									if (n.Sound != 0) {
										FreeSound_Strict(n.Sound)
										n.Sound = 0
									}
									n.Sound = LoadSound_Strict("SFX/Character/MTF/173/Box"+Rand(1,3)+".ogg")
									PlayMTFSound(n.Sound, n)
								}
							}
							PositionEntity(n.obj,EntityX(Curr173.Collider,True),EntityY(Curr173.Collider,True),EntityZ(Curr173.Collider,True),True)
							PointEntity(n.Collider,n.obj)
							RotateEntity(n.Collider,0.0,EntityYaw(n.Collider,True),0.0,True)
							n.Angle = CurveAngle(EntityYaw(n.Collider,True),n.Angle,20.0)
							FinishWalking(n,488,522,n.Speed*26)
							RotateEntity(n.obj,-90.0,n.Angle,0.0,True)
						} else {
							PositionEntity(n.obj,EntityX(Curr173.Collider,True),EntityY(Curr173.Collider,True),EntityZ(Curr173.Collider,True),True)
							PointEntity(n.Collider,n.obj)
							RotateEntity(n.Collider,0.0,EntityYaw(n.Collider,True),0.0,True)
							n.Angle = CurveAngle(EntityYaw(n.Collider,True),n.Angle,20.0)
							RotateEntity(n.obj,-90.0,n.Angle,0.0,True)
							
							n.CurrSpeed = CurveValue(n.Speed,n.CurrSpeed,20.0)
							TranslateEntity(n.Collider, Cos(EntityYaw(n.Collider,True)+90.0)*n.CurrSpeed * FPSfactor, 0, Sin(EntityYaw(n.Collider,True)+90.0)*n.CurrSpeed * FPSfactor, True)
							AnimateNPC(n,488, 522, n.CurrSpeed*26)
						}
					} else {
						if (Curr173.Idle != 2) {Curr173.Idle = False}
						if (n.PathTimer<=0.0) { //update path
							n.PathStatus = FindPath(n,EntityX(Curr173.Collider,True),EntityY(Curr173.Collider,True)+0.1,EntityZ(Curr173.Collider,True))
							n.PathTimer = 70.0 * Rnd(6.0,10.0) //search again after 6 seconds
						} else if (n.PathTimer<=70.0 * 2.5) {
							n.PathTimer=n.PathTimer-FPSfactor
							n.CurrSpeed = 0.0
							if (Rand(1,35)=1) {
								RotateEntity(n.Collider,0.0,Rnd(360.0),0.0,True)
							}
							FinishWalking(n,488,522,n.Speed*26)
							n.Angle = CurveAngle(EntityYaw(n.Collider,True),n.Angle,20.0)
							RotateEntity(n.obj,-90.0,n.Angle,0.0,True)
						} else {
							if (n.PathStatus=2) {
								n.PathTimer=n.PathTimer-(FPSfactor*2.0) //timer goes down fast
								n.CurrSpeed = 0.0
								if (Rand(1,35)=1) {
									RotateEntity(n.Collider,0.0,Rnd(360.0),0.0,True)
								}
								FinishWalking(n,488,522,n.Speed*26)
								n.Angle = CurveAngle(EntityYaw(n.Collider,True),n.Angle,20.0)
								RotateEntity(n.obj,-90.0,n.Angle,0.0,True)
							} else if (n.PathStatus=1) {
								if (n.Path[n.PathLocation]=Null) {
									if (n.PathLocation > 19) {
										n.PathLocation = 0
										n.PathStatus = 0
									} else {
										n.PathLocation = n.PathLocation + 1
									}
								} else {
									prevDist = EntityDistance(n.Collider,n.Path[n.PathLocation].obj)
									
									PointEntity(n.Collider,n.Path[n.PathLocation].obj)
									RotateEntity(n.Collider,0.0,EntityYaw(n.Collider,True),0.0,True)
									n.Angle = CurveAngle(EntityYaw(n.Collider,True),n.Angle,20.0)
									RotateEntity(n.obj,-90.0,n.Angle,0.0,True)
									
									n.CurrSpeed = CurveValue(n.Speed,n.CurrSpeed,20.0)
									
									TranslateEntity(n.Collider, Cos(EntityYaw(n.Collider,True)+90.0)*n.CurrSpeed * FPSfactor, 0, Sin(EntityYaw(n.Collider,True)+90.0)*n.CurrSpeed * FPSfactor, True)
									AnimateNPC(n,488, 522, n.CurrSpeed*26)
									
									newDist = EntityDistance(n.Collider,n.Path[n.PathLocation].obj)
									
									if (newDist<1.0 && n.Path[n.PathLocation].door!=Null) {
										//open the door and make it automatically close after 5 seconds
										if (!n.Path[n.PathLocation].door.open) {
											sound = 0
											if (n.Path[n.PathLocation].door.dir = 1) {sound = 0} else {sound=Rand(0, 2)}
											PlaySound2(OpenDoorSFX(n.Path[n.PathLocation].door.dir,sound),Camera,n.Path[n.PathLocation].door.obj)
											PlayMTFSound(MTFSFX(5),n)
										}
										n.Path[n.PathLocation].door.open = True
										if (n.Path[n.PathLocation].door.MTFClose) {
											n.Path[n.PathLocation].door.timerstate = 70.0*5.0
										}
									}
									
									if ((newDist<0.2) || ((prevDist<newDist) && (prevDist<1.0))) {
										n.PathLocation=n.PathLocation+1
									}
								}
								n.PathTimer=n.PathTimer-FPSfactor //timer goes down slow
							} else {
								n.PathTimer=n.PathTimer-(FPSfactor*2.0) //timer goes down fast
								n.CurrSpeed = 0.0
								if (Rand(1,35)=1) {
									RotateEntity(n.Collider,0.0,Rnd(360.0),0.0,True)
								}
								FinishWalking(n,488,522,n.Speed*26)
								n.Angle = CurveAngle(EntityYaw(n.Collider,True),n.Angle,20.0)
								RotateEntity(n.obj,-90.0,n.Angle,0.0,True)
							}
						}
					}
                }
                
			case 3: //following a path
				//[Block]
				
				n.Angle = CurveValue(0,n.Angle,40.0)
				
				if (n.PathStatus = 2) {
					n.State = 5
					n.CurrSpeed = 0
				} else if (n.PathStatus = 1) {
					if (n.Path[n.PathLocation]=Null) {
						if (n.PathLocation > 19) {
							n.PathLocation = 0
							n.PathStatus = 0
							if (n.LastSeen > 0) {n.State = 5}
						} else {
							n.PathLocation = n.PathLocation + 1
						}
					} else {
						if (n.Path[n.PathLocation].door != Null) {
							if (n.Path[n.PathLocation].door.open = False) {
								n.Path[n.PathLocation].door.open = True
								n.Path[n.PathLocation].door.timerstate = 8.0*70.0
								PlayMTFSound(MTFSFX(5),n)
							}
						}
						
						if (dist < HideDistance*0.7) {
							dist2 = EntityDistance(n.Collider,n.Path[n.PathLocation].obj) 
														
							PointEntity(n.obj, n.Path[n.PathLocation].obj)
							
							RotateEntity(n.Collider, 0, CurveAngle(EntityYaw(n.obj), EntityYaw(n.Collider), 10.0), 0)
							if (n.Idle = 0) {
								n.CurrSpeed = CurveValue(n.Speed*Max(Min(dist2,1.0),0.1), n.CurrSpeed, 20.0)
								MoveEntity(n.Collider, 0, 0, n.CurrSpeed * FPSfactor)
								
								if (EntityDistance(n.Collider,n.Path[n.PathLocation].obj)<0.5) {
									n.PathLocation = n.PathLocation + 1
								}
							}
						} else {
							if (Rand(20)=1) {
								PositionEntity(n.Collider, EntityX(n.Path[n.PathLocation].obj,True),EntityY(n.Path[n.PathLocation].obj,True)+0.25,EntityZ(n.Path[n.PathLocation].obj,True),True)
								n.PathLocation = n.PathLocation + 1
								ResetEntity(n.Collider)
							}
						}
						
					}
				} else {
					n.CurrSpeed = 0
					n.State = 5
				}
				
				
				if (n.Idle == 0 && n.PathStatus == 1) {
					if (dist < HideDistance) {
						if (n.Frame>959) {
							AnimateNPC(n, 1376, 1383, 0.2, False)
							if (n.Frame >1382.9) {
								n.Frame = 488
							}
						} else {
							AnimateNPC(n, 488, 522, n.CurrSpeed*30)
						}
					}
				} else {
					if (dist < HideDistance) {
						if (n.LastSeen > 0) {
							AnimateNPC(n, 78, 312, 0.2, True)
						} else {
							if (n.Frame<962) {
								if (n.Frame>487) {
									n.Frame = 463
								}
								AnimateNPC(n, 463, 487, 0.3, False)
								if (n.Frame>486.9) {
									n.Frame = 962
								}
							} else {
								AnimateNPC(n, 962, 1259, 0.3)
							}
						}
					}
					
					n.CurrSpeed = CurveValue(0, n.CurrSpeed, 20.0)
				}
				
				n.Angle = EntityYaw(n.Collider)
				
			case 4: //SCP-106/049 detected
				//[Block]
				n.Speed = 0.03
                n.State2=n.State2-FPSfactor
				if (n.State2 > 0.0) {
					if (OtherNPCSeesMeNPC(n.Target,n)) {
						n.State2 = 70*15
					}
					
					if (EntityDistance(n.Target.Collider,n.Collider)>HideDistance) {
						if (n.State2 > 70) {
							n.State2 = 70
						}
					}
					
					if (EntityDistance(n.Target.Collider,n.Collider)<3.0 && n.State3 >= 0.0) {
						n.State3 = 70*5
					}
					
					if (n.State3 > 0.0) {
						n.PathStatus = 0
						n.PathLocation = 0
						n.Speed = 0.02
						PointEntity(n.Collider,n.Target.Collider)
						RotateEntity(n.Collider,0.0,EntityYaw(n.Collider,True),0.0,True)
						n.Angle = CurveAngle(EntityYaw(n.Collider,True),n.Angle,20.0)
						RotateEntity(n.obj,-90.0,n.Angle,0.0,True)
						n.CurrSpeed = CurveValue(-n.Speed,n.CurrSpeed,20.0)
						TranslateEntity(n.Collider, Cos(EntityYaw(n.Collider,True)+90.0)*n.CurrSpeed * FPSfactor, 0, Sin(EntityYaw(n.Collider,True)+90.0)*n.CurrSpeed * FPSfactor, True)
						AnimateNPC(n,522, 488, n.CurrSpeed*26)
						
						n.PathTimer = 1.0
						
						n.State3=Max(n.State3-FPSfactor,0)
						
						HideEntity(n.Collider)
						TurnEntity(n.Collider,0,180,0)
						EntityPick(n.Collider, 1.0)
						if (PickedEntity() != 0) {
							n.State3 = -70*2
						}
						ShowEntity(n.Collider)
						TurnEntity(n.Collider,0,180,0)
					} else if (n.State3 < 0.0) {
						n.State3 = Min(n.State3+FPSfactor,0)
					}
					
					if (n.PathTimer<=0.0) {
						if (n.MTFLeader!=Null) {
							n.PathStatus = FindPath(n,EntityX(n.MTFLeader.Collider,True),EntityY(n.MTFLeader.Collider,True)+0.1,EntityZ(n.MTFLeader.Collider,True))
						} else {
							for (r of Rooms.each) {
								if (((Abs(r.x-EntityX(n.Collider,True))>12.0) || (Abs(r.z-EntityZ(n.Collider,True))>12.0)) && (Rand(1,Max(4-Int(Abs(r.z-EntityZ(n.Collider,True)/8.0)),2)) == 1)) {
									if (EntityDistance(r.obj,n.Target.Collider)>6.0) {
										x = r.x
										y = 0.1
										z = r.z
										DebugLog(r.RoomTemplate.Name)
										break
									}
								}
							}
							n.PathStatus = FindPath(n,x,y,z)
						}
						if (n.PathStatus == 1) {
							while (n.Path[n.PathLocation]=Null) {
								if (n.PathLocation>19) {break}
								n.PathLocation=n.PathLocation+1
							}
							if (n.PathLocation<19) {
								if ((n.Path[n.PathLocation]!=Null) && (n.Path[n.PathLocation+1]!=Null)) {
									if ((n.Path[n.PathLocation].door == Null)) {
										if (Abs(DeltaYaw(n.Collider,n.Path[n.PathLocation].obj))>Abs(DeltaYaw(n.Collider,n.Path[n.PathLocation+1].obj))) {
											n.PathLocation=n.PathLocation+1
										}
									}
								}
							}
						}
						n.PathTimer = 70*10
					} else {
						if (n.PathStatus=1) {
							if (n.Path[n.PathLocation]=Null) {
								if (n.PathLocation > 19) {
									n.PathLocation = 0
									n.PathStatus = 0
								} else {
									n.PathLocation = n.PathLocation + 1
								}
							} else {
								prevDist = EntityDistance(n.Collider,n.Path[n.PathLocation].obj)
								
								PointEntity(n.Collider,n.Path[n.PathLocation].obj)
								RotateEntity(n.Collider,0.0,EntityYaw(n.Collider,True),0.0,True)
								n.Angle = CurveAngle(EntityYaw(n.Collider,True),n.Angle,20.0)
								RotateEntity(n.obj,-90.0,n.Angle,0.0,True)
								
								n.CurrSpeed = CurveValue(n.Speed,n.CurrSpeed,20.0)
								TranslateEntity(n.Collider, Cos(EntityYaw(n.Collider,True)+90.0)*n.CurrSpeed * FPSfactor, 0, Sin(EntityYaw(n.Collider,True)+90.0)*n.CurrSpeed * FPSfactor, True)
								AnimateNPC(n,488, 522, n.CurrSpeed*26) //Placeholder (until running animation has been implemented)
								
								newDist = EntityDistance(n.Collider,n.Path[n.PathLocation].obj)
								
								if (newDist<2.0 && n.Path[n.PathLocation].door!=Null) {
									if (!n.Path[n.PathLocation].door.open) {
										sound = 0
										if (n.Path[n.PathLocation].door.dir == 1) {
											sound = 0
										} else {
											sound=Rand(0, 2)
										}
										PlaySound2(OpenDoorSFX(n.Path[n.PathLocation].door.dir,sound),Camera,n.Path[n.PathLocation].door.obj)
										PlayMTFSound(MTFSFX(5),n)
									}
									n.Path[n.PathLocation].door.open = True
									if (n.Path[n.PathLocation].door.MTFClose) {
										n.Path[n.PathLocation].door.timerstate = 70.0*5.0
									}
								}
								
								if ((newDist<0.2) || ((prevDist<newDist) && (prevDist<1.0))) {
									n.PathLocation=n.PathLocation+1
								}
							}
							n.PathTimer=n.PathTimer-FPSfactor
						} else {
							n.PathTimer=0.0
						}
					}
				} else {
					n.State = 0
				}
				
			case 5: //looking at some other target than the player
				//[Block]
				target=CreatePivot()
				PositionEntity(target, n.EnemyX, n.EnemyY, n.EnemyZ, True)
				
				if (dist<HideDistance) {
					AnimateNPC(n, 346, 351, 0.2, False)
				}
				
				if (Abs(EntityX(target)-EntityX(n.Collider)) < 55.0 && Abs(EntityZ(target)-EntityZ(n.Collider)) < 55.0 && Abs(EntityY(target)-EntityY(n.Collider))< 20.0) {
					
					PointEntity(n.obj, target)
					RotateEntity(n.Collider, 0, CurveAngle(EntityYaw(n.obj),EntityYaw(n.Collider),30.0), 0, True)
					
					if (n.PathTimer == 0) {
						n.PathStatus = EntityVisible(n.Collider,target)
						n.PathTimer = Rand(100,200)
					} else {
						n.PathTimer = Min(n.PathTimer-FPSfactor,0.0)
					}
					
					if (n.PathStatus == 1 && n.Reload <= 0) {
						dist = Distance(EntityX(target),EntityZ(target),EntityX(n.Collider),EntityZ(n.Collider))
					}
				}		
				
				FreeEntity(target)
				
				n.Angle = EntityYaw(n.Collider)
				
			case 6: //seeing the player as a 049-2 instance
				//[Block]
				
				PointEntity(n.obj,Collider)
				RotateEntity(n.Collider,0,CurveAngle(EntityYaw(n.obj),EntityYaw(n.Collider),20.0),0)
				n.Angle = EntityYaw(n.Collider)
				
				AnimateNPC(n, 346, 351, 0.2, False)
				
				if (n.Reload <= 0 && KillTimer == 0) {
					if (EntityVisible(n.Collider, Collider)) {
						if (Abs(DeltaYaw(n.Collider,Collider))<50.0) {
							//prev% = KillTimer
							
							PlaySound2(GunshotSFX, Camera, n.Collider, 15)
							
							pvt = CreatePivot()
							
							RotateEntity(pvt, EntityPitch(n.Collider), EntityYaw(n.Collider), 0, True)
							PositionEntity(pvt, EntityX(n.obj), EntityY(n.obj), EntityZ(n.obj))
							MoveEntity (pvt,0.8*0.079, 10.75*0.079, 6.9*0.079)
							
							Shoot(EntityX(pvt),EntityY(pvt),EntityZ(pvt),0.9, False)
							n.Reload = 7
							
							FreeEntity(pvt)
						}	
					}
				}
				
				
			case 7: //just shooting
				//[Block]
				AnimateNPC(n, 346, 351, 0.2, False)
				
				RotateEntity(n.Collider,0,CurveAngle(n.State2,EntityYaw(n.Collider),20),0)
				n.Angle = EntityYaw(n.Collider)
				
				if (n.Reload <= 0) {
					LightVolume = TempLightVolume*1.2
					PlaySound2(GunshotSFX, Camera, n.Collider, 20)
					
					pvt = CreatePivot()
					
					RotateEntity(pvt, EntityPitch(n.Collider), EntityYaw(n.Collider), 0, True)
					PositionEntity(pvt, EntityX(n.obj), EntityY(n.obj), EntityZ(n.obj))
					MoveEntity (pvt,0.8*0.079, 10.75*0.079, 6.9*0.079)
					
					p.Particles = CreateParticle(EntityX(pvt), EntityY(pvt), EntityZ(pvt), 1, Rnd(0.08,0.1), 0.0, 5)
					TurnEntity(p.obj, 0,0,Rnd(360))
					p.Achange = -0.15
					
					FreeEntity(pvt)
					n.Reload = 7
				}
				
			case 8: //SCP-096 spotted
				//[Block]
				n.Speed = 0.015
				n.BoneToManipulate = "head"
				n.ManipulateBone = True
				n.ManipulationType = 2
                if (n.PathTimer<=0.0) { //update path
					if (n.MTFLeader!=Null) { //i'll follow the leader
						n.PathStatus = FindPath(n,EntityX(n.MTFLeader.Collider,True),EntityY(n.MTFLeader.Collider,True)+0.1,EntityZ(n.MTFLeader.Collider,True)) //whatever you say boss
					} else { //i am the leader
						for (r of Rooms.each) {
							if (((Abs(r.x-EntityX(n.Collider,True))>12.0) || (Abs(r.z-EntityZ(n.Collider,True))>12.0)) && (Rand(1,Max(4-Int(Abs(r.z-EntityZ(n.Collider,True)/8.0)),2)) == 1)) {
								x = r.x
								y = 0.1
								z = r.z
								DebugLog(r.RoomTemplate.Name)
								break
							}
						}
						n.PathStatus = FindPath(n,x,y,z) //we're going to this room for no particular reason
					}
					if (n.PathStatus == 1) {
						while (n.Path[n.PathLocation] == Null) {
							if (n.PathLocation>19) {break}
							n.PathLocation=n.PathLocation+1
						}
						if (n.PathLocation<19) {
							if ((n.Path[n.PathLocation]!=Null) && (n.Path[n.PathLocation+1]!=Null)) {
								if ((n.Path[n.PathLocation].door=Null)) {
									if (Abs(DeltaYaw(n.Collider,n.Path[n.PathLocation].obj))>Abs(DeltaYaw(n.Collider,n.Path[n.PathLocation+1].obj))) {
										n.PathLocation=n.PathLocation+1
									}
								}
							}
						}
					}
					n.PathTimer = 70.0 * Rnd(6.0,10.0) //search again after 6-10 seconds
				} else if ((n.PathTimer<=70.0 * 2.5) && (n.MTFLeader == Null)) {
					n.PathTimer=n.PathTimer-FPSfactor
					n.CurrSpeed = 0.0
					FinishWalking(n,488,522,n.Speed*26)
					n.Angle = CurveAngle(EntityYaw(n.Collider,True),n.Angle,20.0)
					RotateEntity(n.obj,-90.0,n.Angle,0.0,True)
				} else {
					if (n.PathStatus == 2) {
						n.PathTimer=n.PathTimer-(FPSfactor*2.0) //timer goes down fast
						n.CurrSpeed = 0.0
						FinishWalking(n,488,522,n.Speed*26)
						n.Angle = CurveAngle(EntityYaw(n.Collider,True),n.Angle,20.0)
						RotateEntity(n.obj,-90.0,n.Angle,0.0,True)
					} else if (n.PathStatus=1) {
						if (n.Path[n.PathLocation]=Null) {
							if (n.PathLocation > 19) {
								n.PathLocation = 0
								n.PathStatus = 0
							} else {
								n.PathLocation = n.PathLocation + 1
							}
						} else {
							prevDist = EntityDistance(n.Collider,n.Path[n.PathLocation].obj)
							
							PointEntity(n.Collider,n.Path[n.PathLocation].obj)
							RotateEntity(n.Collider,0.0,EntityYaw(n.Collider,True),0.0,True)
							n.Angle = CurveAngle(EntityYaw(n.Collider,True),n.Angle,20.0)
							RotateEntity(n.obj,-90.0,n.Angle,0.0,True)
							
							n.CurrSpeed = CurveValue(n.Speed,n.CurrSpeed,20.0)
							TranslateEntity(n.Collider, Cos(EntityYaw(n.Collider,True)+90.0)*n.CurrSpeed * FPSfactor, 0, Sin(EntityYaw(n.Collider,True)+90.0)*n.CurrSpeed * FPSfactor, True)
							AnimateNPC(n,488, 522, n.CurrSpeed*26)
							
							newDist = EntityDistance(n.Collider,n.Path[n.PathLocation].obj)
							
							if (newDist<1.0 && n.Path[n.PathLocation].door!=Null) {
								//open the door and make it automatically close after 5 seconds
								if (!n.Path[n.PathLocation].door.open) {
									sound = 0
									if (n.Path[n.PathLocation].door.dir = 1) {
										sound = 0
									} else {
										sound=Rand(0, 2)
									}
									PlaySound2(OpenDoorSFX(n.Path[n.PathLocation].door.dir,sound),Camera,n.Path[n.PathLocation].door.obj)
									PlayMTFSound(MTFSFX(5),n)
								}
								n.Path[n.PathLocation].door.open = True
								if (n.Path[n.PathLocation].door.MTFClose) {
									n.Path[n.PathLocation].door.timerstate = 70.0*5.0
								}
							}
                            
							if ((newDist<0.2) || ((prevDist<newDist) && (prevDist<1.0))) {
								n.PathLocation=n.PathLocation+1
							}
						}
						n.PathTimer=n.PathTimer-FPSfactor //timer goes down slow
					} else {
						n.PathTimer=n.PathTimer-(FPSfactor*2.0) //timer goes down fast
						if (n.MTFLeader == Null) {

							FinishWalking(n,488,522,n.Speed*26)
							n.CurrSpeed = 0.0
						} else if (EntityDistance(n.Collider,n.MTFLeader.Collider)>1.0) {
							PointEntity(n.Collider,n.MTFLeader.Collider)
							RotateEntity(n.Collider,0.0,EntityYaw(n.Collider,True),0.0,True)
							
							n.CurrSpeed = CurveValue(n.Speed,n.CurrSpeed,20.0)
							TranslateEntity(n.Collider, Cos(EntityYaw(n.Collider,True)+90.0)*n.CurrSpeed * FPSfactor, 0, Sin(EntityYaw(n.Collider,True)+90.0)*n.CurrSpeed * FPSfactor, True)
							AnimateNPC(n,488, 522, n.CurrSpeed*26)
						} else {
							FinishWalking(n,488,522,n.Speed*26)
							n.CurrSpeed = 0.0
						}
						n.Angle = CurveAngle(EntityYaw(n.Collider,True),n.Angle,20.0)
						RotateEntity(n.obj,-90.0,n.Angle,0.0,True)
					}
                }
				
				if ((!EntityVisible(n.Collider,Curr096.Collider)) || EntityDistance(n.Collider,Curr096.Collider)>6.0) {
					n.State = 0
				}
				
			case 9: //SCP-049-2/008 spotted
				//[Block]
				if (EntityVisible(n.Collider, n.Target.Collider)) {
					PointEntity(n.obj,n.Target.Collider)
					RotateEntity(n.Collider,0,CurveAngle(EntityYaw(n.obj),EntityYaw(n.Collider),20.0),0)
					n.Angle = EntityYaw(n.Collider)
					
					if (EntityDistance(n.Target.Collider,n.Collider)<1.3) {
						n.State3 = 70*2
					}
					
					if (n.State3 > 0.0) {
						n.PathStatus = 0
						n.PathLocation = 0
						n.Speed = 0.02
						n.CurrSpeed = CurveValue(-n.Speed,n.CurrSpeed,20.0)
						TranslateEntity(n.Collider, Cos(EntityYaw(n.Collider,True)+90.0)*n.CurrSpeed * FPSfactor, 0, Sin(EntityYaw(n.Collider,True)+90.0)*n.CurrSpeed * FPSfactor, True)
						AnimateNPC(n,522, 488, n.CurrSpeed*26)
						
						n.PathTimer = 1.0
						
						n.State3=Max(n.State3-FPSfactor,0)
					} else {
						n.State3 = 0
						AnimateNPC(n, 346, 351, 0.2, False)
					}
					if (n.Reload <= 0 && !n.Target.IsDead) {
						if (Abs(DeltaYaw(n.Collider,n.Target.Collider))<50.0) {
							
							PlaySound2(GunshotSFX, Camera, n.Collider, 15)
							
							pvt = CreatePivot()
							
							RotateEntity(pvt, EntityPitch(n.Collider), EntityYaw(n.Collider), 0, True)
							PositionEntity(pvt, EntityX(n.obj), EntityY(n.obj), EntityZ(n.obj))
							MoveEntity (pvt,0.8*0.079, 10.75*0.079, 6.9*0.079)
							
							p.Particles = CreateParticle(EntityX(pvt), EntityY(pvt), EntityZ(pvt), 1, Rnd(0.08,0.1), 0.0, 5)
							TurnEntity(p.obj, 0,0,Rnd(360))
							p.Achange = -0.15
							if (n.Target.HP > 0) {
								n.Target.HP = Max(n.Target.HP-Rand(5,10),0)
							} else {
								if (!n.Target.IsDead) {
									if (n.Sound != 0) {
										FreeSound_Strict(n.Sound)
										n.Sound = 0
									}
									if (n.NPCtype == NPCtypeZombie) {
										n.Sound = LoadSound_Strict("SFX/Character/MTF/049/Player0492_2.ogg")
										PlayMTFSound(n.Sound, n)
									} else {
										//Still needs to be added! (for 008)
									}
								}
								SetNPCFrame(n.Target,133)
								n.Target.IsDead = True
								n.Target = Null
								n.State = 0
								return
							}
							n.Reload = 7
							
							FreeEntity(pvt)
						}	
					}
					n.PathStatus = 0
				} else {
					if (n.PathTimer<=0.0) {
						n.PathStatus = FindPath(n,EntityX(n.Target.Collider),EntityY(n.Target.Collider),EntityZ(n.Target.Collider))
						if (n.PathStatus == 1) {
							while (n.Path[n.PathLocation] == Null) {
								if (n.PathLocation>19) {break}
								n.PathLocation=n.PathLocation+1
							}
							if (n.PathLocation<19) {
								if ((n.Path[n.PathLocation]!=Null) && (n.Path[n.PathLocation+1]!=Null)) {
									if ((n.Path[n.PathLocation].door == Null)) {
										if (Abs(DeltaYaw(n.Collider,n.Path[n.PathLocation].obj))>Abs(DeltaYaw(n.Collider,n.Path[n.PathLocation+1].obj))) {
											n.PathLocation=n.PathLocation+1
										}
									}
								}
							}
						}
						n.PathTimer = 70*10
					} else {
						if (n.PathStatus == 1) {
							if (n.Path[n.PathLocation] == Null) {
								if (n.PathLocation > 19) {
									n.PathLocation = 0
									n.PathStatus = 0
								} else {
									n.PathLocation = n.PathLocation + 1
								}
							} else {
								prevDist = EntityDistance(n.Collider,n.Path[n.PathLocation].obj)
								
								PointEntity(n.Collider,n.Path[n.PathLocation].obj)
								RotateEntity(n.Collider,0.0,EntityYaw(n.Collider,True),0.0,True)
								n.Angle = CurveAngle(EntityYaw(n.Collider,True),n.Angle,20.0)
								RotateEntity(n.obj,-90.0,n.Angle,0.0,True)
								
								n.CurrSpeed = CurveValue(n.Speed,n.CurrSpeed,20.0)
								TranslateEntity(n.Collider, Cos(EntityYaw(n.Collider,True)+90.0)*n.CurrSpeed * FPSfactor, 0, Sin(EntityYaw(n.Collider,True)+90.0)*n.CurrSpeed * FPSfactor, True)
								AnimateNPC(n,488, 522, n.CurrSpeed*26)
								
								newDist = EntityDistance(n.Collider,n.Path[n.PathLocation].obj)
								
								if (newDist<1.0 && n.Path[n.PathLocation].door!=Null) {
									if (!n.Path[n.PathLocation].door.open) {
										sound = 0
										if (n.Path[n.PathLocation].door.dir == 1) {
											sound = 0
										} else {
											sound=Rand(0, 2)
										}
										PlaySound2(OpenDoorSFX(n.Path[n.PathLocation].door.dir,sound),Camera,n.Path[n.PathLocation].door.obj)
										PlayMTFSound(MTFSFX(5),n)
									}
									n.Path[n.PathLocation].door.open = True
									if (n.Path[n.PathLocation].door.MTFClose) {
										n.Path[n.PathLocation].door.timerstate = 70.0*5.0
									}
								}
								
								if ((newDist<0.2) || ((prevDist<newDist) && (prevDist<1.0))) {
									n.PathLocation=n.PathLocation+1
								}
							}
							n.PathTimer=n.PathTimer-FPSfactor
						} else {
							n.PathTimer=0.0
						}
					}
				}
				
				if (n.Target.IsDead) {
					n.Target = Null
					n.State = 0
				}
				
				//[End Block]
		}
		
		if (n.CurrSpeed > 0.01) {
			if (prevFrame > 500 && n.Frame<495) {
				PlaySound2(StepSFX(2,0,Rand(0,2)),Camera, n.Collider, 8.0, Rnd(0.5,0.7))
			} else if (prevFrame < 505 && n.Frame>=505) {
				PlaySound2(StepSFX(2,0,Rand(0,2)),Camera, n.Collider, 8.0, Rnd(0.5,0.7))
			}
		}
		
		if (NoTarget && n.State == 1) {n.State = 0}
		
		if (n.State != 3 && n.State != 5 && n.State != 6 && n.State != 7) {
			if (n.MTFLeader!=Null) {
				if (EntityDistance(n.Collider,n.MTFLeader.Collider)<0.7) {
					PointEntity(n.Collider,n.MTFLeader.Collider)
					RotateEntity(n.Collider,0.0,EntityYaw(n.Collider,True),0.0,True)
					n.Angle = CurveAngle(EntityYaw(n.Collider,True),n.Angle,20.0)
					
					TranslateEntity(n.Collider, Cos(EntityYaw(n.Collider,True)-45)* 0.01 * FPSfactor, 0, Sin(EntityYaw(n.Collider,True)-45)* 0.01 * FPSfactor, True)
				}
			} else {
				for (n2 of NPCs.each) {
					if (n2!=n && !n2.IsDead) {
						if (Abs(DeltaYaw(n.Collider,n2.Collider))<80.0) {
							if (EntityDistance(n.Collider,n2.Collider)<0.7) {
								TranslateEntity(n2.Collider, Cos(EntityYaw(n.Collider,True)+90)* 0.01 * FPSfactor, 0, Sin(EntityYaw(n.Collider,True)+90)* 0.01 * FPSfactor, True)
							}
						}
					}
				}
			}
		}
		
		//teleport back to the facility if fell through the floor
		if (n.State != 6 && n.State != 7) {
			if (EntityY(n.Collider) < -10.0) {
				TeleportCloser(n)
			}
		}
		
		RotateEntity(n.obj,-90.0,n.Angle,0.0,True)
		
		PositionEntity(n.obj,EntityX(n.Collider,True),EntityY(n.Collider,True)-0.15,EntityZ(n.Collider,True),True)
		
	}
}

function Shoot(x: float, y: float, z: float, hitProb: float = 1.0, particles: boolean = True, instaKill: boolean = False) {
	
	//muzzle flash
	let p: Particles = CreateParticle(x,y,z, 1, Rnd(0.08,0.1), 0.0, 5)
	TurnEntity(p.obj, 0,0,Rnd(360))
	p.Achange = -0.15
	
	LightVolume = TempLightVolume*1.2

	if (!GodMode) {
		
		if (instaKill) {
			Kill()
			PlaySound_Strict(BullethitSFX)
			return
		}
		
		if (Rnd(1.0) <= hitProb) {
			TurnEntity(Camera, Rnd(-3,3), Rnd(-3,3), 0)
			
			let ShotMessageUpdate: string
			if (WearingVest > 0) {
				if (WearingVest == 1) {
					switch (Rand(8)) {
						case 1,2,3,4,5:
							BlurTimer = 500
							Stamina = 0
							ShotMessageUpdate = "A bullet penetrated your vest, making you gasp."
							Injuries = Injuries + Rnd(0.1,0.5)
						case 6:
							BlurTimer = 500
							ShotMessageUpdate = "A bullet hit your left leg."
							Injuries = Injuries + Rnd(0.8,1.2)
						case 7:
							BlurTimer = 500
							ShotMessageUpdate = "A bullet hit your right leg."
							Injuries = Injuries + Rnd(0.8,1.2)
						case 8:
							BlurTimer = 500
							Stamina = 0
							ShotMessageUpdate = "A bullet struck your neck, making you gasp."
							Injuries = Injuries + Rnd(1.2,1.6)
					}
				} else {
					if (Rand(10) == 1) {
						BlurTimer = 500
						Stamina = Stamina - 1
						ShotMessageUpdate = "A bullet hit your chest. The vest absorbed some of the damage."
						Injuries = Injuries + Rnd(0.8,1.1)
					} else {
						ShotMessageUpdate = "A bullet hit your chest. The vest absorbed most of the damage."
						Injuries = Injuries + Rnd(0.1,0.5)
					}
				}
				
				if (Injuries >= 5) {
					if (Rand(3) == 1) {Kill()}
				}
			} else {
				switch (Rand(6)) {
					case 1:
						Kill()
					case 2:
						BlurTimer = 500
						ShotMessageUpdate = "A bullet hit your left leg."
						Injuries = Injuries + Rnd(0.8,1.2)
					case 3:
						BlurTimer = 500
						ShotMessageUpdate = "A bullet hit your right leg."
						Injuries = Injuries + Rnd(0.8,1.2)
					case 4:
						BlurTimer = 500
						ShotMessageUpdate = "A bullet hit your right shoulder."
						Injuries = Injuries + Rnd(0.8,1.2)	
					case 5:
						BlurTimer = 500
						ShotMessageUpdate = "A bullet hit your left shoulder."
						Injuries = Injuries + Rnd(0.8,1.2)	
					case 6:
						BlurTimer = 500
						ShotMessageUpdate = "A bullet hit your right shoulder."
						Injuries = Injuries + Rnd(2.5,4.0)
				}
			}
			
			//Only updates the message if it's been more than two seconds.
			if (MsgTimer < 64*4) {
				Msg = ShotMessageUpdate
				MsgTimer = 70*6
			}

			Injuries = Min(Injuries, 4.0)
			
			//Kill()
			PlaySound_Strict(BullethitSFX)
		} else if (particles && ParticleAmount>0) {
			pvt = CreatePivot()
			PositionEntity(pvt, EntityX(Collider),(EntityY(Collider)+EntityY(Camera))/2,EntityZ(Collider))
			PointEntity(pvt, p.obj)
			TurnEntity(pvt, 0, 180, 0)
			
			EntityPick(pvt, 2.5)
			
			if (PickedEntity() != 0) {
				PlaySound2(Gunshot3SFX, Camera, pvt, 0.4, Rnd(0.8,1.0))
				
				if (particles) {
					//dust/smoke particles
					p.Particles = CreateParticle(PickedX(),PickedY(),PickedZ(), 0, 0.03, 0, 80)
					p.speed = 0.001
					p.SizeChange = 0.003
					p.A = 0.8
					p.Achange = -0.01
					RotateEntity(p.pvt, EntityPitch(pvt)-180, EntityYaw(pvt),0)
					
					for (i of range(Rand(2,3) + 1)) {
						p.Particles = CreateParticle(PickedX(),PickedY(),PickedZ(), 0, 0.006, 0.003, 80)
						p.speed = 0.02
						p.A = 0.8
						p.Achange = -0.01
						RotateEntity(p.pvt, EntityPitch(pvt)+Rnd(170,190), EntityYaw(pvt)+Rnd(-10,10),0	)
					}
					
					//bullet hole decal
					let de: Decals = CreateDecal(Rand(13,14), PickedX(),PickedY(),PickedZ(), 0,0,0)
					AlignToVector(de.obj,-PickedNX(),-PickedNY(),-PickedNZ(),3)
					MoveEntity(de.obj, 0,0,-0.001)
					EntityFX(de.obj, 1)
					de.lifetime = 70*20
					EntityBlend(de.obj, 2)
					de.Size = Rnd(0.028,0.034)
					ScaleSprite(de.obj, de.Size, de.Size)
				}				
			}
			FreeEntity(pvt)
			
		}
		
	}
}

function PlayMTFSound(sound: int, n: NPCs) {
	if (n != Null) {
		n.SoundChn = PlaySound2(sound, Camera, n.Collider, 8.0)	
	}
	
	if (SelectedItem != Null) {
		if (SelectedItem.state2 == 3 && SelectedItem.state > 0) {
			switch (SelectedItem.itemtemplate.tempname ) {
				case "radio","fineradio","18vradio":
					if (sound!=MTFSFX(5) || (!ChannelPlaying(RadioCHN(3)))) {
						if (RadioCHN(3)!= 0) {
							StopChannel(RadioCHN(3))
						}
						RadioCHN(3) = PlaySound_Strict (sound)
					}
			}
		}
	} 
}

function MoveToPocketDimension() {
	let r: Rooms
	
	for (r of Rooms.each) {
		if (r.RoomTemplate.Name == "pocketdimension") {
			FallTimer = 0
			UpdateDoors()
			UpdateRooms()
			ShowEntity(Collider)
			PlaySound_Strict(Use914SFX)
			PlaySound_Strict(OldManSFX(5))
			PositionEntity(Collider, EntityX(r.obj),0.8,EntityZ(r.obj))
			DropSpeed = 0
			ResetEntity(Collider)
			
			BlinkTimer = -10
			
			Injuries = Injuries+0.5
			
			PlayerRoom = r
			
			return
		}
	}
}

function FindFreeNPCID() : int {
	let id: int = 1
	while (true) {
		let taken: boolean = False
		for (n2 of NPCs.each) {
			if (n2.ID = id) {
				taken = True
				break
			}
		}
		if (!taken) {
			return id
		}
		id = id + 1
	}
}

function ForceSetNPCID(n: NPCs, newID: int) {
	n.ID = newID
	
	for (n2 of NPCs.each) {
		if (n2 != n && n2.ID == newID) {
			n2.id = FindFreeNPCID()
		}
	}
}

function Find860Angle(n: NPCs, fr: Forest) {
	TFormPoint(EntityX(Collider),EntityY(Collider),EntityZ(Collider),0,fr.Forest_Pivot)
	let playerx = Floor((TFormedX()+6.0)/12.0)
	let playerz = Floor((TFormedZ()+6.0)/12.0)
	
	TFormPoint(EntityX(n.Collider),EntityY(n.Collider),EntityZ(n.Collider),0,fr.Forest_Pivot)
	let x: float = (TFormedX()+6.0)/12.0
	let z: float = (TFormedZ()+6.0)/12.0
	
	let xt = Floor(x)
	let zt = Floor(z)
	
	let x2
	let z2
	if (xt!=playerx || zt!=playerz) { //the monster is not on the same tile as the player
		for (x2 of range(Max(xt-1,0), Min(xt+1,gridsize-1) + 1)) {
			for (z2 of range(Max(zt-1,0), Min(zt+1,gridsize-1) + 1)) {
				if (fr.grid[(z2*gridsize)+x2]>0 && (x2!=xt || z2!=zt) && (x2 == xt || z2 == zt)) {
					
					//tile (x2,z2) is closer to the player than the monsters current tile
					if ((Abs(playerx-x2)+Abs(playerz-z2))<(Abs(playerx-xt)+Abs(playerz-zt))) {
						//calculate the position of the tile in world coordinates
						TFormPoint(x2*12.0,0,z2*12.0,fr.Forest_Pivot,0)
						
						return point_direction(EntityX(n.Collider),EntityZ(n.Collider),TFormedX(),TFormedZ())+180
					}
					
				}
			}
		}
	} else {
		return point_direction(EntityX(n.Collider),EntityZ(n.Collider),EntityX(Collider),EntityZ(Collider))+180
	}		
}

function Console_SpawnNPC(c_input: string, c_state: string = "") {
	let n: NPCs
	let consoleMSG: string
	
	switch (c_input) {
		case "008", "008zombie":
			n.NPCs = CreateNPC(NPCtype008, EntityX(Collider), EntityY(Collider) + 0.2, EntityZ(Collider))
			n.State = 1
			consoleMSG = "SCP-008 infected human spawned."
			
		case "049", "scp049", "scp-049":
			n.NPCs = CreateNPC(NPCtype049, EntityX(Collider), EntityY(Collider) + 0.2, EntityZ(Collider))
			n.State = 1
			consoleMSG = "SCP-049 spawned."
			
		case "049-2", "0492", "scp-049-2", "scp049-2", "049zombie":
			n.NPCs = CreateNPC(NPCtypeZombie, EntityX(Collider), EntityY(Collider) + 0.2, EntityZ(Collider))
			n.State = 1
			consoleMSG = "SCP-049-2 spawned."
			
		case "066", "scp066", "scp-066":
			n.NPCs = CreateNPC(NPCtype066, EntityX(Collider), EntityY(Collider) + 0.2, EntityZ(Collider))
			consoleMSG = "SCP-066 spawned."
			
		case "096", "scp096", "scp-096":
			n.NPCs = CreateNPC(NPCtype096, EntityX(Collider), EntityY(Collider) + 0.2, EntityZ(Collider))
			n.State = 5
			if (Curr096 == Null) {Curr096 = n}
			consoleMSG = "SCP-096 spawned."
			
		case "106", "scp106", "scp-106", "larry":
			n.NPCs = CreateNPC(NPCtypeOldMan, EntityX(Collider), EntityY(Collider) - 0.5, EntityZ(Collider))
			n.State = -1
			consoleMSG = "SCP-106 spawned."
			
		case "173", "scp173", "scp-173", "statue":
			n.NPCs = CreateNPC(NPCtype173, EntityX(Collider), EntityY(Collider) + 0.2, EntityZ(Collider))
			Curr173 = n
			if (Curr173.Idle == 3) {Curr173.Idle = false}
			consoleMSG = "SCP-173 spawned."
		case "372", "scp372", "scp-372":
			n.NPCs = CreateNPC(NPCtype372, EntityX(Collider), EntityY(Collider) + 0.2, EntityZ(Collider))
			consoleMSG = "SCP-372 spawned."
			
		case "513-1", "5131", "scp513-1", "scp-513-1":
			n.NPCs = CreateNPC(NPCtype5131, EntityX(Collider), EntityY(Collider) + 0.2, EntityZ(Collider))
			consoleMSG = "SCP-513-1 spawned."
			
		case "860-2", "8602", "scp860-2", "scp-860-2":
			CreateConsoleMsg("SCP-860-2 cannot be spawned with the console. Sorry!", 255, 0, 0)
			
		case "939", "scp939", "scp-939":
			CreateConsoleMsg("SCP-939 instances cannot be spawned with the console. Sorry!", 255, 0, 0)

		case "966", "scp966", "scp-966":
			n.NPCs = CreateNPC(NPCtype966, EntityX(Collider), EntityY(Collider) + 0.2, EntityZ(Collider))
			consoleMSG = "SCP-966 instance spawned."
			
		case "1048-a", "scp1048-a", "scp-1048-a", "scp1048a", "scp-1048a":
			CreateConsoleMsg("SCP-1048-A cannot be spawned with the console. Sorry!", 255, 0, 0)
			
		case "1499-1", "14991", "scp-1499-1", "scp1499-1":
			n.NPCs = CreateNPC(NPCtype1499, EntityX(Collider), EntityY(Collider) + 0.2, EntityZ(Collider))
			consoleMSG = "SCP-1499-1 instance spawned."
			
		case "class-d", "classd", "d":
			n.NPCs = CreateNPC(NPCtypeD, EntityX(Collider), EntityY(Collider) + 0.2, EntityZ(Collider))
			consoleMSG = "D-Class spawned."
			
		case "guard":
			n.NPCs = CreateNPC(NPCtypeGuard, EntityX(Collider), EntityY(Collider) + 0.2, EntityZ(Collider))
			consoleMSG = "Guard spawned."
			
		case "mtf":
			n.NPCs = CreateNPC(NPCtypeMTF, EntityX(Collider), EntityY(Collider) + 0.2, EntityZ(Collider))
			consoleMSG = "MTF unit spawned."
			
		case "apache", "helicopter":
			n.NPCs = CreateNPC(NPCtypeApache, EntityX(Collider), EntityY(Collider) + 0.2, EntityZ(Collider))
			consoleMSG = "Apache spawned."
			
		case "tentacle":
			n.NPCs = CreateNPC(NPCtypeTentacle, EntityX(Collider), EntityY(Collider), EntityZ(Collider))
			consoleMSG = "SCP-035 tentacle spawned."
			
		case "clerk":
			n.NPCs = CreateNPC(NPCtypeClerk, EntityX(Collider), EntityY(Collider) + 0.2, EntityZ(Collider))
			consoleMSG = "Clerk spawned."
			
		default:
			CreateConsoleMsg("NPC type not found.", 255, 0, 0)
			return
	}
	
	if (n != Null) {
		if (c_state != "") {
			n.State = Float(c_state)
			consoleMSG = consoleMSG + " (State = " + n.State + ")"
		}
	}
	
	CreateConsoleMsg(consoleMSG)
}

function ManipulateNPCBones() {
	let n: NPCs
	let bone: int
	let pvt: int
	let bonename: string
	let maxvalue: float
	let minvalue: float
	let offset: float
	let smooth: float
	let i: int
	let tovalue: float
	
	for (n of NPCs.each) {
		if (n.ManipulateBone) {
			bonename = GetNPCManipulationValue(n.NPCNameInSection,n.BoneToManipulate,"bonename",0)
			if (bonename != "") {
				pvt = CreatePivot()
				bone = FindChild(n.obj,bonename)
				if (bone == 0) {
					RuntimeError("ERROR: NPC bone "+Chr(34)+bonename$+Chr(34)+" does not exist.")
				}
				PositionEntity(pvt,EntityX(bone,True),EntityY(bone,True),EntityZ(bone,True))
				switch (n.ManipulationType) {
					case 0: //<--- looking at player
						for (i of range(1, GetNPCManipulationValue(n.NPCNameInSection,n.BoneToManipulate,"controller_max",1) + 1)) {
							if (GetNPCManipulationValue(n.NPCNameInSection,n.BoneToManipulate,"controlleraxis"+i,0) = "pitch") {
								maxvalue = GetNPCManipulationValue(n.NPCNameInSection,n.BoneToManipulate,"controlleraxis"+i+"_max",2)
								minvalue = GetNPCManipulationValue(n.NPCNameInSection,n.BoneToManipulate,"controlleraxis"+i+"_min",2)
								offset = GetNPCManipulationValue(n.NPCNameInSection,n.BoneToManipulate,"controlleraxis"+i+"_offset",2)
								if (GetNPCManipulationValue(n.NPCNameInSection,n.BoneToManipulate,"controlleraxis"+i+"_inverse",3)) {
									tovalue = -DeltaPitch(bone,Camera)+offset
								} else {
									tovalue = DeltaPitch(bone,Camera)+offset
								}
								
								smooth = GetNPCManipulationValue(n.NPCNameInSection,n.BoneToManipulate,"controlleraxis"+i+"_smoothing",2)
								if (smooth>0.0) {
									n.BonePitch = CurveAngle(tovalue,n.BonePitch,smooth)
								} else {
									n.BonePitch = tovalue
								}
								n.BonePitch = ChangeAngleValueForCorrectBoneAssigning(n.BonePitch)
								n.BonePitch = Max(Min(n.BonePitch,maxvalue),minvalue)
							} else if (GetNPCManipulationValue(n.NPCNameInSection,n.BoneToManipulate,"controlleraxis1",0) = "yaw") {
								maxvalue = GetNPCManipulationValue(n.NPCNameInSection,n.BoneToManipulate,"controlleraxis"+i+"_max",2)
								minvalue = GetNPCManipulationValue(n.NPCNameInSection,n.BoneToManipulate,"controlleraxis"+i+"_min",2)
								offset = GetNPCManipulationValue(n.NPCNameInSection,n.BoneToManipulate,"controlleraxis"+i+"_offset",2)
								if (GetNPCManipulationValue(n.NPCNameInSection,n.BoneToManipulate,"controlleraxis"+i+"_inverse",3)) {
									tovalue = -DeltaYaw(bone,Camera)+offset
								} else {
									tovalue = DeltaYaw(bone,Camera)+offset
								}
								
								smooth = GetNPCManipulationValue(n.NPCNameInSection,n.BoneToManipulate,"controlleraxis"+i+"_smoothing",2)
								if (smooth>0.0) {
									n.BoneYaw = CurveAngle(tovalue,n.BoneYaw,smooth)
								} else {
									n.BoneYaw = tovalue
								}
								n.BoneYaw = ChangeAngleValueForCorrectBoneAssigning(n.BoneYaw)
								n.BoneYaw = Max(Min(n.BoneYaw,maxvalue),minvalue)
							
							}
						}
						
						RotateEntity(bone,EntityPitch(bone)+n.BonePitch,EntityYaw(bone)+n.BoneYaw,EntityRoll(bone)+n.BoneRoll)
				}
				FreeEntity(pvt)
			}
		}
	}
}

function GetNPCManipulationValue(NPC: string,bone: string,section: string,valuetype: int = 0) : string {
	//valuetype determines what type of variable should the Output be returned
	//0 - String
	//1 - Int
	//2 - Float
	//3 - Boolean
	
	let value: string = GetINIString("Data/NPCBones.ini",NPC,bone+"_"+section)
	switch (valuetype) {
		case 0:
			return value
		case 1:
			return Int(value)
		case 2:
			return Float(value)
		case 3:
			return (value == "true" || value == "1")
	}
}

function ChangeAngleValueForCorrectBoneAssigning(value: float) {
	let numb: float
	
	if (value <= 180.0) {
		numb = value
	} else {
		numb = -360+value
	}
	
	return numb
}

function NPCSpeedChange(n: NPCs) {
	
	switch (n.NPCtype) {
		case NPCtype173,NPCtypeOldMan,NPCtype096,NPCtype049,NPCtype939,NPCtypeMTF:
			switch (SelectedDifficulty.otherFactors) {
				case NORMAL:
					n.Speed = n.Speed * 1.1
				case HARD:
					n.Speed = n.Speed * 1.2
			}
	}
}

function PlayerInReachableRoom(canSpawnIn049Chamber: boolean = False) {
	let RN: string = PlayerRoom.RoomTemplate.Name
	let e: Events
	let temp
	
	//Player is in these rooms, returning false
	if (RN == "pocketdimension" || RN == "gatea" || RN == "dimension1499" || RN == "173") {
		return false
	}
	//Player is at GateB and is at the surface, returning false
	if (RN == "exit1" && EntityY(Collider)>1040.0*RoomScale) {
		return false
	}
	//Player is in 860's test room and inside the forest, returning false
	temp = false
	for (e of Events.each) {
		if (e.EventName == "room860" && e.EventState == 1.0) {
			temp = True
			break
		}
	}
	if (RN == "room860" && temp) {
		return false
	}
	if (!canSpawnIn049Chamber) {
		if (!SelectedDifficulty.aggressiveNPCs) {
			if (RN = "room049" && EntityY(Collider)<=-2848*RoomScale) {
				return false
			}
		}
	}
	//return true, this means player is in reachable room
	return True
	
}

enum NPCPosition {
	NotInside,
	Inside,
	Tunnels
}

function CheckForNPCInFacility(n: NPCs) : NPCPosition {	
	if (EntityY(n.Collider)>100.0) {
		return NPCPosition.NotInside
	}
	if (EntityY(n.Collider)< -10.0) {
		return NPCPosition.Tunnels
	}
	if (EntityY(n.Collider)> 7.0 && EntityY(n.Collider)<=100.0) {
		return NPCPosition.Tunnels
	}
	
	return NPCPosition.Inside
}

function FindNextElevator(n: NPCs) {
	let eo: ElevatorObj
	let eo2: ElevatorObj
	
	for (eo of ElevatorObj.each) {
		if (eo.InFacility == n.InFacility) {
			if (Abs(EntityY(eo.obj,True)-EntityY(n.Collider))<10.0) {
				for (eo2 of ElevatorObj.each) {
					if (eo2 != eo) {
						if (eo2.InFacility = n.InFacility) {
							if (Abs(EntityY(eo2.obj,True)-EntityY(n.Collider))<10.0) {
								if (EntityDistance(eo2.obj,n.Collider)<EntityDistance(eo.obj,n.Collider)) {
									n.PathStatus = FindPath(n, EntityX(eo2.obj,True),EntityY(eo2.obj,True),EntityZ(eo2.obj,True))
									n.CurrElevator = eo2
									DebugLog("eo2 found for "+n.NPCtype)
									break
								}
							}
						}
					}
				}
				if (n.CurrElevator == Null) {
					n.PathStatus = FindPath(n, EntityX(eo.obj,True),EntityY(eo.obj,True),EntityZ(eo.obj,True))
					n.CurrElevator = eo
					DebugLog("eo found for "+n.NPCtype)
				}
				if (n.PathStatus != 1) {
					n.CurrElevator = Null
					DebugLog("Unable to find elevator path: Resetting CurrElevator")
				}
				break
			}
		}
	}
}

function GoToElevator(n: NPCs) {
	let dist: float
	let inside: int
	
	if (n.PathStatus != 1) {
		PointEntity(n.obj,n.CurrElevator.obj)
		RotateEntity(n.Collider,0,CurveAngle(EntityYaw(n.obj),EntityYaw(n.Collider),20.0),0)
		
		inside = False
		if (Abs(EntityX(n.Collider)-EntityX(n.CurrElevator.obj,True))<280.0*RoomScale) {
			if (Abs(EntityZ(n.Collider)-EntityZ(n.CurrElevator.obj,True))<280.0*RoomScale) {
				if (Abs(EntityY(n.Collider)-EntityY(n.CurrElevator.obj,True))<280.0*RoomScale) {
					inside = True
				}
			}
		}
		
		dist = EntityDistance(n.Collider,n.CurrElevator.door.frameobj)
		if (n.CurrElevator.door.open) {
			if ((dist > 0.4 && dist < 0.7) && inside) {
				UseDoor(n.CurrElevator.door,False)
				DebugLog(n.NPCtype+" used elevator")
			}
		} else {
			if (dist < 0.7) {
				n.CurrSpeed = 0.0
				if (!n.CurrElevator.door.NPCCalledElevator) {
					n.CurrElevator.door.NPCCalledElevator = True
					DebugLog(n.NPCtype+" called elevator")
				}
			}
		}
	}	
}

function FinishWalking(n: NPCs,startframe: float,endframe: float,speed: float) {
	let centerframe: float
	
	if (n!=Null) {
		centerframe = (endframe-startframe)/2
		if (n.Frame >= centerframe) {
			AnimateNPC(n,startframe,endframe,speed,False)
		} else {
			AnimateNPC(n,endframe,startframe,-speed,False)
		}
	}	
}

function ChangeNPCTextureID(n: NPCs,textureid: int) {
	if (n == Null) {
		CreateConsoleMsg("Tried to change the texture of an invalid NPC")
		if (ConsoleOpening) {
			ConsoleOpen = True
		}
		return
	}
	
	n.TextureID = textureid%+1
	FreeEntity(n.obj)
	n.obj = CopyEntity(DTextures[textureid%+1])
	
	temp = 0.5 / MeshWidth(n.obj)
	ScaleEntity(n.obj, temp, temp, temp)
	MeshCullBox (n.obj, -MeshWidth(ClassDObj), -MeshHeight(ClassDObj), -MeshDepth(ClassDObj), MeshWidth(ClassDObj)*2, MeshHeight(ClassDObj)*2, MeshDepth(ClassDObj)*2)
	
	SetNPCFrame(n,n.Frame)
	
}


//-------------------------------------  Events --------------------------------------------------------------

class Events {
	EventName: string
	room: Rooms
	
	EventState: float
	EventState2: float
	EventState3: float
	SoundCHN: int
	SoundCHN2: int
	Sound
	Sound2
	SoundCHN_isStream: int
	SoundCHN2_isStream: int
	
	EventStr: string
	
	img: int
	static each: Events[] = []
}

export function CreateEvent(eventname: string, roomname: string, id: int, prob: float = 0.0): Events {
	//roomname = the name of the room(s) you want the event to be assigned to
	
	//the id-variable determines which of the rooms the event is assigned to,
	//0 will assign it to the first generated room, 1 to the second, etc
	
	//the prob-variable can be used to randomly assign events into some rooms
	//0.5 means that there's a 50% chance that event is assigned to the rooms
	//1.0 means that the event is assigned to every room
	//the id-variable is ignored if prob != 0.0
	
	let i: int = 0
	let temp: boolean
	let e: Events
	let e2: Events
	let r: Rooms
	
	if (prob == 0.0) {
		for (r of Rooms.each) {
			if (roomname == "" || roomname == r.RoomTemplate.Name) {
				temp = false
				for (e2 of Events.each) {
					if (e2.room = r) {
						temp = true
						Exit
					}
				}
				
				i=i+1
				if (i >= id && temp == false) {
					e.Events = new Events()
					e.EventName = eventname					
					e.room = r
					return e
				}
			}
		}
	} else {
		for (r of Rooms.each) {
			if (roomname = "" || roomname == r.RoomTemplate.Name) {
				temp = false
				for (e2 of Events.each) {
					if (e2.room = r) {
						temp = true
						Exit
					}
				}
				
				if (Rnd(0.0, 1.0) < prob && temp == false) {
					e.Events = new Events()
					e.EventName = eventname					
					e.room = r
				}
			}
		}		
	}
	
	return Null
}

function InitEvents() {
	let e: Events
	
	CreateEvent("173", "173", 0)
	CreateEvent("alarm", "start", 0)
	
	CreateEvent("pocketdimension", "pocketdimension", 0)	
	
	//there's a 7% chance that 106 appears in the rooms named "tunnel"
	CreateEvent("tunnel106", "tunnel", 0, 0.07 + (0.1*SelectedDifficulty.aggressiveNPCs))
	
	//the chance for 173 appearing in the first lockroom is about 66%
	//there's a 30% chance that it appears in the later lockrooms
	if (Rand(3)<3) {CreateEvent("lockroom173", "lockroom", 0)}
	CreateEvent("lockroom173", "lockroom", 0, 0.3 + (0.5*SelectedDifficulty.aggressiveNPCs))
	
	CreateEvent("room2trick", "room2", 0, 0.15)	
	
	CreateEvent("1048a", "room2", 0, 1.0)	
	
	CreateEvent("room2storage", "room2storage", 0)	
	
	//096 spawns in the first (and last) lockroom2
	CreateEvent("lockroom096", "lockroom2", 0)
	
	CreateEvent("endroom106", "endroom", Rand(0,1))
	
	CreateEvent("room2poffices2", "room2poffices2", 0)
	
	CreateEvent("room2fan", "room2_2", 0, 1.0)
	
	CreateEvent("room2elevator2", "room2elevator", 0)
	CreateEvent("room2elevator", "room2elevator", Rand(1,2))
	
	CreateEvent("room3storage", "room3storage", 0, 0)
	
	CreateEvent("tunnel2smoke", "tunnel2", 0, 0.2)
	CreateEvent("tunnel2", "tunnel2", Rand(0,2), 0)
	CreateEvent("tunnel2", "tunnel2", 0, (0.2*SelectedDifficulty.aggressiveNPCs))
	
	//173 appears in half of the "room2doors" -rooms
	CreateEvent("room2doors173", "room2doors", 0, 0.5 + (0.4*SelectedDifficulty.aggressiveNPCs))
	
	//the anomalous duck in room2offices2-rooms
	CreateEvent("room2offices2", "room2offices2", 0, 0.7)
	
	CreateEvent("room2closets", "room2closets", 0)	
	
	CreateEvent("room2cafeteria", "room2cafeteria", 0)	
	
	CreateEvent("room3pitduck", "room3pit", 0)
	CreateEvent("room3pit1048", "room3pit", 1)
	
	//the event that causes the door to open by itself in room2offices3
	CreateEvent("room2offices3", "room2offices3", 0, 1.0)	
	
	CreateEvent("room2servers", "room2servers", 0)	
	
	CreateEvent("room3servers", "room3servers", 0)	
	CreateEvent("room3servers", "room3servers2", 0)
	
	//the dead guard
	CreateEvent("room3tunnel","room3tunnel", 0, 0.08)
	
	CreateEvent("room4","room4", 0)
	
	if (Rand(5)<5) { 
		switch (Rand(3)) {
			case 1:
				CreateEvent("682roar", "tunnel", Rand(0,2), 0)	
			case 2:
				CreateEvent("682roar", "room3pit", Rand(0,2), 0)		
			case 3:
				//CreateEvent("682roar", "room2offices", 0, 0)
				CreateEvent("682roar", "room2z3", 0, 0)
		}
	} 
	
	CreateEvent("testroom173", "room2testroom2", 0, 1.0)	
	
	CreateEvent("room2tesla", "room2tesla", 0, 0.9)
	
	CreateEvent("room2nuke", "room2nuke", 0, 0)
	
	if (Rand(5) < 5) {
		CreateEvent("coffin106", "coffin", 0, 0)
	} else {
		CreateEvent("coffin", "coffin", 0, 0)
	} 
	
	CreateEvent("checkpoint", "checkpoint1", 0, 1.0)
	CreateEvent("checkpoint", "checkpoint2", 0, 1.0)
	
	CreateEvent("room3door", "room3", 0, 0.1)
	CreateEvent("room3door", "room3tunnel", 0, 0.1)	
	
	if (Rand(2) == 1) {
		CreateEvent("106victim", "room3", Rand(1,2))
		CreateEvent("106sinkhole", "room3_2", Rand(2,3))
	} else {
		CreateEvent("106victim", "room3_2", Rand(1,2))
		CreateEvent("106sinkhole", "room3", Rand(2,3))
	}
	CreateEvent("106sinkhole", "room4", Rand(1,2))
	
	CreateEvent("room079", "room079", 0, 0)	
	
	CreateEvent("room049", "room049", 0, 0)
	
	CreateEvent("room012", "room012", 0, 0)
	
	CreateEvent("room035", "room035", 0, 0)
	
	CreateEvent("008", "008", 0, 0)
	
	CreateEvent("room106", "room106", 0, 0)	
	
	CreateEvent("pj", "roompj", 0, 0)
	
	CreateEvent("914", "914", 0, 0)
	
	CreateEvent("buttghost", "room2toilets", 0, 0)
	CreateEvent("toiletguard", "room2toilets", 1, 0)
	
	CreateEvent("room2pipes106", "room2pipes", Rand(0, 3)) 
	
	CreateEvent("room2pit", "room2pit", 0, 0.4 + (0.4*SelectedDifficulty.aggressiveNPCs))
	
	CreateEvent("testroom", "testroom", 0)
	
	CreateEvent("room2tunnel", "room2tunnel", 0)
	
	CreateEvent("room2ccont", "room2ccont", 0)
	
	CreateEvent("gateaentrance", "gateaentrance", 0)
	CreateEvent("gatea", "gatea", 0)	
	CreateEvent("exit1", "exit1", 0)
	
	CreateEvent("room205", "room205", 0)
	
	CreateEvent("room860","room860", 0)
	
	CreateEvent("room966","room966", 0)
	
	CreateEvent("room1123", "room1123", 0, 0)
	CreateEvent("room2tesla", "room2tesla_lcz", 0, 0.9)
	CreateEvent("room2tesla", "room2tesla_hcz", 0, 0.9)
	
	//New Events in SCP:CB Version 1.3 - ENDSHN
	CreateEvent("room4tunnels","room4tunnels",0)
	CreateEvent("room_gw","room2gw",0,1.0)
	CreateEvent("dimension1499","dimension1499",0)
	CreateEvent("room1162","room1162",0)
	CreateEvent("room2scps2","room2scps2",0)
	CreateEvent("room_gw","room3gw",0,1.0)
	CreateEvent("room2sl","room2sl",0)
	CreateEvent("medibay","medibay",0)
	CreateEvent("room2shaft","room2shaft",0)
	CreateEvent("room1lifts","room1lifts",0)
	
	CreateEvent("room2gw_b","room2gw_b",Rand(0,1))
	
	CreateEvent("096spawn","room4pit",0,0.6+(0.2*SelectedDifficulty.aggressiveNPCs))
	CreateEvent("096spawn","room3pit",0,0.6+(0.2*SelectedDifficulty.aggressiveNPCs))
	CreateEvent("096spawn","room2pipes",0,0.4+(0.2*SelectedDifficulty.aggressiveNPCs))
	CreateEvent("096spawn","room2pit",0,0.5+(0.2*SelectedDifficulty.aggressiveNPCs))
	CreateEvent("096spawn","room3tunnel",0,0.6+(0.2*SelectedDifficulty.aggressiveNPCs))
	CreateEvent("096spawn","room4tunnels",0,0.7+(0.2*SelectedDifficulty.aggressiveNPCs))
	CreateEvent("096spawn","tunnel",0,0.6+(0.2*SelectedDifficulty.aggressiveNPCs))
	CreateEvent("096spawn","tunnel2",0,0.4+(0.2*SelectedDifficulty.aggressiveNPCs))
	CreateEvent("096spawn","room3z2",0,0.7+(0.2*SelectedDifficulty.aggressiveNPCs))
	
	CreateEvent("room2pit","room2_4",0,0.4 + (0.4*SelectedDifficulty.aggressiveNPCs))
	
	CreateEvent("room2offices035","room2offices",0)
	
	CreateEvent("room2pit106", "room2pit", 0, 0.07 + (0.1*SelectedDifficulty.aggressiveNPCs))
	
	CreateEvent("room1archive", "room1archive", 0, 1.0)
	
}

function UpdateEvents() {
	CatchErrors("Uncaught (UpdateEvents)")
	let dist: float
	let i: int
	let temp: int
	let pvt: int
	let strtemp: string
	let j: int
	let k: int
	
	let p: Particles
	let n: NPCs
	let r: Rooms
	let e: Events
	let e2: Events
	let it: Items
	let it2: Items
	let em: Emitters
	let sc: SecurityCams
	let sc2: SecurityCams
	
	let CurrTrigger: string = ""
	
	let x: float
	let y: float
	let z: float
	
	let angle: float
	
	CurrStepSFX = 0
	
	UpdateRooms()
	
	for (e of Events.each) {
		switch (e.EventName) {
			case "exit1":
				
				if (RemoteDoorOn=False) {
					e.room.RoomDoors[4].locked=True
				} else if (RemoteDoorOn && e.EventState3 == 0) {
					e.room.RoomDoors[4].locked=False
					if (e.room.RoomDoors[4].open) {
						if (e.room.RoomDoors[4].openstate > 50 || EntityDistance(Collider, e.room.RoomDoors[4].frameobj)<0.5) {
							e.room.RoomDoors[4].openstate = Min(e.room.RoomDoors[4].openstate,50)
							e.room.RoomDoors[4].open = False
							PlaySound2 (LoadTempSound("SFX/Door/DoorError.ogg"), Camera, e.room.RoomDoors[4].frameobj)
						}							
					}
				} else {
					e.room.RoomDoors[4].locked=False
					
					if (Curr096 != Null) {
						if (Curr096.State == 0 || Curr096.State == 5) {
							e.EventState2 = UpdateElevators(e.EventState2, e.room.RoomDoors[0], e.room.RoomDoors[1], e.room.Objects[8], e.room.Objects[9], e)
						} else {
							e.EventState2 = Update096ElevatorEvent(e,e.EventState2,e.room.RoomDoors[0],e.room.Objects[8])
						}
					} else {
						e.EventState2 = UpdateElevators(e.EventState2, e.room.RoomDoors[0], e.room.RoomDoors[1], e.room.Objects[8], e.room.Objects[9], e)
					}
					
					EntityAlpha(Fog, 1.0)
				}
				
			case "alarm":
				
				
				if (e.room.RoomDoors[5] == Null) {
					for (i of range(4)) {
						if (e.room.AdjDoor[i] != Null) {
							e.room.RoomDoors[5] = e.room.AdjDoor[i]
							e.room.RoomDoors[5].open = True
							break
						}
					}
				}
				if (e.EventState == 0) {
					if (PlayerRoom == e.room) {
						
						e.room.RoomDoors[2].open=True
						
						ShowEntity(Fog)
						AmbientLight(Brightness, Brightness, Brightness)
						CameraFogRange(Camera, CameraFogNear, CameraFogFar)
						CameraFogMode(Camera, 1)
						if (SelectedDifficulty.saveType == SAVEANYWHERE) {
							Msg = "Press "+KeyName(KEY_SAVE)+" to save."
							MsgTimer = 70*4
							//SetSaveMSG("Press "+KeyName(KEY_SAVE)+" to save.")
						} else if (SelectedDifficulty.saveType == SAVEONSCREENS) {
							Msg = "Saving is only permitted on clickable monitors scattered throughout the facility."
							MsgTimer = 70 * 8
							//SetSaveMSG("Saving is only permitted on clickable monitors scattered throughout the facility.")
						}
						
						Curr173.Idle=False
						
						while (e.room.RoomDoors[1].openstate < 180) {
							e.room.RoomDoors[1].openstate = Min(180, e.room.RoomDoors[1].openstate + 0.8)
							MoveEntity(e.room.RoomDoors[1].obj, Sin(e.room.RoomDoors[1].openstate) / 180.0, 0, 0)
							MoveEntity(e.room.RoomDoors[1].obj2, -Sin(e.room.RoomDoors[1].openstate) / 180.0, 0, 0)
						}
						
						if (e.room.NPC[0]) {
							SetNPCFrame(e.room.NPC[0], 74)
							e.room.NPC[0].State = 8
						}
						
						if (!e.room.NPC[1]) {
							e.room.NPC[1] = CreateNPC(NPCtypeD, 0,0,0)
							ChangeNPCTextureID(e.room.NPC[1],3)
							e.room.NPC[1].texture = "GFX/npcs/scientist2.jpg"
							ChangeNPCTextureID(e.room.NPC[1],3)
						}
						PositionEntity(e.room.NPC[1].Collider, e.room.x, 0.5, e.room.z-1.0, True)
						ResetEntity(e.room.NPC[1].Collider)
						SetNPCFrame(e.room.NPC[1], 210)
						
						if (e.room.NPC[2] == Null) {
							e.room.NPC[2] = CreateNPC(NPCtypeGuard, 0,0,0)
						}
						//x-240
						PositionEntity(e.room.NPC[2].Collider, e.room.x, 0.5, e.room.z+528*RoomScale, True)
						ResetEntity(e.room.NPC[2].Collider)
						e.room.NPC[2].State = 7
						PointEntity(e.room.NPC[2].Collider,e.room.NPC[1].Collider)
						
						if (e.room.NPC[0] == Null) {
							e.room.NPC[3] = CreateNPC(NPCtypeGuard, EntityX(e.room.Objects[2], True), EntityY(e.room.Objects[2], True), EntityZ(e.room.Objects[2], True))
							//e.room.NPC[3].Angle = 180
							RotateEntity(e.room.NPC[3].Collider,0,90,0)
							SetNPCFrame(e.room.NPC[3], 286)
							e.room.NPC[3].State = 8
							MoveEntity(e.room.NPC[3].Collider,1,0,0)
							
							e.room.NPC[4] = CreateNPC(NPCtypeD, EntityX(e.room.Objects[3], True), 0.5, EntityZ(e.room.Objects[3], True))
							//PointEntity(e.room.NPC[4].Collider, e.room.Objects[7])
							SetNPCFrame(e.room.NPC[4], 19)
							e.room.NPC[4].State = 3
							RotateEntity(e.room.NPC[4].Collider,0,270,0)
							MoveEntity(e.room.NPC[4].Collider,0,0,2.65)
							
							e.room.NPC[5] = CreateNPC(NPCtypeD, EntityX(e.room.Objects[4], True), 0.5, EntityZ(e.room.Objects[4], True))
							ChangeNPCTextureID(e.room.NPC[5],6)
							//PointEntity(e.room.NPC[5].Collider, e.room.Objects[7])
							SetNPCFrame(e.room.NPC[5], 19)
							e.room.NPC[5].State = 3
							RotateEntity(e.room.NPC[5].Collider,0,270,0)
														
							MoveEntity(e.room.NPC[5].Collider,0.25,0,3.0)
							RotateEntity(e.room.NPC[5].Collider,0,0,0)
							
							x = EntityX(e.room.obj, True)+3712*RoomScale
							y = 384.0*RoomScale
							z = EntityZ(e.room.obj, True)+1312*RoomScale
							
							for (i of range(3, 6)) {
								PositionEntity(e.room.NPC[i].Collider, x + (EntityX(e.room.NPC[i].Collider) - EntityX(e.room.obj)), y+EntityY(e.room.NPC[i].Collider)+0.4, z + (EntityZ(e.room.NPC[i].Collider) - EntityZ(e.room.obj)))
								ResetEntity(e.room.NPC[i].Collider)
							}
						}
						
						e.EventState = 1
					}
				} else {
					
					if (e.room.NPC[0] != Null) {
						AnimateNPC(e.room.NPC[0], 249, 286, 0.4, False)
					}
					
					CurrTrigger = CheckTriggers()
					
					if (CurrTrigger == "173scene_timer") {
						e.EventState = e.EventState+FPSfactor
					} else if (CurrTrigger = "173scene_activated") {
						e.EventState = Max(e.EventState, 500)
					}
					
					if (e.EventState < 850) {
						PositionEntity(Curr173.Collider, e.room.x+32*RoomScale, 0.31, e.room.z+1072*RoomScale, True)
						HideEntity(Curr173.obj)
					}
					
					if (e.EventState >= 500) {
						e.EventState = e.EventState+FPSfactor
						
						if (e.EventState2 == 0) {
							//CanSave = False
							ShowEntity(Curr173.obj)
							if (e.EventState > 900 && e.room.RoomDoors[5].open) {
								if (e.EventState - FPSfactor <= 900) {
									e.room.NPC[1].Sound = LoadSound_Strict("SFX/Room/Intro/WhatThe.ogg")
									e.room.NPC[1].SoundChn = PlaySound2(e.room.NPC[1].Sound, Camera, e.room.NPC[1].Collider)
								}
								e.room.NPC[1].State = 3
								e.room.NPC[1].CurrSpeed = CurveValue(-0.008, e.room.NPC[1].CurrSpeed, 5.0)
								AnimateNPC(e.room.NPC[1], 260, 236, e.room.NPC[1].CurrSpeed * 18)
								RotateEntity(e.room.NPC[1].Collider, 0, 0, 0)
								
								if (e.EventState > 900+2.5*70) {
									if (e.room.NPC[2].State != 1) {
										e.room.NPC[2].CurrSpeed = CurveValue(-0.012, e.room.NPC[2].CurrSpeed, 5.0)
										AnimateNPC(e.room.NPC[2], 39, 76, e.room.NPC[2].CurrSpeed*40)
										MoveEntity(e.room.NPC[2].Collider, 0,0,e.room.NPC[2].CurrSpeed*FPSfactor)
										e.room.NPC[2].State = 8
										
										//z-512
										if (EntityZ(e.room.NPC[2].Collider) < e.room.z) {
											PointEntity(e.room.NPC[2].obj, e.room.NPC[1].Collider)
											RotateEntity(e.room.NPC[2].Collider, 0, CurveAngle(EntityYaw(e.room.NPC[2].obj)-180,EntityYaw(e.room.NPC[2].Collider),15.0), 0)
										} else {
											RotateEntity(e.room.NPC[2].Collider, 0, 0, 0)
										}
									}
								}
								
								if (e.EventState < 900+4*70) {
									PositionEntity(Curr173.Collider, e.room.x+32*RoomScale, 0.31, e.room.z+1072*RoomScale, True)
									RotateEntity(Curr173.Collider,0,190,0)
									
									if (e.EventState > 900+70 && e.EventState < 900+2.5*70) {
										AnimateNPC(e.room.NPC[2], 1539, 1553, 0.2, False)
										PointEntity(e.room.NPC[2].obj, Curr173.Collider)
										RotateEntity(e.room.NPC[2].Collider, 0, CurveAngle(EntityYaw(e.room.NPC[2].obj),EntityYaw(e.room.NPC[2].Collider),15.0), 0)
									}
									
								} else {
									if (e.EventState-FPSfactor < 900+4*70) {
										PlaySound_Strict(IntroSFX(11))
										LightBlink = 3.0
										PlaySound2 (StoneDragSFX, Camera, Curr173.Collider)
										PointEntity(Curr173.Collider, e.room.NPC[2].Collider)
										if (EntityY(Collider)<320*RoomScale) {BlinkTimer = -10}
									}
									
									PositionEntity(Curr173.Collider, e.room.x-96*RoomScale, 0.31, e.room.z+592*RoomScale, True)
									RotateEntity(Curr173.Collider,0,190,0)
									
									if (e.room.NPC[2].State != 1 && KillTimer >= 0) {
										if (EntityZ(e.room.NPC[2].Collider) < e.room.z-1150*RoomScale) {
											e.room.RoomDoors[5].open = False
											LightBlink = 3.0
											PlaySound_Strict(IntroSFX(11))
											BlinkTimer = -10
											PlaySound2 (StoneDragSFX, Camera, Curr173.Collider)
											if (EntityDistance(Curr173.Collider,Collider)<2.5 && Abs(EntityY(Collider)-EntityY(Curr173.Collider))<1.0) {
                                                PositionEntity(Curr173.Collider, EntityX(Collider),EntityY(Collider),EntityZ(Collider))
											} else {
                                                PositionEntity(Curr173.Collider, 0,0,0)
                                            }
											ResetEntity(Curr173.Collider)
											Msg = "Hold "+KeyName(KEY_SPRINT)+" to run."
											MsgTimer = 70*8
										}
									}
								}
								
								//If Ulgrin can see the player then start shooting at them.
								if ((CurrTrigger = "173scene_end") && EntityVisible(e.room.NPC[2].Collider, Collider) && (!NoTarget)) {
									e.room.NPC[2].State = 1
									e.room.NPC[2].State3 = 1
								} else if (e.room.NPC[2].State = 1 && (!EntityVisible(e.room.NPC[2].Collider, Collider))) {
									e.room.NPC[2].State = 0
									e.room.NPC[2].State3 = 0
								}
								
								if (e.room.NPC[2].State == 1) {e.room.RoomDoors[5].open = True}
							} else {
								CanSave = True
								if (e.room.NPC[2].State != 1) {
									if (EntityX(Collider)<(e.room.x+1384*RoomScale)) {e.EventState = Max(e.EventState,900)}
									
									if (e.room.RoomDoors[5].openstate = 0) {
										if (e.room.NPC[1] != Null) {
											RemoveNPC(e.room.NPC[1])
										}
										if (e.room.NPC[2] != Null) {
											RemoveNPC(e.room.NPC[2])
										}
										
										e.EventState2=1
									}
								}
							}
						}
						
						PositionEntity(e.room.Objects[0], EntityX(e.room.Objects[0],True), -Max(e.EventState-1300,0)/4500, EntityZ(e.room.Objects[0],True), True)
						RotateEntity(e.room.Objects[0], -Max(e.EventState-1320,0)/130, 0, -Max(e.EventState-1300,0)/40, True)
						
						PositionEntity(e.room.Objects[1], EntityX(e.room.Objects[1],True), -Max(e.EventState-1800,0)/5000, EntityZ(e.room.Objects[1],True), True)
						RotateEntity(e.room.Objects[1], -Max(e.EventState-2040,0)/135, 0, -Max(e.EventState-2040,0)/43, True)
						
						if (EntityDistance(e.room.Objects[0],Collider)<2.5) {
							if (Rand(300) == 2) {PlaySound2(DecaySFX(Rand(1,3)),Camera,e.room.Objects[0], 3.0)}
						}
					}
					
					if (e.EventState < 2000) {
						if (e.SoundCHN == 0) {
							e.SoundCHN = PlaySound_Strict(AlarmSFX(0))
						} else {
							if (!ChannelPlaying(e.SoundCHN)) {e.SoundCHN = PlaySound_Strict(AlarmSFX(0))}
						}
					}
					
					if (e.EventState3<11) {
						if (!ChannelPlaying(e.SoundCHN2)) {
							e.EventState3 = e.EventState3+1
							
							if (e.Sound2 != 0) {
								FreeSound_Strict(e.Sound2)
								e.Sound2 = 0
							}
							
							e.Sound2 = LoadSound_Strict("SFX/Alarm/Alarm2_"+Int(e.EventState3)+".ogg")
							e.SoundCHN2 = PlaySound_Strict(e.Sound2)
						} else {
							if (Int(e.EventState3) == 8) {CameraShake = 1.0}
						}
					}
					
					if ((e.EventState % 600 > 300) && ((e.EventState+FPSfactor) % 600 < 300)) {
						i = Floor((e.EventState-5000)/600)+1
						
						if (i == 0) {PlaySound_Strict(LoadTempSound("SFX/Room/Intro/PA/scripted/scripted6.ogg"))}
						
						if (i>0 && i<26) {
							if (!CommotionState(i)) { //Prevents the same commotion file from playing more then once.
								PlaySound_Strict(LoadTempSound("SFX/Room/Intro/Commotion/Commotion"+i+".ogg"))
								CommotionState(i) = True
							}
						}
						
						if (i>26) {
							if (e.room.NPC[0]) {RemoveNPC(e.room.NPC[0])}
							FreeEntity(e.room.Objects[0])
							FreeEntity(e.room.Objects[1])
							e.room.Objects[0]=0
							e.room.Objects[1]=0
							
							DebugLog("delete alarm")
							
							RemoveEvent(e)							
						}
					}				
				}
				
			case "173": //the intro sequence
				
				
				if (KillTimer >= 0 && e.EventState2 == 0) {
					
					PlayerZone = 0
					
					if (e.EventState3>0) {
						
						ShouldPlay = 13
						
						//slow the player down to match his speed to the guards
						CurrSpeed = Min(CurrSpeed - (CurrSpeed * (0.008/EntityDistance(e.room.NPC[3].Collider, Collider)) * FPSfactor), CurrSpeed)
						
						if (e.EventState3 < 170) {
							if (e.EventState3 = 1.0) {
								PositionEntity(Camera, x, y, z)
								HideEntity(Collider)
								PositionEntity(Collider, x, 0.302, z)
								RotateEntity(Camera, -70, 0, 0)
								
								CurrMusicVolume = MusicVolume
								
								StopStream_Strict(MusicCHN)
								MusicCHN = StreamSound_Strict("SFX/Music/"+Music(13)+".ogg",CurrMusicVolume,Mode)
								NowPlaying = ShouldPlay
								
								PlaySound_Strict(IntroSFX(11))
								BlurTimer = 500
								ShowEntity(Light)
								EntityAlpha(Light, 0.5)
							}
							
							if (e.EventState3 < 3) {
								e.EventState3 = e.EventState3+FPSfactor/100.0
							} else if (e.EventState3 < 15 || e.EventState3 >= 50) {
								e.EventState3 = e.EventState3+FPSfactor/30.0
							}
							
							if (e.EventState3 < 15) {
								
								x = EntityX(e.room.obj)-(3224.0+1024.0)*RoomScale
								y = 136.0*RoomScale
								z = EntityZ(e.room.obj)+8.0*RoomScale	
								
								if (e.EventState3 < 14) {
									mouse_x_speed_1 = 0
									mouse_y_speed_1 = 0
									
									if (e.EventState3-FPSfactor/30.0 < 12 && e.EventState3 > 12) {
										PlaySound2(StepSFX(0,0,0), Camera, Collider, 8, 0.3)
									}
									
									ShowEntity(Light)
									EntityAlpha(Light, 0.9-(e.EventState3/2.0))
									
									x = x + (EntityX(e.room.obj)-(3048.0+1024.0)*RoomScale - x) * Max((e.EventState3-10.0)/4.0,0.0) 
									
									if (e.EventState3 < 10) {
										y = y + (0.2) * Min(Max((e.EventState3-3.0)/5.0, 0.0), 1.0)
									} else {
										y = (y+0.2) + (0.302+0.6 - (y+0.2)) * Max((e.EventState3-10)/4.0,0.0) 
									}
									
									z = z + (EntityZ(e.room.obj)+104.0*RoomScale - z) * Min(Max((e.EventState3-3)/5.0, 0), 1.0)
									
									//I'm sorry you have to see this
									RotateEntity(Camera, -70.0 + 70.0*Min(Max((e.EventState3-3.0)/5.0,0.0),1.0)+Sin(e.EventState3*12.857)*5.0, -60.0*Max((e.EventState3-10.0)/4.0,0.0), Sin(e.EventState3*25.7)*8.0)
									
									PositionEntity(Camera, x, y, z)
									HideEntity(Collider)
									PositionEntity(Collider, x, 0.302, z	)
									DropSpeed = 0
								} else {
									HideEntity(Light)
									
									PositionEntity(Collider, EntityX(Collider), 0.302, EntityZ(Collider))
									ResetEntity(Collider)
									ShowEntity(Collider)
									DropSpeed = 0
									e.EventState3 = 15
									Msg = "Pick up the paper on the desk."
									MsgTimer=70*7
								}
								
								user_camera_pitch = 0
								RotateEntity(Collider, 0, EntityYaw(Camera), 0)
								
							} else if (e.EventState3 < 40) {
								if (Inventory(0)) {
									Msg = "Press "+KeyName(KEY_INV)+" to open the inventory."
									MsgTimer=70*7
									e.EventState3 = 40
									break
								}
							}
							
							if (SelectedItem) {
								e.EventState3 = e.EventState3+FPSfactor/5.0
							}							
							
						} else if (e.EventState3 >= 150.0 && e.EventState3 < 700) {
							if (e.room.NPC[3].State == 7) {
								if (e.room.NPC[3].Sound2 == 0) {
									e.room.NPC[3].Sound2 = LoadSound_Strict("SFX/Room/Intro/Guard/Ulgrin/BeforeDoorOpen.ogg")
									e.room.NPC[3].SoundChn2 = PlaySound2(e.room.NPC[3].Sound2,Camera,e.room.NPC[3].Collider)
									DebugLog("Playing guard sound before cell opening")
								}
								
								UpdateSoundOrigin(e.room.NPC[3].SoundChn2,Camera,e.room.NPC[3].Collider)
								
								if (!ChannelPlaying(e.room.NPC[3].SoundChn2)) {
									//BlinkTimer = -10
									
									e.room.NPC[3].Sound = LoadSound_Strict("SFX/Room/Intro/Guard/Ulgrin/ExitCell.ogg")
									e.room.NPC[3].SoundChn = PlaySound2(e.room.NPC[3].Sound, Camera, e.room.NPC[3].Collider)
									
									e.room.NPC[3].State = 9
									e.room.NPC[4].State = 9
									e.room.NPC[5].State = 9
									
									e.room.RoomDoors[6].locked = False		
									UseDoor(e.room.RoomDoors[6], False)
									e.room.RoomDoors[6].locked = True
								}
							} else {	
								FreeSound_Strict(e.room.NPC[3].Sound2)
								
								e.EventState3 = Min(e.EventState3+FPSfactor/4,699)
								
								//outside the cell
								if (Distance(EntityX(Collider),EntityZ(Collider),PlayerRoom.x-(3072+1024)*RoomScale, PlayerRoom.z+192.0*RoomScale)>1.5) {
									if (e.EventState3 > 250) {
										if (e.room.NPC[3].SoundChn != 0) {
											if (ChannelPlaying(e.room.NPC[3].SoundChn)) {
												StopChannel(e.room.NPC[3].SoundChn)
											}
										}
										FreeSound_Strict(e.room.NPC[3].Sound)
										e.room.NPC[3].Sound = LoadSound_Strict("SFX/Room/Intro/Guard/Ulgrin/Escort"+Rand(1,2)+".ogg")
										e.room.NPC[3].SoundChn = PlaySound2(e.room.NPC[3].Sound, Camera, e.room.NPC[3].Collider)
										
										e.room.NPC[3].PathStatus = FindPath(e.room.NPC[3],PlayerRoom.x-320*RoomScale, 0.3, PlayerRoom.z-704*RoomScale)
										e.room.NPC[4].PathStatus = FindPath(e.room.NPC[4],PlayerRoom.x-320*RoomScale, 0.3, PlayerRoom.z-704*RoomScale)
										
										e.EventState3 = 710
									}
								} else { //inside the cell
									e.room.NPC[3].State = 9
									
									if (e.EventState3-(FPSfactor/4) < 350 && e.EventState3 >= 350) {
										FreeSound_Strict(e.room.NPC[3].Sound)
										e.room.NPC[3].Sound = LoadSound_Strict("SFX/Room/Intro/Guard/Ulgrin/ExitCellRefuse"+Rand(1,2)+".ogg")
										e.room.NPC[3].SoundChn = PlaySound2(e.room.NPC[3].Sound, Camera, e.room.NPC[3].Collider)
									} else if (e.EventState3-(FPSfactor/4) < 550 && e.EventState3 >= 550 ) {
										FreeSound_Strict(e.room.NPC[3].Sound)
										e.room.NPC[3].Sound = LoadSound_Strict("SFX/Room/Intro/Guard/Ulgrin/CellGas"+Rand(1,2)+".ogg")
										e.room.NPC[3].SoundChn = PlaySound2(e.room.NPC[3].Sound, Camera, e.room.NPC[3].Collider)
									} else if (e.EventState3>630) {
										PositionEntity(Collider, EntityX(Collider), EntityY(Collider), Min(EntityZ(Collider), EntityZ(e.room.obj,True)+490*RoomScale))
										if (e.room.RoomDoors[6].open) {
											e.room.RoomDoors[6].locked = False		
											UseDoor(e.room.RoomDoors[6],False)
											e.room.RoomDoors[6].locked = True
											
											em.Emitters = CreateEmitter(PlayerRoom.x - (2976.0+1024) * RoomScale, 373.0 * RoomScale, PlayerRoom.z + 204.0 * RoomScale, 0)
											TurnEntity(em.Obj, 90, 0, 0, True)
											em.RandAngle = 7
											em.Speed = 0.03
											em.SizeChange = 0.003
											em.Room = PlayerRoom
											
											em.Emitters = CreateEmitter(PlayerRoom.x - (3168.0+1024) * RoomScale, 373.0 * RoomScale, PlayerRoom.z + 204.0 * RoomScale, 0)
											TurnEntity(em.Obj, 90, 0, 0, True)
											em.RandAngle = 7
											em.Speed = 0.03
											em.SizeChange = 0.003
											em.Room = PlayerRoom
										}
										
										EyeIrritation=Max(EyeIrritation+FPSfactor * 4, 1.0)
									}
								}
							}
						} else if (e.EventState3 < 800) {
							e.EventState3 = e.EventState3+FPSfactor/4.0

							if (e.room.NPC[5].State != 11) {
								if (EntityDistance(e.room.NPC[3].Collider,e.room.NPC[5].Collider)>5.0 && EntityDistance(e.room.NPC[4].Collider,e.room.NPC[5].Collider)) {
									if (EntityDistance(e.room.NPC[5].Collider,Collider)<3.5) {
										e.room.NPC[5].State = 11
										e.room.NPC[5].State3 = 1
										e.room.NPC[5].SoundChn2 = PlaySound2(e.room.NPC[5].Sound2,Camera,e.room.NPC[5].Collider)
										e.room.NPC[5].Reload = 70*3
									}
								}
							}
						} else if (e.EventState3 < 900) {
							e.room.NPC[4].Angle = 0
							
							if (EntityX(Collider)<EntityX(e.room.obj,True)-5376*RoomScale && e.EventStr == "") {
								if (Rand(3) == 1) {
									e.EventStr = "scripted/scripted"+Rand(1,5)+".ogg|off.ogg|"
								} else {
									//generate the PA message
									e.EventStr = "1/attention"+Rand(1,2)+".ogg"
									switch (Rand(3)) {
										case 1:
											strtemp = "crew"
											e.EventStr = e.EventStr + "|2/crew"+Rand(0,5)+".ogg"
										case 2:
											strtemp = "scientist"
											e.EventStr = e.EventStr + "|2/scientist"+Rand(0,19)+".ogg"
										case 3:
											strtemp = "security"	
											e.EventStr = e.EventStr + "|2/security"+Rand(0,5)+".ogg"
									}
									if (Rand(2) == 1 && strtemp == "scientist") { //call on line...
										e.EventStr = e.EventStr + "|3/callonline.ogg"
										
										e.EventStr = e.EventStr + "|numbers/"+Rand(1,9)+".ogg"
										if (Rand(2) == 1) {
											e.EventStr = e.EventStr + "|numbers/"+Rand(1,9)+".ogg"
										}
									} else {
										e.EventStr = e.EventStr + "|3/report"+Rand(0,1)+".ogg"
										
										switch (strtemp) {
											case "crew":
												e.EventStr = e.EventStr + "|4/crew"+Rand(0,6)+".ogg"
												if (Rand(2) == 1) {
													e.EventStr = e.EventStr + "|5/crew"+Rand(0,6)+".ogg"
												}
											case "scientist":
												e.EventStr = e.EventStr + "|4/scientist"+Rand(0,7)+".ogg"
												if (Rand(2) == 1) {
													e.EventStr = e.EventStr + "|5/scientist0.ogg"
												}
											case "security":
												e.EventStr = e.EventStr + "|4/security"+Rand(0,5)+".ogg"
												if (Rand(2) == 1) {
													e.EventStr = e.EventStr + "|5/security"+Rand(1,2)+".ogg"
												}
										}
									}
									e.EventStr = e.EventStr + "|off.ogg|"
								}
							}
							
							if (e.room.NPC[6] != Null) { //the scientist
								if (e.room.NPC[6].State == 0) { 
									if (e.room.RoomDoors[7].open) { 
										if (Distance(EntityX(Collider), EntityZ(Collider), EntityX(e.room.obj,True)-3328*RoomScale, EntityZ(e.room.obj,True)-1232*RoomScale)<5.0) {
											e.room.NPC[6].State = 1
											if (e.EventStr == "done") { 
												PlaySound_Strict(LoadTempSound("SFX/Room/Intro/PA/scripted/announcement"+Rand(1,7)+".ogg"))
											}
										}
									}
								} else {
									if (EntityZ(e.room.NPC[6].Collider)>EntityZ(e.room.obj,True)-64.0*RoomScale) {
										RotateEntity(e.room.NPC[6].Collider, 0, CurveAngle(90,EntityYaw(e.room.NPC[6].Collider),15.0),0)
										if (e.room.RoomDoors[7].open) {UseDoor(e.room.RoomDoors[7],False)}
										if (e.room.RoomDoors[7].openstate < 1.0) {e.room.NPC[6].State = 0}
									}
								}
							}
							
							If e\room\NPC[8]<>Null Then //the 2 guards and ClassD
								If e\room\NPC[8]\State = 7 Then
									//If e\room\RoomDoors[7]\open Then 
									If Distance(EntityX(Collider), EntityZ(Collider), EntityX(e\room\obj,True)-6688*RoomScale, EntityZ(e\room\obj,True)-1252*RoomScale)<2.5 Then
										e\room\NPC[8]\State = 10
										e\room\NPC[9]\State = 1
										e\room\NPC[10]\State = 10
									EndIf
								Else
									If EntityX(e\room\NPC[8]\Collider)<EntityX(e\room\obj,True)-7100.0*RoomScale Then
										For i = 8 To 10
											e\room\NPC[i]\State = 0
										Next
									EndIf
								EndIf
							EndIf
							
							e\room\NPC[5]\SoundChn = LoopSound2(e\room\NPC[5]\Sound,e\room\NPC[5]\SoundChn,Camera,e\room\NPC[5]\obj,2,0.5)
							
							If e.EventStr <> "" And e.EventStr <> "done" Then
								If e.SoundCHN = 0 Then 
									e.SoundCHN = PlaySound_Strict(LoadTempSound("SFX/Room/Intro/PA/on.ogg"))
								EndIf
								If ChannelPlaying(e.SoundCHN)=False Then
									strtemp = Left(e.EventStr, Instr(e.EventStr, "|", 1)-1)
									e.SoundCHN = PlaySound_Strict (LoadTempSound("SFX/Room/Intro/PA/"+strtemp))
									e.EventStr = Right(e.EventStr, Len(e.EventStr)-Len(strtemp)-1)
									If e.EventStr = "" Then 
										FreeSound_Strict e.room.NPC[3].Sound
										temp = Rand(1,5)
										e.room.NPC[3].Sound = LoadSound_Strict("SFX/Room/Intro/Guard/Conversation"+temp+"a.ogg")
										e.room.NPC[3].SoundChn = PlaySound2(e.room.NPC[3].Sound, Camera, e.room.NPC[3].Collider)
										e.room.NPC[4].Sound = LoadSound_Strict("SFX/Room/Intro/Guard/Conversation"+temp+"b.ogg")
										e.room.NPC[4].SoundChn = PlaySound2(e.room.NPC[4].Sound, Camera, e.room.NPC[4].Collider)
										e.EventStr = "done"
									EndIf
								EndIf
							EndIf
							
							dist = Distance(EntityX(Collider), EntityZ(Collider), EntityX(e\room\NPC[3]\Collider), EntityZ(e\room\NPC[3]\Collider))
							
							If dist < 3.0 Then
								e\room\NPC[3]\State3 = Min(Max(e\room\NPC[3]\State3-FPSfactor,0),50)
							Else
								e\room\NPC[3]\State3 = Max(e\room\NPC[3]\State3+FPSfactor,50)
								If e\room\NPC[3]\State3 => 70*8 And e\room\NPC[3]\State3-FPSfactor < 70*8 And e\room\NPC[3]\State=7 Then
									If e\room\NPC[4]\SoundChn <> 0 Then
										If ChannelPlaying(e\room\NPC[4]\SoundChn) Then StopChannel(e\room\NPC[4]\SoundChn)
									EndIf
									
									if (e.room.NPC[3].State2 < 2) {
										FreeSound_Strict(e.room.NPC[3].Sound)
										e.room.NPC[3].Sound = LoadSound_Strict("SFX/Room/Intro/Guard/Ulgrin/EscortRefuse"+Rand(1,2)+".ogg")
										e.room.NPC[3].SoundChn = PlaySound2(e.room.NPC[3].Sound, Camera, e.room.NPC[3].Collider)
										e.room.NPC[3].State3=50
										e.room.NPC[3].State2=3
									} else if (e.room.NPC[3].State2 == 3) {
										FreeSound_Strict(e.room.NPC[3].Sound)
										e.room.NPC[3].Sound = LoadSound_Strict("SFX/Room/Intro/Guard/Ulgrin/EscortPissedOff"+Rand(1,2)+".ogg")
										e.room.NPC[3].SoundChn = PlaySound2(e.room.NPC[3].Sound, Camera, e.room.NPC[3].Collider)
										e.room.NPC[3].State3=50
										e.room.NPC[3].State2=4
									} else if (e.room.NPC[3].State2 == 4) {
										FreeSound_Strict(e.room.NPC[3].Sound)
										e.room.NPC[3].Sound = LoadSound_Strict("SFX/Room/Intro/Guard/Ulgrin/EscortKill"+Rand(1,2)+".ogg")
										e.room.NPC[3].SoundChn = PlaySound2(e.room.NPC[3].Sound, Camera, e.room.NPC[3].Collider)
										e.room.NPC[3].State3 = 50+70*2.5
										e.room.NPC[3].State2=5
									} else if (e.room.NPC[3].State2 == 5) {
										e.room.NPC[3].State = 11
										e.room.NPC[4].State = 11
										e.room.NPC[5].State = 11
										e.room.NPC[3].State3 = 1
										e.room.NPC[4].State3 = 1
										e.room.NPC[5].State3 = 1
									}
								EndIf
								If e\room\NPC[5]\State <> 11
									If EntityDistance(e\room\NPC[3]\Collider,e\room\NPC[5]\Collider)>5.0 And EntityDistance(e\room\NPC[4]\Collider,e\room\NPC[5]\Collider)
										If EntityDistance(e\room\NPC[5]\Collider,Collider)<3.5
											e\room\NPC[5]\State = 11
											e\room\NPC[5]\State3 = 1
											e\room\NPC[5]\SoundChn2 = PlaySound2(e\room\NPC[5]\Sound2,Camera,e\room\NPC[5]\Collider)
											e\room\NPC[5]\Reload = 70*3
										EndIf
									EndIf
								EndIf
							EndIf
							
							If e\room\NPC[5]\State = 11
								UpdateSoundOrigin(e\room\NPC[5]\SoundChn2,Camera,e\room\NPC[5]\Collider)
							EndIf
							
							If e\room\NPC[3]\State <> 11 Then
								If dist < Min(Max(4.0-e\room\NPC[3]\State3*0.05, 1.5),4.0) Then
									If e\room\NPC[3]\PathStatus <> 1 Then
										e\room\NPC[3]\State = 7
										PointEntity e\room\NPC[3]\obj, Collider
										RotateEntity e\room\NPC[3]\Collider,0,CurveValue(EntityYaw(e\room\NPC[3]\obj),EntityYaw(e\room\NPC[3]\Collider),20.0),0,True
										
										If e\room\NPC[3]\PathStatus = 2 Then
											//e\room\NPC[3]\PathStatus = FindPath(e\room\NPC[3],EntityX(e\room\obj,True)-1584*RoomScale, 0.3, EntityZ(e\room\obj,True)-1040*RoomScale)
											e\room\NPC[3]\PathStatus = FindPath(e\room\NPC[3],PlayerRoom\x-320*RoomScale, 0.3, PlayerRoom\z-704*RoomScale)
											e\room\NPC[4]\PathStatus = FindPath(e\room\NPC[4],PlayerRoom\x-320*RoomScale, 0.3, PlayerRoom\z-704*RoomScale)
											e\room\NPC[3]\State = 3
										EndIf
									Else
										e\room\NPC[3]\State = 3
									EndIf
								Else
									e\room\NPC[3]\State = 7
									PointEntity e\room\NPC[3]\obj, Collider
									RotateEntity e\room\NPC[3]\Collider,0,CurveValue(EntityYaw(e\room\NPC[3]\obj),EntityYaw(e\room\NPC[3]\Collider),20.0),0,True		
									
									If dist > 5.5 Then
										e\room\NPC[3]\PathStatus = 2
										If e\room\NPC[3]\State2=0 Then
											FreeSound_Strict e\room\NPC[3]\Sound
											e\room\NPC[3]\Sound = LoadSound_Strict("SFX/Room/Intro/Guard\Ulgrin\EscortRun.ogg")
											e\room\NPC[3]\SoundChn = PlaySound2(e\room\NPC[3]\Sound, Camera, e\room\NPC[3]\Collider)
											PlaySound2(e\Sound, Camera, e\room\NPC[3]\Collider)
											e\room\NPC[3]\State2=1
										EndIf
										
										e\room\NPC[3]\State = 5
										e\room\NPC[3]\EnemyX = EntityX(Collider)
										e\room\NPC[3]\EnemyY = EntityY(Collider)
										e\room\NPC[3]\EnemyZ = EntityZ(Collider)
										//e\room\NPC[3]\PathStatus = FindPath(e\room\NPC[3],EntityY(Collider), 0.3, EntityZ(Collider))
									EndIf
								EndIf	
								
								//PointEntity e\room\NPC[5]\obj, Collider
								//RotateEntity e\room\NPC[5]\Collider, 0, CurveAngle(EntityYaw(e\room\NPC[5]\obj),EntityYaw(e\room\NPC[5]\Collider),30), 0
								
								dist = EntityDistance(Collider, e\room\NPC[4]\Collider)
								If dist > 1.5 And EntityDistance(e\room\NPC[3]\Collider, Collider)<EntityDistance(e\room\NPC[3]\Collider,e\room\NPC[4]\Collider) Then
									e\room\NPC[4]\State = 3	
									
								Else
									e\room\NPC[4]\State = 5
									e\room\NPC[4]\EnemyX = EntityX(Collider)
									e\room\NPC[4]\EnemyY = EntityY(Collider)
									e\room\NPC[4]\EnemyZ = EntityZ(Collider)
								EndIf
								
							EndIf
							
							dist = Distance(EntityX(Collider), EntityZ(Collider), EntityX(e\room\RoomDoors[2]\frameobj,True), EntityZ(e\room\RoomDoors[2]\frameobj,True))
							
							If Distance(EntityX(e\room\NPC[3]\Collider), EntityZ(e\room\NPC[3]\Collider), EntityX(e\room\RoomDoors[2]\frameobj,True), EntityZ(e\room\RoomDoors[2]\frameobj,True)) < 4.5 And dist < 5.0 Then
								e\room\NPC[0] = CreateNPC(NPCtypeGuard, EntityX(e\room\Objects[0], True), EntityY(e\room\Objects[0], True), EntityZ(e\room\Objects[0], True))
								e\room\NPC[0]\Angle = 180
								
								e\room\NPC[1] = CreateNPC(NPCtypeD, EntityX(e\room\Objects[1], True), 0.5, EntityZ(e\room\Objects[1], True))
								PointEntity(e\room\NPC[1]\Collider, e\room\Objects[5])
								
								e\room\NPC[2] = CreateNPC(NPCtypeD, EntityX(e\room\Objects[2], True), 0.5, EntityZ(e\room\Objects[2], True))
								PointEntity(e\room\NPC[2]\Collider, e\room\Objects[5])
								ChangeNPCTextureID(e\room\NPC[2],6)
								e\room\NPC[3]\State = 9								
								
								If e\room\NPC[7]\SoundChn<>0 Then
									If ChannelPlaying(e\room\NPC[7]\SoundChn) Then
										StopChannel(e\room\NPC[7]\SoundChn)
										FreeSound_Strict e\room\NPC[7]\Sound 
										e\room\NPC[7]\Sound=0											
									EndIf
								EndIf
								
								FreeEntity(e\room\Objects[9])
								e\room\Objects[9]=0
								FreeEntity(e\room\Objects[10])
								e\room\Objects[10]=0
								
								If e\room\NPC[5]<>Null Then
									RemoveNPC(e\room\NPC[5])
								EndIf
								
								For i = 8 To 10
									If e\room\NPC[i]<>Null Then
										RemoveNPC(e\room\NPC[i])
									EndIf
								Next
								
								FreeSound_Strict e\room\NPC[3]\Sound
								e\room\NPC[3]\Sound = LoadSound_Strict("SFX/Room/Intro/Guard/Ulgrin/EscortDone"+Rand(1,5)+".ogg")
								e\room\NPC[3]\SoundChn = PlaySound2(e\room\NPC[3]\Sound, Camera, e\room\NPC[3]\Collider)
								
								PositionEntity e\room\NPC[6]\Collider, EntityX(e\room\obj,True)-1190*RoomScale, 450*RoomScale, EntityZ(e\room\obj, True)+456*RoomScale, True
								ResetEntity e\room\NPC[6]\Collider
								PointEntity e\room\NPC[6]\Collider, e\room\obj
								e\room\NPC[6]\CurrSpeed = 0
								e\room\NPC[6]\State = 0
								
								e\EventState3 = 905 //910
								
								e\room\RoomDoors[3]\locked = False
								UseDoor(e\room\RoomDoors[3],False)
								e\room\RoomDoors[3]\locked = True
								
								e\room\NPC[4]\State = 9
							EndIf
						ElseIf e.EventState3 <= 905
							If (Not ChannelPlaying(e.room.NPC[3].SoundChn)) And e.room.NPC[3].Frame < 358.0 Then
								e.room.NPC[3].State = 8
								FreeSound_Strict e.room.NPC[3].Sound
								e.room.NPC[3].Sound = LoadSound_Strict("SFX/Room/Intro/Guard/Ulgrin/OhAndByTheWay.ogg")
								e.room.NPC[3].SoundChn = PlaySound2(e.room.NPC[3].Sound, Camera, e.room.NPC[3].Collider)
								SetNPCFrame(e.room.NPC[3],358)
							ElseIf e.room.NPC[3].Frame >= 358.0 Then
								PointEntity e.room.NPC[3].Collider,Collider
								RotateEntity e.room.NPC[3].Collider,0,EntityYaw(e.room.NPC[3].Collider),0
								
								If e.room.NPC[3].Frame <= 481.5 Then
									Local prevAnimFrame# = e.room.NPC[3].Frame
									AnimateNPC(e.room.NPC[3],358.0,482.0,0.4,False)
								Else
									AnimateNPC(e.room.NPC[3],483.0,607.0,0.2,True)
									If (EntityDistance(Collider, e.room.NPC[3].Collider)<1.5) Then
										If EntityInView(e.room.NPC[3].obj, Camera) Then
											DrawHandIcon = True
											
											If MouseHit1 Then
												SelectedItem = CreateItem("Document SCP-173", "paper", 0.0, 0.0, 0.0)
												EntityType SelectedItem.collider,HIT_ITEM
												
												PickItem(SelectedItem)
												
												e.room.RoomDoors[2].locked = False
												UseDoor(e.room.RoomDoors[2],False)
												e.room.RoomDoors[2].locked = True
												e.EventState3 = 910
												SetNPCFrame(e.room.NPC[3],608)
											EndIf
										EndIf
									EndIf
								EndIf
							EndIf
						Else
							If e\room\NPC[3]\Frame <= 620.5 And e\room\NPC[3]\State = 8 Then
								AnimateNPC(e\room\NPC[3],608,621,0.4,False)
							Else
								e\room\NPC[3]\Angle = EntityYaw(e\room\NPC[3]\Collider)
								e\room\NPC[3]\State = 9
								e\room\NPC[4]\State = 9
								If Distance(EntityX(Collider), EntityZ(Collider), EntityX(e\room\obj), EntityZ(e\room\obj)) < 4.0 Then
									e\room\RoomDoors[2]\locked = False
									UseDoor(e\room\RoomDoors[2],False)
									e\room\RoomDoors[2]\locked = True
									e\EventState3 = 0
									e\room\NPC[3]\State = 0
									e\room\NPC[4]\State = 0
									
									UseDoor(e\room\RoomDoors[1],False)
								EndIf
							EndIf
						EndIf
						
						//the scientist sitting at his desk
						If e\room\NPC[7]<>Null Then
							RotateEntity e\room\NPC[7]\Collider,0,180+Sin(MilliSecs2()/20)*3,0,True
							PositionEntity e\room\NPC[7]\Collider, EntityX(e\room\obj,True)-3361*RoomScale,-315*RoomScale,EntityZ(e\room\obj,True)-2165*RoomScale
							ResetEntity e\room\NPC[7]\Collider
							
							e\room\NPC[7]\State = 6
							SetNPCFrame(e\room\NPC[7], 182)
							
							If e\room\NPC[6]\State=1 And e\room\NPC[7]\Sound<>0 Then 
								If e\room\NPC[7]\SoundChn<>0 Then
									If (Not ChannelPlaying(e\room\NPC[7]\SoundChn)) Then FreeSound_Strict e\room\NPC[7]\Sound : e\room\NPC[7]\Sound=0	
									
								EndIf
								
								If e\room\NPC[7]\Sound<>0 Then e\room\NPC[7]\SoundChn = LoopSound2(e\room\NPC[7]\Sound, e\room\NPC[7]\SoundChn, Camera, e\room\NPC[7]\Collider, 7.0)
							EndIf
						EndIf
						
						For i = 3 To 4
							If e\room\NPC[i]\Sound <> 0 Then
								If ChannelPlaying(e\room\NPC[i]\SoundChn)=False Then
									FreeSound_Strict e\room\NPC[i]\Sound 
									e\room\NPC[i]\Sound=0
								Else
									e\room\NPC[i]\SoundChn=LoopSound2(e\room\NPC[i]\Sound, e\room\NPC[i]\SoundChn, Camera, e\room\NPC[i]\Collider)
								EndIf
							EndIf
						Next
						
					Else
						
						//ambience inside the chamber
						If IntroSFX(18)<>0 Then e\SoundCHN2 = LoopSound2(IntroSFX(18), e\SoundCHN2, Camera, e\room\Objects[4], 6)
						
						
						If e\EventState = 0 Then
							If PlayerRoom = e\room Then
								IntroSFX(0) = LoadSound_Strict("SFX/Room/Intro/Scientist/Franklin/EnterChamber.ogg")
								IntroSFX(1) = LoadSound_Strict("SFX/Room/Intro/Scientist/Franklin/Approach173.ogg")
								IntroSFX(2) = LoadSound_Strict("SFX/Room/Intro/Scientist/Franklin/Problem.ogg")
								For i = 4 To 6
									IntroSFX(i) = LoadSound_Strict("SFX/Room/Intro/Scientist/Franklin/Refuse" + (i - 3) + ".ogg")
								Next
								IntroSFX(16) = LoadSound_Strict("SFX/Room/Intro/Horror.ogg")
								IntroSFX(17) = LoadSound_Strict("SFX/Room/Intro/See173.ogg")
								IntroSFX(18) = LoadSound_Strict("SFX/Room/Intro/173Chamber.ogg")
								
								Curr173\Idle = True
								
								e.room.NPC[3] = CreateNPC(NPCtypeGuard, e.room.x-4096*RoomScale+Rnd(-0.3,0.3), 0.3, e.room.z+Rand(860,896)*RoomScale)
								RotateEntity e.room.NPC[3].Collider,0,e.room.angle+180,0
								e.room.NPC[3].State = 7
								e.room.NPC[4] = CreateNPC(NPCtypeGuard, e.room.x-3840*RoomScale, 0.3, e.room.z+768*RoomScale)
								RotateEntity e.room.NPC[4].Collider,0,e.room.angle+135,0
								e.room.NPC[4].State = 7
								
								e.room.NPC[5] = CreateNPC(NPCtypeGuard, e.room.x-8288*RoomScale, 0.3, e.room.z+1096*RoomScale)
								e.room.NPC[5].Sound = LoadSound_Strict("SFX/Room/Intro/Guard/Music"+Rand(1,5)+".ogg")
								RotateEntity e.room.NPC[5].Collider, 0, e.room.angle+180, 0, True
								e.room.NPC[5].State = 7
								e.room.NPC[5].Sound2 = LoadSound_Strict("SFX/Room/Intro/Guard/PlayerEscape.ogg")
								e.room.NPC[6] = CreateNPC(NPCtypeD, e.room.x-3712*RoomScale, -0.3, e.room.z-2208*RoomScale)
								ChangeNPCTextureID(e.room.NPC[6],3)
								e.room.NPC[7] = CreateNPC(NPCtypeD, e.room.x-3712*RoomScale, -0.3, e.room.z-2208*RoomScale)
								//tex = LoadTexture_Strict("GFX.npcs.scientist.jpg")
								e.room.NPC[7].Sound = LoadSound_Strict("SFX/Room/Intro/Scientist/Conversation/ogg")
								//EntityTexture e.room.NPC[7].obj, DTextures[3]
								//FreeTexture tex
								ChangeNPCTextureID(e.room.NPC[7],2)
								pvt = CreatePivot()
								RotateEntity pvt,90,0,0
								
								e.room.NPC[8] = CreateNPC(NPCtypeGuard, e.room.x-3800.0*RoomScale, 1.0, e.room.z-3900.0*RoomScale)
								e.room.NPC[8].State = 7
								e.room.NPC[9] = CreateNPC(NPCtypeD, e.room.x-4000.0*RoomScale, 1.1, e.room.z-3900.0*RoomScale)
								e.room.NPC[9]\State2 = 1.0
								tex = LoadTexture_Strict("GFX/npcs/classd3.jpg")
								EntityTexture e\room\NPC[9]\obj, tex
								FreeTexture tex
								e.room.NPC[10] = CreateNPC(NPCtypeGuard, e.room.x-4200.0*RoomScale, 1.0, e.room.z-3900.0*RoomScale)
								e.room.NPC[10].State = 7
								
								For i = 8 To 10
									PositionEntity pvt,EntityX(e\room\NPC[i]\Collider),EntityY(e\room\NPC[i]\Collider),EntityZ(e\room\NPC[i]\Collider)
									EntityPick pvt,20.0
									If PickedEntity() <> 0
										PositionEntity e\room\NPC[i]\Collider,PickedX(),PickedY(),PickedZ(),True
										AlignToVector e\room\NPC[i]\Collider,-PickedNX(),-PickedNY(),-PickedNZ(),3
										RotateEntity e\room\NPC[i]\Collider,0,90,0
									EndIf
								Next
								
								FreeEntity pvt
								
								PositionEntity(Curr173\Collider, EntityX(e\room\Objects[5], True), 0.5, EntityZ(e\room\Objects[5], True))
								ResetEntity(Curr173\Collider)
								
								PositionEntity Collider, PlayerRoom\x-(3072+1024)*RoomScale, 0.3, PlayerRoom\z+192.0*RoomScale
								ResetEntity Collider
								
								e\EventState = 1
								e\EventState3 = 1
							EndIf
						ElseIf e\EventState < 10000
							If e\room\NPC[6]\SoundChn<>0 Then 
								If ChannelPlaying (e\room\NPC[6]\SoundChn) Then
									e\room\NPC[6]\State = 6
									;PointEntity e\room\NPC[6]\Collider, e\room\obj
									If AnimTime(e\room\NPC[6]\obj)=>325 Then
										Animate2(e\room\NPC[6]\obj, AnimTime(e\room\NPC[6]\obj),326,328, 0.02, False)
									Else
										Animate2(e\room\NPC[6]\obj, AnimTime(e\room\NPC[6]\obj),320,328, 0.05, False)
									EndIf
								Else
									Animate2(e\room\NPC[6]\obj,AnimTime(e\room\NPC[6]\obj), 328,320,-0.02, False)
								EndIf
							EndIf
							
							If IntroSFX(17)<>0 Then
								If EntityVisible(Curr173\Collider, Collider) Then
									If EntityInView(Curr173\obj, Camera) Then
										Msg = "Press "+KeyName(KEY_BLINK)+" to blink."
										MsgTimer = 70*4
										PlaySound_Strict IntroSFX(17)
										IntroSFX(17)=0
									EndIf
								EndIf
							EndIf
							
							e\EventState = Min(e\EventState + (FPSfactor / 3), 5000)
							If e\EventState >= 130 And e\EventState - (FPSfactor/3) < 130 Then
								e\room\NPC[6]\SoundChn = PlaySound_Strict(IntroSFX(0))
							ElseIf e\EventState > 230
								temp = True
								For i = 1 To 2
									If Distance(EntityX(e\room\NPC[i]\Collider), EntityZ(e\room\NPC[i]\Collider), EntityX(e\room\Objects[i + 2], True), EntityZ(e\room\Objects[i + 2], True)) > 0.3 Then
										
										PointEntity(e\room\NPC[i]\obj, e\room\Objects[i + 2])
										RotateEntity(e\room\NPC[i]\Collider, 0, CurveValue(EntityYaw(e\room\NPC[i]\obj),EntityYaw(e\room\NPC[i]\Collider),15.0),0)
										;moveentity(e\room\npc(i).Collider, 0, 0, 0.015 * FPSfactor)
										If e\EventState > (200 + i * 30) Then e\room\NPC[i]\State = 1
										temp = False
									Else
										e\room\NPC[i]\State = 0
										
										PointEntity(e\room\NPC[i]\obj, e\room\Objects[5])
										RotateEntity(e\room\NPC[i]\Collider, 0, CurveValue(EntityYaw(e\room\NPC[i]\obj),EntityYaw(e\room\NPC[i]\Collider),15.0), 0)
										
									EndIf
								Next
								
								If EntityX(Collider) < (EntityX(e\room\obj)) + 408.0 * RoomScale Then
									If e\EventState => 450 And e\EventState - (FPSfactor/3) < 450 Then ;"mene huoneeseen"
										e\room\NPC[6]\SoundChn = PlaySound_Strict(IntroSFX(4))
									ElseIf e\EventState => 650 And e\EventState - (FPSfactor/3) < 650 ;"viimeinen varoitus, 5 sek aikaa"
										e\room\NPC[6]\SoundChn = PlaySound_Strict(IntroSFX(5))
									ElseIf e\EventState => 850 And e\EventState - (FPSfactor/3) < 850 ;"fire at will"
										UseDoor(e\room\RoomDoors[1],False)
										;e\room\RoomDoors[1]\open = False
										e\room\NPC[6]\SoundChn = PlaySound_Strict(IntroSFX(6))
									ElseIf e\EventState > 1000
										e\room\NPC[0]\State = 1
										e\room\NPC[0]\State2= 10
										e\room\NPC[0]\State3= 1
										e\room\NPC[3]\State = 11
										e\room\RoomDoors[2]\locked = False
										UseDoor(e\room\RoomDoors[2],False)
										e\room\RoomDoors[2]\locked = True
										e\EventState2 = 1
										Exit
									EndIf
									
									If e\EventState > 850 Then
										PositionEntity(Collider, Min(EntityX(Collider), EntityX(e\room\obj) + 352.0 * RoomScale), EntityY(Collider), EntityZ(Collider))
									End If
								ElseIf temp = True ;pelaaja ja molemmat npc:t huoneessa
									e\EventState = 10000
									UseDoor(e\room\RoomDoors[1],False)
								End If
							End If
							
							e\room\NPC[6]\State = 7
							PointEntity e\room\NPC[6]\obj, Collider
							RotateEntity e\room\NPC[6]\Collider,0,CurveValue(EntityYaw(e\room\NPC[6]\obj),EntityYaw(e\room\NPC[6]\Collider),20.0),0,True	
							
							PositionEntity(Curr173\Collider, EntityX(e\room\Objects[5], True), EntityY(Curr173\Collider), EntityZ(e\room\Objects[5], True))
							RotateEntity(Curr173\Collider, 0, 0, 0, True)
							ResetEntity(Curr173\Collider)
						ElseIf e\EventState < 14000 ; player is inside the room
							e\EventState = Min(e\EventState + FPSfactor, 13000)
							
							If e\EventState < 10300 Then
								PositionEntity(Collider, Max(EntityX(Collider), EntityX(e\room\obj) + 352.0 * RoomScale), EntityY(Collider), EntityZ(Collider))
							End If
							
							e\room\NPC[6]\State = 6
							PointEntity e\room\NPC[6]\obj, Curr173\Collider
							RotateEntity e\room\NPC[6]\Collider,0,CurveValue(EntityYaw(e\room\NPC[6]\obj),EntityYaw(e\room\NPC[6]\Collider),50.0),0,True	
							
							If e\EventState => 10300 And e\EventState - FPSfactor < 10300 Then ;"please approach SCP-173..."
								e\SoundCHN = PlaySound_Strict(IntroSFX(1))
								PositionEntity(Collider, Max(EntityX(Collider), EntityX(e\room\obj) + 352.0 * RoomScale), EntityY(Collider), EntityZ(Collider))
							ElseIf e\EventState => 10440 And e\EventState - FPSfactor < 10440 ;the door opens
								UseDoor(e\room\RoomDoors[1],False)
								e\SoundCHN = PlaySound_Strict(IntroSFX(7)) ;bang
							ElseIf e\EventState => 10740 And e\EventState - FPSfactor < 10740 ;"there seems to be a problem..."
								e\SoundCHN = PlaySound_Strict(IntroSFX(2))
							ElseIf e\EventState => 11145 And e\EventState - FPSfactor < 11145;"I don't like this"
								e\SoundCHN = PlaySound_Strict(IntroSFX(10))
								e\room\NPC[1]\Sound = LoadSound_Strict("SFX/Room/Intro/ClassD\DontLikeThis.ogg")
								PlaySound2(e\room\NPC[1]\Sound, Camera, e\room\NPC[2]\Collider)
							ElseIf e\EventState => 11561 And e\EventState - FPSfactor < 11561 ;lights go out
								e\EventState = 14000
								PlaySound_Strict IntroSFX(16)
								e\room\NPC[2]\Sound = LoadSound_Strict("SFX/Room/Intro/ClassD\Breen.ogg")
								PlaySound2(e\room\NPC[2]\Sound, Camera, e\room\NPC[1]\Collider)
							End If
							
							;Guard Alert
							If e\EventState => 10440 And e\EventState - FPSfactor < 11561
								If EntityX(Collider) < EntityX(e\room\RoomDoors[1]\frameobj, True)
									If e\room\NPC[0]\State <> 12
										e\room\NPC[0]\Sound = LoadSound_Strict("SFX/Room/Intro/Guard\Balcony\Alert"+Rand(1,2)+".ogg")
										e\room\NPC[0]\SoundChn = PlaySound2(e\room\NPC[0]\Sound,Camera,e\room\NPC[0]\Collider,20)
										e\room\NPC[0]\State = 12
										e\room\NPC[0]\State2 = 1
									EndIf
								EndIf
							EndIf
							
							If e\EventState > 10300 Then 
								
								If e\EventState > 10560 Then
									If e\EventState < 10750 Then
										e\room\NPC[1]\State = 1
										e\room\NPC[1]\CurrSpeed = 0.005										
									Else
										e\room\NPC[1]\State = 0
										e\room\NPC[1]\CurrSpeed = CurveValue(0,e\room\NPC[1]\CurrSpeed,10)	
									EndIf
									
								EndIf
								
								If AnimTime(e\room\NPC[6]\obj)=>325 Then
									Animate2(e\room\NPC[6]\obj, AnimTime(e\room\NPC[6]\obj),326,328, 0.02, False)
								Else
									Animate2(e\room\NPC[6]\obj, AnimTime(e\room\NPC[6]\obj),320,328, 0.05, False)
								EndIf
							EndIf
							
							PositionEntity(Curr173\Collider, EntityX(e\room\Objects[5], True),EntityY(Curr173\Collider), EntityZ(e\room\Objects[5], True))
							RotateEntity(Curr173\Collider, 0, 0, 0, True)
							ResetEntity(Curr173\Collider)
						ElseIf e\EventState < 20000
							pvt% = CreatePivot()
							PositionEntity pvt, EntityX(Camera), EntityY(Curr173\Collider,True)-0.05, EntityZ(Camera)
							PointEntity(pvt, Curr173\Collider)
							RotateEntity(Collider, EntityPitch(Collider), CurveAngle(EntityYaw(pvt), EntityYaw(Collider), 40), 0)
							
							TurnEntity(pvt, 90, 0, 0)
							user_camera_pitch = CurveAngle(EntityPitch(pvt), user_camera_pitch + 90.0, 40)
							user_camera_pitch=user_camera_pitch-90
							FreeEntity pvt
							
							e\room\NPC[6]\State = 6
							PointEntity e\room\NPC[6]\obj, Curr173\Collider
							RotateEntity e\room\NPC[6]\Collider,0,CurveValue(EntityYaw(e\room\NPC[6]\obj),EntityYaw(e\room\NPC[6]\Collider),20.0),0,True	
							Animate2(e\room\NPC[6]\obj, AnimTime(e\room\NPC[6]\obj),357,381, 0.05)
							
							e\EventState = Min(e\EventState + FPSfactor, 19000)
							If e\EventState < 14100 Then ;lights go out and 173 kills the first Class D
								
								;14000-14030
								If e\EventState < 14060 Then
									BlinkTimer = Max((14000-e\EventState)/2-Rnd(0,1.0),-10)
									;0-60,   90-640
									If BlinkTimer = -10 Then
										PointEntity Curr173\Collider, e\room\NPC[1]\obj
										RotateEntity(Curr173\Collider, 0, EntityYaw(Curr173\Collider),0)
										MoveEntity Curr173\Collider, 0,0,Curr173\Speed*0.6*FPSfactor
										
										Curr173\SoundChn = LoopSound2(StoneDragSFX, Curr173\SoundChn, Camera, Curr173\Collider, 10.0, Curr173\State)
										
										Curr173\State = CurveValue(1.0, Curr173\State, 3)
										
									Else
										Curr173\State = Max(0, Curr173\State - FPSfactor / 20)
									EndIf
								ElseIf e\EventState < 14065
									BlinkTimer = -10
									If e\room\NPC[1]\State = 0 Then PlaySound2(NeckSnapSFX(Rand(0, 2)),Camera,Curr173\Collider)
									
									;e\room\NPC[0]\State=8
									SetAnimTime e\room\NPC[1]\obj, 0
									e\room\NPC[1]\State = 6
									PositionEntity(Curr173\Collider, EntityX(e\room\NPC[1]\obj), EntityY(Curr173\Collider), EntityZ(e\room\NPC[1]\obj))
									ResetEntity(Curr173\Collider)
									PointEntity(Curr173\Collider, e\room\NPC[2]\Collider)
									
									e\room\NPC[2]\State = 3
									RotateEntity e\room\NPC[2]\Collider, 0, EntityYaw(e\room\NPC[2]\Collider), 0
									Animate2(e\room\NPC[2]\obj, AnimTime(e\room\NPC[2]\obj),406,382,-0.01*15)
									MoveEntity e\room\NPC[2]\Collider, 0,0,-0.01*FPSfactor
									
									//Guard WTF
									e\room\NPC[0]\State = 12
									If e\room\NPC[0]\Sound<>0
										StopChannel(e\room\NPC[0]\SoundChn)
										FreeSound_Strict(e\room\NPC[0]\Sound)
										e\room\NPC[0]\Sound = 0
									EndIf
									e\room\NPC[0]\Angle = 180
									e\room\NPC[0]\Sound = LoadSound_Strict("SFX/Room/Intro/Guard\Balcony\WTF"+Rand(1,2)+".ogg")
									e\room\NPC[0]\SoundChn = PlaySound2(e\room\NPC[0]\Sound,Camera,e\room\NPC[0]\Collider,20)
									e\room\NPC[0]\State2 = 0
								Else
									Animate2(e\room\NPC[1]\obj, AnimTime(e\room\NPC[1]\obj), 0, 19, 0.2, False)
									If e\room\NPC[2]\Sound=0 Then 
										e\room\NPC[2]\Sound = LoadSound_Strict("SFX/Room/Intro/ClassD\Gasp.ogg")
										PlaySound2 (e\room\NPC[2]\Sound, Camera, e\room\NPC[2]\Collider, 8.0)	
									EndIf									
								EndIf
								
								If e\EventState > 14080 And e\EventState - FPSfactor < 14080 Then PlaySound_Strict(IntroSFX(12))
								CameraShake = 3
							ElseIf e\EventState < 14200 //kills the other class d
								Animate2(e\room\NPC[1]\obj, AnimTime(e\room\NPC[1]\obj), 0, 19, 0.2, False)
								
								//Animate2(e\room\NPC[0]\obj, AnimTime(e\room\NPC[0]\obj), 110, 120, 0.2, False)
								e\room\NPC[0]\State=8
								If e\EventState > 14105 Then
									If e\room\NPC[2]\State<>6 Then PlaySound2 (NeckSnapSFX(1), Camera, e\room\NPC[2]\Collider, 8.0)
									e\room\NPC[2]\State = 6
									PositionEntity(Curr173\Collider, EntityX(e\room\NPC[2]\obj), EntityY(Curr173\Collider), EntityZ(e\room\NPC[2]\obj))
									ResetEntity(Curr173\Collider)
									PointEntity(Curr173\Collider, Collider)
								EndIf
								If e\EventState < 14130 Then 
									SetAnimTime e\room\NPC[2]\obj,50
									BlinkTimer = -10 : LightBlink = 1.0
								Else 
									Animate2(e\room\NPC[2]\obj, AnimTime(e\room\NPC[2]\obj), 50, 60, 0.2, False)
									Curr173\Idle = False
								EndIf
								If e\EventState > 14100 And e\EventState - FPSfactor < 14100 Then PlaySound_Strict(IntroSFX(8))
								If e\EventState < 14150 Then CameraShake = 5
							Else
								Animate2(e\room\NPC[2]\obj, AnimTime(e\room\NPC[2]\obj), 45, 60, 0.2, False)
								If e\EventState > 14300 Then 
									If e\EventState > 14600 And e\EventState < 14700 Then BlinkTimer = -10 : LightBlink = 1.0
									If EntityX(Collider) < (EntityX(e\room\obj)) + 448.0 * RoomScale Then e\EventState = 20000
								EndIf
							End If
						ElseIf e\EventState < 30000
							e\EventState = Min(e\EventState + FPSfactor, 30000)
							If e\EventState < 20100 Then
								CameraShake = 2
							Else
								If e\EventState < 20200 Then //lights go out again and 173 teleports next to the guard
									If e\EventState > 20105 And e\EventState - FPSfactor < 20105 Then 
										PlaySound_Strict(IntroSFX(9))
										PositionEntity(e\room\NPC[0]\Collider, EntityX(e\room\obj) - 160.0 * RoomScale, EntityY(e\room\NPC[0]\Collider) + 0.1, EntityZ(e\room\obj) + 1280.0 * RoomScale)
										ResetEntity(e\room\NPC[0]\Collider)										
										
										//Guard OhShit
										If e\room\NPC[0]\Sound<>0
											StopChannel(e\room\NPC[0]\SoundChn)
											FreeSound_Strict(e\room\NPC[0]\Sound)
											e\room\NPC[0]\Sound = 0
										EndIf
										e\room\NPC[0]\Sound = LoadSound_Strict("SFX/Room/Intro/Guard\Balcony\OhSh.ogg")
										e\room\NPC[0]\SoundChn = PlaySound2(e\room\NPC[0]\Sound,Camera,e\room\NPC[0]\Collider,20)
									EndIf
									If e\EventState > 20105 Then
										Curr173\Idle = True
										PointEntity(e\room\NPC[0]\Collider, Curr173\obj)
										PositionEntity(Curr173\Collider, EntityX(e\room\obj) - 608.0 * RoomScale, EntityY(e\room\obj) + 480.0 * RoomScale, EntityZ(e\room\obj) + 1312.0 * RoomScale)
										ResetEntity(Curr173\Collider)
										PointEntity(Curr173\Collider, e\room\NPC[0]\Collider)
									EndIf
									
									BlinkTimer = -10 : LightBlink = 1.0
									CameraShake = 3
								ElseIf e\EventState < 20300 //lights on, the guard starts shooting at 173
									PointEntity(e\room\NPC[0]\Collider, Curr173\Collider)
									MoveEntity(e\room\NPC[0]\Collider, 0, 0, -0.002)
									e\room\NPC[0]\State = 2
									UpdateSoundOrigin(e\room\NPC[0]\SoundChn,Camera,e\room\NPC[0]\Collider,20)
									If e\EventState > 20260 And e\EventState - FPSfactor < 20260 Then PlaySound_Strict(IntroSFX(12))
								Else //lights out, guard dies
									
									If e\EventState - FPSfactor < 20300 Then
										BlinkTimer = -10 : LightBlink = 1.0
										CameraShake = 3
										PlaySound_Strict(IntroSFX(11))
										PlaySound2 (NeckSnapSFX(1), Camera, e\room\NPC[0]\Collider, 8.0)
										
										Curr173\Idle = False
										
										e\SoundCHN = PlaySound_Strict(IntroSFX(15))
										
										PositionEntity(Curr173\Collider, EntityX(PlayerRoom\obj) - 400.0 * RoomScale, 100.0, EntityZ(PlayerRoom\obj) + 1072.0 * RoomScale)
										ResetEntity(Curr173\Collider)
										
										For r.Rooms = Each Rooms
											If r\RoomTemplate\Name = "start" Then
												DebugLog "tostart"
												//Msg = "Press "+KeyName(KEY_SAVE)+" to save."
												//MsgTimer = 70*8
												
												PlayerRoom = r
												
												x# = EntityX(r\obj, True)+3712*RoomScale
												y# = 384.0*RoomScale
												z# = EntityZ(r\obj, True)+1312*RoomScale
												
												PositionEntity(Collider, x  + (EntityX(Collider) - EntityX(e\room\obj)), y+EntityY(Collider)+0.4, z + (EntityZ(Collider) - EntityZ(e\room\obj)))
												DropSpeed = 0
												ResetEntity(Collider)
												
												For i = 0 To 2
													PositionEntity(e\room\NPC[i]\Collider, x + (EntityX(e\room\NPC[i]\Collider) - EntityX(e\room\obj)), y+EntityY(e\room\NPC[i]\Collider)+0.4, z + (EntityZ(e\room\NPC[i]\Collider) - EntityZ(e\room\obj)))
													ResetEntity(e\room\NPC[i]\Collider)
												Next
												
												ShouldPlay = 0
												
												For i = 0 To 9
													FreeSound_Strict IntroSFX(i)
												Next
												For i = 16 To 18
													FreeSound_Strict IntroSFX(i)
												Next
												
												r\NPC[0]=e\room\NPC[0]
												r\NPC[0]\State=8
												
												For do.doors = Each Doors
													If do\room = e\room Then
														RemoveDoor(do)
													EndIf
												Next
												
												For w.waypoints = Each WayPoints
													If w\room = e\room Then 
														FreeEntity w\obj
														Delete w
													EndIf
												Next
												
												For i = 3 To 4
													RemoveNPC(e\room\NPC[i])
												Next
												r\NPC[1]=e\room\NPC[6]
												//RemoveNPC(e\room\NPC[7])
												
												FreeEntity e\room\obj
												Delete e\room
												
												For sc.SecurityCams = Each SecurityCams
													If sc\room = e\room Then Delete sc
												Next
												
												ShowEntity Fog
												AmbientLight Brightness, Brightness, Brightness
												CameraFogRange(Camera, CameraFogNear, CameraFogFar)
												CameraFogMode(Camera, 1)
												
												e\EventState2 = 1
												
												//For i = 8 To 10
												//	RemoveNPC(e\room\NPC[i])
												//Next
												
												Exit
											EndIf
										Next
									EndIf
									
								EndIf
								
							EndIf
						EndIf
						
						//[End block]
						
					EndIf
					
				Else
					If KillTimer<0 Then
						If e\room\NPC[3]\State = 1 Then 
							LoadEventSound(e,"SFX/Room/Intro/Guard\Ulgrin\EscortTerminated.ogg")
							PlaySound_Strict e\Sound
						EndIf
					EndIf
					
					For i = 0 To 6
						If IntroSFX(i)<>0 Then FreeSound_Strict IntroSFX(i) : IntroSFX(i)=0
					Next
					FreeSound_Strict IntroSFX(16) : IntroSFX(16)=0
					
					e\EventState2 = 1
				EndIf
				
				If PlayerRoom = e\room Then
					If e\EventState >= 10 Then
						CameraRange(Camera, 0.05, 15)
						If e\room\NPC[7]<>Null Then
							RemoveNPC(e\room\NPC[7])
						EndIf
					Else															
						CameraRange(Camera, 0.05, 40)
					EndIf	
					CameraFogMode(Camera, 0)
	 	            AmbientLight (140, 140, 140)
	   				HideEntity(Fog)
					
					LightVolume = 4.0
					TempLightVolume = 4.0			
				Else
					DebugLog "delete intro event"
					RemoveEvent(e)		
				EndIf	
				
			Case "buttghost"
				
				If PlayerRoom = e\room Then
					If EntityDistance(Collider, e\room\Objects[0]) < 1.8 Then
						If e\EventState = 0
							GiveAchievement(Achv789)
							e\SoundCHN = PlaySound2(ButtGhostSFX, Camera,e\room\Objects[0])
							e\EventState = 1
						Else
							If (Not ChannelPlaying(e\SoundCHN))
								RemoveEvent(e)
							EndIf
						EndIf
					EndIf
				EndIf
				
			Case "checkpoint"
				
				If PlayerRoom = e\room Then
					//If e\room\RoomDoors[0]\open <> e\EventState Then
					//	If e\Sound = 0 Then LoadEventSound(e,"SFX\Door\DoorCheckpoint.Ogg")
					//	PlaySound_Strict e\Sound
					//EndIf
					
					//play a sound clip when the player passes through the gate
					If e\EventState2 = 0 Then
						If EntityZ(Collider) < e\room\z Then
							If PlayerZone = 1 Then
								PlaySound_Strict(LoadTempSound("SFX\Ambient\ToZone2.ogg"))
							Else
								PlaySound_Strict(LoadTempSound("SFX\Ambient\ToZone3.ogg"))
							EndIf
							e\EventState2 = 1
						EndIf
					EndIf
					
					If e\EventState3=0 Then
						If Rand(2)=1 Then
							GiveAchievement(Achv1048)
							e\room\Objects[1]=LoadAnimMesh_Strict("GFX\npcs\scp-1048.b3d")
							ScaleEntity e\room\Objects[1], 0.05,0.05,0.05
							PositionEntity(e\room\Objects[1],EntityX(e\room\Objects[0],True),EntityY(e\room\Objects[0],True),EntityZ(e\room\Objects[0],True))
							SetAnimTime e\room\Objects[1],267	
						EndIf
						
						e\EventState3 = 1
					ElseIf e\room\Objects[1]<>0
						If e\EventState3 = 1 Then
							PointEntity e\room\Objects[1], Collider
							RotateEntity e\room\Objects[1], -90, EntityYaw(e\room\Objects[1]),0
							angle = WrapAngle(DeltaYaw(Collider, e\room\Objects[1]))
							If angle<40 Or angle > 320 Then e\EventState3=2
						ElseIf e\EventState3 = 2
							PointEntity e\room\Objects[1], Collider
							RotateEntity e\room\Objects[1], -90, EntityYaw(e\room\Objects[1]),0
							Animate2(e\room\Objects[1],AnimTime(e\room\Objects[1]),267,283,0.3,False)
							If AnimTime(e\room\Objects[1])=283 Then e\EventState3=3
						ElseIf e\EventState3 = 3
							Animate2(e\room\Objects[1],AnimTime(e\room\Objects[1]),283,267,-0.2,False)
							If AnimTime( e\room\Objects[1])=267 Then e\EventState3=4
						ElseIf e\EventState3 = 4
							angle = WrapAngle(DeltaYaw(Collider, e\room\Objects[1]))
							If angle>90 And angle < 270 Then 
								FreeEntity(e\room\Objects[1])
								e\room\Objects[1]=0
								e\EventState3=5
							EndIf
						EndIf
					EndIf
				EndIf
				
				If e\room\RoomTemplate\Name = "checkpoint2"
					For e2.Events = Each Events
						If e2\EventName = "008"
							If e2\EventState = 2
								If e\room\RoomDoors[0]\locked
									TurnCheckpointMonitorsOff(1)
									e\room\RoomDoors[0]\locked = False
									e\room\RoomDoors[1]\locked = False
								EndIf
							Else
								If e\room\dist < 12
									UpdateCheckpointMonitors(1)
									e\room\RoomDoors[0]\locked = True
									e\room\RoomDoors[1]\locked = True
								EndIf
							EndIf
						EndIf
					Next
				Else
					For e2.Events = Each Events
						If e2\EventName = "room2sl"
							If e2\EventState3 = 0
								If e\room\dist < 12
									TurnCheckpointMonitorsOff(0)
									e\room\RoomDoors[0]\locked = False
									e\room\RoomDoors[1]\locked = False
								EndIf
							Else
								If e\room\dist < 12
									UpdateCheckpointMonitors(0)
									e\room\RoomDoors[0]\locked = True
									e\room\RoomDoors[1]\locked = True
								EndIf
							EndIf
						EndIf
					Next
				EndIf
				
				If e\room\RoomDoors[0]\open <> e\EventState Then
					If e\Sound = 0 Then LoadEventSound(e,"SFX\Door\DoorCheckpoint.ogg")
					e\SoundCHN = PlaySound2(e\Sound,Camera,e\room\RoomDoors[0]\obj)
					e\SoundCHN2 = PlaySound2(e\Sound,Camera,e\room\RoomDoors[1]\obj)
				EndIf
				
				e\EventState = e\room\RoomDoors[0]\open
				
				If ChannelPlaying(e\SoundCHN)
					UpdateSoundOrigin(e\SoundCHN,Camera,e\room\RoomDoors[0]\obj)
				EndIf
				If ChannelPlaying(e\SoundCHN2)
					UpdateSoundOrigin(e\SoundCHN2,Camera,e\room\RoomDoors[1]\obj)
				EndIf
				
			Case "coffin", "coffin106"
				
				
				If e\EventState < MilliSecs2() Then
					//SCP-079 starts broadcasting 895 camera feed on monitors after leaving the first zone
					If PlayerZone > 0 Then 
						If EntityPitch(e\room\Levers[0],True) > 0 Then //camera feed on
							For sc.SecurityCams = Each SecurityCams
								If sc\CoffinEffect=0 And sc\room\RoomTemplate\Name<>"room106" And sc\room\RoomTemplate\Name<>"room205" Then sc\CoffinEffect = 2
								If sc\room = e\room Then sc\Screen = True
							Next
						Else //camera feed off
							For sc.SecurityCams = Each SecurityCams
								If sc\CoffinEffect<>1 Then sc\CoffinEffect = 0
								If sc\room = e\room Then sc\Screen = False
							Next
						EndIf						
					EndIf
					
					e\EventState = MilliSecs2()+3000
				EndIf
				
				If PlayerRoom = e\room Then
					CoffinDistance = EntityDistance(Collider, e\room\Objects[1])
					If CoffinDistance < 1.5 Then 
						GiveAchievement(Achv895)
						If (Not Contained106) And e\EventName="coffin106" And e\EventState2 = 0 Then
							de.Decals = CreateDecal(0, EntityX(e\room\Objects[1],True), -1531.0*RoomScale, EntityZ(e\room\Objects[1],True), 90, Rand(360), 0)
							de\Size = 0.05 : de\SizeChange = 0.001 : EntityAlpha(de\obj, 0.8) : UpdateDecals()
							
							If Curr106\State > 0 Then
								PositionEntity Curr106\Collider, EntityX(e\room\Objects[1],True), -10240*RoomScale, EntityZ(e\room\Objects[1],True)
								Curr106\State = -0.1
								ShowEntity Curr106\obj
								e\EventState2 = 1
							EndIf
						EndIf
					ElseIf CoffinDistance < 3.0 Then
						If e\room\NPC[0]=Null Then
							e\room\NPC[0]=CreateNPC(NPCtypeGuard,e\room\x,e\room\y,e\room\z)
							RotateEntity e\room\NPC[0]\Collider,0,e\room\angle+90,0
							e\room\NPC[0]\State = 8
							//270, 286, 0.4, False
							SetNPCFrame(e\room\NPC[0],270)
							e\room\NPC[0]\GravityMult = 0.0
							e\room\NPC[0]\Sound = LoadSound_Strict("SFX/Room/895Chamber\GuardIdle"+Rand(1,3)+".ogg")
							e\room\NPC[0]\SoundChn = PlaySound2(e\room\NPC[0]\Sound,Camera,e\room\NPC[0]\Collider)
							e\room\NPC[0]\IsDead = True
							e\room\NPC[0]\FallingPickDistance = 0.0
						EndIf
					ElseIf CoffinDistance > 5.0 Then
						If e\room\NPC[0]<>Null Then
							If e\room\NPC[0]\PrevState = 0 Then
								If ChannelPlaying(e\room\NPC[0]\SoundChn) Then
									StopChannel e\room\NPC[0]\SoundChn
								EndIf
								FreeSound_Strict e\room\NPC[0]\Sound
								e\room\NPC[0]\Sound = LoadSound_Strict("SFX/Room/895Chamber\GuardScream"+Rand(1,3)+".ogg")
								e\room\NPC[0]\SoundChn = PlaySound2(e\room\NPC[0]\Sound,Camera,e\room\NPC[0]\Collider,100)
								e\room\NPC[0]\PrevState = 1
								e\room\NPC[0]\State2 = 0.0
							EndIf
						EndIf
					EndIf
					
					If e\room\NPC[0]<>Null Then
						UpdateSoundOrigin(e\room\NPC[0]\SoundChn,Camera,e\room\NPC[0]\Collider,100)
						If e\room\NPC[0]\PrevState = 0 Then
							e\room\NPC[0]\GravityMult = 0.0
						ElseIf e\room\NPC[0]\PrevState = 1 Then
							If e\room\NPC[0]\State2 < 70*1 Then
								e\room\NPC[0]\State2 = e\room\NPC[0]\State2 + FPSfactor
								e\room\NPC[0]\GravityMult = 0.0
							Else
								e\room\NPC[0]\GravityMult = 1.0
							EndIf
							If EntityY(e\room\NPC[0]\Collider)>(-1531.0*RoomScale)+0.35 Then
								dist# = EntityDistance(Collider,e\room\NPC[0]\Collider)
								If dist<0.8 Then //get the player out of the way
									fdir# = point_direction(EntityX(Collider,True),EntityZ(Collider,True),EntityX(e\room\NPC[0]\Collider,True),EntityZ(e\room\NPC[0]\Collider,True))
									TranslateEntity Collider,Cos(-fdir+90)*(dist-0.8)*(dist-0.8),0,Sin(-fdir+90)*(dist-0.8)*(dist-0.8)
								EndIf
								
								If EntityY(e\room\NPC[0]\Collider)>0.6 Then EntityType e\room\NPC[0]\Collider,0
							Else
								e\EventState=e\EventState+FPSfactor
								AnimateNPC(e\room\NPC[0], 270, 286, 0.4, False)
								If e\Sound=0 Then
									LoadEventSound(e,"SFX\General\BodyFall.ogg")
									e\SoundCHN = PlaySound_Strict(e\Sound)
									
									de.Decals = CreateDecal(3, EntityX(e\room\obj), -1531.0*RoomScale, EntityZ(e\room\obj), 90, Rand(360), 0)
									de\Size = 0.4 : ScaleSprite(de\obj,de\Size,de\Size) : UpdateDecals()
								EndIf
								If e\room\NPC[0]\Frame = 286.0 Then
									e\room\NPC[0]\PrevState = 2
								EndIf
							EndIf
							If e\room\NPC[0]\SoundChn2 = 0 Then
								e\room\NPC[0]\Sound2 = LoadSound_Strict("SFX/Room/895Chamber\GuardRadio.ogg")
								e\room\NPC[0]\SoundChn2 = LoopSound2(e\room\NPC[0]\Sound2,e\room\NPC[0]\SoundChn2,Camera,e\room\NPC[0]\Collider,5)
							EndIf
						ElseIf e\room\NPC[0]\PrevState = 2 Then
							If (Not ChannelPlaying(e\SoundCHN)) And e\Sound<>0 Then
								FreeSound_Strict e\Sound : e\Sound = 0
								e\SoundCHN = 0
							EndIf
							If (Not ChannelPlaying(e\room\NPC[0]\SoundChn)) And e\room\NPC[0]\Sound<>0 Then
								FreeSound_Strict e\room\NPC[0]\Sound : e\room\NPC[0]\Sound = 0
								e\room\NPC[0]\SoundChn = 0
							EndIf
							If e\room\NPC[0]\Sound2 = 0 Then
								e\room\NPC[0]\Sound2 = LoadSound_Strict("SFX/Room/895Chamber\GuardRadio.ogg")
							EndIf
							e\room\NPC[0]\SoundChn2 = LoopSound2(e\room\NPC[0]\Sound2,e\room\NPC[0]\SoundChn2,Camera,e\room\NPC[0]\Collider,5)
						EndIf
					EndIf
					
					If WearingNightVision > 0 Then
						Local hasBatteryFor895% = 0
						For i% = 0 To MaxItemAmount - 1
							If (Inventory(i) <> Null) Then
								If (WearingNightVision = 1 And Inventory(i)\itemtemplate\tempname = "nvgoggles") Or (WearingNightVision = 2 And Inventory(i)\itemtemplate\tempname = "supernv") Or (WearingNightVision = 3 And Inventory(i)\itemtemplate\tempname = "finenvgoggles") Then
									If Inventory(i)\state > 0.0 Or WearingNightVision=3 Then
										hasBatteryFor895 = 1
										Exit
									EndIf
								EndIf
							EndIf
						Next
						If (CoffinDistance < 4.0) And (hasBatteryFor895) And (Not Wearing714) Then
							tempF# = point_direction(EntityX(Collider,True),EntityZ(Collider,True),EntityX(e\room\Objects[1],True),EntityZ(e\room\Objects[1],True))
							tempF2# = EntityYaw(Collider)
							tempF3# = angleDist(tempF+90+Sin(WrapAngle(e\EventState3/10)),tempF2)
							TurnEntity Collider, 0,tempF3/4,0,True
							tempF# = Abs(point_distance(EntityX(Collider,True),EntityZ(Collider,True),EntityX(e\room\Objects[1],True),EntityZ(e\room\Objects[1],True)))
							tempF2# = -60.0 * Min(Max((2.0-tempF)/2.0,0.0),1.0)
							user_camera_pitch=(user_camera_pitch * 0.8)+(tempF2 * 0.2)
							
							Sanity = Sanity-(FPSfactor*1.1/WearingNightVision)
							RestoreSanity = False
							BlurTimer = Sin(MilliSecs2()/10)*Abs(Sanity)
							
							If VomitTimer < 0 Then
								RestoreSanity = False
								Sanity = -1010
							EndIf
							
							If Sanity < -1000 Then
								If WearingNightVision > 1
									DeathMSG = Chr(34)+"Class D viewed SCP-895 through a pair of digital night vision goggles, presumably enhanced by SCP-914. It might be possible that the subject "
									DeathMSG = DeathMSG + "was able to resist the memetic effects partially through these goggles. The goggles have been stored for further study."+Chr(34)
								Else
									DeathMSG = Chr(34)+"Class D viewed SCP-895 through a pair of digital night vision goggles, killing him."+Chr(34)
								EndIf
								EntityTexture(NVOverlay, NVTexture)
								If VomitTimer < -10 Then
									Kill()
								EndIf
							ElseIf Sanity < - 800 Then
								If Rand(3) = 1 Then EntityTexture(NVOverlay, NVTexture)
								If Rand(6) < 5 Then
									EntityTexture(NVOverlay, GorePics(Rand(0, 5)))
									For i% = 0 To MaxItemAmount - 1
										If (Inventory(i) <> Null) Then
											If (WearingNightVision = 1 And Inventory(i)\itemtemplate\tempname = "nvgoggles") Or (WearingNightVision = 2 And Inventory(i)\itemtemplate\tempname = "supernv") Or (WearingNightVision = 3 And Inventory(i)\itemtemplate\tempname = "finenvgoggles") Then
												If Inventory(i)\state2 = 1 Then PlaySound_Strict(HorrorSFX(1))
												Inventory(i)\state2 = 2
												Exit
											EndIf
										EndIf
									Next
								EndIf
								BlurTimer = 1000
								If VomitTimer = 0 Then
									VomitTimer = 1
								EndIf
							ElseIf Sanity < - 500 Then
								If Rand(7) = 1 Then EntityTexture(NVOverlay, NVTexture)
								If Rand(50) = 1 Then
									EntityTexture(NVOverlay, GorePics(Rand(0, 5)))
									For i% = 0 To MaxItemAmount - 1
										If (Inventory(i) <> Null) Then
											If (WearingNightVision = 1 And Inventory(i)\itemtemplate\tempname = "nvgoggles") Or (WearingNightVision = 2 And Inventory(i)\itemtemplate\tempname = "supernv") Or (WearingNightVision = 3 And Inventory(i)\itemtemplate\tempname = "finenvgoggles") Then
												If Inventory(i)\state2 = 0 Then PlaySound_Strict(HorrorSFX(0))
												Inventory(i)\state2 = 1
												Exit
											EndIf
										EndIf
									Next
								EndIf
							Else
								EntityTexture(NVOverlay, NVTexture)
								For i% = 0 To MaxItemAmount - 1
									If (Inventory(i) <> Null) Then
										If (WearingNightVision = 1 And Inventory(i)\itemtemplate\tempname = "nvgoggles") Or (WearingNightVision = 2 And Inventory(i)\itemtemplate\tempname = "supernv") Or (WearingNightVision = 3 And Inventory(i)\itemtemplate\tempname = "finenvgoggles") Then
											Inventory(i)\state2 = 0
										EndIf
									EndIf
								Next
							EndIf
						EndIf
					EndIf
					
					If e\EventState3>0.0 Then e\EventState3=Max(e\EventState3-FPSfactor,0.0)
					If e\EventState3=0.0 Then
						e\EventState3=-1.0
						EntityTexture(NVOverlay, NVTexture)
						If WearingNightVision = 1 Then
							EntityColor(NVOverlay, 0,255,0)
						ElseIf WearingNightVision = 2 Then
							EntityColor(NVOverlay, 0,100,255)
						EndIf
					EndIf
					
					ShouldPlay = 66
					
					If UpdateLever(e\room\Levers[0]) Then
						For sc.SecurityCams = Each SecurityCams
							If sc\CoffinEffect=0 And sc\room\RoomTemplate\Name<>"room106" Then sc\CoffinEffect = 2
							If sc\CoffinEffect = 1 Then EntityBlend(sc\ScrOverlay, 3)
							If sc\room = e\room Then sc\Screen = True
						Next
					Else
						For sc.SecurityCams = Each SecurityCams
							If sc\CoffinEffect <> 1 Then sc\CoffinEffect = 0
							If sc\CoffinEffect = 1 Then EntityBlend(sc\ScrOverlay, 0)
							If sc\room = e\room Then sc\Screen = False
						Next
					EndIf
				Else
					CoffinDistance = e\room\dist
				EndIf
				
			Case "endroom106"
				
				If (Not Contained106) Then
					If e\EventState = 0 Then
						If e\room\dist < 8 And e\room\dist > 0 Then
							If Curr106\State < 0 Then 
								RemoveEvent(e)
							Else
								e\room\RoomDoors[0]\open = True
								
								e\room\NPC[0]=CreateNPC(NPCtypeD, EntityX(e\room\RoomDoors[0]\obj,True), 0.5, EntityZ(e\room\RoomDoors[0]\obj,True))
								
								ChangeNPCTextureID(e\room\NPC[0],4)
								
								PointEntity e\room\NPC[0]\Collider, e\room\obj
								RotateEntity e\room\NPC[0]\Collider, 0, EntityYaw(e\room\NPC[0]\Collider),0, True
								MoveEntity e\room\NPC[0]\Collider, 0,0,0.5 
								
								e\room\RoomDoors[0]\open = False
								PlaySound2(LoadTempSound("SFX\Door\EndroomDoor.ogg"), Camera, e\room\obj, 15)
								
								e\EventState = 1							
							EndIf
						EndIf
					ElseIf e\EventState = 1
						If PlayerRoom = e\room Then
							//PlaySound_Strict(CloseDoorSFX(1,0))
							//PlaySound_Strict(DecaySFX(0))
							//e\room\RoomDoors[0]\open = False
							e\room\NPC[0]\State = 1
							e\EventState = 2
							
							e\Sound = LoadSound_Strict("SFX\Character\Janitor\106Abduct.ogg")
							PlaySound_Strict(e\Sound)		
							
							If e\SoundCHN<>0 Then StopChannel e\SoundCHN
						ElseIf e\room\dist < 8
							If e\Sound = 0 Then e\Sound = LoadSound_Strict("SFX\Character\Janitor\Idle.ogg")
							e\SoundCHN = LoopSound2(e\Sound, e\SoundCHN, Camera, e\room\NPC[0]\obj, 15.0)
						EndIf
					ElseIf e\EventState = 2
						dist = EntityDistance(e\room\NPC[0]\Collider, e\room\obj)
						If dist<1.5 Then
							de.Decals = CreateDecal(0, EntityX(e\room\obj), 0.01, EntityZ(e\room\obj), 90, Rand(360), 0)
							de\Size = 0.05 : de\SizeChange = 0.008 : de\timer=10000 : UpdateDecals
							e\EventState = 3
							
							//PlaySound_Strict(DecaySFX(1))
						EndIf					
					Else
						dist = Distance(EntityX(e\room\NPC[0]\Collider),EntityZ(e\room\NPC[0]\Collider), EntityX(e\room\obj),EntityZ(e\room\obj))
						PositionEntity(Curr106\obj, EntityX(e\room\obj, True), 0.0, EntityZ(e\room\obj, True))
						//ResetEntity(Curr106\Collider)
						PointEntity(Curr106\obj, e\room\NPC[0]\Collider)
						RotateEntity(Curr106\obj, 0, EntityYaw(Curr106\obj), 0, True)
						
						Curr106\Idle = True
						
						If dist<0.4 Then
							If e\room\NPC[0]\State=1 Then 
								//PlaySound_Strict(HorrorSFX(10))
								SetNPCFrame(e\room\NPC[0],41)
							EndIf
							e\EventState = e\EventState+FPSfactor/2
							e\room\NPC[0]\State = 6
							e\room\NPC[0]\CurrSpeed = CurveValue(0.0, e\room\NPC[0]\CurrSpeed, 25.0)
							PositionEntity(e\room\NPC[0]\Collider, CurveValue(EntityX(e\room\obj, True), EntityX(e\room\NPC[0]\Collider), 25.0), 0.3-e\EventState/70, CurveValue(EntityZ(e\room\obj, True), EntityZ(e\room\NPC[0]\Collider), 25.0))
							ResetEntity(e\room\NPC[0]\Collider)
							
							//TurnEntity(e\room\NPC[0]\Collider,0,0,0.5*FPSfactor)
							AnimateNPC(e\room\NPC[0], 41, 58, 0.1, False)
							
							AnimateNPC(Curr106, 206,112, -1.0, False)
						Else
							AnimateNPC(Curr106, 112,206, 1.5, False)
						EndIf
						CurrSpeed = Min(CurrSpeed - (CurrSpeed * (0.15/EntityDistance(e\room\NPC[0]\Collider, Collider)) * FPSfactor), CurrSpeed)
						If e\EventState > 100 Then
							//PlaySound2(OldManSFX(Rand(1,2)), Camera, e\room\NPC[0]\Collider)
							
							PositionEntity(Curr106\obj, EntityX(Curr106\Collider), -100.0, EntityZ(Curr106\Collider), True)
							PositionEntity(Curr106\Collider, EntityX(Curr106\Collider), -100.0, EntityZ(Curr106\Collider), True)
							
							Curr106\Idle = False
							If EntityDistance(Collider, e\room\obj)<2.5 Then Curr106\State=-0.1
							
							RemoveNPC(e\room\NPC[0])
							
							RemoveEvent(e)
						EndIf
					EndIf
				EndIf
				
			Case "gateaentrance"
				
				If PlayerRoom = e\room Then 
					If RemoteDoorOn=False Then
						e\room\RoomDoors[1]\locked=True
					ElseIf RemoteDoorOn And e\EventState3=0
						e\room\RoomDoors[1]\locked=False
						If e\room\RoomDoors[1]\open Then 
							If e\room\RoomDoors[1]\openstate > 50 Or EntityDistance(Collider, e\room\RoomDoors[1]\frameobj)<0.5 Then
								e\room\RoomDoors[1]\openstate = Min(e\room\RoomDoors[1]\openstate,50)
								e\room\RoomDoors[1]\open = False
								PlaySound2 (LoadTempSound("SFX\Door\DoorError.ogg"), Camera, e\room\RoomDoors[1]\frameobj)
							EndIf							
						EndIf
					Else
						e\room\RoomDoors[1]\locked=False
						Local gatea.Rooms =Null
						For r.Rooms = Each Rooms
							If r\RoomTemplate\Name = "gatea" Then
								gatea = r 
								Exit
							EndIf
						Next
						
						If Curr096 <> Null Then
							If Curr096\State = 0 Or Curr096\State = 5 Then
								e\EventState = UpdateElevators(e\EventState, e\room\RoomDoors[0], gatea\RoomDoors[1], e\room\Objects[0], e\room\Objects[1], e)
							Else
								e\EventState = Update096ElevatorEvent(e,e\EventState,e\room\RoomDoors[0],e\room\Objects[0])
							EndIf
						Else
							e\EventState = UpdateElevators(e\EventState, e\room\RoomDoors[0], gatea\RoomDoors[1], e\room\Objects[0], e\room\Objects[1], e)
						EndIf
						If Contained106 = False Then 
							If e\EventState < -1.5 And e\EventState+FPSfactor=> -1.5 Then
								PlaySound_Strict(OldManSFX(3))
							EndIf
						EndIf
						
						If EntityDistance(Collider, e\room\Objects[1])<4.0 Then
							gatea\RoomDoors[1]\locked = True
							PlayerRoom = gatea
							RemoveEvent(e)
						EndIf						
					EndIf
				EndIf
				
			Case "lockroom173"
				
				If e\room\dist < 6.0  And e\room\dist > 0 Then
					If Curr173\Idle > 1 Then
						RemoveEvent(e)
					Else
						If (Not EntityInView(Curr173\Collider, Camera)) Or EntityDistance(Curr173\Collider, Collider)>15.0 Then 
							PositionEntity(Curr173\Collider, e\room\x + Cos(225-90 + e\room\angle) * 2, 0.6, e\room\z + Sin(225-90 + e\room\angle) * 2)
							ResetEntity(Curr173\Collider)
							RemoveEvent(e)
						EndIf						
					EndIf
				EndIf
				
			Case "lockroom096"
				
				If PlayerRoom = e\room Then
					If Curr096=Null Then
						Curr096 = CreateNPC(NPCtype096, EntityX(e\room\obj,True), 0.3, EntityZ(e\room\obj,True))
						RotateEntity Curr096\Collider, 0, e\room\angle+45, 0, True
					EndIf
					RemoveEvent(e)
				End If
				
			Case "pj"
				
				If PlayerRoom = e\room Then
					If e\EventState = 0 Then
						If EntityDistance(Collider, e\room\obj) < 2.5 Then
							PlaySound_Strict(RustleSFX(Rand(0,2)))
							CreateNPC(NPCtype372, 0, 0, 0)
							e\EventState = 1
							RemoveEvent(e)
						EndIf					
					EndIf
				EndIf
				
			Case "pocketdimension"
				
				
				//eventstate: a timer for scaling the tunnels in the starting room
				//eventstate2:
					//0 if the player is in the starting room
					//1 if in the room with the throne, moving pillars, plane etc
					//12-15 if player is in the room with the tall pillars 
						//(goes down from 15 to 12 And 106 teleports from pillar to another, pillars being room\objects[12 to 15])
				//eventstate3:
					//1 when appearing in the tunnel that looks like the tunnels in hcz
					//2 after opening the door in the tunnel
					//otherwise 0
				
				If PlayerRoom = e\room Then
					ShowEntity e\room\obj
					
					PlayerFallingPickDistance = 0.0
					
					Injuries = Injuries+FPSfactor*0.00005
					PrevSecondaryLightOn = SecondaryLightOn : SecondaryLightOn = True
					
					If (EntityY(Collider)<2000*RoomScale Or EntityY(Collider)>2608*RoomScale) Then CurrStepSFX = 1
					
					If e\Sound = 0 Then LoadEventSound(e,"SFX/Room/PocketDimension\Rumble.ogg")
					If e\Sound2 = 0 Then e\Sound2 = LoadEventSound(e,"SFX/Room/PocketDimension\PrisonVoices.ogg",1)
					
					If e\EventState = 0 Then
						CameraFogColor Camera, 0,0,0
						CameraClsColor Camera, 0,0,0
						e\EventState = 0.1
					EndIf
					
					If EntityY(Collider)<2000*RoomScale Or e\EventState3=0 Or EntityY(Collider)>2608*RoomScale Then 
						ShouldPlay = 3
					Else 
						ShouldPlay = 0
					EndIf
					
					ScaleEntity(e\room\obj,RoomScale, RoomScale*(1.0 + Sin(e\EventState/14.0)*0.2), RoomScale)
					For i = 0 To 7
						ScaleEntity(e\room\Objects[i],RoomScale*(1.0 + Abs(Sin(e\EventState/21.0+i*45.0)*0.1)),RoomScale*(1.0 + Sin(e\EventState/14.0+i*20.0)*0.1), RoomScale,True)
					Next
					ScaleEntity(e\room\Objects[9],RoomScale*(1.5 + Abs(Sin(e\EventState/21.0+i*45.0)*0.1)),RoomScale*(1.0 + Sin(e\EventState/14.0+i*20.0)*0.1), RoomScale,True)
					
					e\EventState = e\EventState + FPSfactor
					
					If e\EventState2 = 0 Then 
						e\room\RoomDoors[0]\open = False
						e\room\RoomDoors[1]\open = False
						
						If Curr106\State > 0 //106 circles around the starting room
							angle = (e\EventState/10 Mod 360)
							PositionEntity(Curr106\Collider, EntityX(e\room\obj), 0.2+0.35+Sin(e\EventState/14.0+i*20.0)*0.4, EntityX(e\room\obj))
							RotateEntity(Curr106\Collider, 0,angle,0)
							MoveEntity(Curr106\Collider,0,0,6.0-Sin(e\EventState/10.0))
							AnimateNPC(Curr106, 55, 104, 0.5)
							RotateEntity(Curr106\Collider, 0,angle+90,0)
							Curr106\Idle = True
							ShowEntity Curr106\obj
							ShowEntity Curr106\Collider
							ResetEntity Curr106\Collider
							Curr106\GravityMult = 0.0
							Curr106\DropSpeed = 0
							PositionEntity(Curr106\obj, EntityX(Curr106\Collider), EntityY(Curr106\Collider) - 0.15, EntityZ(Curr106\Collider))
							RotateEntity Curr106\obj, 0, EntityYaw(Curr106\Collider), 0
							
							If e\EventState > 65*70 Then
								If Rand(800)=1 Then	
									PlaySound_Strict HorrorSFX(8)
									Curr106\State = -0.1
									Curr106\Idle = False
									e\EventState = 601
								EndIf
							EndIf
						EndIf
					EndIf 
					
					If EntityDistance(Collider, Curr106\Collider) < 0.3 Then //106 attacks if close enough to player
						Curr106\Idle = False
						Curr106\State = -10
					EndIf
					
					If e\EventState2 = 1 Then //in the second room
						
						PositionEntity(e\room\Objects[9], EntityX(e\room\Objects[8],True)+3384*RoomScale, 0.0, EntityZ(e\room\Objects[8],True))
						
						TranslateEntity e\room\Objects[9], Cos(e\EventState*0.8)*5, 0, Sin(e\EventState*1.6)*4, True
						RotateEntity e\room\Objects[9],0,e\EventState * 2,0
						
						PositionEntity(e\room\Objects[10], EntityX(e\room\Objects[8],True), 0.0, EntityZ(e\room\Objects[8],True)+3384*RoomScale)
						
						TranslateEntity e\room\Objects[10], Sin(e\EventState*1.6)*4, 0, Cos(e\EventState*0.8)*5, True
						RotateEntity e\room\Objects[10],0,e\EventState * 2,0
						
						If e\EventState3 = 1 Or e\EventState3 = 2 Then //the "trick room"
							If e\EventState3 = 1 And (e\room\RoomDoors[0]\openstate>150 Or e\room\RoomDoors[1]\openstate>150) Then
								PlaySound_Strict LoadTempSound("SFX\Horror\Horror16.ogg")
								BlurTimer = 800
								e\EventState3=2
							EndIf
							
							If EntityY(Collider)<5.0 Then e\EventState3 = 0
						Else
							//the trenches
							If EntityY(Collider)>6.0 Then
								ShouldPlay = 15
								
								CameraFogColor Camera, 38, 55, 47
								CameraClsColor Camera, 38, 55, 47
								
								If EntityX(e\room\Objects[20],True)<EntityX(e\room\Objects[8],True)-4000*RoomScale Then
									e\SoundCHN2 = PlaySound_Strict(e\Sound2)
									
									PositionEntity e\room\Objects[20], EntityX(Collider,True)+4000*RoomScale, 12.0, EntityZ(Collider,True)
								EndIf
								
								MoveEntity(Collider, 0, Min((12.0 - EntityY(Collider)),0.0)*FPSfactor, 0)
								
								x = -FPSfactor*RoomScale*4.0
								y = (17.0-Abs(EntityX(Collider)-EntityX(e\room\Objects[20]))*0.5)-EntityY(e\room\Objects[20])
								z = EntityZ(Collider,True)-EntityZ(e\room\Objects[20])
								TranslateEntity e\room\Objects[20], x, y, z,True
								RotateEntity e\room\Objects[20], -90-(EntityX(Collider)-EntityX(e\room\Objects[20]))*1.5, -90.0, 0.0, True
								
								
								//check if the plane can see the player
								Local safe=False
								For i = 0 To 2
									Select i
										Case 0
											x = -1452*RoomScale
											z = -37*RoomScale
										Case 1
											x = -121*RoomScale
											z = 188*RoomScale
										Case 2
											x = 1223*RoomScale
											z = -196*RoomScale							
									End Select
									
									x = x + EntityX(e\room\Objects[8],True)
									z = z + EntityZ(e\room\Objects[8],True)
									
									If Distance(EntityX(Collider), EntityZ(Collider), x, z) < 200*RoomScale Then safe = True : Exit
								Next
								
								dist = EntityDistance(Collider, e\room\Objects[20])
								
								If e\SoundCHN2<>0 And ChannelPlaying(e\SoundCHN2)
									e\SoundCHN2 = LoopSound2(e\Sound2, e\SoundCHN2, Camera, Camera, 10.0, 0.3+(Not safe)*0.6)
								EndIf	
								
								If safe Then
									EntityTexture e\room\Objects[20], e\room\Objects[18]
								ElseIf dist < 8.0
									e\SoundCHN = LoopSound2(e\Sound, e\SoundCHN, Camera, e\room\Objects[20], 8.0)
									EntityTexture e\room\Objects[20], e\room\Objects[19]
									Injuries=Injuries+(8.0-dist)*FPSfactor*0.0003
									
									If dist<7.0 Then 
										pvt% = CreatePivot()
										PositionEntity pvt, EntityX(Camera), EntityY(Camera), EntityZ(Camera)
										PointEntity(pvt, e\room\Objects[20])
										TurnEntity(pvt, 90, 0, 0)
										user_camera_pitch = CurveAngle(EntityPitch(pvt), user_camera_pitch + 90.0, 10.0)
										user_camera_pitch=user_camera_pitch-90
										RotateEntity(Collider, EntityPitch(Collider), CurveAngle(EntityYaw(pvt), EntityYaw(Collider), 10), 0)
										FreeEntity pvt
									EndIf
								EndIf
								
								CameraShake = Max(4.0+((Not safe) * 4.0) - dist, 0.0)
								
								//check if player is at the sinkhole (the exit from the trench room)
								If EntityY(Collider)<8.5 Then
									LoadEventSound(e,"SFX/Room/PocketDimension\Rumble.ogg")
									LoadEventSound(e,"SFX/Room/PocketDimension\PrisonVoices.ogg",1)
									
									//move to the "exit room"
									BlurTimer = 1500
									e\EventState2=1
									BlinkTimer = -10
									
									PositionEntity(Collider, EntityX(e\room\Objects[8],True)-400*RoomScale, -304*RoomScale, EntityZ(e\room\Objects[8],True))
									ResetEntity Collider
									
									CameraFogColor Camera, 0,0,0
									CameraClsColor Camera, 0,0,0
								EndIf
								
							Else
								e\EventState3 = 0
								
								For i = 9 To 10
									dist = Distance(EntityX(Collider), EntityZ(Collider),EntityX(e\room\Objects[i],True),EntityZ(e\room\Objects[i],True))
									If dist<6.0 Then 
										If dist<100.0*RoomScale Then
											pvt=CreatePivot()
											PositionEntity pvt, EntityX(e\room\Objects[i],True),EntityY(Collider),EntityZ(e\room\Objects[i],True)
											
											PointEntity pvt, Collider
											RotateEntity pvt, 0, Int(EntityYaw(pvt)/90)*90,0,True
											MoveEntity pvt, 0,0,100*RoomScale
											PositionEntity Collider, EntityX(pvt),EntityY(Collider),EntityZ(pvt)
											
											FreeEntity pvt
											
											If KillTimer = 0 Then
												DeathMSG = "In addition to the decomposed appearance typical of SCP-106's victims, the body exhibits injuries that have not been observed before: "
												DeathMSG = DeathMSG + "massive skull fracture, three broken ribs, fractured shoulder and multiple heavy lacerations."
												
												PlaySound_Strict LoadTempSound("SFX/Room/PocketDimension\Impact.ogg")
												KillTimer=-1.0
											EndIf
										EndIf
										If Float(e\EventStr) < 1000.0 Then
											e\SoundCHN = LoopSound2(e\Sound, e\SoundCHN, Camera, e\room\Objects[i], 6.0)
										EndIf
									EndIf
								Next
								
								pvt=CreatePivot()
								PositionEntity pvt, EntityX(e\room\Objects[8],True)-1536*RoomScale,500*RoomScale,EntityZ(e\room\Objects[8],True)+608*RoomScale
								If EntityDistance(pvt, Collider)<5.0 Then 
									e\SoundCHN2 = LoopSound2(e\Sound2, e\SoundCHN2, Camera, pvt, 3.0)
								EndIf
								FreeEntity pvt
								
								//106's eyes
								ShowEntity e\room\Objects[17]
								PositionEntity e\room\Objects[17], EntityX(e\room\Objects[8],True),1376*RoomScale,EntityZ(e\room\Objects[8],True)-2848*RoomScale
								PointEntity e\room\Objects[17], Collider
								TurnEntity e\room\Objects[17], 0, 180, 0
								
								temp = EntityDistance(Collider, e\room\Objects[17])
								If temp < 2000*RoomScale Then
									Injuries = Injuries + (FPSfactor/4000)
									e\EventStr = Float(e\EventStr)+(FPSfactor/1000.0)
									
									//If Injuries > 1.0 Then
									If Float(e\EventStr) > 1.0 And Float(e\EventStr) < 1000.0 Then
										PlaySound_Strict LoadTempSound("SFX/Room/PocketDimension\Kneel.ogg")
										LoadEventSound(e,"SFX/Room/PocketDimension\Screech.ogg")
										e\EventStr = Float(1000.0)
										DebugLog "Loaded screech sound"
									EndIf
									
									Sanity = Max(Sanity - FPSfactor / temp / 8,-1000)
									
									//e\SoundCHN = LoopSound2(OldManSFX(4), e\SoundCHN, Camera, e\room\Objects[17], 5.0, 0.6)
									
									CurrCameraZoom = Max(CurrCameraZoom, (Sin(Float(MilliSecs2()) / 20.0)+1.0)*15.0*Max((6.0-temp)/6.0,0.0))
									
									pvt% = CreatePivot()
									PositionEntity pvt, EntityX(Camera), EntityY(Camera), EntityZ(Camera)
									PointEntity(pvt, e\room\Objects[17])
									TurnEntity(pvt, 90, 0, 0)
									user_camera_pitch = CurveAngle(EntityPitch(pvt), user_camera_pitch + 90.0, Min(Max(15000.0 / (-Sanity), 15.0), 500.0))
									user_camera_pitch=user_camera_pitch-90
									RotateEntity(Collider, EntityPitch(Collider), CurveAngle(EntityYaw(pvt), EntityYaw(Collider), Min(Max(15000.0 / (-Sanity), 15.0), 500.0)), 0)
									FreeEntity pvt
									
									//teleport the player to the trenches
									If Crouch Then
										BlinkTimer = -10
										PositionEntity Collider, EntityX(e\room\Objects[8],True)-1344*RoomScale,2944*RoomScale,EntityZ(e\room\Objects[8],True)-1184*RoomScale
										ResetEntity Collider
										Crouch = False
										
										LoadEventSound(e,"SFX/Room/PocketDimension/Explosion.ogg")
										LoadEventSound(e,"SFX/Room/PocketDimension/TrenchPlane.ogg",1)
										PositionEntity e\room\Objects[20], EntityX(e\room\Objects[8],True)-1000,0,0,True
										
										e\EventStr = Float(0)
									EndIf
								ElseIf EntityY(Collider)<-180*RoomScale //the "exit room"
									temp = Distance(EntityX(Collider),EntityZ(Collider),EntityX(e\room\Objects[8],True)+1024*RoomScale,EntityZ(e\room\Objects[8],True))
									If temp<640*RoomScale
										BlurTimer = (640*RoomScale-temp)*3000
										
										e\SoundCHN2 = LoopSound2(DecaySFX(Rand(1, 3)), e\SoundCHN2, Camera, Collider, 2.0, (640*RoomScale-temp)*Abs(CurrSpeed)*100)
										CurrSpeed = CurveValue(0.0, CurrSpeed, temp*10)
										
										If temp < 130*RoomScale Then
											
											For r.Rooms = Each Rooms
												If r\RoomTemplate\Name = "room2shaft" Then
													GiveAchievement(AchvPD)
													e\EventState = 0
													e\EventState2 = 0
													
													SecondaryLightOn = PrevSecondaryLightOn
													PrevSecondaryLightOn = 0.0
													
													BlinkTimer = -10
													LightBlink = 5
													
													BlurTimer = 1500
													
													PlayerRoom = r
													
													PlaySound_Strict(LoadTempSound("SFX/Room/PocketDimension\Exit.ogg"))
													
													TeleportEntity(Collider,EntityX(r\Objects[0],True),0.4,EntityZ(r\Objects[0],True),0.3,True)
													
													UpdateRooms()
													UpdateDoors()
													Curr106\State = 10000
													Curr106\Idle = False
													
													de.decals = CreateDecal(0, EntityX(r\Objects[0],True),EntityY(r\Objects[0],True),EntityZ(r\Objects[0],True), 270, Rand(360), 0)
													TeleportEntity(de\obj,EntityX(r\Objects[0],True),EntityY(r\Objects[0],True)+0.6,EntityZ(r\Objects[0],True),0.0,True,4,1)
													
													For e2.Events = Each Events
														If e2\EventName = "room2sl"
															e2\EventState3 = 0
															UpdateLever(e2\room\Levers[0])
															RotateEntity e2\room\Levers[0],0,EntityYaw(e2\room\Levers[0]),0
															TurnCheckpointMonitorsOff(0)
															Exit
														EndIf
													Next
													Exit
													Return
												EndIf
											Next
										EndIf
									EndIf
								EndIf
							EndIf	
						EndIf
						
						
						
						If EntityY(Collider) < -1600*RoomScale Then
							If EntityDistance(Collider, e\room\Objects[8]) > 4750*RoomScale Then
								CameraFogColor Camera, 0,0,0
								CameraClsColor Camera, 0,0,0
								
								DropSpeed = 0
								BlurTimer = 500
								BlurTimer = 1500
								PositionEntity(Collider, EntityX(e\room\obj,True), 0.4, EntityX(e\room\obj,True))
								For r.Rooms = Each Rooms
									If r\RoomTemplate\Name = "room106" Then
										e\EventState = 0
										e\EventState2 = 0
										
										TeleportEntity(Collider,EntityX(r\Objects[10],True),0.4,EntityZ(r\Objects[10],True),0.3,True)
										
										GiveAchievement(AchvPD)
										SecondaryLightOn = PrevSecondaryLightOn
										PrevSecondaryLightOn = 0.0
										
										Curr106\State = 10000
										Curr106\Idle = False
										
										For e2.Events = Each Events
											If e2\EventName = "room2sl"
												e2\EventState3 = 0
												UpdateLever(e2\room\Levers[0])
												RotateEntity e2\room\Levers[0],0,EntityYaw(e2\room\Levers[0]),0
												TurnCheckpointMonitorsOff(0)
												Exit
											EndIf
										Next
										Exit
										Return
									EndIf
								Next
								ResetEntity Collider
								
								e\EventState2 = 0
								UpdateDoorsTimer = 0
								UpdateDoors()
								UpdateRooms()
							Else //the player is not at the exit, must've fallen down
								
								If KillTimer => 0 Then 
									PlaySound_Strict HorrorSFX(8)
									DeathMSG = "In addition to the decomposed appearance typical of the victims of SCP-106, the subject seems to have suffered multiple heavy fractures to both of his legs."
									
								EndIf
								KillTimer = Min(-1, KillTimer)	
								BlurTimer = 3000
							EndIf
						EndIf
						
						UpdateDoorsTimer = 0
						UpdateDoors()
						UpdateRooms()
						
					ElseIf e\EventState2 = 0
						dist# = EntityDistance(Collider, e\room\obj)	
						
						If dist > 1700*RoomScale Then
							BlinkTimer = -10
							
							Select Rand(25)
								Case 1,2,3,4
									PlaySound_Strict(OldManSFX(3))
									
									pvt = CreatePivot()
									PositionEntity(pvt, EntityX(Collider), EntityY(Collider), EntityZ(Collider))
									
									PointEntity(pvt, e\room\obj)
									MoveEntity pvt, 0,0,dist*1.9
									PositionEntity(Collider, EntityX(pvt), EntityY(Collider), EntityZ(pvt))
									ResetEntity Collider
									
									MoveEntity pvt, 0,0,0.8
									PositionEntity(e\room\Objects[10], EntityX(pvt), 0.0, EntityZ(pvt))
									RotateEntity e\room\Objects[10], 0, EntityYaw(pvt), 0, True	
									
									FreeEntity pvt
								Case 5,6,7,8,9,10 
									e\EventState2=1
									BlinkTimer = -10
									PlaySound_Strict(OldManSFX(3))
									
									PositionEntity(Collider, EntityX(e\room\Objects[8],True), 0.5, EntityZ(e\room\Objects[8],True))
									ResetEntity Collider
								Case 11,12 //middle of the large starting room
									BlurTimer = 500
									PositionEntity Collider,EntityX(e\room\obj), 0.5, EntityZ(e\room\obj)
								Case 13,14,15 //"exit room"
									BlurTimer = 1500
									e\EventState2=1
									BlinkTimer = -10
									
									PositionEntity(Collider, EntityX(e\room\Objects[8],True)-400*RoomScale, -304*RoomScale, EntityZ(e\room\Objects[8],True))
									ResetEntity Collider
								Case 16,17,18,19
									BlurTimer = 1500
									For r.Rooms = Each Rooms
										If r\RoomTemplate\Name = "tunnel" Then
											GiveAchievement(AchvPD)
											e\EventState = 0
											e\EventState2 = 0
											
											SecondaryLightOn = PrevSecondaryLightOn
											PrevSecondaryLightOn = 0.0
											TeleportEntity(Collider,EntityX(r\obj,True),0.4,EntityZ(r\obj,True),0.3,True)
											Curr106\State = 250
											Curr106\Idle = False
											
											For e2.Events = Each Events
												If e2\EventName = "room2sl"
													e2\EventState3 = 0
													UpdateLever(e2\room\Levers[0])
													RotateEntity e2\room\Levers[0],0,EntityYaw(e2\room\Levers[0]),0
													TurnCheckpointMonitorsOff(0)
													Exit
												EndIf
											Next
											Exit
											Return
										EndIf
									Next
								Case 20,21,22 //the tower room
									BlinkTimer = -10
									PositionEntity(Collider, EntityX(e\room\Objects[12],True), 0.6, EntityZ(e\room\Objects[12],True))
									ResetEntity Collider
									e\EventState2 = 15
								Case 23,24,25
									BlurTimer = 1500
									e\EventState2=1
									e\EventState3=1
									BlinkTimer = -10
									
									PlaySound_Strict(OldManSFX(3))
									
									PositionEntity(Collider, EntityX(e\room\Objects[8],True), 2288*RoomScale, EntityZ(e\room\Objects[8],True))
									ResetEntity Collider
							End Select 
							
							UpdateDoorsTimer = 0
							UpdateDoors()
							UpdateRooms()
						EndIf					
					Else //pillar room
						CameraFogColor Camera, 38*0.5, 55*0.5, 47*0.5
						CameraClsColor Camera, 38*0.5, 55*0.5, 47*0.5
						
						If ParticleAmount > 0
							If Rand(800)=1 Then 
								angle = EntityYaw(Camera,True)+Rnd(150,210)
								p.Particles = CreateParticle(EntityX(Collider)+Cos(angle)*7.5, 0.0, EntityZ(Collider)+Sin(angle)*7.5, 3, 4.0, 0.0, 2500)
								EntityBlend(p\obj, 2)
								//EntityFX(p\obj, 1)
								p\speed = 0.01
								p\SizeChange = 0
								PointEntity(p\pvt, Camera)
								TurnEntity(p\pvt, 0, 145, 0, True)
								TurnEntity(p\pvt, Rand(10,20), 0, 0, True)
							EndIf
						EndIf
						
						If e\EventState2 > 12 Then 
							Curr106\Idle = True
							PositionEntity(Curr106\Collider, EntityX(e\room\Objects[e\EventState2],True),0.27, EntityZ(e\room\Objects[e\EventState2],True))
							
							PointEntity(Curr106\Collider, Camera)
							TurnEntity(Curr106\Collider, 0, Sin(MilliSecs2() / 20) * 6.0, 0, True)
							MoveEntity(Curr106\Collider, 0, 0, Sin(MilliSecs2() / 15) * 0.06)
							
							ShowEntity Curr106\obj
							ShowEntity Curr106\Collider
							ResetEntity Curr106\Collider
							Curr106\GravityMult = 0.0
							Curr106\DropSpeed = 0
							PositionEntity(Curr106\obj, EntityX(Curr106\Collider), EntityY(Curr106\Collider) - 0.15, EntityZ(Curr106\Collider))
							RotateEntity Curr106\obj, 0, EntityYaw(Curr106\Collider), 0
							
							If Rand(750)=1 And e\EventState2 > 12 Then
								BlinkTimer = -10
								e\EventState2 = e\EventState2-1
								PlaySound_Strict HorrorSFX(8)
							EndIf
							
							If e\EventState2 = 12 Then
								CameraShake = 1.0
								PositionEntity(Curr106\Collider, EntityX(e\room\Objects[e\EventState2],True),-1.0, EntityZ(e\room\Objects[e\EventState2],True))
								Curr106\State = -10
								ResetEntity Curr106\Collider
							EndIf
							
						Else 
							Curr106\State = -10
							Curr106\Idle = False
						EndIf
						
						If EntityY(Collider) < -1600*RoomScale Then
							//player is at the exit
							If Distance(EntityX(e\room\Objects[16],True),EntityZ(e\room\Objects[16],True),EntityX(Collider),EntityZ(Collider))<144*RoomScale Then
								
								CameraFogColor Camera, 0,0,0
								CameraClsColor Camera, 0,0,0
								
								DropSpeed = 0
								BlurTimer = 500
								PositionEntity(Collider, EntityX(e\room\obj), 0.5, EntityZ(e\room\obj))
								ResetEntity Collider
								e\EventState2 = 0
								UpdateDoorsTimer = 0
								UpdateDoors()
								UpdateRooms()
							Else //somewhere else -> must've fallen down
								If KillTimer => 0 Then PlaySound_Strict HorrorSFX(8)
								KillTimer = Min(-1, KillTimer)	
								BlurTimer = 3000
							EndIf
						EndIf 
						
					EndIf
					
				Else
					HideEntity e\room\obj
					//CameraClsColor Camera, 0,0,0
					e\EventState = 0
					e\EventState2 = 0
					e\EventState3 = 0
					e\EventStr = Float(0)
				EndIf
				
			Case "room2cafeteria"
				
				If PlayerRoom = e\room Then
					If Not Using294 Then
						If EntityDistance(e\room\Objects[0], Collider)<1.5 Then
							GiveAchievement(Achv294)
							If EntityInView(e\room\Objects[0], Camera) Then
								DrawHandIcon = True
								If MouseHit1 Then
									temp = True
									For it.Items = Each Items
										If it\Picked=False Then
											If EntityX(it\collider)-EntityX(e\room\Objects[1],True)=0 Then
												If EntityZ(it\collider)-EntityZ(e\room\Objects[1],True)=0 Then
													temp = False
													Exit
												EndIf
											EndIf
										EndIf
									Next
									Local inserted% = False
									If e\EventState2 < 2 Then
										If SelectedItem<>Null Then
											If SelectedItem\itemtemplate\tempname="25ct" Or SelectedItem\itemtemplate\tempname="coin" Then
												RemoveItem(SelectedItem)
												SelectedItem=Null
												e\EventState2 = e\EventState2 + 1
												PlaySound_Strict LoadTempSound("SFX\SCP\294\coin_drop.ogg")
												inserted = True
											EndIf
										EndIf
									EndIf
									If e\EventState2 = 2 Then
										Using294=temp
										If Using294 Then MouseHit1=False
									ElseIf e\EventState2 = 1 And (Not inserted) Then
										Using294=False
										Msg = "You need to insert another Quarter in order to use this machine."
										MsgTimer = 70*5
									ElseIf (Not inserted) Then
										Using294=False
										Msg = "You need to insert two Quarters in order to use this machine."
										MsgTimer = 70*5
									EndIf
								EndIf
							EndIf
						EndIf
					EndIf		
				EndIf
				
				If e\EventState = 0 Then
					CreateNPC(NPCtype066, EntityX(e\room\obj), 0.5, EntityZ(e\room\obj))
					e\EventState = 1
				EndIf
				
			Case "room2ccont"
				
				If PlayerRoom = e\room Then
					
					EntityPick(Camera, 1.5)
					
					If PickedEntity() = e\room\Objects[3]
						If e\EventState = 0
							e\EventState = Max(e\EventState,1)
							PlaySound_Strict HorrorSFX(7)
							PlaySound_Strict LeverSFX
						EndIf 
					EndIf
					
					//Primary Lighting
					UpdateLever(e\room\Objects[1])
					
					//Secondary Lighting
					Local prevstate2 = e\EventState2
					e\EventState2 = UpdateLever(e\room\Objects[3])
					If (prevstate2 <> e\EventState2) And e\EventState>0 Then PlaySound2(LightSFX, Camera, e\room\Objects[3])
					If e\EventState2
						SecondaryLightOn = CurveValue(1.0, SecondaryLightOn, 10.0)
					Else
						SecondaryLightOn = CurveValue(0.0, SecondaryLightOn, 10.0)
					EndIf
					
					//Remote Door Control
					RemoteDoorOn = UpdateLever(e\room\Objects[5])
					
					If e\EventState > 0 And e\EventState < 200 Then
						e\EventState = e\EventState + FPSfactor
						RotateEntity(e\room\Objects[3], CurveValue(-85, EntityPitch(e\room\Objects[3]), 5), EntityYaw(e\room\Objects[3]), 0)
					EndIf 
					
				EndIf
				
			Case "room2closets"
				
				If e\EventState = 0 Then
					If PlayerRoom = e\room And Curr173\Idle<2 Then
						If e\EventStr = "" And QuickLoadPercent = -1
							QuickLoadPercent = 0
							QuickLoad_CurrEvent = e
							e\EventStr = "load0"
						EndIf
					EndIf
				Else
					e\EventState=e\EventState+FPSfactor
					If e.EventState < 70*3.5 Then
						RotateEntity(e.room.NPC[1].Collider,0,CurveAngle(e.room.angle+90,EntityYaw(e.room.NPC[1].Collider),100.0),0,True)
						
						e.room.NPC[0].State=1
						if (e.EventState > 70*3.2 And e.EventState-FPSfactor =< 70*3.2) {PlaySound2(IntroSFX(15),Camera,e.room.obj,15.0)}
					ElseIf e.EventState < 70*6.5
						If e.EventState-FPSfactor < 70*3.5 Then
							e.room.NPC[0].State=0
							e.room.NPC[1].SoundChn = PlaySound2(e.room.NPC[1].Sound, Camera, e.room.NPC[1].Collider,12.0)
						EndIf
						
						If e.EventState > 70*4.5 Then
							PointEntity(e.room.NPC[0].obj, e.room.obj)
							RotateEntity(e.room.NPC[0].Collider,0,CurveAngle(EntityYaw(e.room.NPC[0].obj),EntityYaw(e.room.NPC[0].Collider),30.0),0,True)
						EndIf
						PointEntity e.room.NPC[1].obj, e.room.obj
						TurnEntity e.room.NPC[1].obj, 0, Sin(e.EventState)*25, 0
						RotateEntity(e.room.NPC[1].Collider,0,CurveAngle(EntityYaw(e.room.NPC[1].obj),EntityYaw(e.room.NPC[1].Collider),30.0),0,True)
					Else
						If e.EventState-FPSfactor < 70*6.5 Then 
							PlaySound_Strict (HorrorSFX(0))
							PlaySound_Strict (LightSFX)
						EndIf
						BlinkTimer = Max((70*6.5-e.EventState)/5.0 - Rnd(0.0,2.0),-10)
						If BlinkTimer =-10 Then
							If e.EventState > 70*7.5 And e.EventState-FPSfactor =< 70*7.5 Then
								PlaySound2(NeckSnapSFX(0),Camera,e.room.NPC[0].Collider,8.0)
								//Wallet spawning (with 3 coins)
								it.Items = CreateItem("Wallet","wallet",EntityX(e.room.NPC[0].Collider,True),EntityY(e.room.NPC[0].Collider,True),EntityZ(e.room.NPC[0].Collider,True))
								EntityType(it.collider, HIT_ITEM)
								PointEntity it.collider,e.room.NPC[1].Collider
								MoveEntity it.collider,-0.4,0,-0.2
								TeleportEntity(it.collider,EntityX(it.collider),EntityY(it.collider),EntityZ(it.collider),-0.02,True,10)
								For i = 0 To 1
									it2.Items = CreateItem("Quarter","25ct",1,1,1)
									it2.Picked = True
									it2.Dropped = -1
									it2.itemtemplate.found=True
									it.SecondInv[i] = it2
									HideEntity(it2.collider)
									EntityType(it2.collider, HIT_ITEM)
								Next
							EndIf
							If e.EventState > 70*8.0 And e.EventState-FPSfactor =< 70*8.0 Then
								PlaySound2(NeckSnapSFX(1),Camera,e.room.NPC[1].Collider,8.0)
							EndIf
							SetNPCFrame e\room\NPC[0], 60
							e\room\NPC[0]\State=8
							
							SetNPCFrame e\room\NPC[1], 19
							e\room\NPC[1]\State = 6
						EndIf
						
						If e\EventState > 70*8.5 Then
							PositionEntity Curr173\Collider, (EntityX(e\room\Objects[0],True)+EntityX(e\room\Objects[1],True))/2,EntityY(e\room\Objects[0],True),(EntityZ(e\room\Objects[0],True)+EntityZ(e\room\Objects[1],True))/2
							PointEntity Curr173\Collider, Collider
							ResetEntity Curr173\Collider
							RemoveEvent(e)
						EndIf
					EndIf
				EndIf
				
			Case "room2doors173"
				
				If PlayerRoom = e\room Then
					If e\EventState = 0 And Curr173\Idle = 0 Then
						If (Not EntityInView(Curr173\obj, Camera)) Then
							e\EventState = 1
							PositionEntity(Curr173\Collider, EntityX(e\room\Objects[0], True), 0.5, EntityZ(e\room\Objects[0], True))
							ResetEntity(Curr173\Collider)
							RemoveEvent(e)
						EndIf
					EndIf
				EndIf
				
			Case "room2elevator"
				
				If e\EventState = 0 Then
					If e\room\dist < 8.0 And e\room\dist > 0 Then
						e\room\NPC[0]=CreateNPC(NPCtypeGuard, EntityX(e\room\obj,True), 0.5, EntityZ(e\room\obj,True))
						PointEntity e\room\NPC[0]\Collider, Collider
						RotateEntity e\room\NPC[0]\Collider, 0, EntityYaw(e\room\NPC[0]\Collider),0, True	
						
						e\EventState = 1
					EndIf
				Else
					If e\EventState = 1 Then
						If e\room\dist<5.0 Or Rand(700)=1 Then 
							e\EventState = 2
							
							e\room\NPC[0]\State = 5
							e\room\NPC[0]\EnemyX = EntityX(e\room\Objects[1],True)
							e\room\NPC[0]\EnemyY = EntityY(e\room\Objects[1],True)
							e\room\NPC[0]\EnemyZ = EntityZ(e\room\Objects[1],True)
						EndIf
					ElseIf e\EventState = 2
						If EntityDistance(e\room\NPC[0]\Collider,e\room\Objects[1])<2.0 Then
							e\room\RoomDoors[0]\open = False
							PlaySound2(CloseDoorSFX(3, 0), Camera, e\room\RoomDoors[0]\obj, 8.0)			
							
							PlaySound_Strict (LoadTempSound("SFX/Room/Room2ElevatorDeath.ogg"))
							
							e\EventState = 2.05
						EndIf
					ElseIf e\EventState < 13*70
						e\EventState = e\EventState+FPSfactor
						//6.7 - 7.4
						//8.6 - 10
						If e\EventState > 6.7*70 And e\EventState < 7.4*70 Then
							CameraShake = 7.4-(e\EventState/70.0)
						ElseIf e\EventState > 8.6*70 And e\EventState < 10.6*70 
							CameraShake = 10.6-(e\EventState/70.0)
						ElseIf e\EventState > 12.6*70
							CameraShake = 0
							If e\EventState-FPSfactor < 12.6*70 And e\room\NPC[0]<>Null Then
								RemoveNPC(e\room\NPC[0])
								e\room\NPC[0]=Null
								
								de.Decals = CreateDecal(3, EntityX(e\room\Objects[0],True), 0.0005, EntityZ(e\room\Objects[0],True),90,Rnd(360),0)
								
								de.Decals = CreateDecal(17, EntityX(e\room\Objects[0],True), 0.002, EntityZ(e\room\Objects[0],True),90,Rnd(360),0)
								de\size = 0.5
								
								de.Decals = CreateDecal(3, EntityX(e\room\Objects[1],True), EntityY(e\room\Objects[1],True), EntityZ(e\room\Objects[1],True),0,e\room\angle+270,0)
								de\size = 0.9
							EndIf
							e\room\RoomDoors[0]\locked = False
						EndIf
					Else
						If e\room\RoomDoors[0]\open Then e\room\RoomDoors[0]\locked = True : RemoveEvent(e)
					EndIf
				EndIf
				
			Case "room2elevator2"
				
				If e\room\dist < 8.0 And e\room\dist > 0 Then
					
					de.Decals = CreateDecal(3, EntityX(e\room\Objects[0],True), 0.0005, EntityZ(e\room\Objects[0],True),90,Rnd(360),0)
					
					e\room\NPC[0]=CreateNPC(NPCtypeD, EntityX(e\room\Objects[0],True), 0.5, EntityZ(e\room\Objects[0],True))
					ChangeNPCTextureID(e\room\NPC[0],0)
					
					RotateEntity e\room\NPC[0]\Collider, 0, EntityYaw(e\room\obj)-80,0, True	
					
					SetNPCFrame e\room\NPC[0], 19
					e\room\NPC[0]\State=8
					
					RemoveEvent(e)
				EndIf
				
			Case "room2fan"
				
				//eventstate1 = timer for turning the fan on/off
				//eventstate2 = fan on/off
				//eventstate3 = the speed of the fan
				If PlayerRoom = e\room Then
					TurnEntity (e\room\Objects[0], e\EventState3*FPSfactor, 0, 0)
					If e\EventState3 > 0.01 Then
						e\room\SoundCHN = LoopSound2 (RoomAmbience[9], e\room\SoundCHN, Camera, e\room\Objects[0], 5.0, (e\EventState3/4.0))
					EndIf
					e\EventState3 = CurveValue(e\EventState2*5, e\EventState3, 150.0)			
				EndIf
				
				If e\room\dist < 16.0 Then 
					If e\EventState < 0 Then
						e\EventState = Rand(15,30)*70
						temp = e\EventState2
						e\EventState2 = Rand(0,1)
						If PlayerRoom<>e\room Then
							e\EventState3 = e\EventState2*5
						Else
							If temp = 0 And e\EventState2 = 1.0 Then //turn on the fan
								PlaySound2 (LoadTempSound("SFX\ambient\Room ambience\FanOn.ogg"), Camera, e\room\Objects[0], 8.0)
							ElseIf temp = 1 And e\EventState2 = 0.0 //turn off the fan
								PlaySound2 (LoadTempSound("SFX\ambient\Room ambience\FanOff.ogg"), Camera, e\room\Objects[0], 8.0)
							EndIf
						EndIf
					Else
						e\EventState = e\EventState-FPSfactor
					EndIf					
				EndIf
				
			Case "room2nuke"
				
				If PlayerRoom = e\room Then
					e\EventState2 = UpdateElevators(e\EventState2, e\room\RoomDoors[0], e\room\RoomDoors[1], e\room\Objects[4], e\room\Objects[5], e)
					
					e\EventState = UpdateLever(e\room\Objects[1])
					UpdateLever(e\room\Objects[3])
				EndIf
				
				If e\EventState3 = 0 Then
					n.NPCs = CreateNPC(NPCtypeD,EntityX(e\room\Objects[6],True),0.5,EntityZ(e\room\Objects[6],True))
					RotateEntity n\Collider,0,e\room\angle+90,0
					n\State = 3
					SetNPCFrame(n,40)
					n\IsDead = True
					n\texture = "GFX\npcs\body2.jpg"
					tex = LoadTexture_Strict(n\texture)
					EntityTexture(n\obj, tex)
					FreeTexture tex
					e\EventState3 = 1
				EndIf
				
			Case "room2offices2"
				
				If PlayerRoom = e\room Then
					If BlinkTimer<-8 And BlinkTimer >-12 Then
						temp = Rand(1,4)
						PositionEntity e\room\Objects[0], EntityX(e\room\Objects[temp],True),EntityY(e\room\Objects[temp],True),EntityZ(e\room\Objects[temp],True),True
						RotateEntity e\room\Objects[0], 0, Rnd(360), 0
					EndIf
				EndIf
				
			Case "room2offices3"
				
				If PlayerRoom = e\room Then
					e\EventState = e\EventState+FPSfactor
					If e\EventState > 700 Then
						If EntityDistance(e\room\RoomDoors[0]\obj, Collider)>0.5 Then 
							If EntityInView(e\room\RoomDoors[0]\obj, Camera)=False Then
								DebugLog "%@@= \ {2E6C2=FD gi`h]c"
								e\room\RoomDoors[0]\open = False
								RemoveEvent(e)
							EndIf
						EndIf
					EndIf
				EndIf
				
			Case "room2tesla"
				
				temp = True
				If e\EventState2 > 70*3.5 And e\EventState2 < 70*90 Then temp = False
				
				If temp And EntityY(Collider, True) > EntityY(e\room\obj,True) And EntityY(Collider, True) < 4.0 Then
					
					If e\Sound = 0 Then e\Sound = LoadSound_Strict("SFX/Room/Tesla\Shock.ogg")
					
					If e\EventState = 0 Then
						If e\room\dist < 8 Then
							HideEntity e\room\Objects[3]
							If (MilliSecs2() Mod 1500) < 800 Then
								ShowEntity e\room\Objects[4]
							Else
								HideEntity e\room\Objects[4]
							EndIf			
							
							If e\SoundCHN = 0 Then //humming when the player isn't close
								e\SoundCHN = PlaySound2(TeslaIdleSFX, Camera, e\room\Objects[3],4.0,0.5)
							Else
								If Not ChannelPlaying(e\SoundCHN) Then e\SoundCHN = PlaySound2(TeslaIdleSFX, Camera, e\room\Objects[3],4.0,0.5)
							EndIf
							
							For i = 0 To 2
								If Distance(EntityX(Collider),EntityZ(Collider),EntityX(e\room\Objects[i],True),EntityZ(e\room\Objects[i],True)) < 300.0*RoomScale Then
									//play the activation sound
									If KillTimer => 0 Then 
										PlayerSoundVolume = Max(8.0,PlayerSoundVolume)
										StopChannel(e\SoundCHN)
										e\SoundCHN = PlaySound2(TeslaActivateSFX, Camera, e\room\Objects[3],4.0,0.5)
										e\EventState = 1
										Exit
									EndIf
								EndIf
							Next
							
							Local temp2 = True
							For e2.Events = Each Events
								If e2\EventName = e\EventName And e2 <> e
									If e2\EventStr <> ""
										temp2 = False
										e\EventStr = "done"
										Exit
									EndIf
								EndIf
							Next
							
							Local temp3 = 0
							If temp2
								If e\EventStr = "" And PlayerRoom = e\room
									If EntityDistance(e\room\Objects[5],Collider)<EntityDistance(e\room\Objects[6],Collider)
										temp3 = 6
									Else
										temp3 = 5
									EndIf
									
									e\room\NPC[0] = CreateNPC(NPCtypeClerk,EntityX(e\room\Objects[temp3],True),0.5,EntityZ(e\room\Objects[temp3],True))
									PointEntity e\room\NPC[0]\Collider,e\room\Objects[2]
									e\room\NPC[0]\State = 2
									e\EventStr = "step1"
									e\EventState = 0
									e\EventState2 = 0
									e\EventState3 = 0
								EndIf
							EndIf
						Else
							HideEntity e\room\Objects[4]
						EndIf
						
						If Curr106\State < -10 And e\EventState = 0 Then 
							For i = 0 To 2
								If Distance(EntityX(Curr106\Collider),EntityZ(Curr106\Collider),EntityX(e\room\Objects[i],True),EntityZ(e\room\Objects[i],True)) < 300.0*RoomScale Then
									//play the activation sound
									If KillTimer => 0 Then 
										StopChannel(e\SoundCHN)
										e\SoundCHN = PlaySound2(TeslaActivateSFX, Camera, e\room\Objects[3],4.0,0.5)
										HideEntity e\room\Objects[4]
										e\EventState = 1
										Curr106\State = 70 * 60 * Rand(10,13)
										GiveAchievement(AchvTesla)
										Exit
									EndIf
								EndIf
							Next
						EndIf
					Else
						e\EventState = e\EventState+FPSfactor
						If e\EventState =< 40 Then
							HideEntity e\room\Objects[3]
							If (MilliSecs2() Mod 100) < 50 Then
								ShowEntity e\room\Objects[4]
							Else
								HideEntity e\room\Objects[4]
							EndIf
						Else
							If e\room\dist < 2
							If e\EventState-FPSfactor =< 40 Then PlaySound_Strict(e\Sound)	
							Else
								If e\EventState-FPSfactor =< 40 Then PlaySound2(e\Sound,Camera,e\room\Objects[2])
							EndIf
							If e\EventState < 70 Then 
								
								If KillTimer => 0 Then 
									For i = 0 To 2
										If Distance(EntityX(Collider),EntityZ(Collider),EntityX(e\room\Objects[i],True),EntityZ(e\room\Objects[i],True)) < 250.0*RoomScale Then
											ShowEntity Light
											LightFlash = 0.4
											CameraShake = 1.0
											Kill()
											DeathMSG = "Subject D-9341 killed by the Tesla gate at [REDACTED]."
										EndIf
									Next
								EndIf
								
								If e\EventStr = "step1"
									e\room\NPC[0]\State = 3
								EndIf
								
								If Curr106\State < -10 Then
									For i = 0 To 2
										If Distance(EntityX(Curr106\Collider),EntityZ(Curr106\Collider),EntityX(e\room\Objects[i],True),EntityZ(e\room\Objects[i],True)) < 250.0*RoomScale Then
											ShowEntity Light
											LightFlash = 0.3
											If ParticleAmount > 0
												For i = 0 To 5+(5*(ParticleAmount-1))
													p.Particles = CreateParticle(EntityX(Curr106\Collider, True), EntityY(Curr106\Collider, True), EntityZ(Curr106\Collider, True), 0, 0.015, -0.2, 250)
													p\size = 0.03
													p\gravity = -0.2
													p\lifetime = 200
													p\SizeChange = 0.005
													p\speed = 0.001
													RotateEntity(p\pvt, Rnd(360), Rnd(360), 0, True)
												Next
											EndIf
											Curr106\State = -20000
											TranslateEntity(Curr106\Collider,0,-50.0,0,True)
										EndIf
									Next								
								EndIf
								
								HideEntity e\room\Objects[3]
								HideEntity e\room\Objects[4]
								
								If Rand(5)<5 Then 
									PositionTexture TeslaTexture,0.0,Rnd(0,1.0)
									ShowEntity e\room\Objects[3]								
								EndIf
							Else 
								If e\EventState-FPSfactor < 70 Then 
									StopChannel(e\SoundCHN)	
									e\SoundCHN = PlaySound2(TeslaPowerUpSFX, Camera, e\room\Objects[3],4.0,0.5)
								EndIf 
								HideEntity e\room\Objects[3]
								
								If e\EventState > 150 Then e\EventState = 0
							EndIf
						EndIf
					EndIf
				Else
					HideEntity e\room\Objects[4]
				EndIf
				
				If e\room\NPC[0] <> Null
					If e\EventStr = "step1" And e\room\NPC[0]\State <> 3
						If e\EventState = 0
							For i = 0 To 2
								If Distance(EntityX(e\room\NPC[0]\Collider),EntityZ(e\room\NPC[0]\Collider),EntityX(e\room\Objects[i],True),EntityZ(e\room\Objects[i],True)) < 400.0*RoomScale
									StopChannel(e\SoundCHN)
									e\SoundCHN = PlaySound2(TeslaActivateSFX, Camera, e\room\Objects[3],4.0,0.5)
									HideEntity e\room\Objects[4]
									e\EventState = 1
									Exit
								EndIf
							Next
						EndIf
					ElseIf e\EventStr = "step1" And e\room\NPC[0]\State = 3
						e\room\NPC[0]\CurrSpeed = 0
						AnimateNPC(e\room\NPC[0],41,60,0.5,False)
						If e\room\NPC[0]\Frame = 60
							e\room\NPC[0]\IsDead = True
							e\EventStr = "step2"
							SetNPCFrame(e\room\NPC[0],57)
						EndIf
					ElseIf e\EventStr = "step2"
						AnimateNPC(e\room\NPC[0],57,60,0.5,False)
						If e\room\NPC[0]\Frame = 60
							e\EventStr = "0"
						EndIf
					ElseIf e\EventStr <> "" And e\EventStr <> "step1" And e\EventStr <> "done"
						If Float(e\EventStr) < 70*10 Then
							If ParticleAmount > 0 Then
								If Rand(20-(10*(ParticleAmount-1)))=1 Then
									//p.Particles = CreateParticle(EntityX(e\room\NPC[0]\Collider),EntityY(e\room\NPC[0]\obj)+0.05,EntityZ(e\room\NPC[0]\Collider),6,0.05,0,60)
									p.Particles = CreateParticle(EntityX(e\room\NPC[0]\Collider),EntityY(e\room\NPC[0]\obj)+0.05,EntityZ(e\room\NPC[0]\Collider),0,0.05,0,60)
									p\speed = 0.002
									RotateEntity(p\pvt, 0, EntityYaw(e\room\NPC[0]\Collider), 0)
									MoveEntity p\pvt,Rnd(-0.1,0.1),0,0.1+Rnd(0,0.5)
									RotateEntity(p\pvt, -90, EntityYaw(e\room\NPC[0]\Collider), 0)
									p\Achange = -0.02
								EndIf
							EndIf
							e\EventStr = Float(e\EventStr) + FPSfactor
						Else
							e\EventStr = "done"
						EndIf
					EndIf
				EndIf
				
				If PlayerRoom\RoomTemplate\Name <> "pocketdimension" And PlayerRoom\RoomTemplate\Name <> "room860" Then
					If e\EventState2 = 0 Then
						If e\EventState3 <=0 Then 
							temp = False
							For n.NPCs = Each NPCs
								If n\NPCtype = NPCtypeMTF Then
									If Abs(EntityX(n\Collider)-EntityX(e\room\obj,True))<4.0 Then
										If Abs(EntityZ(n\Collider)-EntityZ(e\room\obj,True))<4.0 Then
											temp = True
											If e\EventState2 = 0 Then
												n\Sound = LoadSound_Strict("SFX\Character\MTF\Tesla0.ogg")
												PlayMTFSound(n\Sound,n)
												
												//LoadEventSound(e,"SFX\Character\MTF\Tesla1.ogg")
												//e\SoundCHN = PlaySound_Strict (e\Sound)
												//PlayAnnouncement("SFX\Character\MTF\Tesla"+Rand(1,3)+".ogg")
												n\Idle = 70*10
												e\EventState2 = 70*100
											EndIf
										EndIf
									EndIf
								EndIf
							Next
							If temp = False Then e\EventState2=70*3.5
							e\EventState3=e\EventState3+140
						Else
							e\EventState3=e\EventState3-FPSfactor
						EndIf
					Else
						If e\EventState2 => 70*92 And e\EventState2-FPSfactor < 70*92
							PlayAnnouncement("SFX\Character\MTF\Tesla"+Rand(1,3)+".ogg")
						EndIf
						
						e\EventState2 = Max(e\EventState2-FPSfactor,0)
					EndIf					
				EndIf
				
				
			Case "room2trick"
				
				If PlayerRoom = e\room Then
					If EntityDistance(e\room\obj,Collider)<2.0 Then
						If EntityDistance(Collider, Curr173\obj)<6.0 Or EntityDistance(Collider, Curr106\obj)<6.0 Then
							RemoveEvent(e)
						Else
							DebugLog "%@@= \ {2E6C2=FD gi`h]c"
							
							pvt = CreatePivot()
							PositionEntity pvt, EntityX(Collider),EntityY(Collider),EntityZ(Collider)
							PointEntity pvt, e\room\obj
							RotateEntity pvt, 0, EntityYaw(pvt),0,True
							MoveEntity pvt, 0,0,EntityDistance(pvt,e\room\obj)*2
							
							//CameraShake = 5.0
							//BlurTimer = 100
							
							BlinkTimer = -10
							
							PlaySound_Strict HorrorSFX(11)//DripSFX(0)
							
							PositionEntity Collider, EntityX(pvt),EntityY(pvt)+0.05,EntityZ(pvt)
							UpdateWorld()
							//ResetEntity Collider
							
							TurnEntity Collider, 0,180,0
							
							FreeEntity pvt
							RemoveEvent(e)							
						EndIf
					EndIf
				EndIf
				
			Case "room2tunnel"	
				
				
				If EntityY(Collider,True)>=8.0 And EntityY(Collider,True)<=12.0 Then
					If (EntityX(Collider,True)>=e\room\x-6.0) And (EntityX(Collider,True)<=(e\room\x+2.0*gridsz+6.0)) Then
						If (EntityZ(Collider,True)>=e\room\z-6.0) And (EntityZ(Collider,True)<=(e\room\z+2.0*gridsz+6.0)) Then
							PlayerRoom=e\room
						EndIf
					EndIf
				EndIf
				
				If PlayerRoom = e\room Then
					
					
					Local Meshes%[7]
					Local tempStr$
					
					Local ia%,ib%,ic%,id%
					Local dr.Doors
					
					Local tempInt%,tempInt2%
					Local ix%,iy%
					
					If I_Zone\HasCustomMT Then
						If e\room\grid\Meshes[0]=0 Then
							PlaceGrid_MapCreator(e\room)
						EndIf
					EndIf
					
					If e\room\grid = Null Then
						
						e\room\grid = New Grids
						
						oldSeed% = RndSeed()
						SeedRnd GenerateSeedNumber(RandomSeed)
						
						Local dir%
						
						dir=Rand(0,1) Shl 1
						//0 = right
						//1 = up
						//2 = left
						//3 = down
						
						ix=gridsz/2+Rand(-2,2)
						iy=gridsz/2+Rand(-2,2)
						
						e\room\grid\grid[ix+(iy*gridsz)]=1
						
						If dir=2 Then e\room\grid\grid[(ix+1)+(iy*gridsz)]=1 Else e\room\grid\grid[(ix-1)+(iy*gridsz)]=1
						
						Local count% = 2
						
						While count<100
							tempInt=Rand(1,5) Shl Rand(1,2)
							For i=1 To tempInt
								
								tempInt2=True
								
								Select dir
									Case 0
										If ix<gridsz-2-(i Mod 2) Then ix=ix+1 Else tempInt2=False
									Case 1
										If iy<gridsz-2-(i Mod 2) Then iy=iy+1 Else tempInt2=False
									Case 2
										If ix>1+(i Mod 2) Then ix=ix-1 Else tempInt2=False
									Case 3
										If iy>1+(i Mod 2) Then iy=iy-1 Else tempInt2=False
								End Select
								
								If tempInt2 Then
									If e\room\grid\grid[ix+(iy*gridsz)]=0 Then
										e\room\grid\grid[ix+(iy*gridsz)]=1
										count=count+1
									EndIf
								Else
									Exit
								EndIf
							Next
							dir=dir+((Rand(0,1) Shl 1)-1)
							While dir<0
								dir=dir+4
							Wend
							While dir>3
								dir=dir-4
							Wend
						Wend
						
						//generate the tunnels
						For iy=0 To gridsz-1
							For ix=0 To gridsz-1
								If e\room\grid\grid[ix+(iy*gridsz)]>0 Then
									e\room\grid\grid[ix+(iy*gridsz)]=(e\room\grid\grid[(ix)+((iy+1)*gridsz)]>0)+(e\room\grid\grid[(ix)+((iy-1)*gridsz)]>0)+(e\room\grid\grid[(ix+1)+((iy)*gridsz)]>0)+(e\room\grid\grid[(ix-1)+((iy)*gridsz)]>0)
								EndIf
							Next
						Next
						
						Local maxX%=gridsz-1
						Local canRetry%=0
						
						For ix=0 To maxX
							For iy=0 To gridsz-1
								If e\room\grid\grid[ix+1+(iy*gridsz)]>0 Then
									maxX=ix
									If (e\room\grid\grid[ix+1+((iy+1)*gridsz)]<3) And (e\room\grid\grid[ix+1+((iy-1)*gridsz)]<3) Then
										canRetry=1
										If Rand(0,1)=1 Then
											e\room\grid\grid[ix+1+((iy)*gridsz)]=e\room\grid\grid[ix+1+((iy)*gridsz)]+1
											e\room\grid\grid[ix+((iy)*gridsz)]=7 //generator room
											canRetry=0
											Exit
										EndIf
									EndIf
								EndIf
							Next
							If canRetry Then ix=ix-1
						Next
						
						Local firstX%,lastX%
						Local firstY%,lastY%
						
						firstX=-1
						lastY=-1
						firstX=-1
						lastY=-1
						
						For iy=0 To gridsz-1
							For ix=0 To gridsz-1
								If e\room\grid\grid[ix+(iy*gridsz)]=2 Then
									If e\room\grid\grid[(ix+1)+((iy)*gridsz)]>0 And e\room\grid\grid[(ix-1)+((iy)*gridsz)]>0 Then //horizontal
										If firstX=-1 Or firstY=-1 Then
											If e\room\grid\grid[ix-1+(iy*gridsz)]<3 And e\room\grid\grid[ix+1+(iy*gridsz)]<3 And e\room\grid\grid[ix+((iy-1)*gridsz)]<3 And e\room\grid\grid[ix+((iy+1)*gridsz)]<3 Then
												If e\room\grid\grid[ix-1+((iy-1)*gridsz)]<1 And e\room\grid\grid[ix+1+((iy-1)*gridsz)]<1 And e\room\grid\grid[ix+1+((iy-1)*gridsz)]<1 And e\room\grid\grid[ix-1+((iy+1)*gridsz)]<1 Then
													firstX=ix : firstY=iy
												EndIf
											EndIf
										EndIf
										If e\room\grid\grid[ix-1+(iy*gridsz)]<3 And e\room\grid\grid[ix+1+(iy*gridsz)]<3 And e\room\grid\grid[ix+((iy-1)*gridsz)]<3 And e\room\grid\grid[ix+((iy+1)*gridsz)]<3 Then
											If e\room\grid\grid[ix-1+((iy-1)*gridsz)]<1 And e\room\grid\grid[ix+1+((iy-1)*gridsz)]<1 And e\room\grid\grid[ix+1+((iy-1)*gridsz)]<1 And e\room\grid\grid[ix-1+((iy+1)*gridsz)]<1 Then
												lastX=ix : lastY=iy
											EndIf
										EndIf
									ElseIf e\room\grid\grid[(ix)+((iy+1)*gridsz)]>0 And e\room\grid\grid[(ix)+((iy-1)*gridsz)]>0 Then //vertical
										If firstX=-1 Or firstY=-1 Then
											If e\room\grid\grid[ix-1+(iy*gridsz)]<3 And e\room\grid\grid[ix+1+(iy*gridsz)]<3 And e\room\grid\grid[ix+((iy-1)*gridsz)]<3 And e\room\grid\grid[ix+((iy+1)*gridsz)]<3 Then
												If e\room\grid\grid[ix-1+((iy-1)*gridsz)]<1 And e\room\grid\grid[ix+1+((iy-1)*gridsz)]<1 And e\room\grid\grid[ix+1+((iy-1)*gridsz)]<1 And e\room\grid\grid[ix-1+((iy+1)*gridsz)]<1 Then
													firstX=ix : firstY=iy
												EndIf
											EndIf
										EndIf
										If e\room\grid\grid[ix-1+(iy*gridsz)]<3 And e\room\grid\grid[ix+1+(iy*gridsz)]<3 And e\room\grid\grid[ix+((iy-1)*gridsz)]<3 And e\room\grid\grid[ix+((iy+1)*gridsz)]<3 Then
											If e\room\grid\grid[ix-1+((iy-1)*gridsz)]<1 And e\room\grid\grid[ix+1+((iy-1)*gridsz)]<1 And e\room\grid\grid[ix+1+((iy-1)*gridsz)]<1 And e\room\grid\grid[ix-1+((iy+1)*gridsz)]<1 Then
												lastX=ix : lastY=iy
											EndIf
										EndIf
									EndIf
								EndIf
							Next
						Next
						
						If lastX=firstX And lastY=firstY Then
							RuntimeError("The maintenance tunnels could not be generated properly!")
						EndIf
						
						//place the tunnels
						
						For i=0 To 6
							Meshes[i]=CopyEntity(OBJTunnel(i))
							//Meshes[i]=LoadRMesh("GFX\map\mt"+tempStr+".rmesh",Null)
							DebugLog i
							HideEntity Meshes[i]
						Next
						
						FreeTextureCache
						
						tempInt=0
						
						For iy=0 To gridsz-1
							For ix=0 To gridsz-1
								If e\room\grid\grid[ix+(iy*gridsz)]>0 Then
									
									Select e\room\grid\grid[ix+(iy*gridsz)]
										Case 1,7
											
											tempInt%=CopyEntity(Meshes[e\room\grid\grid[ix+(iy*gridsz)]-1])
											
											If e\room\grid\grid[(ix+1)+((iy)*gridsz)]>0 Then
												RotateEntity tempInt,0,90,0
												e\room\grid\angles[ix+(iy*gridsz)]=1
											ElseIf e\room\grid\grid[(ix-1)+((iy)*gridsz)]>0 Then
												RotateEntity tempInt,0,270,0
												e\room\grid\angles[ix+(iy*gridsz)]=3
											ElseIf e\room\grid\grid[(ix)+((iy+1)*gridsz)]>0 Then
												RotateEntity tempInt,0,180,0
												e\room\grid\angles[ix+(iy*gridsz)]=2
											Else
												RotateEntity tempInt,0,0,0
												e\room\grid\angles[ix+(iy*gridsz)]=0
											EndIf
										Case 2
											
											If (ix=firstX And iy=firstY) Or (ix=lastX And iy=lastY) Then
												e\room\grid\grid[ix+(iy*gridsz)]=6
											EndIf
											
											If e\room\grid\grid[(ix+1)+((iy)*gridsz)]>0 And e\room\grid\grid[(ix-1)+((iy)*gridsz)]>0 Then ;horizontal
												tempInt%=CopyEntity(Meshes[e\room\grid\grid[ix+(iy*gridsz)]-1])
												
												AddLight%(Null, e\room\x+ix*2.0, 8.0+(368.0*RoomScale), e\room\z+iy*2.0, 2, 500.0 * RoomScale, 255, 255, 255)
												
												tempInt2=Rand(0,1)
												RotateEntity tempInt,0.0,tempInt2*180.0+90,0.0
												
												e\room\grid\angles[ix+(iy*gridsz)]=(tempInt2*2)+1
											ElseIf e\room\grid\grid[(ix)+((iy+1)*gridsz)]>0 And e\room\grid\grid[(ix)+((iy-1)*gridsz)]>0 Then ;vertical
												tempInt%=CopyEntity(Meshes[e\room\grid\grid[ix+(iy*gridsz)]-1])
												
												AddLight%(Null, e\room\x+ix*2.0, 8.0+(368.0*RoomScale), e\room\z+iy*2.0, 2, 500.0 * RoomScale, 255, 255, 255)
												
												tempInt2=Rand(0,1)
												RotateEntity tempInt,0.0,tempInt2*180.0,0.0
												e\room\grid\angles[ix+(iy*gridsz)]=(tempInt2*2)
											Else
												tempInt%=CopyEntity(Meshes[e\room\grid\grid[ix+(iy*gridsz)]])
												
												AddLight%(Null, e\room\x+ix*2.0, 8.0+(412.0*RoomScale), e\room\z+iy*2.0, 2, 500.0 * RoomScale, 255, 255, 255)
												
												ia=e\room\grid\grid[(ix)+((iy+1)*gridsz)]
												ib=e\room\grid\grid[(ix)+((iy-1)*gridsz)]
												ic=e\room\grid\grid[(ix+1)+((iy)*gridsz)]
												id=e\room\grid\grid[(ix-1)+((iy)*gridsz)]
												
												If ia>0 And ic>0 Then
													RotateEntity tempInt,0,0,0
													e\room\grid\angles[ix+(iy*gridsz)]=0
												ElseIf ia>0 And id>0 Then
													RotateEntity tempInt,0,90,0
													e\room\grid\angles[ix+(iy*gridsz)]=1
												ElseIf ib>0 And ic>0 Then
													RotateEntity tempInt,0,270,0
													e\room\grid\angles[ix+(iy*gridsz)]=3
												Else
													RotateEntity tempInt,0,180,0
													e\room\grid\angles[ix+(iy*gridsz)]=2
												EndIf
											EndIf
											
											If (ix=firstX And iy=firstY) Then
												e\room\grid\grid[ix+(iy*gridsz)]=5
											EndIf
											
										Case 3
											tempInt%=CopyEntity(Meshes[e\room\grid\grid[ix+(iy*gridsz)]])
											
											ia=e\room\grid\grid[(ix)+((iy+1)*gridsz)]
											ib=e\room\grid\grid[(ix)+((iy-1)*gridsz)]
											ic=e\room\grid\grid[(ix+1)+((iy)*gridsz)]
											id=e\room\grid\grid[(ix-1)+((iy)*gridsz)]
											If ia>0 And ic>0 And id>0 Then
												RotateEntity tempInt,0,90,0
												e\room\grid\angles[ix+(iy*gridsz)]=1
											ElseIf ib>0 And ic>0 And id>0 Then
												RotateEntity tempInt,0,270,0
												e\room\grid\angles[ix+(iy*gridsz)]=3
											ElseIf ic>0 And ia>0 And ib>0 Then
												RotateEntity tempInt,0,0,0
												e\room\grid\angles[ix+(iy*gridsz)]=0
											Else
												RotateEntity tempInt,0,180,0
												e\room\grid\angles[ix+(iy*gridsz)]=2
											EndIf
										Case 4
											tempInt%=CopyEntity(Meshes[e\room\grid\grid[ix+(iy*gridsz)]])
											
											tempInt2=Rand(0,3)
											RotateEntity tempInt,0,tempInt2*90.0,0
											
											e\room\grid\angles[ix+(iy*gridsz)]=tempInt2
									End Select
									
									ScaleEntity tempInt,RoomScale,RoomScale,RoomScale,True
									PositionEntity tempInt,e\room\x+ix*2.0,8.0,e\room\z+iy*2.0,True
									
									Select e\room\grid\grid[ix+(iy*gridsz)]
										Case 1;,5,6
											AddLight%(Null, e\room\x+ix*2.0, 8.0+(368.0*RoomScale), e\room\z+iy*2.0, 2, 500.0 * RoomScale, 255, 255, 255)
										Case 3,4
											AddLight%(Null, e\room\x+ix*2.0, 8.0+(412.0*RoomScale), e\room\z+iy*2.0, 2, 500.0 * RoomScale, 255, 255, 255)
										Case 7
											AddLight%(Null, e\room\x+ix*2.0-(Sin(EntityYaw(tempInt,True))*504.0*RoomScale)+(Cos(EntityYaw(tempInt,True))*16.0*RoomScale), 8.0+(396.0*RoomScale), e\room\z+iy*2.0+(Cos(EntityYaw(tempInt,True))*504.0*RoomScale)+(Sin(EntityYaw(tempInt,True))*16.0*RoomScale), 2, 500.0 * RoomScale, 255, 200, 200)
											it = CreateItem("SCP-500-01","scp500",e\room\x+ix*2.0+(Cos(EntityYaw(tempInt,True))*(-208.0)*RoomScale)-(Sin(EntityYaw(tempInt,True))*1226.0*RoomScale),8.0+(80.0*RoomScale),e\room\z+iy*2.0+(Sin(EntityYaw(tempInt,True))*(-208.0)*RoomScale)+(Cos(EntityYaw(tempInt,True))*1226.0*RoomScale))
											EntityType (it\collider, HIT_ITEM)
											
											it = CreateItem("Night Vision Goggles", "nvgoggles",e\room\x+ix*2.0-(Sin(EntityYaw(tempInt,True))*504.0*RoomScale)+(Cos(EntityYaw(tempInt,True))*16.0*RoomScale), 8.0+(80.0*RoomScale), e\room\z+iy*2.0+(Cos(EntityYaw(tempInt,True))*504.0*RoomScale)+(Sin(EntityYaw(tempInt,True))*16.0*RoomScale))
											EntityType (it\collider, HIT_ITEM)
									End Select
									
									If e\room\grid\grid[ix+(iy*gridsz)]=6 Or e\room\grid\grid[ix+(iy*gridsz)]=5 Then
										dr=CreateDoor(e\room\zone,e\room\x+(ix*2.0)+(Cos(EntityYaw(tempInt,True))*240.0*RoomScale),8.0,e\room\z+(iy*2.0)+(Sin(EntityYaw(tempInt,True))*240.0*RoomScale),EntityYaw(tempInt,True)+90.0,Null,False,3,False,"")
										PositionEntity dr\buttons[0],EntityX(dr\buttons[0],True)+(Cos(EntityYaw(tempInt,True))*0.05),EntityY(dr\buttons[0],True)+0.0,EntityZ(dr\buttons[0],True)+(Sin(EntityYaw(tempInt,True))*0.05),True
										
										AddLight%(Null, e\room\x+ix*2.0+(Cos(EntityYaw(tempInt,True))*555.0*RoomScale), 8.0+(469.0*RoomScale), e\room\z+iy*2.0+(Sin(EntityYaw(tempInt,True))*555.0*RoomScale), 2, 600.0 * RoomScale, 255, 255, 255)
										
										tempInt2=CreatePivot()
										RotateEntity tempInt2,0,EntityYaw(tempInt,True)+180.0,0,True
										PositionEntity tempInt2,e\room\x+(ix*2.0)+(Cos(EntityYaw(tempInt,True))*552.0*RoomScale),8.0+(240.0*RoomScale),e\room\z+(iy*2.0)+(Sin(EntityYaw(tempInt,True))*552.0*RoomScale)
										If e\room\grid\grid[ix+(iy*gridsz)]=6 Then
											If e\room\RoomDoors[1]=Null Then
												dr\open = (Not e\room\RoomDoors[0]\open)
												e\room\RoomDoors[1]=dr
											Else
												RemoveDoor(dr)
											EndIf
											If e\room\Objects[3]=0 Then
												e\room\Objects[3]=tempInt2
												PositionEntity e\room\Objects[1],e\room\x+ix*2.0,8.0,e\room\z+iy*2.0,True
											Else
												FreeEntity tempInt2
											EndIf
										Else
											If e\room\RoomDoors[3]=Null Then
												dr\open = (Not e\room\RoomDoors[2]\open)
												e\room\RoomDoors[3]=dr
											Else
												RemoveDoor(dr)
											EndIf
											If e\room\Objects[5]=0 Then
												e\room\Objects[5]=tempInt2
												PositionEntity e\room\Objects[0],e\room\x+ix*2.0,8.0,e\room\z+iy*2.0,True
											Else
												FreeEntity tempInt2
											EndIf
										EndIf
									EndIf
									
									e\room\grid\Entities[ix+(iy*gridsz)]=tempInt
									
									wayp.WayPoints = CreateWaypoint(e\room\x+(ix*2.0),8.2,e\room\z+(iy*2.0),Null,e\room)
									
									e\room\grid\waypoints[ix+(iy*gridsz)]=wayp
									
									If iy<gridsz-1 Then
										If e\room\grid\waypoints[ix+((iy+1)*gridsz)]<>Null Then
											dist=EntityDistance(e\room\grid\waypoints[ix+(iy*gridsz)]\obj,e\room\grid\waypoints[ix+((iy+1)*gridsz)]\obj)
											For i=0 To 3
												If e\room\grid\waypoints[ix+(iy*gridsz)]\connected[i]=e\room\grid\waypoints[ix+((iy+1)*gridsz)] Then
													Exit
												ElseIf e\room\grid\waypoints[ix+(iy*gridsz)]\connected[i]=Null Then
													e\room\grid\waypoints[ix+(iy*gridsz)]\connected[i]=e\room\grid\waypoints[ix+((iy+1)*gridsz)]
													e\room\grid\waypoints[ix+(iy*gridsz)]\dist[i]=dist
													Exit
												EndIf
											Next
											For i=0 To 3
												If e\room\grid\waypoints[ix+((iy+1)*gridsz)]\connected[i]=e\room\grid\waypoints[ix+(iy*gridsz)] Then
													Exit
												ElseIf e\room\grid\waypoints[ix+((iy+1)*gridsz)]\connected[i]=Null Then
													e\room\grid\waypoints[ix+((iy+1)*gridsz)]\connected[i]=e\room\grid\waypoints[ix+(iy*gridsz)]
													e\room\grid\waypoints[ix+((iy+1)*gridsz)]\dist[i]=dist
													Exit
												EndIf
											Next
										EndIf
									EndIf
									If iy>0 Then
										If e\room\grid\waypoints[ix+((iy-1)*gridsz)]<>Null Then
											dist=EntityDistance(e\room\grid\waypoints[ix+(iy*gridsz)]\obj,e\room\grid\waypoints[ix+((iy-1)*gridsz)]\obj)
											For i=0 To 3
												If e\room\grid\waypoints[ix+(iy*gridsz)]\connected[i]=e\room\grid\waypoints[ix+((iy-1)*gridsz)] Then
													Exit
												ElseIf e\room\grid\waypoints[ix+(iy*gridsz)]\connected[i]=Null Then
													e\room\grid\waypoints[ix+(iy*gridsz)]\connected[i]=e\room\grid\waypoints[ix+((iy-1)*gridsz)]
													e\room\grid\waypoints[ix+(iy*gridsz)]\dist[i]=dist
													Exit
												EndIf
											Next
											For i=0 To 3
												If e\room\grid\waypoints[ix+((iy-1)*gridsz)]\connected[i]=e\room\grid\waypoints[ix+(iy*gridsz)] Then
													Exit
												ElseIf e\room\grid\waypoints[ix+(iy*gridsz)]\connected[i]=Null Then
													e\room\grid\waypoints[ix+((iy-1)*gridsz)]\connected[i]=e\room\grid\waypoints[ix+(iy*gridsz)]
													e\room\grid\waypoints[ix+((iy-1)*gridsz)]\dist[i]=dist
													Exit
												EndIf
											Next
										EndIf
									EndIf
									If ix>0 Then
										If e\room\grid\waypoints[ix-1+(iy*gridsz)]<>Null Then
											dist=EntityDistance(e\room\grid\waypoints[ix+(iy*gridsz)]\obj,e\room\grid\waypoints[ix-1+(iy*gridsz)]\obj)
											For i=0 To 3
												If e\room\grid\waypoints[ix+(iy*gridsz)]\connected[i]=e\room\grid\waypoints[ix-1+(iy*gridsz)] Then
													Exit
												ElseIf e\room\grid\waypoints[ix+(iy*gridsz)]\connected[i]=Null Then
													e\room\grid\waypoints[ix+(iy*gridsz)]\connected[i]=e\room\grid\waypoints[ix-1+(iy*gridsz)]
													e\room\grid\waypoints[ix+(iy*gridsz)]\dist[i]=dist
													Exit
												EndIf
											Next
											For i=0 To 3
												If e\room\grid\waypoints[ix-1+(iy*gridsz)]\connected[i]=e\room\grid\waypoints[ix+(iy*gridsz)] Then
													Exit
												ElseIf e\room\grid\waypoints[ix+(iy*gridsz)]\connected[i]=Null Then
													e\room\grid\waypoints[ix-1+(iy*gridsz)]\connected[i]=e\room\grid\waypoints[ix+(iy*gridsz)]
													e\room\grid\waypoints[ix-1+(iy*gridsz)]\dist[i]=dist
													Exit
												EndIf
											Next
										EndIf
									EndIf
									If ix<gridsz-1 Then
										If e\room\grid\waypoints[ix+1+(iy*gridsz)]<>Null Then
											dist=EntityDistance(e\room\grid\waypoints[ix+(iy*gridsz)]\obj,e\room\grid\waypoints[ix+1+(iy*gridsz)]\obj)
											For i=0 To 3
												If e\room\grid\waypoints[ix+(iy*gridsz)]\connected[i]=e\room\grid\waypoints[ix+1+(iy*gridsz)] Then
													Exit
												ElseIf e\room\grid\waypoints[ix+(iy*gridsz)]\connected[i]=Null Then
													e\room\grid\waypoints[ix+(iy*gridsz)]\connected[i]=e\room\grid\waypoints[ix+1+(iy*gridsz)]
													e\room\grid\waypoints[ix+(iy*gridsz)]\dist[i]=dist
													Exit
												EndIf
											Next
											For i=0 To 3
												If e\room\grid\waypoints[ix+1+(iy*gridsz)]\connected[i]=e\room\grid\waypoints[ix+(iy*gridsz)] Then
													Exit
												ElseIf e\room\grid\waypoints[ix+(iy*gridsz)]\connected[i]=Null Then
													e\room\grid\waypoints[ix+1+(iy*gridsz)]\connected[i]=e\room\grid\waypoints[ix+(iy*gridsz)]
													e\room\grid\waypoints[ix+1+(iy*gridsz)]\dist[i]=dist
													Exit
												EndIf
											Next
										EndIf
									EndIf
									
								EndIf
							Next
						Next
						
						For i=0 To 6
							e\room\grid\Meshes[i]=Meshes[i]
							;FreeEntity Meshes[i]
						Next
						
						PositionEntity e\room\Objects[0],e\room\x+firstX*2.0,8.0,e\room\z+firstY*2.0,True
						PositionEntity e\room\Objects[1],e\room\x+lastX*2.0,8.0,e\room\z+lastY*2.0,True
						
					Else If e\room\grid\Meshes[0]=0 Then
						
						;place the tunnels
						For i=0 To 6
					;		Select True
					;			Case i=2
					;				tempStr="2c"
					;			Case i>2
					;				tempStr=Str(i)
					;			Default
					;				tempStr=Str(i+1)
					;		End Select
							Meshes[i]=CopyEntity(OBJTunnel(i))
							DebugLog i
							HideEntity Meshes[i]
						Next
					;	Meshes[5]=CopyEntity(OBJTunnel(5))
					;	HideEntity Meshes[5]
					;	Meshes[6]=CopyEntity(OBJTunnel(6))
					;	HideEntity Meshes[6]
						
					;	For i=0 To 4
					;		Select True
					;			Case i=2
					;				tempStr="2c"
					;			Case i>2
					;				tempStr=Str(i)
					;			Default
					;				tempStr=Str(i+1)
					;		End Select
					;		Meshes[i]=LoadRMesh("GFX\map\mt"+tempStr+".rmesh",Null)
					;		DebugLog i
					;		HideEntity Meshes[i]
					;	Next
					;	
					;	Meshes[5]=LoadRMesh("GFX\map\mt_elevator.rmesh",Null)
					;	HideEntity Meshes[5]
					;	Meshes[6]=LoadRMesh("GFX\map\mt_generator.rmesh",Null)
					;	HideEntity Meshes[6]
						
						FreeTextureCache
						
						tempInt=0
						
						For iy=0 To gridsz-1
							For ix=0 To gridsz-1
								If e\room\grid\grid[ix+(iy*gridsz)]>0 Then
									Select e\room\grid\grid[ix+(iy*gridsz)]
										Case 1,7
											tempInt%=CopyEntity(Meshes[e\room\grid\grid[ix+(iy*gridsz)]-1])
										Case 2
											If e\room\grid\grid[(ix+1)+((iy)*gridsz)]>0 And e\room\grid\grid[(ix-1)+((iy)*gridsz)]>0 Then ;horizontal
												tempInt%=CopyEntity(Meshes[e\room\grid\grid[ix+(iy*gridsz)]-1])
												AddLight%(Null, e\room\x+ix*2.0, 8.0+(368.0*RoomScale), e\room\z+iy*2.0, 2, 500.0 * RoomScale, 255, 255, 255)
											ElseIf e\room\grid\grid[(ix)+((iy+1)*gridsz)]>0 And e\room\grid\grid[(ix)+((iy-1)*gridsz)]>0 Then ;vertical
												tempInt%=CopyEntity(Meshes[e\room\grid\grid[ix+(iy*gridsz)]-1])
												AddLight%(Null, e\room\x+ix*2.0, 8.0+(368.0*RoomScale), e\room\z+iy*2.0, 2, 500.0 * RoomScale, 255, 255, 255)
											Else
												tempInt%=CopyEntity(Meshes[e\room\grid\grid[ix+(iy*gridsz)]])
												AddLight%(Null, e\room\x+ix*2.0, 8.0+(412.0*RoomScale), e\room\z+iy*2.0, 2, 500.0 * RoomScale, 255, 255, 255)
											EndIf
										Case 3,4
											tempInt%=CopyEntity(Meshes[e\room\grid\grid[ix+(iy*gridsz)]])
										Case 5,6
											tempInt%=CopyEntity(Meshes[5])
									End Select
									
									ScaleEntity tempInt,RoomScale,RoomScale,RoomScale,True
									
									RotateEntity tempInt,0,e\room\grid\angles[ix+(iy*gridsz)]*90.0,0
									PositionEntity tempInt,e\room\x+ix*2.0,8.0,e\room\z+iy*2.0,True
									
									Select e\room\grid\grid[ix+(iy*gridsz)]
										Case 1,5,6
											AddLight%(Null, e\room\x+ix*2.0, 8.0+(368.0*RoomScale), e\room\z+iy*2.0, 2, 500.0 * RoomScale, 255, 255, 255)
										Case 3,4
											AddLight%(Null, e\room\x+ix*2.0, 8.0+(412.0*RoomScale), e\room\z+iy*2.0, 2, 500.0 * RoomScale, 255, 255, 255)
										Case 7
											AddLight%(Null, e\room\x+ix*2.0-(Sin(EntityYaw(tempInt,True))*504.0*RoomScale)+(Cos(EntityYaw(tempInt,True))*16.0*RoomScale), 8.0+(396.0*RoomScale), e\room\z+iy*2.0+(Cos(EntityYaw(tempInt,True))*504.0*RoomScale)+(Sin(EntityYaw(tempInt,True))*16.0*RoomScale), 2, 500.0 * RoomScale, 255, 200, 200)
									End Select
									
									If e\room\grid\grid[ix+(iy*gridsz)]=6 Or e\room\grid\grid[ix+(iy*gridsz)]=5 Then
										dr=CreateDoor(e\room\zone,e\room\x+(ix*2.0)+(Cos(EntityYaw(tempInt,True))*240.0*RoomScale),8.0,e\room\z+(iy*2.0)+(Sin(EntityYaw(tempInt,True))*240.0*RoomScale),EntityYaw(tempInt,True)+90.0,Null,False,3,False,"")
										
										AddLight%(Null, e\room\x+ix*2.0+(Cos(EntityYaw(tempInt,True))*555.0*RoomScale), 8.0+(469.0*RoomScale), e\room\z+iy*2.0+(Sin(EntityYaw(tempInt,True))*555.0*RoomScale), 2, 600.0 * RoomScale, 255, 255, 255)
										
										PositionEntity dr\buttons[0],EntityX(dr\buttons[0],True)+(Cos(EntityYaw(tempInt,True))*0.05),EntityY(dr\buttons[0],True)+0.0,EntityZ(dr\buttons[0],True)+(Sin(EntityYaw(tempInt,True))*0.05),True
										tempInt2=CreatePivot()
										RotateEntity tempInt2,0,EntityYaw(tempInt,True)+180.0,0,True
										PositionEntity tempInt2,e\room\x+(ix*2.0)+(Cos(EntityYaw(tempInt,True))*552.0*RoomScale),8.0+(240.0*RoomScale),e\room\z+(iy*2.0)+(Sin(EntityYaw(tempInt,True))*552.0*RoomScale)
										If e\room\grid\grid[ix+(iy*gridsz)]=6 Then
											If e\room\RoomDoors[1]=Null Then
												dr\open = (Not e\room\RoomDoors[0]\open)
												e\room\RoomDoors[1]=dr
											Else
												RemoveDoor(dr)
											EndIf
											If e\room\Objects[3]=0 Then
												e\room\Objects[3]=tempInt2
												PositionEntity e\room\Objects[1],e\room\x+ix*2.0,8.0,e\room\z+iy*2.0,True
											Else
												FreeEntity tempInt2
											EndIf
										Else
											If e\room\RoomDoors[3]=Null Then
												dr\open = (Not e\room\RoomDoors[2]\open)
												e\room\RoomDoors[3]=dr
											Else
												RemoveDoor(dr)
											EndIf
											If e\room\Objects[5]=0 Then
												e\room\Objects[5]=tempInt2
												PositionEntity e\room\Objects[0],e\room\x+ix*2.0,8.0,e\room\z+iy*2.0,True
											Else
												FreeEntity tempInt2
											EndIf
										EndIf
									EndIf
									
									e\room\grid\Entities[ix+(iy*gridsz)]=tempInt
									
									wayp.WayPoints = CreateWaypoint(e\room\x+(ix*2.0),8.2,e\room\z+(iy*2.0),Null,e\room)
									
									e\room\grid\waypoints[ix+(iy*gridsz)]=wayp
									
									If iy<gridsz-1 Then
										If e\room\grid\waypoints[ix+((iy+1)*gridsz)]<>Null Then
											dist=EntityDistance(e\room\grid\waypoints[ix+(iy*gridsz)]\obj,e\room\grid\waypoints[ix+((iy+1)*gridsz)]\obj)
											For i=0 To 3
												If e\room\grid\waypoints[ix+(iy*gridsz)]\connected[i]=e\room\grid\waypoints[ix+((iy+1)*gridsz)] Then
													Exit
												ElseIf e\room\grid\waypoints[ix+(iy*gridsz)]\connected[i]=Null Then
													e\room\grid\waypoints[ix+(iy*gridsz)]\connected[i]=e\room\grid\waypoints[ix+((iy+1)*gridsz)]
													e\room\grid\waypoints[ix+(iy*gridsz)]\dist[i]=dist
													Exit
												EndIf
											Next
											For i=0 To 3
												If e\room\grid\waypoints[ix+((iy+1)*gridsz)]\connected[i]=e\room\grid\waypoints[ix+(iy*gridsz)] Then
													Exit
												ElseIf e\room\grid\waypoints[ix+((iy+1)*gridsz)]\connected[i]=Null Then
													e\room\grid\waypoints[ix+((iy+1)*gridsz)]\connected[i]=e\room\grid\waypoints[ix+(iy*gridsz)]
													e\room\grid\waypoints[ix+((iy+1)*gridsz)]\dist[i]=dist
													Exit
												EndIf
											Next
										EndIf
									EndIf
									If iy>0 Then
										If e\room\grid\waypoints[ix+((iy-1)*gridsz)]<>Null Then
											dist=EntityDistance(e\room\grid\waypoints[ix+(iy*gridsz)]\obj,e\room\grid\waypoints[ix+((iy-1)*gridsz)]\obj)
											For i=0 To 3
												If e\room\grid\waypoints[ix+(iy*gridsz)]\connected[i]=e\room\grid\waypoints[ix+((iy-1)*gridsz)] Then
													Exit
												ElseIf e\room\grid\waypoints[ix+(iy*gridsz)]\connected[i]=Null Then
													e\room\grid\waypoints[ix+(iy*gridsz)]\connected[i]=e\room\grid\waypoints[ix+((iy-1)*gridsz)]
													e\room\grid\waypoints[ix+(iy*gridsz)]\dist[i]=dist
													Exit
												EndIf
											Next
											For i=0 To 3
												If e\room\grid\waypoints[ix+((iy-1)*gridsz)]\connected[i]=e\room\grid\waypoints[ix+(iy*gridsz)] Then
													Exit
												ElseIf e\room\grid\waypoints[ix+(iy*gridsz)]\connected[i]=Null Then
													e\room\grid\waypoints[ix+((iy-1)*gridsz)]\connected[i]=e\room\grid\waypoints[ix+(iy*gridsz)]
													e\room\grid\waypoints[ix+((iy-1)*gridsz)]\dist[i]=dist
													Exit
												EndIf
											Next
										EndIf
									EndIf
									If ix>0 Then
										If e\room\grid\waypoints[ix-1+(iy*gridsz)]<>Null Then
											dist=EntityDistance(e\room\grid\waypoints[ix+(iy*gridsz)]\obj,e\room\grid\waypoints[ix-1+(iy*gridsz)]\obj)
											For i=0 To 3
												If e\room\grid\waypoints[ix+(iy*gridsz)]\connected[i]=e\room\grid\waypoints[ix-1+(iy*gridsz)] Then
													Exit
												ElseIf e\room\grid\waypoints[ix+(iy*gridsz)]\connected[i]=Null Then
													e\room\grid\waypoints[ix+(iy*gridsz)]\connected[i]=e\room\grid\waypoints[ix-1+(iy*gridsz)]
													e\room\grid\waypoints[ix+(iy*gridsz)]\dist[i]=dist
													Exit
												EndIf
											Next
											For i=0 To 3
												If e\room\grid\waypoints[ix-1+(iy*gridsz)]\connected[i]=e\room\grid\waypoints[ix+(iy*gridsz)] Then
													Exit
												ElseIf e\room\grid\waypoints[ix+(iy*gridsz)]\connected[i]=Null Then
													e\room\grid\waypoints[ix-1+(iy*gridsz)]\connected[i]=e\room\grid\waypoints[ix+(iy*gridsz)]
													e\room\grid\waypoints[ix-1+(iy*gridsz)]\dist[i]=dist
													Exit
												EndIf
											Next
										EndIf
									EndIf
									If ix<gridsz-1 Then
										If e\room\grid\waypoints[ix+1+(iy*gridsz)]<>Null Then
											dist=EntityDistance(e\room\grid\waypoints[ix+(iy*gridsz)]\obj,e\room\grid\waypoints[ix+1+(iy*gridsz)]\obj)
											For i=0 To 3
												If e\room\grid\waypoints[ix+(iy*gridsz)]\connected[i]=e\room\grid\waypoints[ix+1+(iy*gridsz)] Then
													Exit
												ElseIf e\room\grid\waypoints[ix+(iy*gridsz)]\connected[i]=Null Then
													e\room\grid\waypoints[ix+(iy*gridsz)]\connected[i]=e\room\grid\waypoints[ix+1+(iy*gridsz)]
													e\room\grid\waypoints[ix+(iy*gridsz)]\dist[i]=dist
													Exit
												EndIf
											Next
											For i=0 To 3
												If e\room\grid\waypoints[ix+1+(iy*gridsz)]\connected[i]=e\room\grid\waypoints[ix+(iy*gridsz)] Then
													Exit
												ElseIf e\room\grid\waypoints[ix+(iy*gridsz)]\connected[i]=Null Then
													e\room\grid\waypoints[ix+1+(iy*gridsz)]\connected[i]=e\room\grid\waypoints[ix+(iy*gridsz)]
													e\room\grid\waypoints[ix+1+(iy*gridsz)]\dist[i]=dist
													Exit
												EndIf
											Next
										EndIf
									EndIf
								EndIf
							Next
						Next
						
						For i=0 To 6
							e\room\grid\Meshes[i]=Meshes[i]
						Next
						
						SeedRnd oldSeed
						
						For it.Items = Each Items
							If (EntityY(it\collider,True)>=8.0) And (EntityY(it\collider,True)<=12.0) Then
								DebugLog it\name+" is within Y limits"
								If (EntityX(it\collider,True)>=e\room\x-6.0) And (EntityX(it\collider,True)<=(e\room\x+(2.0*gridsz)+6.0)) Then
									DebugLog "and within X limits"
								EndIf
								If (EntityZ(it\collider,True)>=e\room\z-6.0) And (EntityZ(it\collider,True)<=(e\room\z+(2.0*gridsz)+6.0)) Then
									DebugLog "and within Z limits"
								EndIf
							EndIf
							
							If (EntityY(it\collider,True)>=8.0) And (EntityY(it\collider,True)<=12.0) And (EntityX(it\collider,True)>=e\room\x-6.0) And (EntityX(it\collider,True)<=(e\room\x+(2.0*gridsz)+6.0)) And (EntityZ(it\collider,True)>=e\room\z-6.0) And (EntityZ(it\collider,True)<=(e\room\z+(2.0*gridsz)+6.0)) Then
								DebugLog it\name
								TranslateEntity it\collider,0.0,0.3,0.0,True
								ResetEntity it\collider
							EndIf
						Next
						
					EndIf
					
					
					If EntityY(Collider,True)>4.0 Then
						For iy=0 To gridsz-1
							For ix=0 To gridsz-1
								If e\room\grid\Entities[ix+(iy*gridsz)]<>0
									ShowEntity e\room\grid\Entities[ix+(iy*gridsz)]
								EndIf
							Next
						Next
						
						For r.Rooms = Each Rooms
							If r <> e\room
								HideEntity r\obj
							EndIf
						Next
						EntityAlpha(GetChild(e\room\obj,2),0)
						
						ShouldPlay = 7
						
						If e\EventState = 0 Then
							If EntityDistance(Collider, e\room\Objects[0]) < EntityDistance(Collider, e\room\Objects[1]) Then
								temp = 0
							Else
								temp = 1
							EndIf
							e\EventState = 2
							
							If (Not Contained106) Then 	
								de.Decals = CreateDecal(0, EntityX(e\room\Objects[temp],True), EntityY(e\room\Objects[temp],True)+0.05, EntityZ(e\room\Objects[temp],True), 90, Rand(360), 0)
								de\Size = 0.05 : de\SizeChange = 0.001 : EntityAlpha(de\obj, 0.8) : UpdateDecals
								
								DebugLog "updateevents collider: "+EntityY(Collider,True)
								PositionEntity Curr106\Collider, EntityX(e\room\Objects[temp],True), EntityY(Collider,True)-3.0, EntityZ(e\room\Objects[temp],True)
								SetAnimTime Curr106\obj, 110
								Curr106\State = -0.1	
								Curr106\PrevY = EntityY(Collider)
							EndIf
							
							For i = 0 To 1
								Local spawnPoint.WayPoints = Null
								For x = i*((gridsz*gridsz)/5.0) To (gridsz*gridsz-1)
									DebugLog("spawn 966 X: "+x)
									If Rand(2)=1 And e\room\grid\waypoints[x]<>Null Then 
										spawnPoint = e\room	\grid\waypoints[x]
										x = gridsz*gridsz
									EndIf
								Next 
								If (spawnPoint<>Null) Then
									e\room\NPC[i] =CreateNPC(NPCtype966, EntityX(spawnPoint\obj,True), EntityY(spawnPoint\obj,True), EntityZ(spawnPoint\obj,True))
								EndIf
							Next
						EndIf
					Else
						For iy=0 To gridsz-1
							For ix=0 To gridsz-1
								If e\room\grid\Entities[ix+(iy*gridsz)]<>0
									HideEntity e\room\grid\Entities[ix+(iy*gridsz)]
								EndIf
							Next
						Next
					EndIf ;entityy(collider) >4
					
					e\EventState2 = UpdateElevators(e\EventState2, e\room\RoomDoors[0], e\room\RoomDoors[1],e\room\Objects[2],e\room\Objects[3], e, False)
					e\EventState3 = UpdateElevators(e\EventState3, e\room\RoomDoors[2], e\room\RoomDoors[3],e\room\Objects[4],e\room\Objects[5], e, False)
				Else
					If e\room\grid <> Null
						If e\room\grid\Meshes[0]<>0
							For iy=0 To gridsz-1
								For ix=0 To gridsz-1
									If e\room\grid\Entities[ix+(iy*gridsz)]<>0
										HideEntity e\room\grid\Entities[ix+(iy*gridsz)]
									EndIf
								Next
							Next
						EndIf
					EndIf
				EndIf 
				
			Case "room2pipes106"
				
				If (Not Contained106) Then 
					If e\EventState = 0 Then
						If PlayerRoom = e\room Then e\EventState = 1
					Else
						e\EventState=(e\EventState+FPSfactor*0.7)
						;0-50 = walk to the middle
						;50-200 = look around
						;200-250 = leave
						If e\EventState < 50 Then
							Curr106\Idle = True
							PositionEntity(Curr106\Collider, EntityX(e\room\Objects[0], True), EntityY(Collider) - 0.15, EntityZ(e\room\Objects[0], True))
							PointEntity(Curr106\Collider, e\room\Objects[1])
							MoveEntity(Curr106\Collider, 0, 0, EntityDistance(e\room\Objects[0], e\room\Objects[1])*0.5 * (e\EventState / 50.0))
							AnimateNPC(Curr106, 284, 333, 0.02*35)
						ElseIf e\EventState < 200
							Curr106\Idle = True
							AnimateNPC(Curr106, 334, 494, 0.2)
							
							PositionEntity(Curr106\Collider, (EntityX(e\room\Objects[0], True)+EntityX(e\room\Objects[1], True))/2, EntityY(Collider) - 0.15, (EntityZ(e\room\Objects[0], True)+EntityZ(e\room\Objects[1], True))/2)
							;MoveEntity(Curr106\Collider, 0, 0, EntityDistance(e\room\Objects[0], e\room\Objects[1])*0.5)
							RotateEntity(Curr106\Collider,0, CurveValue(e\EventState,EntityYaw(Curr106\Collider),30.0),0,True)
							If EntityDistance(Curr106\Collider, Collider)<4.0 Then
								pvt = CreatePivot()
								PositionEntity(pvt, EntityX(Curr106\Collider),EntityY(Curr106\Collider),EntityZ(Curr106\Collider))
								PointEntity pvt, Collider
								If WrapAngle(EntityYaw(pvt)-EntityYaw(Curr106\Collider))<80 Then
									Curr106\State = -11
									Curr106\Idle = False
									PlaySound_Strict(HorrorSFX(10))
									e\EventState = 260
								EndIf
								FreeEntity pvt
							EndIf
						ElseIf e\EventState < 250
							Curr106\Idle = True
							PositionEntity(Curr106\Collider, EntityX(e\room\Objects[0], True), EntityY(Collider) - 0.15, EntityZ(e\room\Objects[0], True))
							PointEntity(Curr106\Collider, e\room\Objects[1])
							;200-250     (- 150)      50-100
							MoveEntity(Curr106\Collider, 0, 0, EntityDistance(e\room\Objects[0], e\room\Objects[1]) * ((e\EventState-150.0) / 100.0))
							AnimateNPC(Curr106, 284, 333, 0.02*35)
						EndIf
						ResetEntity(Curr106\Collider)
						
						PositionEntity(Curr106\obj, EntityX(Curr106\Collider), EntityY(Curr106\Collider) - 0.15, EntityZ(Curr106\Collider))
						RotateEntity Curr106\obj, 0, EntityYaw(Curr106\Collider), 0
						
						;PositionEntity(Curr106\Collider, EntityX(Curr106\Collider), EntityY(Collider) - 0.20, EntityZ(Curr106\Collider))
						
						If (e\EventState / 250.0) > 0.3 And ((e\EventState - FPSfactor*0.7) / 250.0) <= 0.3 Then
							e\SoundCHN = PlaySound_Strict(HorrorSFX(6))
							BlurTimer = 800
							d.Decals = CreateDecal(0, EntityX(e\room\Objects[2], True), EntityY(e\room\Objects[2], True), EntityZ(e\room\Objects[2], True), 0, e\room\angle - 90, Rnd(360)) ;90, Rnd(360), 0
							d\Timer = 90000
							d\Alpha = 0.01 : d\AlphaChange = 0.005
							d\Size = 0.1 : d\SizeChange = 0.003
						EndIf
						
						If (e\EventState / 250.0) > 0.65 And ((e\EventState - FPSfactor*0.7) / 250.0) <= 0.65 Then
							d.Decals = CreateDecal(0, EntityX(e\room\Objects[3], True), EntityY(e\room\Objects[3], True), EntityZ(e\room\Objects[3], True), 0, e\room\angle + 90, Rnd(360))
							d\Timer = 90000
							d\Alpha = 0.01 : d\AlphaChange = 0.005
							d\Size = 0.1 : d\SizeChange = 0.003
						EndIf						
						
						If e\EventState > 250 Then Curr106\Idle = False :RemoveEvent(e)
						
					End If
				EndIf
				
			Case "room2pit106"
                
                If (Not Contained106) And Curr106\State>0 Then 
                    If e\EventState = 0 Then
                        If PlayerRoom = e\room Then e\EventState = 1
                    Else
                        e\EventState = e\EventState + 1
                        PositionEntity(Curr106\Collider, EntityX(e\room\Objects[7], True), EntityY(e\room\Objects[7], True), EntityZ(e\room\Objects[7], True))
                        ResetEntity(Curr106\Collider)
                        
                        PointEntity(Curr106\Collider, Camera)
                        TurnEntity(Curr106\Collider, 0, Sin(MilliSecs2() / 20) * 6.0, 0, True)
                        MoveEntity(Curr106\Collider, 0, 0, Sin(MilliSecs2() / 15) * 0.06)
                        PositionEntity(Curr106\obj, EntityX(Curr106\Collider), EntityY(Curr106\Collider) - 0.15, EntityZ(Curr106\Collider))
                        
                        RotateEntity Curr106\obj, 0, EntityYaw(Curr106\Collider), 0
                        Curr106\Idle = True
                        AnimateNPC(Curr106, 334, 494, 0.3)
                        If e\EventState > 800 Then
                            If BlinkTimer < - 5 Then Curr106\Idle = False : RemoveEvent(e)
                        EndIf
                    EndIf
                End If
                
			Case "room2pit"
				
				If Curr173\Idle = 0 Then 
					If e\room\dist < 8.0  And e\room\dist > 0 Then			
						If (Not EntityVisible(Curr173\Collider, Camera)) And (Not EntityVisible(e\room\Objects[6], Camera)) Then 
							PositionEntity(Curr173\Collider, EntityX(e\room\Objects[6], True), 0.5, EntityZ(e\room\Objects[6], True))
							ResetEntity(Curr173\Collider)
							RemoveEvent(e)
						EndIf
					End If
				EndIf
				
			Case "room3pitduck"
				
				If PlayerRoom = e\room Then
					If e\room\Objects[2] = 0 Then
						e\room\Objects[2] =	LoadMesh_Strict("GFX\npcs\duck_low_res.b3d")
						ScaleEntity(e\room\Objects[2], 0.07, 0.07, 0.07)
						tex = LoadTexture_Strict("GFX\npcs\duck1.png")
						EntityTexture e\room\Objects[2], tex
						FreeTexture tex
						PositionEntity (e\room\Objects[2], EntityX(e\room\Objects[0],True), EntityY(e\room\Objects[0],True), EntityZ(e\room\Objects[0],True))
						PointEntity e\room\Objects[2], e\room\obj
						RotateEntity(e\room\Objects[2], 0, EntityYaw(e\room\Objects[2],True),0, True)
						
						LoadEventSound(e,"SFX\SCP\Joke\Saxophone.ogg")
					Else
						If EntityInView(e\room\Objects[2],Camera)=False Then
							e\EventState = e\EventState + FPSfactor
							If Rand(200)=1 And e\EventState > 300 Then
								e\EventState = 0
								e\SoundCHN = PlaySound2(e\Sound, Camera, e\room\Objects[2],6.0)
							EndIf
						Else
							If e\SoundCHN <> 0 Then
								If ChannelPlaying(e\SoundCHN) Then StopChannel e\SoundCHN
							EndIf
						EndIf						
					EndIf
				EndIf
				
			Case "room3pit1048"
				
				If PlayerRoom = e\room Then
					If e\room\Objects[2] = 0 Then
						e\room\Objects[2] =	LoadAnimMesh_Strict("GFX\npcs\scp-1048pp.b3d")
						ScaleEntity e\room\Objects[2], 0.05,0.05,0.05
						SetAnimTime(e\room\Objects[2], 414)
						
						Local imgPath$ = "GFX\items\1048\1048_"+Rand(1,20)+".jpg"
						
						Local itt.ItemTemplates
						For itt.ItemTemplates = Each ItemTemplates
							If itt\name = "Drawing" Then
								If itt\img<>0 Then FreeImage itt\img	
								itt\img = LoadImage_Strict(imgPath)
								MaskImage(itt\img, 255,0,255)
								itt\imgpath = imgPath
								
								Exit
							EndIf
						Next
						
						tex% = LoadTexture_Strict(imgPath)
						Local brush% = LoadBrush_Strict(imgPath, 1)
						
						For i = 1 To CountSurfaces(e\room\Objects[2])
							sf% = GetSurface(e\room\Objects[2],i)
							b% = GetSurfaceBrush( sf )
							t% = GetBrushTexture(b, 0)
							texname$ = StripPath(TextureName(t))
							DebugLog "texname: "+texname
							If Lower(texname) = "1048_1.jpg" Then
								PaintSurface sf, brush
							EndIf
							;MAV???
							;If texname<>"" Then FreeTexture t
							FreeBrush b
						Next
						
						FreeTexture tex
						FreeBrush brush
						
						PositionEntity (e\room\Objects[2], EntityX(e\room\Objects[0],True), EntityY(e\room\Objects[0],True), EntityZ(e\room\Objects[0],True))
						
						;e\Sound = LoadSound_Strict("SFX\SCP\Joke\Saxophone.ogg")
					Else
						PointEntity e\room\Objects[2], Collider
						RotateEntity(e\room\Objects[2], -90, EntityYaw(e\room\Objects[2],True),0, True)
						
						If e\EventState=0 Then
							If (EntityDistance(Collider, e\room\Objects[2])<3.0) Then
								If EntityInView(e\room\Objects[2],Camera) Then 
									e\EventState = 1
									GiveAchievement(Achv1048)
								EndIf
							EndIf
						Else If e\EventState=1
							Animate2(e\room\Objects[2], AnimTime(e\room\Objects[2]), 1, 205, 0.5, False)
							If AnimTime(e\room\Objects[2])=205 Then e\EventState=2
						Else If e\EventState = 2
							Animate2(e\room\Objects[2], AnimTime(e\room\Objects[2]), 205, 353, 1.0)	
							If (EntityDistance(Collider, e\room\Objects[2])<1.5) Then
								DrawHandIcon = True
								
								If MouseHit1 Then
									If ItemAmount >= MaxItemAmount Then
										Msg = "You cannot carry any more items."
										MsgTimer = 70 * 5
									Else
										SelectedItem = CreateItem("Drawing", "paper", 0.0, 0.0, 0.0)
										EntityType SelectedItem\collider,HIT_ITEM
										
										PickItem(SelectedItem)
										
										FreeEntity(e\room\Objects[2])
										e\room\Objects[2] = 0
										
										e\EventState = 3
										RemoveEvent(e)
									EndIf
								EndIf
							EndIf
						EndIf
					EndIf
				EndIf
				
			Case "room2poffices2"
				
				If PlayerRoom = e\room Then
					If e\EventState = 0 Then
						If e\room\RoomDoors[0]\open = True Then 
							If e\room\RoomDoors[0]\openstate = 180 Then 
								e\EventState = 1
								PlaySound_Strict HorrorSFX(5)
							EndIf
						Else
							If (EntityDistance(Collider, e\room\RoomDoors[0]\obj)<1.5) And (RemoteDoorOn) Then
								e\room\RoomDoors[0]\open = True
							EndIf
						EndIf
					Else
						If EntityDistance(e\room\Objects[0], Collider) < 2.0 Then
							HeartBeatVolume = CurveValue(0.5, HeartBeatVolume, 5)
							HeartBeatRate = CurveValue(120, HeartBeatRate, 150) 
							e\SoundCHN = LoopSound2(OldManSFX(4), e\SoundCHN, Camera, e\room\obj, 5.0, 0.3)
							Curr106\State=Curr106\State-FPSfactor*3
						EndIf
						
					EndIf
				EndIf
				
			Case "room2servers"
				
				If e\EventState=0 Then
					If PlayerRoom = e\room Then
						;close the doors when the player enters the room
						UseDoor(e\room\RoomDoors[0],False)
						e\room\RoomDoors[0]\locked = True
						UseDoor(e\room\RoomDoors[1],False)
						e\room\RoomDoors[1]\locked = True
						
						If Curr096=Null Then
							Curr096 = CreateNPC(NPCtype096, EntityX(e\room\Objects[6],True),EntityY(e\room\Objects[6],True)+0.1,EntityZ(e\room\Objects[6],True))
						Else
							PositionEntity Curr096\Collider, EntityX(e\room\Objects[6],True),EntityY(e\room\Objects[6],True)+0.1,EntityZ(e\room\Objects[6],True),True
						EndIf
						
						RotateEntity Curr096\Collider, 0, e\room\angle+270, 0, True
						ResetEntity Curr096\Collider
						Curr096\State=6
						Curr096\State2=70*10
						
						LoadEventSound(e,"SFX\Character\Guard\096ServerRoom1.ogg")
						e\SoundCHN = PlaySound_Strict (e\Sound)
						
						e\room\NPC[0]=CreateNPC(NPCtypeGuard, EntityX(e\room\Objects[7],True),EntityY(e\room\Objects[7],True),EntityZ(e\room\Objects[7],True))
						
						GiveAchievement(Achv096)
						
						e\EventState=1
					EndIf
				ElseIf e\EventState < 70*45
					If	Rand(200)<5 And PlayerRoom = e\room Then 
						LightBlink = Rnd(1.0,2.0)
						If Rand(5)=1 Then PlaySound2(IntroSFX(Rand(10,12)), Camera, e\room\obj, 8.0, Rnd(0.1,0.3))
					EndIf
					
					e\EventState=Min(e\EventState+FPSfactor,70*43)
					
					If e\room\NPC[0]<>Null Then
						
;						If e\EventState < 70*13 Then
;							
;							If e\EventState > 70*8 Then
;								Curr096\State=Min(Max(2,Curr096\State),3)
;								Curr096\State2=70*10
;							Else
;								Curr096\State = 5
;								PointEntity Curr096\Collider, e\room\Objects[9]
;								RotateEntity Curr096\Collider, 0, EntityYaw(Curr096\Collider,True),0,True								
;								If EntityDistance(Curr096\Collider, e\room\Objects[8])<2.4 Then
;									Curr096\State2 = 0
;								Else
;									Curr096\State2 = 1001
;								EndIf	
;							EndIf
;							
;							e\room\NPC[0]\State=13
;							;SetAnimTime e\room\NPC[0]\obj, 115
;							PointEntity e\room\NPC[0]\Collider, Curr096\Collider								
;						ElseIf e\EventState-FPSfactor =< 70*15 Then ;walk to the doorway
;							If e\EventState > 70*15 Then
;								e\room\NPC[0]\State=14
;								;e\room\NPC[0]\PathStatus = FindPath(e\room\NPC[0], EntityX(e\room\Objects[8],True),0.5,EntityZ(e\room\Objects[8],True))
;								e\room\NPC[0]\PathStatus = FindPath(e\room\NPC[0], EntityX(Curr096\Collider,True),0.4,EntityZ(Curr096\Collider,True))
;								e\room\NPC[0]\PathTimer=300
;							EndIf
;						ElseIf e\EventState<70*20 Then
;							If e\room\NPC[0]\PathStatus=0 Then
;								e\room\RoomDoors[2]\open = False
;								
;								e\room\NPC[0]\State=13
;								;SetAnimTime e\room\NPC[0]\obj, 115
;								PointEntity e\room\NPC[0]\obj, Curr096\Collider
;								RotateEntity (e\room\NPC[0]\Collider, 0, CurveAngle(EntityYaw(e\room\NPC[0]\obj),EntityYaw(e\room\NPC[0]\Collider),30),0)
;								
;							EndIf
;						Else ;start walking away
;							
;							If Curr096\State = 4 Then ;shoot at 096 when it starts attacking
;								Curr096\LastSeen=1
;								
;								e\room\NPC[0]\State = 2
;								PointEntity e\room\NPC[0]\obj, Curr096\Collider
;								RotateEntity (e\room\NPC[0]\Collider, 0, CurveAngle(EntityYaw(e\room\NPC[0]\obj),EntityYaw(e\room\NPC[0]\Collider),30),0)
;								If PlayerRoom = e\room Then LightBlink = (e\room\NPC[0]\Reload)+Rnd(0.5,2.0)
;								Curr096\Target = e\room\NPC[0]
;							Else
;								If e\EventState>70*22 Then Curr096\State = 4
;								If e\room\NPC[0]\State=13 Then
;									e\room\NPC[0]\State=14
;									e\room\NPC[0]\PathStatus = FindPath(e\room\NPC[0], EntityX(e\room\obj,True),0.4,EntityZ(e\room\obj,True))
;									e\room\NPC[0]\PathTimer=300
;									e\room\NPC[0]\Speed = e\room\NPC[0]\Speed*1.8 ;Making the guard walking a bit faster
;								EndIf
;							EndIf
;						EndIf
;						
;						Curr096\Target = e\room\NPC[0]
;						If AnimTime(Curr096\obj)>25 And AnimTime(Curr096\obj)<150 Then
;							FreeSound_Strict e\Sound : e\Sound = 0
;							e\Sound=LoadSound_Strict("SFX\Character\Guard\096ServerRoom2.ogg")
;							e\SoundCHN=PlaySound_Strict(e\Sound)
;							
;							Curr096\CurrSpeed = 0
;							
;							For i = 0 To 6
;								If e\room\angle = 0 Or e\room\angle = 180 Then
;									de.Decals = CreateDecal(Rand(2,3), e\room\x-Rnd(197,199)*Cos(e\room\angle)*RoomScale, 1.0, e\room\z+(140.0*(i-3))*RoomScale,0,e\room\angle+90,Rnd(360))
;									de\size = Rnd(0.8,0.85) : de\sizechange = 0.001
;									de.Decals = CreateDecal(Rand(2,3), e\room\x-Rnd(197,199)*Cos(e\room\angle)*RoomScale, 1.0, e\room\z+(140.0*(i-3))*RoomScale,0,e\room\angle-90,Rnd(360))
;									de\size = Rnd(0.8,0.85) : de\sizechange = 0.001
;								Else
;									de.Decals = CreateDecal(Rand(2,3), e\room\x+(140.0*(i-3))*RoomScale, 1.0, e\room\z-Rnd(197,199)*Sin(e\room\angle)*RoomScale-Rnd(0.001,0.003),0,e\room\angle+90,Rnd(360))
;									de\size = Rnd(0.8,0.85) : de\sizechange = 0.001
;									de.Decals = CreateDecal(Rand(2,3), e\room\x+(140.0*(i-3))*RoomScale, 1.0, e\room\z-Rnd(197,199)*Sin(e\room\angle)*RoomScale-Rnd(0.001,0.003),0,e\room\angle-90,Rnd(360))
;									de\size = Rnd(0.8,0.85) : de\sizechange = 0.001
;								EndIf
;								de.Decals = CreateDecal(Rand(2,3), EntityX(e\room\NPC[0]\Collider)+Rnd(-2,2),Rnd(0.001,0.003),EntityZ(e\room\NPC[0]\Collider)+Rnd(-2,2),90,Rnd(360),0)
;								
;							Next
;							de\Size = Rnd(0.5,0.7)
;							ScaleSprite(de\obj, de\Size,de\Size)
;							
;							Curr096\State=5
;							
;							RemoveNPC(e\room\NPC[0])
;							e\room\NPC[0]=Null
;							
;						EndIf
						
						
						Curr096\Target = e\room\NPC[0]
						
						If e\EventState < 70*8
							AnimateNPC(Curr096,472,520,0.25)
							PointEntity e\room\NPC[0]\Collider, Curr096\Collider
						ElseIf e\EventState >= 70*8 And e\EventState < 70*10
							;Checking at which side the player is
							If EntityDistance(Collider,e\room\RoomDoors[0]\frameobj)<EntityDistance(Collider,e\room\RoomDoors[1]\frameobj)
								AnimateNPC(Curr096,521,555,0.25,False)
								If Curr096\Frame=>554.5
									e\EventState=70*10
									Curr096\Frame = 677
									SetNPCFrame(Curr096,Curr096\Frame)
									Curr096\State = 1
									TurnEntity Curr096\Collider,0,180,0
									MoveEntity Curr096\Collider,0,0,0.3
								EndIf
							Else
								AnimateNPC(Curr096,556,590,0.25,False)
								If Curr096\Frame=>589.5
									e\EventState=70*10
									Curr096\Frame = 677
									SetNPCFrame(Curr096,Curr096\Frame)
									Curr096\State = 1
									TurnEntity Curr096\Collider,0,180,0
									MoveEntity Curr096\Collider,0,0,0.3
								EndIf
							EndIf
							PointEntity e\room\NPC[0]\Collider, Curr096\Collider
						ElseIf e\EventState >= 70*10 And e\EventState < 70*20
							Curr096\State=Min(Max(1,Curr096\State),3)
							Curr096\State2=Max(Curr096\State2,70*12)
							If e\EventState-FPSfactor =< 70*15 Then ;walk to the doorway
								If e\EventState > 70*15 Then
									e\room\NPC[0]\State=14
									e\room\NPC[0]\PathStatus = FindPath(e\room\NPC[0], EntityX(Curr096\Collider,True),0.4,EntityZ(Curr096\Collider,True))
									e\room\NPC[0]\PathTimer=300
								Else
									PointEntity e\room\NPC[0]\Collider, Curr096\Collider
								EndIf
							EndIf
							;If e\room\NPC[0]\PathStatus=0 Then
							If EntityVisible(e\room\NPC[0]\Collider,Curr096\Collider)
								e\room\RoomDoors[2]\open = False
								e\room\NPC[0]\State=13
								PointEntity e\room\NPC[0]\obj, Curr096\Collider
								RotateEntity (e\room\NPC[0]\Collider, 0, CurveAngle(EntityYaw(e\room\NPC[0]\obj),EntityYaw(e\room\NPC[0]\Collider),30),0)
							EndIf
						Else
							If Curr096\State = 4 Then ;shoot at 096 when it starts attacking
								Curr096\LastSeen=1
								e\room\NPC[0]\State = 2
								PointEntity e\room\NPC[0]\obj, Curr096\Collider
								RotateEntity (e\room\NPC[0]\Collider, 0, CurveAngle(EntityYaw(e\room\NPC[0]\obj),EntityYaw(e\room\NPC[0]\Collider),30),0)
								If PlayerRoom = e\room Then LightBlink = (e\room\NPC[0]\Reload)+Rnd(0.5,2.0)
								Curr096\Target = e\room\NPC[0]
							Else
								If e\EventState>70*22 Then Curr096\State = 4
								If e\room\NPC[0]\State=13 Then
									e\room\NPC[0]\State=14
									e\room\NPC[0]\PathStatus = FindPath(e\room\NPC[0], EntityX(e\room\obj,True),0.4,EntityZ(e\room\obj,True))
									e\room\NPC[0]\PathTimer=300
									e\room\NPC[0]\Speed = e\room\NPC[0]\Speed*1.8 ;Making the guard walking a bit faster
								EndIf
							EndIf
						EndIf
						
						If AnimTime(Curr096\obj)>25 And AnimTime(Curr096\obj)<150 Then
							FreeSound_Strict e\Sound : e\Sound = 0
							e\Sound=LoadSound_Strict("SFX\Character\Guard\096ServerRoom2.ogg")
							e\SoundCHN=PlaySound_Strict(e\Sound)
							
							Curr096\CurrSpeed = 0
							
							For i = 0 To 6
								If e\room\angle = 0 Or e\room\angle = 180 Then
									de.Decals = CreateDecal(Rand(2,3), e\room\x-Rnd(197,199)*Cos(e\room\angle)*RoomScale, 1.0, e\room\z+(140.0*(i-3))*RoomScale,0,e\room\angle+90,Rnd(360))
									de\size = Rnd(0.8,0.85) : de\sizechange = 0.001
									de.Decals = CreateDecal(Rand(2,3), e\room\x-Rnd(197,199)*Cos(e\room\angle)*RoomScale, 1.0, e\room\z+(140.0*(i-3))*RoomScale,0,e\room\angle-90,Rnd(360))
									de\size = Rnd(0.8,0.85) : de\sizechange = 0.001
								Else
									de.Decals = CreateDecal(Rand(2,3), e\room\x+(140.0*(i-3))*RoomScale, 1.0, e\room\z-Rnd(197,199)*Sin(e\room\angle)*RoomScale-Rnd(0.001,0.003),0,e\room\angle+90,Rnd(360))
									de\size = Rnd(0.8,0.85) : de\sizechange = 0.001
									de.Decals = CreateDecal(Rand(2,3), e\room\x+(140.0*(i-3))*RoomScale, 1.0, e\room\z-Rnd(197,199)*Sin(e\room\angle)*RoomScale-Rnd(0.001,0.003),0,e\room\angle-90,Rnd(360))
									de\size = Rnd(0.8,0.85) : de\sizechange = 0.001
								EndIf
								de.Decals = CreateDecal(Rand(2,3), EntityX(e\room\NPC[0]\Collider)+Rnd(-2,2),Rnd(0.001,0.003),EntityZ(e\room\NPC[0]\Collider)+Rnd(-2,2),90,Rnd(360),0)
								
							Next
							de\Size = Rnd(0.5,0.7)
							ScaleSprite(de\obj, de\Size,de\Size)
							
							Curr096\State=5
							StopStream_Strict(Curr096\SoundChn)
							Curr096\SoundChn=0
							
							RemoveNPC(e\room\NPC[0])
							e\room\NPC[0]=Null
						EndIf
					Else
						
						If e\EventState >= 70*40 And e\EventState-FPSfactor < 70*40 Then ;open them again to let the player in
							e\room\RoomDoors[0]\locked=False
							e\room\RoomDoors[1]\locked=False
							UseDoor(e\room\RoomDoors[0],False)
							UseDoor(e\room\RoomDoors[1],False)
							FreeSound_Strict e\Sound : e\Sound = 0
							e\room\RoomDoors[0]\locked=True
							e\room\RoomDoors[1]\locked=True
						EndIf
						
						If PlayerRoom = e\room Then
							If e\SoundCHN<>0 Then
								If	ChannelPlaying(e\SoundCHN) Then 
									LightBlink = Rnd(0.5,6.0)
									If Rand(50)=1 Then PlaySound2(IntroSFX(Rand(10,12)), Camera, e\room\obj, 8.0, Rnd(0.1,0.3))
								EndIf
							EndIf						
							
							If (e\room\angle = 0 Or e\room\angle = 180) Then ;lock the player inside
								If Abs(EntityX(Collider)-EntityX(e\room\obj,True))> 1.3 Then 
									e\EventState = 70*50
									e\Sound=0
								EndIf
							Else
								If Abs(EntityZ(Collider)-EntityZ(e\room\obj,True))> 1.3 Then 
									e\EventState = 70*50
									e\Sound=0
								EndIf
							EndIf	
						EndIf
						
					EndIf
					
				ElseIf PlayerRoom = e\room
					temp = UpdateLever(e\room\Objects[1]) ;power switch
					x = UpdateLever(e\room\Objects[3]) ;fuel pump
					z = UpdateLever(e\room\Objects[5]) ;generator
					
					;fuel pump on
					If x Then
						e\EventState2 = Min(1.0, e\EventState2+FPSfactor/350)
						
						;generator on
						If z Then
							If e\Sound2=0 Then LoadEventSound(e,"SFX\General\GeneratorOn.ogg",1)
							e\EventState3 = Min(1.0, e\EventState3+FPSfactor/450)
						Else
							e\EventState3 = Min(0.0, e\EventState3-FPSfactor/450)
						EndIf
					Else
						e\EventState2 = Max(0, e\EventState2-FPSfactor/350)
						e\EventState3 = Max(0, e\EventState3-FPSfactor/450)
					EndIf
					
					If e\EventState2>0 Then e\SoundCHN=LoopSound2(RoomAmbience[8], e\SoundCHN, Camera, e\room\Objects[3], 5.0, e\EventState2*0.8)
					If e\EventState3>0 Then e\SoundCHN2=LoopSound2(e\Sound2, e\SoundCHN2, Camera, e\room\Objects[5], 6.0, e\EventState3)
					
					If temp=0 And x And z Then
						e\room\RoomDoors[0]\locked = False
						e\room\RoomDoors[1]\locked = False
					Else
						If	Rand(200)<5 Then LightBlink = Rnd(0.5,1.0)
						
						If e\room\RoomDoors[0]\open Then 
							e\room\RoomDoors[0]\locked = False
							UseDoor(e\room\RoomDoors[0],False) 
						EndIf
						If e\room\RoomDoors[1]\open Then 
							e\room\RoomDoors[1]\locked = False
							UseDoor(e\room\RoomDoors[1],False)
						EndIf
						e\room\RoomDoors[0]\locked=True
						e\room\RoomDoors[1]\locked=True							
					EndIf 
				EndIf
				
				
			Case "room2storage"
				
				If PlayerRoom = e\room Then
					If e\EventState2 <= 0 Then
						e\room\RoomDoors[1]\locked = False
						e\room\RoomDoors[4]\locked = False
						
						If EntityDistance(Collider, Curr173\obj)<8.0 Or EntityDistance(Collider, Curr106\obj)<8.0 Then
							e\room\RoomDoors[1]\locked = True
							e\room\RoomDoors[4]\locked = True
						Else
							For n.NPCs = Each NPCs
								If n\NPCtype = NPCtypeMTF Then 
									If EntityDistance(Collider, Curr173\obj)<8.0 Then 
										e\room\RoomDoors[1]\locked = True
										e\room\RoomDoors[4]\locked = True
										Exit
									EndIf
								EndIf
							Next
						EndIf
						e\EventState2 = 70*5
					Else
						e\EventState2 = e\EventState2 - FPSfactor
					EndIf
					
					LightVolume = TempLightVolume*0.5
					
					TFormPoint EntityX(Collider),EntityY(Collider),EntityZ(Collider),0,e\room\obj
					
					temp = 0
					If TFormedX()>730 Then
						GiveAchievement(Achv970)
						
						UpdateWorld()
						TFormPoint EntityX(Collider),EntityY(Collider),EntityZ(Collider),0,e\room\obj
						
						;1->3, 2->4
						;3->0, 4->0
						For i = 1 To 2
							e\room\RoomDoors[i]\open = e\room\RoomDoors[i+2]\open
							e\room\RoomDoors[i]\openstate = e\room\RoomDoors[i+2]\openstate
							PositionEntity e\room\RoomDoors[i]\obj, EntityX(e\room\RoomDoors[i+2]\obj),EntityY(e\room\RoomDoors[i+2]\obj),EntityZ(e\room\RoomDoors[i+2]\obj)
							PositionEntity e\room\RoomDoors[i]\obj2, EntityX(e\room\RoomDoors[i+2]\obj2),EntityY(e\room\RoomDoors[i+2]\obj2),EntityZ(e\room\RoomDoors[i+2]\obj2)							
							
							e\room\RoomDoors[i+2]\open = False
							e\room\RoomDoors[i+2]\openstate = 0
							PositionEntity e\room\RoomDoors[i+2]\obj, EntityX(e\room\RoomDoors[0]\obj),EntityY(e\room\RoomDoors[0]\obj),EntityZ(e\room\RoomDoors[0]\obj)
							PositionEntity e\room\RoomDoors[i+2]\obj2, EntityX(e\room\RoomDoors[0]\obj2),EntityY(e\room\RoomDoors[0]\obj2),EntityZ(e\room\RoomDoors[0]\obj2)							
						Next	
						
						TFormPoint TFormedX()-1024, TFormedY(), TFormedZ(),e\room\obj,0
						HideEntity Collider
						PositionEntity Collider, TFormedX(), EntityY(Collider), TFormedZ(), True
						ShowEntity Collider
						DebugLog "tformedx()>720"
						temp = True
						
					ElseIf TFormedX()<-730
						GiveAchievement(Achv970)
						
						UpdateWorld()
						TFormPoint EntityX(Collider),EntityY(Collider),EntityZ(Collider),0,e\room\obj
						
						;3->1, 4->2
						;1->0, 2->0
						For i = 1 To 2
							e\room\RoomDoors[i+2]\open = e\room\RoomDoors[i]\open
							e\room\RoomDoors[i+2]\openstate = e\room\RoomDoors[i]\openstate
							PositionEntity e\room\RoomDoors[i+2]\obj, EntityX(e\room\RoomDoors[i]\obj),EntityY(e\room\RoomDoors[i]\obj),EntityZ(e\room\RoomDoors[i]\obj)
							PositionEntity e\room\RoomDoors[i+2]\obj2, EntityX(e\room\RoomDoors[i]\obj2),EntityY(e\room\RoomDoors[i]\obj2),EntityZ(e\room\RoomDoors[i]\obj2)							
							
							e\room\RoomDoors[i]\open = False
							e\room\RoomDoors[i]\openstate = 0
							PositionEntity e\room\RoomDoors[i]\obj, EntityX(e\room\RoomDoors[0]\obj),EntityY(e\room\RoomDoors[0]\obj),EntityZ(e\room\RoomDoors[0]\obj)
							PositionEntity e\room\RoomDoors[i]\obj2, EntityX(e\room\RoomDoors[0]\obj2),EntityY(e\room\RoomDoors[0]\obj2),EntityZ(e\room\RoomDoors[0]\obj2)							
						Next
						
						TFormPoint TFormedX()+1024, TFormedY(), TFormedZ(),e\room\obj,0
						HideEntity Collider
						PositionEntity Collider, TFormedX(), EntityY(Collider), TFormedZ(), True
						ShowEntity Collider
						
						DebugLog "tformedx()<720"
						
						temp = True
					EndIf
					
					If temp = True Then 
						
						e\EventState=e\EventState+1;Rand(1,2)
						
						For it.Items = Each Items
							If EntityDistance(it\collider,Collider)<5.0 Then
								
								TFormPoint EntityX(it\collider),EntityY(it\collider),EntityZ(it\collider),0,e\room\obj
								x = TFormedX() : y = TFormedY() : z = TFormedZ()
								If TFormedX()>264 Then
									TFormPoint x-1024,y,z,e\room\obj,0
									PositionEntity it\collider, TFormedX(), TFormedY(), TFormedZ()
									ResetEntity it\collider
								ElseIf TFormedX()<-264
									TFormPoint x+1024,y,z,e\room\obj,0
									PositionEntity it\collider, TFormedX(), TFormedY(), TFormedZ()
									ResetEntity it\collider
								EndIf
								
							EndIf
						Next
						
						Select e\EventState 
							Case 2
								i = Rand(MaxItemAmount)
								If Inventory(i)<>Null Then RemoveItem(Inventory(i))								
							Case 5
								Injuries = Injuries + 0.3
							Case 10
								de.Decals = CreateDecal(3, EntityX(e\room\obj)+Cos(e\room\angle-90)*760*RoomScale, 0.0005, EntityZ(e\room\obj)+Sin(e\room\angle-90)*760*RoomScale,90,Rnd(360),0)
							Case 14
								For i = 0 To MaxItemAmount-1
									If Inventory(i)<> Null Then
										If Inventory(i)\itemtemplate\tempname = "paper" Then
											RemoveItem(Inventory(i))
											For itt.ItemTemplates = Each ItemTemplates
												If itt\tempname = "paper" And Rand(6)=1 Then
													Inventory(i) = CreateItem(itt\name, itt\tempname, 1,1,1)
													HideEntity Inventory(i)\collider
													Inventory(i)\Picked = True
													Exit
												EndIf
											Next
											Exit
										EndIf
									EndIf
								Next
							Case 18
								TFormPoint -344,176, 272, e\room\obj,0
								it.Items = CreateItem("Strange Note", "paper", TFormedX(), TFormedY(), TFormedZ())
								EntityType(it\collider, HIT_ITEM)
							Case 25
								e\room\NPC[0]=CreateNPC(NPCtypeD, EntityX(e\room\obj)+Cos(e\room\angle-90)*760*RoomScale, 0.35, EntityZ(e\room\obj)+Sin(e\room\angle-90)*760*RoomScale)
								RotateEntity e\room\NPC[0]\Collider, 0, e\room\angle-200, 0, True
								tex=LoadTexture("GFX\NPCs\corpse.jpg")
								e\room\NPC[0]\texture = "GFX\NPCs\corpse.jpg"
								EntityTexture e\room\NPC[0]\obj, tex
								FreeTexture tex
								SetAnimTime(e\room\NPC[0]\obj,80)
								e\room\NPC[0]\State=10
							Case 30
								i = Rand(0,MaxItemAmount-1)
								If Inventory(i)<>Null Then RemoveItem(Inventory(i))
								Inventory(i) = CreateItem("Strange Note", "paper", 1,1,1)
								HideEntity Inventory(i)\collider
								Inventory(i)\Picked = True
							Case 35
								For i = 0 To 3
									de.Decals = CreateDecal(17, e\room\x+Rnd(-2,2), 700*RoomScale, e\room\z+Rnd(-2,2), 270, Rand(360), 0)
									de\Size = 0.05 : de\SizeChange = 0.0005 : EntityAlpha(de\obj, 0.8) : UpdateDecals
								Next
							Case 40
								PlaySound_Strict(LoadTempSound("SFX\radio\franklin4.ogg"))
							Case 50
								e\room\NPC[1]=CreateNPC(NPCtypeGuard, EntityX(e\room\obj)+Cos(e\room\angle+90)*600*RoomScale, 0.35, EntityZ(e\room\obj)+Sin(e\room\angle+90)*600*RoomScale)
								e\room\NPC[1]\State=7
							Case 52
								If e\room\NPC[1] <> Null Then
									RemoveNPC(e\room\NPC[1])
									e\room\NPC[1]=Null
								EndIf
							Case 60
								If (Not HalloweenTex) Then
									Local tex970 = LoadTexture_Strict("GFX\npcs\173h.pt", 1)
									EntityTexture Curr173\obj, tex970, 0, 0
									FreeTexture tex970
								EndIf
						End Select
						
						If Rand(10)=1 Then
							temp = Rand(0,2)
							PlaySound_Strict(AmbientSFX(temp, Rand(0,AmbientSFXAmount(temp)-1)))
						EndIf
					Else
						If e\room\NPC[0] <> Null Then
							If EntityDistance(Collider, e\room\NPC[0]\Collider)<3.0 Then
								If EntityInView(e\room\NPC[0]\obj, Camera) Then
									CurrCameraZoom = (Sin(Float(MilliSecs2())/20.0)+1.0)*15.0
									HeartBeatVolume = Max(CurveValue(0.3, HeartBeatVolume, 2.0), HeartBeatVolume)
									HeartBeatRate = Max(HeartBeatRate, 120)
								EndIf
							EndIf
						EndIf
						
						If e\room\NPC[1] <> Null Then
							PointEntity e\room\NPC[1]\obj, Collider
							RotateEntity e\room\NPC[1]\Collider, 0, CurveAngle(EntityYaw(e\room\NPC[1]\obj),EntityYaw(e\room\NPC[1]\Collider),35),0
						EndIf
						
						;If Abs(TFormedX())<264 Then 
						For it.Items = Each Items
							If (it\Dropped=1 And Abs(TFormedX())<264) Or it\Dropped=-1 Then
								DebugLog "dropping/picking: "+it\Dropped+" - "+EntityX(it\collider)+", "+EntityY(it\collider)+", "+EntityZ(it\collider)
								
								TFormPoint EntityX(it\collider),EntityY(it\collider),EntityZ(it\collider),0,e\room\obj
								x = TFormedX() : y = TFormedY() : z = TFormedZ()
								
								If it\Dropped=1 Then
									For i = - 1 To 1 Step 2
										TFormPoint x+1024*i,y,z,e\room\obj,0
										it2.items = CreateItem(it\name, it\itemtemplate\tempname, TFormedX(), EntityY(it\collider), TFormedZ())
										RotateEntity(it2\collider, EntityPitch(it\collider),EntityYaw(it\collider),0)
										EntityType(it2\collider, HIT_ITEM)
									Next
								Else
									For it2.items = Each Items
										If it2<>it And it2\dist < 15.0 Then
											
											TFormPoint EntityX(it2\collider),EntityY(it2\collider),EntityZ(it2\collider),0,e\room\obj
											DebugLog TFormedZ()+" - "+z
											
											If TFormedZ()=z Then RemoveItem(it2) : DebugLog "item removed"									
										EndIf
									Next
								EndIf
								
								Exit
							EndIf
						Next
						;EndIf						
					EndIf
					
				EndIf
				
				
				If e\EventState > 26 Then
					If Abs(EntityX(Collider)-e\room\x)<8.0 Then
						If Abs(EntityZ(Collider)-e\room\z)<8.0 Then
							If e\Sound = 0 Then
								e\Sound = LoadSound_Strict("SFX\SCP\970\Corpse.ogg")
							EndIf
							e\SoundCHN = LoopSound2(e\Sound, e\SoundCHN, Camera, e\room\NPC[0]\obj);
							If e\EventState < 30 Then
								LightVolume = TempLightVolume*0.4
							ElseIf e\EventState > 60
								AnimateNPC(e\room\NPC[0], 80, 61, -0.02, False)
								
								e\room\NPC[0]\DropSpeed = 0
								y = CurveValue(1.5+Sin(Float(MilliSecs2())/20.0)*0.1,EntityY(e\room\NPC[0]\Collider),50.0)
								
								PositionEntity e\room\NPC[0]\Collider,EntityX(e\room\NPC[0]\Collider),y,EntityZ(e\room\NPC[0]\Collider)
								TurnEntity e\room\NPC[0]\Collider,0,0.1*FPSfactor,0
							EndIf 								
						EndIf
						
					EndIf
				EndIf					
				
				
				
			Case "room2test1074"
				
				
				If PlayerRoom=e\room Then
					If e\Sound=0 Then e\Sound=LoadSound_Strict("SFX\music\420J.ogg") ;tell me if you can find a better alternative to this					
					
					GiveAchievement(Achv1074)
					If (Wearing714=1) Or (WearingNightVision>0) Then
						Playable = True : e\EventState = 0 : e\EventState2 = 0
						If EntityInView(e\room\Objects[0],Camera) And EntityVisible(e\room\Objects[0],Camera) Then GiveAchievement(Achv1074)
					EndIf					
					
					;check if 714 is being used, and choose the right texture---------------					
					If (e\EventState3 < 1.0 And ((Wearing714=1) Or (WearingNightVision>0))) Then
						ForceAngle = 0.0
						e\EventState3 = 1.0
						If EntityInView(e\room\Objects[0],Camera) And EntityVisible(e\room\Objects[0],Camera) Then BlinkTimer = -2 : BlurTimer = 500
						If e\SoundCHN <> 0 Then StopChannel e\SoundCHN : e\SoundCHN = 0
						aa=GetSurfaceBrush(e\room\NonFreeAble[0])
						BrushTexture aa, e\room\Textures[0], 0, 1
						PaintSurface e\room\NonFreeAble[0],aa
						FreeBrush aa
						HeartBeatVolume = 0.0
					EndIf
					If (e\EventState3 > 0.0 And (Not ((Wearing714=1) Or (WearingNightVision>0)))) Then
						e\EventState3 = 0.0
						If EntityInView(e\room\Objects[0],Camera) And EntityVisible(e\room\Objects[0],Camera) Then BlinkTimer = -2 : BlurTimer = 500
						aa=GetSurfaceBrush(e\room\NonFreeAble[0])
						BrushTexture aa, e\room\Textures[1], 0, 1
						PaintSurface e\room\NonFreeAble[0],aa
						FreeBrush aa
					EndIf
					
					;end with that------------
					
					
					bb# = point_direction(EntityX(e\room\Objects[0],True),EntityZ(e\room\Objects[0],True),EntityX(Collider,True),EntityZ(Collider,True))
					cc# = point_direction(EntityX(e\room\Objects[0],True),EntityZ(e\room\Objects[0],True),EntityX(e\room\Objects[1],True),EntityZ(e\room\Objects[1],True))
					
					
					If EntityInView(e\room\Objects[0],Camera) And EntityVisible(e\room\Objects[0],Camera) And BlinkTimer > 0 And (Not (Wearing714=1)) And (Not (WearingNightVision>0)) And Abs(angleDist(bb,cc))<95.0 Then
						If e\EventState = 0.0 Then e\EventState = 1.0
						;
					EndIf
					If e\EventState > 0.0 Then
						HeartBeatRate = 150
						HeartBeatVolume = 0.5
						If e\EventState = 1.0 Then e\SoundCHN = PlaySound_Strict(e\Sound) : ChannelVolume e\SoundCHN,1.0
						;Player saw 1074: walk towards r\Objects[1]
						tempF# = point_direction(EntityX(Collider,True),EntityZ(Collider,True),EntityX(e\room\Objects[0],True),EntityZ(e\room\Objects[0],True))
						tempF2# = EntityYaw(Collider)
						tempF3# = angleDist(tempF+90+Sin(WrapAngle(e\EventState/10)),tempF2)
						TurnEntity Collider, 0,tempF3/8,0,True
						If e\EventState < 100.0 Or e\EventState > 105.0 Then
							e\EventState = e\EventState + Min(FPSfactor,1.99)
						Else
							e\EventState2 = Min(e\EventState2+(0.01*Min(FPSfactor,1.99)),0.5) ;If e\EventState2<0.5 Then 
							ForceMove = e\EventState2
							Crouch = 0
							If point_distance(EntityX(Collider,True),EntityZ(Collider,True),EntityX(e\room\Objects[1],True),EntityZ(e\room\Objects[1],True)) <= RoomScale*800.0 Then
								ForceAngle = point_direction(EntityX(Collider,True),EntityZ(Collider,True),EntityX(e\room\Objects[1],True),EntityZ(e\room\Objects[1],True))-tempF2+90.0
							Else
								ForceAngle = point_direction(EntityX(Collider,True),EntityZ(Collider,True),EntityX(e\room\Objects[0],True),EntityZ(e\room\Objects[0],True))-tempF2+90.0
							EndIf
							If point_distance(EntityX(Collider,True),EntityZ(Collider,True),EntityX(e\room\Objects[1],True),EntityZ(e\room\Objects[1],True)) < RoomScale*8.0 Then
								e\EventState = 106.0
								Playable = False
								ForceMove = 0
								ForceAngle = 0
								e\EventState2 = 0
							EndIf
						EndIf
						
						If (Not EntityVisible(e\room\Objects[0],Camera)) Then Playable=True : e\EventState = 0 : e\EventState2 = 0
						
						Select Floor(e\EventState)
							Case 250.0
								Msg = "Hey there!"
								MsgTimer = 70*5
							Case 500.0
								Msg = "If you're seeing this, post a bug report."
								MsgTimer = 70*5
							Case 700.0
								Msg = "Seriously, this SCP should not spawn." ; shouldn't --> should not why juan why --Mark
								MsgTimer = 70*5
							Case 800.0
								BlinkTimer = -2
								BlurTimer = 800
							Case 1200.0
								Msg = "This event sucks."
								MsgTimer = 70*5
							Case 1400.0
								Msg = "Thanks a lot, Juan."
								MsgTimer = 70*5
							Case 1500.0
								DeathMSG = "God DAMMIT, Juan. What were you thinking?"
								Kill()
						End Select
						If e\EventState >= 2500.0 Then
							;BlinkTimer = -20 : LightBlink = 1.0
							ChannelVolume e\SoundCHN,(Max(0,2600.0-e\EventState))/100.0
						EndIf
						If PlayerRoom <> e\room Then
							;e\EventState = 2300.0
							If PlayerRoom\RoomTemplate\Name = "pocketdimension" Then DeathMSG = "Subject D-9341 was captured and killed by SCP-106. Body was disposed of via incineration."
							Kill()
							Playable = True
						EndIf
						If KillTimer < 0 Then
							e\EventState = 2300.0
							ForceAngle = 0.0
							ForceMove = 0.0
							If e\SoundCHN <> 0 Then StopChannel e\SoundCHN : e\SoundCHN = 0
							Playable = True
							;FreeTexture r\Objects[2]
							;FreeTexture r\Objects[3]
							;FreeEntity r\Objects[0]
							;FreeEntity r\Objects[1]
							;FreeSound_Strict e\Sound
							;e\Sound = 0
						EndIf
						user_camera_pitch = user_camera_pitch-((user_camera_pitch-10.0)/8)
					Else
						If e\SoundCHN <> 0 Then StopChannel e\SoundCHN : e\SoundCHN = 0
					EndIf
					
				EndIf
				
			Case "room3door"
				
				If PlayerRoom = e\room Then
					If EntityDistance(e\room\obj,Collider)<2.5 Then
						For do.doors = Each Doors
							If Abs(EntityX(do\obj,True)-EntityX(Collider))<2.0 Then
								If Abs(EntityZ(do\obj,True)-EntityZ(Collider))<2.0 Then
									If (Not EntityInView(do\obj,Camera)) Then
										If do\open Then
											DebugLog "%@@= \ {2E6C2=FD gi`h]c"
											do\open = False
											do\openstate = 0
											BlurTimer = 100
											CameraShake = 3.0											
										EndIf
										
									EndIf
									Exit
								EndIf
							EndIf
						Next
						RemoveEvent(e)
					EndIf
				EndIf
				
			Case "room3servers"
				
				If PlayerRoom = e\room Then
					If e\EventState3=0 And Curr173\Idle = 0 Then
						If BlinkTimer < -10 Then 
							temp = Rand(0,2)
							PositionEntity Curr173\Collider, EntityX(e\room\Objects[temp],True),EntityY(e\room\Objects[temp],True),EntityZ(e\room\Objects[temp],True)
							ResetEntity Curr173\Collider
							e\EventState3=1
						EndIf
					EndIf
					
					If e\room\Objects[3]>0 Then 
						If BlinkTimer<-8 And BlinkTimer >-12 Then
							PointEntity e\room\Objects[3], Camera
							RotateEntity(e\room\Objects[3], 0, EntityYaw(e\room\Objects[3],True),0, True)
						EndIf
						If e\EventState2 = 0 Then 
							e\EventState = CurveValue(0, e\EventState, 15.0)
							If Rand(800)=1 Then e\EventState2 = 1
						Else
							e\EventState = e\EventState+(FPSfactor*0.5)
							If e\EventState > 360 Then e\EventState = 0	
							
							If Rand(1200)=1 Then e\EventState2 = 0
						EndIf
						
						PositionEntity e\room\Objects[3], EntityX(e\room\Objects[3],True), (-608.0*RoomScale)+0.05+Sin(e\EventState+270)*0.05, EntityZ(e\room\Objects[3],True), True
					EndIf
				EndIf
				
			Case "room3storage"
				
				If PlayerRoom = e\room Then
					e\EventState2 = UpdateElevators(e\EventState2, e\room\RoomDoors[0], e\room\RoomDoors[1],e\room\Objects[0],e\room\Objects[1], e)
					
					e\EventState3 = UpdateElevators(e\EventState3, e\room\RoomDoors[2], e\room\RoomDoors[3],e\room\Objects[2],e\room\Objects[3], e)
					
					If EntityY(Collider)<-4600*RoomScale Then
						
						GiveAchievement(Achv939)
						
						ShouldPlay = 7
						
						If e\room\NPC[0]=Null Or e\room\NPC[1]=Null Or e\room\NPC[2]=Null Then
							If QuickLoadPercent = -1 Then
								QuickLoadPercent = 0
								QuickLoad_CurrEvent = e
							EndIf
						Else
							If e\EventState = 0 Then
								;Instance 1
								PositionEntity(e\room\NPC[0]\Collider, EntityX(e\room\Objects[4],True),EntityY(e\room\Objects[4],True)+0.2,EntityZ(e\room\Objects[4],True))
								ResetEntity e\room\NPC[0]\Collider
								e\room\NPC[0]\State = 2
								e\room\NPC[0]\State2 = 5
								e\room\NPC[0]\PrevState = 7
								;Instance 2
								PositionEntity(e\room\NPC[1]\Collider, EntityX(e\room\Objects[9],True),EntityY(e\room\Objects[9],True)+0.2,EntityZ(e\room\Objects[9],True))
								ResetEntity e\room\NPC[1]\Collider
								e\room\NPC[1]\State = 2
								e\room\NPC[1]\State2 = 10
								e\room\NPC[1]\PrevState = 12
								;Instance 3
								PositionEntity(e\room\NPC[2]\Collider, EntityX(e\room\Objects[13],True),EntityY(e\room\Objects[13],True)+0.2,EntityZ(e\room\Objects[13],True))
								ResetEntity e\room\NPC[2]\Collider
								e\room\NPC[2]\State = 2
								e\room\NPC[2]\State2 = 14
								e\room\NPC[2]\PrevState = 16
								;Other
								e\EventState = 1
							EndIf
							
							If e\room\RoomDoors[4]\open = False
								If UpdateLever(e\room\Levers[0])
									e\room\RoomDoors[4]\open = True
									If e\Sound2 <> 0 Then FreeSound_Strict e\Sound2 : e\Sound2=0
									e\Sound2 = LoadSound_Strict("SFX\Door\Door2Open1_dist.ogg")
									e\SoundCHN2 = PlaySound2(e\Sound2,Camera,e\room\RoomDoors[4]\obj,400)
								EndIf
								If UpdateLever(e\room\Levers[1])
									e\room\RoomDoors[4]\open = True
									If e\Sound2 <> 0 Then FreeSound_Strict e\Sound2 : e\Sound2=0
									e\Sound2 = LoadSound_Strict("SFX\Door\Door2Open1_dist.ogg")
									e\SoundCHN2 = PlaySound2(e\Sound2,Camera,e\room\RoomDoors[4]\obj,400)
								EndIf
							EndIf
							
							UpdateLever(e\room\Levers[0],e\room\RoomDoors[4]\open)
							UpdateLever(e\room\Levers[1],e\room\RoomDoors[4]\open)
							
							e\room\NPC[0]\IgnorePlayer = False
							e\room\NPC[2]\IgnorePlayer = False
							
							CurrTrigger$ = CheckTriggers()
							
							Select CurrTrigger$
								Case "939-1_fix"
									e\room\NPC[0]\IgnorePlayer = True
								Case "939-3_fix"
									e\room\NPC[2]\IgnorePlayer = True
							End Select
							
							If ChannelPlaying(e\SoundCHN2)
								UpdateSoundOrigin(e\SoundCHN2,Camera,e\room\RoomDoors[4]\obj,400)
							EndIf
							
							PlayerFallingPickDistance = 0.0
							
							If EntityY(Collider)<-6400*RoomScale And KillTimer >= 0 And FallTimer >= 0 Then
								DeathMSG=""
								PlaySound_Strict LoadTempSound("SFX/Room/PocketDimension\Impact.ogg")
								KillTimer=-1.0
							EndIf
						EndIf
					Else
						e\EventState = 0
						If e\room\NPC[0]<>Null Then e\room\NPC[0]\State = 66
						If e\room\NPC[1]<>Null Then e\room\NPC[1]\State = 66
						If e\room\NPC[2]<>Null Then e\room\NPC[2]\State = 66
					EndIf
				Else
					If e\room\NPC[0]<>Null Then e\room\NPC[0]\State = 66
					If e\room\NPC[1]<>Null Then e\room\NPC[1]\State = 66
					If e\room\NPC[2]<>Null Then e\room\NPC[2]\State = 66
				EndIf 
				
			Case "room3tunnel"
				
				If e\EventState = 0 Then
					e\room\NPC[0]=CreateNPC(NPCtypeGuard, EntityX(e\room\Objects[0],True), EntityY(e\room\Objects[0],True)+0.5, EntityZ(e\room\Objects[0],True))
					PointEntity e\room\NPC[0]\Collider, e\room\obj
					RotateEntity e\room\NPC[0]\Collider, 0, EntityYaw(e\room\NPC[0]\Collider)+Rnd(-20,20),0, True
					SetNPCFrame (e\room\NPC[0], 288)
					e\room\NPC[0]\State = 8
					
					e\EventState = 1
					RemoveEvent(e)
				EndIf
				
			Case "room4"
				
				If e\EventState < MilliSecs2() Then
					If PlayerRoom <> e\room Then
						If Distance(EntityX(Collider),EntityZ(Collider),EntityX(e\room\obj),EntityZ(e\room\obj))<16.0 Then
							For n.NPCs = Each NPCs
								If n\NPCtype = NPCtype049 Then
									If n\State = 2 And EntityDistance(Collider,n\Collider)>16.0 Then
										TFormVector(368, 528, 176, e\room\obj, 0)
										PositionEntity n\Collider, EntityX(e\room\obj)+TFormedX(), TFormedY(), EntityZ(e\room\obj)+TFormedZ()
										DebugLog TFormedX()+", "+ TFormedY()+", "+ TFormedZ()
										ResetEntity n\Collider
										n\PathStatus = 0
										n\State = 4
										n\State2 = 0
										n\State3 = 0
										RemoveEvent(e)
									EndIf
									Exit
								EndIf
							Next
						EndIf
					EndIf
					If e<>Null Then e\EventState = MilliSecs2()+5000
				EndIf
				
			Case "room012"
				
				If PlayerRoom = e\room Then
					
					If e\EventState=0 Then
						If EntityDistance(Collider, e\room\RoomDoors[0]\obj)<2.5 And RemoteDoorOn Then
							GiveAchievement(Achv012)
							PlaySound_Strict HorrorSFX(7)
							PlaySound2 (LeverSFX,Camera,e\room\RoomDoors[0]\obj) 
							e\EventState=1
							e\room\RoomDoors[0]\locked = False
							UseDoor(e\room\RoomDoors[0],False)
							e\room\RoomDoors[0]\locked = True
						EndIf
					Else
						
						If e\Sound=0 Then LoadEventSound(e,"SFX\Music\012Golgotha.ogg")
						e\SoundCHN = LoopSound2(e\Sound, e\SoundCHN, Camera, e\room\Objects[3], 5.0)
						
						If e\Sound2=0 Then LoadEventSound(e,"SFX\Music\012.ogg",1)
						
						If e\EventState<90 Then e\EventState=CurveValue(90,e\EventState,500)
						PositionEntity e\room\Objects[2], EntityX(e\room\Objects[2],True),(-130-448*Sin(e\EventState))*RoomScale,EntityZ(e\room\Objects[2],True),True
						
						If e\EventState2 > 0 And e\EventState2 < 200 Then
							e\EventState2 = e\EventState2 + FPSfactor
							RotateEntity(e\room\Objects[1], CurveValue(85, EntityPitch(e\room\Objects[1]), 5), EntityYaw(e\room\Objects[1]), 0)
						Else
							e\EventState2 = e\EventState2 + FPSfactor
							If e\EventState2<250 Then
								ShowEntity e\room\Objects[3] 
							Else
								HideEntity e\room\Objects[3] 
								If e\EventState2>300 Then e\EventState2=200
							EndIf
						EndIf
						
						If Wearing714=False And WearingGasMask<3 And WearingHazmat<3 Then
							;temp = False
							If EntityVisible(e\room\Objects[2],Camera) Then 							
							;012 not visible, walk to the door														
								
								
							;DebugLog "WHERE IS IT?!"	
								e\SoundCHN2 = LoopSound2(e\Sound2, e\SoundCHN2, Camera, e\room\Objects[3], 10, e\EventState3/(86.0*70.0))
								
								pvt% = CreatePivot()
								PositionEntity pvt, EntityX(Camera), EntityY(e\room\Objects[2],True)-0.05, EntityZ(Camera)
								PointEntity(pvt, e\room\Objects[2])
								RotateEntity(Collider, EntityPitch(Collider), CurveAngle(EntityYaw(pvt), EntityYaw(Collider), 80-(e\EventState3/200.0)), 0)
								
								TurnEntity(pvt, 90, 0, 0)
								user_camera_pitch = CurveAngle(EntityPitch(pvt)+25, user_camera_pitch + 90.0, 80-(e\EventState3/200.0))
								user_camera_pitch=user_camera_pitch-90
								
								dist = Distance(EntityX(Collider),EntityZ(Collider),EntityX(e\room\Objects[2],True),EntityZ(e\room\Objects[2],True))
								
								HeartBeatRate = 150
								HeartBeatVolume = Max(3.0-dist,0.0)/3.0
								BlurVolume = Max((2.0-dist)*(e\EventState3/800.0)*(Sin(Float(MilliSecs2()) / 20.0 + 1.0)),BlurVolume)
								CurrCameraZoom = Max(CurrCameraZoom, (Sin(Float(MilliSecs2()) / 20.0)+1.0)*8.0*Max((3.0-dist),0.0))
								
								If BreathCHN <> 0 Then
									If ChannelPlaying(BreathCHN) Then StopChannel(BreathCHN)
								EndIf
								
								If dist < 0.6 Then
									e\EventState3=Min(e\EventState3+FPSfactor,86*70)
									If e\EventState3>70 And e\EventState3-FPSfactor=<70 Then
										PlaySound_Strict LoadTempSound("SFX\SCP\012\Speech1.ogg")
									ElseIf e\EventState3>13*70 And e\EventState3-FPSfactor=<13*70
										Msg="You start pushing your nails into your wrist, drawing blood."
										MsgTimer = 7*70
										Injuries=Injuries+0.5
										PlaySound_Strict LoadTempSound("SFX\SCP\012\Speech2.ogg")
									ElseIf e\EventState3>31*70 And e\EventState3-FPSfactor=<31*70
										tex = LoadTexture_Strict("GFX\map\scp-012_1.jpg")
										EntityTexture (e\room\Objects[4], tex,0,1)
										FreeTexture tex
										
										Msg="You tear open your left wrist and start writing on the composition with your blood."
										MsgTimer = 7*70
										Injuries=Max(Injuries,1.5)
										PlaySound_Strict LoadTempSound("SFX\SCP\012\Speech"+Rand(3,4)+".ogg")
									ElseIf e\EventState3>49*70 And e\EventState3-FPSfactor=<49*70
										Msg="You push your fingers deeper into the wound."
										MsgTimer = 8*70
										Injuries=Injuries+0.3
										PlaySound_Strict LoadTempSound("SFX\SCP\012\Speech5.ogg")
									ElseIf e\EventState3>63*70 And e\EventState3-FPSfactor=<63*70
										tex = LoadTexture_Strict("GFX\map\scp-012_2.jpg")
										EntityTexture (e\room\Objects[4], tex,0,1)	
										FreeTexture tex
										
										Injuries=Injuries+0.5
										PlaySound_Strict LoadTempSound("SFX\SCP\012\Speech6.ogg")
									ElseIf e\EventState3>74*70 And e\EventState3-FPSfactor=<74*70
										tex = LoadTexture_Strict("GFX\map\scp-012_3.jpg")
										EntityTexture (e\room\Objects[4], tex,0,1)
										FreeTexture tex
										
										Msg="You rip the wound wide open. Grabbing scoops of blood pouring out."
										MsgTimer = 7*70
										Injuries=Injuries+0.8
										PlaySound_Strict LoadTempSound("SFX\SCP\012\Speech7.ogg")
										Crouch = True
										
										de.Decals = CreateDecal(17,  EntityX(Collider), -768*RoomScale+0.01, EntityZ(Collider),90,Rnd(360),0)
										de\Size = 0.1 : de\maxsize = 0.45 : de\sizechange = 0.0002 : UpdateDecals()
									ElseIf e\EventState3>85*70 And e\EventState3-FPSfactor=<85*70	
										DeathMSG = "Subject D-9341 found in a pool of blood next to SCP-012. Subject seems to have ripped open his wrists and written three extra "
										DeathMSG = DeathMSG + "lines to the composition before dying of blood loss."
										Kill()
									EndIf
									
									RotateEntity(Collider, EntityPitch(Collider), CurveAngle(EntityYaw(Collider)+Sin(e\EventState3*(e\EventState3/2000))*(e\EventState3/300), EntityYaw(Collider), 80), 0)
									
								Else
									angle = WrapAngle(EntityYaw(pvt)-EntityYaw(Collider))
									If angle<40.0 Then
										ForceMove = (40.0-angle)*0.02
									ElseIf angle > 310.0
										ForceMove = (40.0-Abs(360.0-angle))*0.02
									EndIf
								EndIf								
								
								FreeEntity pvt								
							Else
								
							;	If EntityY(Collider)=-768.0*RoomScale Then
								If (Distance(EntityX(Collider), EntityZ(Collider), EntityX(e\room\RoomDoors[0]\frameobj), EntityZ(e\room\RoomDoors[0]\frameobj))<4.5) And  EntityY(Collider)<-2.5 Then
									pvt% = CreatePivot()
									PositionEntity pvt, EntityX(Camera), EntityY(Collider), EntityZ(Camera)
									PointEntity(pvt, e\room\RoomDoors[0]\frameobj)
									;TurnEntity(pvt, 90, 0, 0)
									user_camera_pitch = CurveAngle(90, user_camera_pitch+90, 100)
									user_camera_pitch=user_camera_pitch-90
									RotateEntity(Collider, EntityPitch(Collider), CurveAngle(EntityYaw(pvt), EntityYaw(Collider), 150), 0)
									
									angle = WrapAngle(EntityYaw(pvt)-EntityYaw(Collider))
									If angle<40.0 Then
										ForceMove = (40.0-angle)*0.008
									ElseIf angle > 310.0
										ForceMove = (40.0-Abs(360.0-angle))*0.008
									EndIf
									FreeEntity pvt	
									
								EndIf
								DebugLog Distance(EntityX(Collider), EntityZ(Collider), EntityX(e\room\RoomDoors[0]\frameobj), EntityZ(e\room\RoomDoors[0]\frameobj))
								DebugLog EntityY(Collider)
							EndIf
							
						EndIf
						
					EndIf
				EndIf
				
			Case "room035"
				
				If PlayerRoom = e\room Then
					;eventstate2 = has 035 told the code to the storage room (true/false)
					;eventstate3 = has the player opened the gas valves (0=no, 0<x<35*70 yes, x>35*70 the host has died)
					
					If e\EventState = 0 Then
						If EntityDistance(Collider, e\room\Objects[3])<2 Then
							n.NPCs = CreateNPC(NPCtypeD, EntityX(e\room\Objects[4],True),0.5,EntityZ(e\room\Objects[4],True))
							
							n\texture = "GFX\NPCs\035victim.jpg"
							n\Model = "GFX\NPCs\035.b3d"
							HideEntity n\obj
							
							SetAnimTime(n\obj, 501)
							n\Frame = 501
							
							n\State = 6
							
							e\EventState=1
						EndIf
						
					ElseIf e\EventState > 0
						If e\room\NPC[0]=Null Then
							For n.NPCs = Each NPCs
								If n\texture = "GFX\NPCs\035victim.jpg" Then
									e\room\NPC[0]=n
									
									temp = e\room\NPC[0]\Frame
									
									FreeEntity e\room\NPC[0]\obj
									e\room\NPC[0]\obj = LoadAnimMesh_Strict("GFX\NPCs\035.b3d")
									x = 0.5 / MeshWidth(e\room\NPC[0]\obj)
									e\room\NPC[0]\ModelScaleX = x
									e\room\NPC[0]\ModelScaleY = x
									e\room\NPC[0]\ModelScaleZ = x
									ScaleEntity e\room\NPC[0]\obj, x,x,x
									SetAnimTime(e\room\NPC[0]\obj, temp)
									ShowEntity e\room\NPC[0]\obj
									
									RotateEntity n\Collider, 0, e\room\angle+270, 0, True
									
									Exit
								EndIf
							Next
						EndIf
						
						If e\room\NPC[0]\SoundChn <> 0 Then
							If ChannelPlaying(e\room\NPC[0]\SoundChn) Then
								e\room\NPC[0]\SoundChn=LoopSound2(e\room\NPC[0]\Sound, e\room\NPC[0]\SoundChn, Camera, e\room\obj, 6.0)
							EndIf
						EndIf
						
						If e\EventState=1 Then
							If EntityDistance(Collider, e\room\Objects[3])<1.2 
								If EntityInView(e\room\NPC[0]\obj, Camera) Then
									GiveAchievement(Achv035)
									PlaySound_Strict(LoadTempSound("SFX\SCP\035\GetUp.ogg"))
									e\EventState = 1.5
								EndIf
							EndIf
						Else
							
							If e\room\RoomDoors[3]\open Then e\EventState2 = Max(e\EventState2, 1)
							
							;the door is closed
							If UpdateLever(e\room\Levers[0],(e\EventState2=20)) = 0 Then
								;the gas valves are open
								temp = UpdateLever(e\room\Levers[1],False)
								If temp Or (e\EventState3>25*70 And e\EventState3<50*70) Then 
									If temp Then 
										PositionEntity(e\room\Objects[5], EntityX(e\room\Objects[5],True), 424.0*RoomScale, EntityZ(e\room\Objects[5],True),True)
										PositionEntity(e\room\Objects[6], EntityX(e\room\Objects[6],True), 424.0*RoomScale, EntityZ(e\room\Objects[6],True),True)
									Else
										PositionEntity(e\room\Objects[5], EntityX(e\room\Objects[5],True), 10, EntityZ(e\room\Objects[5],True),True)
										PositionEntity(e\room\Objects[6], EntityX(e\room\Objects[6],True), 10, EntityZ(e\room\Objects[6],True),True)
										
									EndIf
									
									If e\EventState3 >-30*70 Then 
										e\EventState3=Abs(e\EventState3)+FPSfactor
										If e\EventState3 > 1 And e\EventState3-FPSfactor=<1 Then
											e\room\NPC[0]\State = 0
											If e\room\NPC[0]\Sound<>0 Then FreeSound_Strict(e\room\NPC[0]\Sound) : e\room\NPC[0]\Sound = 0
											e\room\NPC[0]\Sound = LoadSound_Strict("SFX\SCP\035\Gased1.ogg")
											e\room\NPC[0]\SoundChn = PlaySound_Strict(e\room\NPC[0]\Sound)
										ElseIf e\EventState3>15*70 And e\EventState3<25*70
											If e\EventState3-FPSfactor=<15*70 Then
												If e\room\NPC[0]\Sound<>0 Then FreeSound_Strict(e\room\NPC[0]\Sound) : e\room\NPC[0]\Sound = 0
												e\room\NPC[0]\Sound = LoadSound_Strict("SFX\SCP\035\Gased2.ogg")
												e\room\NPC[0]\SoundChn = PlaySound_Strict(e\room\NPC[0]\Sound)
												SetNPCFrame( e\room\NPC[0],553)
											EndIf
											e\room\NPC[0]\State = 6
											
											AnimateNPC(e\room\NPC[0], 553, 529, -0.12, False)
										ElseIf e\EventState3>25*70 And e\EventState3<35*70
											e\room\NPC[0]\State = 6
											AnimateNPC(e\room\NPC[0], 529, 524, -0.08, False)
										ElseIf e\EventState3>35*70
											If e\room\NPC[0]\State = 6 Then
												Sanity = -150*Sin(AnimTime(e\room\NPC[0]\obj)-524)*9
												AnimateNPC(e\room\NPC[0], 524, 553, 0.08, False)
												If e\room\NPC[0]\Frame=553 Then e\room\NPC[0]\State = 0
											EndIf
											
											If e\EventState3-FPSfactor=<35*70 Then 
												If e\room\NPC[0]\Sound<>0 Then FreeSound_Strict(e\room\NPC[0]\Sound) : e\room\NPC[0]\Sound = 0
												e\room\NPC[0]\Sound = LoadSound_Strict("SFX\SCP\035\GasedKilled1.ogg")
												e\room\NPC[0]\SoundChn = PlaySound_Strict(e\room\NPC[0]\Sound)
												PlaySound_Strict(LoadTempSound("SFX\SCP\035\KilledGetUp.ogg"))
												e\EventState = 60*70
											EndIf
										EndIf
									EndIf
								Else ;gas valves closed
									
									If e\room\NPC[0]\State = 6 Then
										If e\room\NPC[0]\Frame>=501 And e\room\NPC[0]\Frame<=523 Then
											e\room\NPC[0]\Frame = Animate2(e\room\NPC[0]\obj, AnimTime(e\room\NPC[0]\obj), 501, 523, 0.08, False)
											If e\room\NPC[0]\Frame=523 Then e\room\NPC[0]\State = 0
										EndIf	
										
										If e\room\NPC[0]\Frame>=524 And e\room\NPC[0]\Frame<=553 Then
											e\room\NPC[0]\Frame = Animate2(e\room\NPC[0]\obj, AnimTime(e\room\NPC[0]\obj), 524, 553, 0.08, False)
											If e\room\NPC[0]\Frame=553 Then e\room\NPC[0]\State = 0
										EndIf	
									EndIf
									
									PositionEntity(e\room\Objects[5], EntityX(e\room\Objects[5],True), 10, EntityZ(e\room\Objects[5],True),True)
									PositionEntity(e\room\Objects[6], EntityX(e\room\Objects[6],True), 10, EntityZ(e\room\Objects[6],True),True)
									
									If e\room\NPC[0]\State = 0 Then
										PointEntity e\room\NPC[0]\obj, Collider
										RotateEntity e\room\NPC[0]\Collider, 0, CurveAngle(EntityYaw(e\room\NPC[0]\obj), EntityYaw(e\room\NPC[0]\Collider), 15.0), 0
										
										If Rand(500)=1 Then
											If EntityDistance(e\room\NPC[0]\Collider, e\room\Objects[4])>2 Then
												e\room\NPC[0]\State2 = 1
											Else
												e\room\NPC[0]\State2 = 0
											EndIf
											e\room\NPC[0]\State = 1
										EndIf
									ElseIf e\room\NPC[0]\State = 1
										If e\room\NPC[0]\State2 = 1 Then
											PointEntity e\room\NPC[0]\obj, e\room\Objects[4]
											If EntityDistance(e\room\NPC[0]\Collider, e\room\Objects[4])<0.2 Then e\room\NPC[0]\State = 0
										Else
											RotateEntity e\room\NPC[0]\obj, 0, e\room\angle-180, 0, True
											If EntityDistance(e\room\NPC[0]\Collider, e\room\Objects[4])>2 Then e\room\NPC[0]\State = 0
										EndIf
										
										RotateEntity e\room\NPC[0]\Collider, 0, CurveAngle(EntityYaw(e\room\NPC[0]\obj), EntityYaw(e\room\NPC[0]\Collider), 15.0), 0
										
									EndIf
									
									If e\EventState3 > 0 Then
										e\EventState3=-e\EventState3
										If e\EventState3<-35*70 Then ;the host is dead
											If e\room\NPC[0]\Sound<>0 Then FreeSound_Strict(e\room\NPC[0]\Sound) : e\room\NPC[0]\Sound = 0
											e\room\NPC[0]\Sound = LoadSound_Strict("SFX\SCP\035\GasedKilled2.ogg")
											e\room\NPC[0]\SoundChn = PlaySound_Strict(e\room\NPC[0]\Sound)
											e\EventState = 60*70
										Else 
											If e\room\NPC[0]\Sound<>0 Then FreeSound_Strict(e\room\NPC[0]\Sound) : e\room\NPC[0]\Sound = 0
											If e\EventState3<-20*70 Then
												e\room\NPC[0]\Sound = LoadSound_Strict("SFX\SCP\035\GasedStop2.ogg")
											Else
												e\EventState3=-21*70
												e\room\NPC[0]\Sound = LoadSound_Strict("SFX\SCP\035\GasedStop1.ogg")
											EndIf
											
											e\room\NPC[0]\SoundChn = PlaySound_Strict(e\room\NPC[0]\Sound)
											e\EventState = 61*70
										EndIf
									Else
										
										e\EventState = e\EventState+FPSfactor
										If e\EventState > 4*70 And e\EventState-FPSfactor =<4*70 Then
											If e\room\NPC[0]\Sound<>0 Then FreeSound_Strict(e\room\NPC[0]\Sound) : e\room\NPC[0]\Sound = 0
											e\room\NPC[0]\Sound = LoadSound_Strict("SFX\SCP\035\Help1.ogg")
											e\room\NPC[0]\SoundChn = PlaySound_Strict(e\room\NPC[0]\Sound)
											e\EventState = 10*70
										ElseIf e\EventState > 20*70 And e\EventState-FPSfactor =<20*70
											If e\room\NPC[0]\Sound<>0 Then FreeSound_Strict(e\room\NPC[0]\Sound) : e\room\NPC[0]\Sound = 0
											e\room\NPC[0]\Sound = LoadSound_Strict("SFX\SCP\035\Help2.ogg")
											e\room\NPC[0]\SoundChn = PlaySound_Strict(e\room\NPC[0]\Sound)
										ElseIf e\EventState > 40*70 And e\EventState-FPSfactor =<40*70
											If e\room\NPC[0]\Sound<>0 Then FreeSound_Strict(e\room\NPC[0]\Sound) : e\room\NPC[0]\Sound = 0
											e\room\NPC[0]\Sound = LoadSound_Strict("SFX\SCP\035\Idle1.ogg")
											e\room\NPC[0]\SoundChn = PlaySound_Strict(e\room\NPC[0]\Sound)
										ElseIf e\EventState > 50*70 And e\EventState-FPSfactor =<50*70
											If e\room\NPC[0]\Sound<>0 Then FreeSound_Strict(e\room\NPC[0]\Sound) : e\room\NPC[0]\Sound = 0
											e\room\NPC[0]\Sound = LoadSound_Strict("SFX\SCP\035\Idle2.ogg")
											e\room\NPC[0]\SoundChn = PlaySound_Strict(e\room\NPC[0]\Sound)
										ElseIf e\EventState > 80*70 And e\EventState-FPSfactor =<80*70
											If e\EventState2 Then ;skip the closet part if player has already opened it
												e\EventState = 130*70
											Else
												If e\EventState3<-30*70 Then ;the host is dead
													If e\room\NPC[0]\Sound<>0 Then FreeSound_Strict(e\room\NPC[0]\Sound) : e\room\NPC[0]\Sound = 0
													e\room\NPC[0]\Sound = LoadSound_Strict("SFX\SCP\035\GasedCloset.ogg")
													e\room\NPC[0]\SoundChn = PlaySound_Strict(e\room\NPC[0]\Sound)
												ElseIf e\EventState3 = 0 ;the gas valves haven't been opened
													If e\room\NPC[0]\Sound<>0 Then FreeSound_Strict(e\room\NPC[0]\Sound) : e\room\NPC[0]\Sound = 0
													e\room\NPC[0]\Sound = LoadSound_Strict("SFX\SCP\035\Closet1.ogg")
													e\room\NPC[0]\SoundChn = PlaySound_Strict(e\room\NPC[0]\Sound)
												Else ;gas valves have been opened but 035 isn't dead
													If e\room\NPC[0]\Sound<>0 Then FreeSound_Strict(e\room\NPC[0]\Sound) : e\room\NPC[0]\Sound = 0
													e\room\NPC[0]\Sound = LoadSound_Strict("SFX\SCP\035\GasedCloset.ogg")
													e\room\NPC[0]\SoundChn = PlaySound_Strict(e\room\NPC[0]\Sound)
												EndIf												
											EndIf
										ElseIf e\EventState > 80*70
											If e\EventState2 Then e\EventState = Max(e\EventState,100*70)
											If e\EventState>110*70 And e\EventState-FPSfactor =<110*70 Then
												If e\EventState2 Then
													If e\room\NPC[0]\Sound<>0 Then FreeSound_Strict(e\room\NPC[0]\Sound) : e\room\NPC[0]\Sound = 0
													e\room\NPC[0]\Sound = LoadSound_Strict("SFX\SCP\035\Closet2.ogg")
													e\room\NPC[0]\SoundChn = PlaySound_Strict(e\room\NPC[0]\Sound)
													e\EventState = 130*70
												Else
													If e\room\NPC[0]\Sound<>0 Then FreeSound_Strict(e\room\NPC[0]\Sound) : e\room\NPC[0]\Sound = 0
													e\room\NPC[0]\Sound = LoadSound_Strict("SFX\SCP\035\Idle3.ogg")
													e\room\NPC[0]\SoundChn = PlaySound_Strict(e\room\NPC[0]\Sound)
												EndIf
											ElseIf e\EventState>125*70 And e\EventState-FPSfactor =<125*70
												If e\EventState2 Then
													If e\room\NPC[0]\Sound<>0 Then FreeSound_Strict(e\room\NPC[0]\Sound) : e\room\NPC[0]\Sound = 0
													e\room\NPC[0]\Sound = LoadSound_Strict("SFX\SCP\035\Closet2.ogg")
													e\room\NPC[0]\SoundChn = PlaySound_Strict(e\room\NPC[0]\Sound)
												Else
													If e\room\NPC[0]\Sound<>0 Then FreeSound_Strict(e\room\NPC[0]\Sound) : e\room\NPC[0]\Sound = 0
													e\room\NPC[0]\Sound = LoadSound_Strict("SFX\SCP\035\Idle4.ogg")
													e\room\NPC[0]\SoundChn = PlaySound_Strict(e\room\NPC[0]\Sound)
												EndIf
											ElseIf e\EventState>150*70 And e\EventState-FPSfactor =<150*70
												If e\room\NPC[0]\Sound<>0 Then FreeSound_Strict(e\room\NPC[0]\Sound) : e\room\NPC[0]\Sound = 0
												e\room\NPC[0]\Sound = LoadSound_Strict("SFX\SCP\035\Idle5.ogg")
												e\room\NPC[0]\SoundChn = PlaySound_Strict(e\room\NPC[0]\Sound)
											ElseIf e\EventState>200*70 And e\EventState-FPSfactor =<200*70
												If e\room\NPC[0]\Sound<>0 Then FreeSound_Strict(e\room\NPC[0]\Sound) : e\room\NPC[0]\Sound = 0
												e\room\NPC[0]\Sound = LoadSound_Strict("SFX\SCP\035\Idle6.ogg")
												e\room\NPC[0]\SoundChn = PlaySound_Strict(e\room\NPC[0]\Sound)
												
											EndIf
										EndIf
										
									EndIf
									
								EndIf								
								
							Else ;the player has opened the door
								If e\EventState2 < 10 Then
									e\room\RoomDoors[2]\open = False
									e\room\RoomDoors[2]\locked = True
									
									If e\room\RoomDoors[1]\open = False Then 
										e\room\RoomDoors[0]\locked = False
										e\room\RoomDoors[1]\locked = False
										UseDoor(e\room\RoomDoors[1])
										e\room\RoomDoors[0]\locked = True
										e\room\RoomDoors[1]\locked = True
										
									EndIf
									
									If e\EventState3=0 Then
										If e\room\NPC[0]\Sound<>0 Then FreeSound_Strict(e\room\NPC[0]\Sound) : e\room\NPC[0]\Sound = 0
										e\room\NPC[0]\Sound = LoadSound_Strict("SFX\SCP\035\Escape.ogg")
										e\room\NPC[0]\SoundChn = PlaySound_Strict(e\room\NPC[0]\Sound)
									ElseIf Abs(e\EventState3)>35*70
										If e\room\NPC[0]\Sound<>0 Then FreeSound_Strict(e\room\NPC[0]\Sound) : e\room\NPC[0]\Sound = 0
										e\room\NPC[0]\Sound = LoadSound_Strict("SFX\SCP\035\KilledEscape.ogg")
										e\room\NPC[0]\SoundChn = PlaySound_Strict(e\room\NPC[0]\Sound)
									Else
										If e\room\NPC[0]\Sound<>0 Then FreeSound_Strict(e\room\NPC[0]\Sound) : e\room\NPC[0]\Sound = 0
										e\room\NPC[0]\Sound = LoadSound_Strict("SFX\SCP\035\GasedEscape.ogg")
										e\room\NPC[0]\SoundChn = PlaySound_Strict(e\room\NPC[0]\Sound)
									EndIf
									e\EventState2 = 20
								EndIf
								
								If e\EventState2 = 20 Then
									dist = EntityDistance(e\room\RoomDoors[0]\frameobj, e\room\NPC[0]\Collider)
									
									e\room\NPC[0]\State = 1
									If dist > 2.5 Then
										PointEntity e\room\NPC[0]\obj, e\room\RoomDoors[1]\frameobj
										RotateEntity e\room\NPC[0]\Collider, 0, CurveAngle(EntityYaw(e\room\NPC[0]\obj), EntityYaw(e\room\NPC[0]\Collider), 15.0), 0
									ElseIf dist > 0.7
										If ChannelPlaying (e\room\NPC[0]\SoundChn) Then
											e\room\NPC[0]\State = 0
											PointEntity e\room\NPC[0]\obj, Collider
											RotateEntity e\room\NPC[0]\Collider, 0, CurveAngle(EntityYaw(e\room\NPC[0]\obj), EntityYaw(e\room\NPC[0]\Collider), 15.0), 0
										Else
											PointEntity e\room\NPC[0]\obj, e\room\RoomDoors[0]\frameobj
											RotateEntity e\room\NPC[0]\Collider, 0, CurveAngle(EntityYaw(e\room\NPC[0]\obj), EntityYaw(e\room\NPC[0]\Collider), 15.0), 0
										EndIf
									Else
										RemoveNPC(e\room\NPC[0])
										e\room\NPC[0]=Null
										e\EventState = -1
										e\EventState2 = 0
										e\EventState3 = 0
										e\room\RoomDoors[0]\locked = False										
										e\room\RoomDoors[1]\locked = False
										e\room\RoomDoors[2]\locked = False
										UseDoor(e\room\RoomDoors[1],False)
										For do.doors = Each Doors
											If do\dir = 2 Then
												If Abs(EntityX(e\room\obj)-EntityX(do\frameobj,True))<4.5 Then 
													If Abs(EntityZ(e\room\obj)-EntityZ(do\frameobj,True))<4.5 Then 
														UseDoor(do,False)
														Exit
													EndIf
												EndIf
											EndIf
										Next
									EndIf
								EndIf
								
							EndIf
							
						EndIf ;eventstate > 1
						
					Else ;eventstate < 0 (SCP-035 has left)
						
						If UpdateLever(e\room\Levers[1],False) Then 
							PositionEntity(e\room\Objects[5], EntityX(e\room\Objects[5],True), 424.0*RoomScale, EntityZ(e\room\Objects[5],True),True)
							PositionEntity(e\room\Objects[6], EntityX(e\room\Objects[6],True), 424.0*RoomScale, EntityZ(e\room\Objects[6],True),True)
						Else
							PositionEntity(e\room\Objects[5], EntityX(e\room\Objects[5],True), 10, EntityZ(e\room\Objects[5],True),True)
							PositionEntity(e\room\Objects[6], EntityX(e\room\Objects[6],True), 10, EntityZ(e\room\Objects[6],True),True)
						EndIf
						
						;If UpdateLever(e\room\Levers[0]) Then
						;	If e\room\RoomDoors[0]\open = True Then UseDoor(e\room\RoomDoors[1])
						;Else
						;	If e\room\RoomDoors[0]\open = False Then UseDoor(e\room\RoomDoors[1])
						;EndIf
						
						temp = False
						
						;player is inside the containment chamber
						If EntityX(Collider)>Min(EntityX(e\room\Objects[7],True),EntityX(e\room\Objects[8],True)) Then
							If EntityX(Collider)<Max(EntityX(e\room\Objects[7],True),EntityX(e\room\Objects[8],True)) Then
								If EntityZ(Collider)>Min(EntityZ(e\room\Objects[7],True),EntityZ(e\room\Objects[8],True)) Then
									If EntityZ(Collider)<Max(EntityZ(e\room\Objects[7],True),EntityZ(e\room\Objects[8],True)) Then
										
										ShouldPlay = 0
										
										If e\room\NPC[0]=Null Then
											If e\room\NPC[0]=Null Then e\room\NPC[0] = CreateNPC(NPCtypeTentacle, 0,0,0)
										EndIf
										
										PositionEntity e\room\NPC[0]\Collider, EntityX(e\room\Objects[4],True), 0, EntityZ(e\room\Objects[4],True)
										
										If e\room\NPC[0]\State > 0 Then 
											If e\room\NPC[1]=Null Then
												If e\room\NPC[1]=Null Then e\room\NPC[1] = CreateNPC(NPCtypeTentacle, 0,0,0)
											EndIf
										EndIf
										
										Stamina = CurveValue(Min(60,Stamina), Stamina, 20.0)
										
										temp = True
										
										If e\Sound = 0 Then LoadEventSound(e,"SFX/Room/035Chamber\Whispers1.ogg")
										If e\Sound2 = 0 Then LoadEventSound(e,"SFX/Room/035Chamber\Whispers2.ogg",1)
										
										e\EventState2 = Min(e\EventState2+(FPSfactor/6000),1.0)
										e\EventState3 = CurveValue(e\EventState2, e\EventState3, 50)
										
										If (Not Wearing714) And WearingHazmat<3 And WearingGasMask<3 Then
											Sanity=Sanity-FPSfactor*1.1
											BlurTimer = Sin(MilliSecs2()/10)*Abs(Sanity)
										EndIf
										
										If (Not WearingHazmat) Then
											Injuries = Injuries + (FPSfactor/5000)
										Else
											Injuries = Injuries + (FPSfactor/10000)
										EndIf
										
										If KillTimer < 0 And Bloodloss =>100 Then
											DeathMSG = "Class D Subject D-9341 found dead inside SCP-035's containment chamber. "
											DeathMSG = DeathMSG + "The subject exhibits heavy hemorrhaging of blood vessels around the eyes and inside the mouth and nose. "
											DeathMSG = DeathMSG + "Sent for autopsy."
										EndIf
									EndIf
								EndIf
							EndIf
						EndIf
						
						If e\room\NPC[1]<>Null Then 
							PositionEntity e\room\NPC[1]\Collider, EntityX(e\room\obj,True), 0, EntityZ(e\room\obj,True)
							angle = WrapAngle(EntityYaw(e\room\NPC[1]\Collider)-e\room\angle)
							
							If angle>90 Then 
								If angle < 225 Then 
									RotateEntity e\room\NPC[1]\Collider, 0, e\room\angle-89-180, 0
								Else
									RotateEntity e\room\NPC[1]\Collider, 0, e\room\angle-1, 0	
								EndIf
							EndIf
						EndIf
						
						If temp = False Then 
							e\EventState2 = Max(e\EventState2-(FPSfactor/2000),0)
							e\EventState3 = Max(e\EventState3-(FPSfactor/100),0)
						EndIf
						
						If e\EventState3 > 0 And (Not Wearing714) And WearingHazmat<3 And WearingGasMask<3 Then 
							e\SoundCHN = LoopSound2(e\Sound, e\SoundCHN, Camera, e\room\obj, 10, e\EventState3)
							e\SoundCHN2 = LoopSound2(e\Sound2, e\SoundCHN2, Camera, e\room\obj, 10, (e\EventState3-0.5)*2)
						EndIf
						
					EndIf
					
				Else	
					If e\EventState=0 Then	
						If e\Sound = 0 Then
							If EntityDistance(Collider, e\room\obj) < 20 Then
								LoadEventSound(e,"SFX/Room/035Chamber\InProximity.ogg")
								PlaySound_Strict e\Sound
							EndIf
						EndIf
					ElseIf e\EventState < 0
						For i = 0 To 1
							If e\room\NPC[i]<>Null Then 
								RemoveNPC(e\room\NPC[i])
								e\room\NPC[i]=Null
							EndIf						
						Next						
					EndIf
					
				EndIf
				
			Case "room049"
				
				If PlayerRoom = e\room Then
					If EntityY(Collider) > -2848*RoomScale Then
						e\EventState2 = UpdateElevators(e\EventState2, e\room\RoomDoors[0], e\room\RoomDoors[1],e\room\Objects[0],e\room\Objects[1], e)
						e\EventState3 = UpdateElevators(e\EventState3, e\room\RoomDoors[2], e\room\RoomDoors[3],e\room\Objects[2],e\room\Objects[3], e)
					Else
						
						ShouldPlay = 25
						
						If e\EventState = 0 Then
							If e\EventStr = "" And QuickLoadPercent = -1
								QuickLoadPercent = 0
								QuickLoad_CurrEvent = e
								e\EventStr = "load0"
							EndIf
							PlaySound_Strict LoadTempSound("SFX/Room/Blackout.ogg")
							If EntityDistance(e\room\Objects[11],Collider)<EntityDistance(e\room\Objects[12],Collider) Then
								it = CreateItem("Research Sector-02 Scheme", "paper", EntityX(e\room\Objects[11],True),EntityY(e\room\Objects[11],True),EntityZ(e\room\Objects[11],True))
								EntityType it\collider,HIT_ITEM
							Else
								it = CreateItem("Research Sector-02 Scheme", "paper", EntityX(e\room\Objects[12],True),EntityY(e\room\Objects[12],True),EntityZ(e\room\Objects[12],True))
								EntityType it\collider,HIT_ITEM
							EndIf
						ElseIf e\EventState > 0
							
							Local prevGenLever
							If EntityPitch(e\room\Objects[9],True) > 0 Then
								prevGenLever = True
							Else
								prevGenLever = False
							EndIf
							temp = Not UpdateLever(e\room\Objects[7]) ;power feed
							x = UpdateLever(e\room\Objects[9]) ;generator
							
							e\room\RoomDoors[1]\locked = True
							e\room\RoomDoors[3]\locked = True
							e\room\RoomDoors[1]\IsElevatorDoor = 0
							e\room\RoomDoors[3]\IsElevatorDoor = 0
							
							If (prevGenLever <> x) Then
								If x=False Then
									PlaySound_Strict LightSFX
								Else
									PlaySound_Strict TeslaPowerUpSFX
								EndIf
							EndIf
							
							If e\EventState >= 70 Then
								If x Then
									ShouldPlay = 8
									e\EventState = Max(e\EventState,70*180)
									SecondaryLightOn = CurveValue(1.0, SecondaryLightOn, 10.0)
									If e\Sound2=0 Then LoadEventSound(e,"SFX\Ambient\Room ambience\fuelpump.ogg",1)
									e\SoundCHN2=LoopSound2(e\Sound2, e\SoundCHN2, Camera, e\room\Objects[10], 6.0)
									For i = 4 To 6
										e\room\RoomDoors[i]\locked = False
									Next
								Else
									SecondaryLightOn = CurveValue(0.0, SecondaryLightOn, 10.0)
									If ChannelPlaying(e\SoundCHN2) Then
										StopChannel(e\SoundCHN2)
									EndIf
									For i = 4 To 6
										e\room\RoomDoors[i]\locked = True
									Next
								EndIf
							Else
								e\EventState = Min(e\EventState+FPSfactor,70)
							EndIf
							
							If temp And x Then
								e\room\RoomDoors[1]\locked = False
								e\room\RoomDoors[3]\locked = False
								e\EventState2 = UpdateElevators(e\EventState2, e\room\RoomDoors[0], e\room\RoomDoors[1],e\room\Objects[0],e\room\Objects[1], e)
								e\EventState3 = UpdateElevators(e\EventState3, e\room\RoomDoors[2], e\room\RoomDoors[3],e\room\Objects[2],e\room\Objects[3], e)
								
								If e\room\NPC[0]\Idle > 0
									i = 0
									If EntityDistance(Collider,e\room\RoomDoors[1]\frameobj)<3.0
										i = 1
									ElseIf EntityDistance(Collider,e\room\RoomDoors[3]\frameobj)<3.0
										i = 3
									EndIf
									If i > 0
										PositionEntity e\room\NPC[0]\Collider,EntityX(e\room\Objects[i],True),EntityY(e\room\Objects[i],True),EntityZ(e\room\Objects[i],True)
										ResetEntity e\room\NPC[0]\Collider
										PlaySound2(ElevatorBeepSFX, Camera, e\room\Objects[i], 4.0)
										e\room\RoomDoors[i]\locked = False
										UseDoor(e\room\RoomDoors[i],False,True)
										e\room\RoomDoors[i-1]\open = False
										e\room\RoomDoors[i]\open = True
										e\room\NPC[0]\PathStatus = FindPath(e\room\NPC[0],EntityX(Collider),EntityY(Collider),EntityZ(Collider))
										If e\room\NPC[0]\Sound2 <> 0 Then FreeSound_Strict(e\room\NPC[0]\Sound2)
										e\room\NPC[0]\Sound2 = LoadSound_Strict("SFX\SCP\049\DetectedInChamber.ogg")
										e\room\NPC[0]\SoundChn2 = LoopSound2(e\room\NPC[0]\Sound2,e\room\NPC[0]\SoundChn2,Camera,e\room\NPC[0]\obj)
										e\room\NPC[0]\Idle = 0
										e\room\NPC[0]\HideFromNVG = False
										e\room\NPC[0]\PrevState = 2
										e\room\NPC[0]\State = 2
									EndIf
								EndIf
							EndIf
							
							If e\EventState < 70*190 Then
								If e\EventState >= 70*180 Then
									e\room\RoomDoors[1]\open = False
									e\room\RoomDoors[3]\open = False
									e\room\RoomDoors[0]\open = True
									e\room\RoomDoors[2]\open = True
									
									e\EventState= 70*190
								EndIf
							ElseIf e\EventState < 70*240
								For n.NPCs = Each NPCs ;awake the zombies
									If n\NPCtype = NPCtypeZombie And n\State = 0 Then
										n\State = 1
										SetNPCFrame(n, 155)
									EndIf
								Next
								e\EventState=70*241
							EndIf
						EndIf
					EndIf
				Else
					e\EventState2 = UpdateElevators(e\EventState2, e\room\RoomDoors[0], e\room\RoomDoors[1],e\room\Objects[0],e\room\Objects[1], e)
					e\EventState3 = UpdateElevators(e\EventState3, e\room\RoomDoors[2], e\room\RoomDoors[3],e\room\Objects[2],e\room\Objects[3], e)
				EndIf 
				
				If e\EventState < 0 Then
					If e\EventState > -70*4 Then
						Infect = 0
						If FallTimer => 0 Then 
							FallTimer = Min(-1, FallTimer)
							PositionEntity(Head, EntityX(Camera, True), EntityY(Camera, True), EntityZ(Camera, True), True)
							ResetEntity (Head)
							RotateEntity(Head, 0, EntityYaw(Camera) + Rand(-45, 45), 0)
						ElseIf FallTimer < -230
							FallTimer = -231
							BlinkTimer = 0
							e\EventState = e\EventState-FPSfactor
							
							If e\EventState =< -70*4 Then 
								UpdateDoorsTimer = 0
								UpdateDoors()
								UpdateRooms()
								ShowEntity Collider
								DropSpeed = 0
								BlinkTimer = -10
								FallTimer = 0
								PositionEntity Collider, EntityX(e\room\obj,True), EntityY(e\room\Objects[5],True)+0.2, EntityZ(e\room\obj,True)
								ResetEntity Collider										
								
								PositionEntity e\room\NPC[0]\Collider, EntityX(e\room\Objects[0],True),EntityY(e\room\Objects[0],True),EntityZ(e\room\Objects[0],True),True
								ResetEntity e\room\NPC[0]\Collider
								
								For n.NPCs = Each NPCs
									If n\NPCtype = NPCtypeZombie Then
										PositionEntity n\Collider, EntityX(e\room\Objects[4],True),EntityY(e\room\Objects[4],True),EntityZ(e\room\Objects[4],True),True
										ResetEntity n\Collider
										n\State = 4
										DebugLog "moving zombie"
									EndIf
								Next
								
								n.NPCs = CreateNPC(NPCtypeMTF, EntityX(e\room\Objects[5],True), EntityY(e\room\Objects[5],True)+0.2, EntityZ(e\room\Objects[5],True))
								n\State = 6
								n\Reload = 6*70
								PointEntity n\Collider,Collider
								e\room\NPC[1] = n
								
								n.NPCs = CreateNPC(NPCtypeMTF, EntityX(e\room\Objects[5],True), EntityY(e\room\Objects[5],True)+0.2, EntityZ(e\room\Objects[5],True))
								n\State = 6
								n\Reload = (6*70)+Rnd(15,30)
								RotateEntity n\Collider,0,EntityYaw(e\room\NPC[1]\Collider),0
								MoveEntity n\Collider,0.5,0,0
								PointEntity n\Collider,Collider
								
								n.NPCs = CreateNPC(NPCtypeMTF, EntityX(e\room\Objects[5],True), EntityY(e\room\Objects[5],True)+0.2, EntityZ(e\room\Objects[5],True))
								n\State = 6
								n\Reload = 6*70+Rnd(15,30)
								RotateEntity n\Collider,0,EntityYaw(e\room\NPC[1]\Collider),0
								n\State2 = EntityYaw(n\Collider)
								MoveEntity n\Collider,-0.65,0,0
								
								MoveEntity e\room\NPC[1]\Collider,0,0,0.1
								PointEntity Collider, e\room\NPC[1]\Collider
								
								PlaySound_Strict LoadTempSound("SFX\Character\MTF\049\Player0492_1.ogg")
								
								LoadEventSound(e,"SFX\SCP\049\0492Breath.ogg")
								
								IsZombie = True
							EndIf
						EndIf
					Else
						BlurTimer = 800
						ForceMove = 0.5
						Injuries = Max(2.0,Injuries)
						Bloodloss = 0
						Infect = 0
						
						;Msg = ""
						
;						If e\room\NPC[2]\State = 7
;							If e\room\NPC[2]\State3 < 70*1.75
;								e\room\NPC[2]\State3 = e\room\NPC[2]\State3 + FPSfactor
;							Else
;								e\room\NPC[2]\State = 6
;								e\room\NPC[2]\Reload = e\room\NPC[1]\Reload+Rnd(5,10)
;							EndIf
;						ElseIf e\room\NPC[2]\State = 6 And e\room\NPC[2]\Reload > 70*4
;							If e\room\NPC[2]\State3 > -(70*4)
;								e\room\NPC[2]\State3 = e\room\NPC[2]\State3 - FPSfactor
;							Else
;								e\room\NPC[2]\State3 = 0.0
;								e\room\NPC[2]\Reload = 45
;								e\room\NPC[2]\State = 7
;							EndIf
;						EndIf
						
						pvt% = CreatePivot()
						PositionEntity pvt%,EntityX(e\room\NPC[1]\Collider),EntityY(e\room\NPC[1]\Collider)+0.2,EntityZ(e\room\NPC[1]\Collider)
						
						PointEntity Collider, e\room\NPC[1]\Collider
						PointEntity Camera, pvt%,EntityRoll(Camera)
						
						FreeEntity pvt%
						
						If KillTimer < 0 Then
							PlaySound_Strict LoadTempSound("SFX\Character\MTF\049\Player0492_2.ogg")
							RemoveEvent(e)
						Else
							If e\SoundCHN = 0 Then
								e\SoundCHN = PlaySound_Strict (e\Sound)
							Else
								If (Not ChannelPlaying(e\SoundCHN)) Then e\SoundCHN = PlaySound_Strict(e\Sound)
							EndIf
						EndIf
					EndIf
				EndIf
				
			Case "room079"
				
				If PlayerRoom = e\room Then
					
					If e\EventState = 0 Then
						
						e\room\NPC[0]=CreateNPC(NPCtypeGuard, EntityX(e\room\Objects[2],True), EntityY(e\room\Objects[2],True)+0.5, EntityZ(e\room\Objects[2],True))
						PointEntity e\room\NPC[0]\Collider, e\room\obj
						RotateEntity e\room\NPC[0]\Collider, 0, EntityYaw(e\room\NPC[0]\Collider),0, True
						;SetAnimTime e\room\NPC[0]\obj, 906
						SetNPCFrame(e\room\NPC[0], 288)
						e\room\NPC[0]\State = 8
						
						e\EventState = 1
					EndIf
					
					ShouldPlay = 4
					If RemoteDoorOn Then 
						If e\room\RoomDoors[0]\open Then 
							If e\room\RoomDoors[0]\openstate > 50 Or EntityDistance(Collider, e\room\RoomDoors[0]\frameobj)<0.5 Then
								e\room\RoomDoors[0]\openstate = Min(e\room\RoomDoors[0]\openstate,50)
								e\room\RoomDoors[0]\open = False
								PlaySound_Strict (LoadTempSound("SFX\Door\DoorError.ogg"))
							EndIf							
						EndIf
					ElseIf e\EventState < 10000
						If e\EventState = 1 Then 
							e\EventState = 2
						ElseIf e\EventState = 2
							If EntityDistance(e\room\Objects[0], Collider)<3.0 Then 
								GiveAchievement(Achv079)
								e\EventState = 3
								e\EventState2 = 1
								;e\Sound = LoadSound_Strict("SFX\SCP\079\Speech.ogg")
								;LoadEventSound(e,"SFX\SCP\079\Speech.ogg")
								;e\SoundCHN = PlaySound_Strict (e\Sound)
								e\SoundCHN = StreamSound_Strict("SFX\SCP\079\Speech.ogg",SFXVolume,0)
								e\SoundCHN_isStream = True
							EndIf							
						;ElseIf e\EventState = 3
						ElseIf e\EventState < 2000 Then ;3500
							;If ChannelPlaying(e\SoundCHN) Then
							If IsStreamPlaying_Strict(e\SoundCHN)
								If Rand(3) = 1 Then
									EntityTexture(e\room\Objects[1], OldAiPics(0))
									ShowEntity (e\room\Objects[1])
								ElseIf Rand(10) = 1 
									HideEntity (e\room\Objects[1])							
								EndIf							
							Else
								;If e\Sound <> 0 Then FreeSound_Strict e\Sound : e\Sound = 0
								If e\SoundCHN<>0
									StopStream_Strict(e\SoundCHN) : e\SoundCHN=0
								EndIf
								EntityTexture(e\room\Objects[1], OldAiPics(1))
								ShowEntity (e\room\Objects[1])
								e\EventState = e\EventState + FPSfactor
							EndIf
						Else
							If EntityDistance(e\room\Objects[0], Collider)<2.5 Then 
								e\EventState = 10001
								;e\Sound = LoadSound_Strict("SFX\SCP\079\Refuse.ogg")
								;LoadEventSound(e,"SFX\SCP\079\Refuse.ogg")
								;e\SoundCHN = PlaySound_Strict (e\Sound)
								If e\SoundCHN<>0
									StopStream_Strict(e\SoundCHN) : e\SoundCHN=0
								EndIf
								e\SoundCHN = StreamSound_Strict("SFX\SCP\079\Refuse.ogg",SFXVolume,0)
								;EntityTexture(e\room\Objects[1], OldAiPics(1))
								;ShowEntity (e\room\Objects[1])
							EndIf
						EndIf
					Else
						If e\SoundCHN<>0
							If (Not IsStreamPlaying_Strict(e\SoundCHN))
								e\SoundCHN = 0
								EntityTexture(e\room\Objects[1], OldAiPics(1))
								ShowEntity (e\room\Objects[1])
							Else
								If Rand(3) = 1 Then
									EntityTexture(e\room\Objects[1], OldAiPics(0))
									ShowEntity (e\room\Objects[1])
								ElseIf Rand(10) = 1 
									HideEntity (e\room\Objects[1])							
								EndIf
							EndIf
						EndIf
					EndIf
					
				EndIf
				
				
				If e\EventState2 = 1 Then
					If RemoteDoorOn Then 	
						;LoadEventSound(e,"SFX\SCP\079\GateB.ogg")
						;e\SoundCHN = PlaySound_Strict (e\Sound)
						If e\SoundCHN<>0
							StopStream_Strict(e\SoundCHN) : e\SoundCHN=0
						EndIf
						e\SoundCHN = StreamSound_Strict("SFX\SCP\079\GateB.ogg",SFXVolume,0)
						e\SoundCHN_isStream = True
						e\EventState2 = 2
						
						For e2.Events = Each Events
							If e2\EventName="exit1" Or e2\EventName="gateaentrance" Then
								e2\EventState3 = 1
							EndIf
						Next
					EndIf	
				EndIf
				
				
			Case "room106"
				
				
				;eventstate2 = are the magnets on
				
				If SoundTransmission Then 
					If e\EventState = 1 Then
						e\EventState3 = Min(e\EventState3+FPSfactor,4000)
					EndIf
					If ChannelPlaying(e\SoundCHN) = False Then e\SoundCHN = PlaySound_Strict(RadioStatic)   
				EndIf
				
				If e\room\NPC[0]=Null Then ;add the lure subject
					TFormPoint(1088, 1096, 1728, e\room\obj, 0)
					e\room\NPC[0] = CreateNPC(NPCtypeD, TFormedX(), TFormedY(), TFormedZ())
					TurnEntity e\room\NPC[0]\Collider,0,e\room\angle+90,0,True
					e\room\NPC[0]\HideFromNVG = True
				EndIf
				
				If PlayerRoom = e\room And e\room\NPC[0]<>Null Then
					
					;ShowEntity e\room\NPC[0]\obj
					
					ShouldPlay = 66
					
					e\room\NPC[0]\State=6
					If e\room\NPC[0]\Idle = 0 Then
						AnimateNPC(e\room\NPC[0], 17.0, 19.0, 0.01, False)
						If e\room\NPC[0]\Frame = 19.0 Then e\room\NPC[0]\Idle = 1
					Else
						AnimateNPC(e\room\NPC[0], 19.0, 17.0, -0.01, False)	
						If e\room\NPC[0]\Frame = 17.0 Then e\room\NPC[0]\Idle = 0
					EndIf
					
					PositionEntity(e\room\NPC[0]\Collider, EntityX(e\room\Objects[5],True),EntityY(e\room\Objects[5],True)+0.1,EntityZ(e\room\Objects[5],True),True)
					RotateEntity(e\room\NPC[0]\Collider,EntityPitch(e\room\Objects[5],True),EntityYaw(e\room\Objects[5],True),0,True)
					ResetEntity(e\room\NPC[0]\Collider)
					
					temp = e\EventState2
					
					Local leverstate = UpdateLever(e\room\Objects[1],((EntityY(e\room\Objects[6],True)<-990*RoomScale) And (EntityY(e\room\Objects[6],True)>-1275.0*RoomScale)))
					If GrabbedEntity = e\room\Objects[1] And DrawHandIcon = True Then e\EventState2 = leverstate
					
					If e\EventState2 <> temp Then 
						If e\EventState2 = False Then
							PlaySound_Strict(MagnetDownSFX)
						Else
							PlaySound_Strict(MagnetUpSFX)	
						EndIf
					EndIf
					
					If ((e\EventState3>3200) Or (e\EventState3<2500)) Or (e\EventState<>1) Then
						SoundTransmission% = UpdateLever(e\room\Objects[3])
					EndIf
					If (Not SoundTransmission) Then
						If (e\SoundCHN2<>0) Then
							If ChannelPlaying(e\SoundCHN2) Then StopChannel e\SoundCHN2
						EndIf
						If (e\SoundCHN<>0) Then
							If ChannelPlaying(e\SoundCHN) Then StopChannel e\SoundCHN
						EndIf
					EndIf
					
					If e\EventState = 0 Then 
						If SoundTransmission And Rand(100)=1 Then
							If e\SoundCHN2 = 0 Then
								LoadEventSound(e,"SFX\Character\LureSubject\Idle"+Rand(1,6)+".ogg",1)
								e\SoundCHN2 = PlaySound_Strict(e\Sound2)								
							EndIf
							If ChannelPlaying(e\SoundCHN2) = False Then
								LoadEventSound(e,"SFX\Character\LureSubject\Idle"+Rand(1,6)+".ogg",1)
								e\SoundCHN2 = PlaySound_Strict(e\Sound2)
							EndIf
						EndIf
						
						If SoundTransmission Then
							UpdateButton(e\room\Objects[4])
							If ClosestButton = e\room\Objects[4] And MouseHit1 Then
								e\EventState = 1 ;start the femur breaker
								If SoundTransmission = True Then ;only play sounds if transmission is on
									If e\SoundCHN2 <> 0 Then
										If ChannelPlaying(e\SoundCHN2) Then StopChannel e\SoundCHN2
									EndIf 
									FemurBreakerSFX = LoadSound_Strict("SFX/Room/106Chamber\FemurBreaker.ogg")
									e\SoundCHN2 = PlaySound_Strict (FemurBreakerSFX)
								EndIf
							EndIf
						EndIf
					ElseIf e\EventState = 1 ;bone broken
						If SoundTransmission And e\EventState3 < 2000 Then 
							If e\SoundCHN2 = 0 Then 
								LoadEventSound(e,"SFX\Character\LureSubject\Sniffling.ogg",1)
								e\SoundCHN2 = PlaySound_Strict(e\Sound2)								
							EndIf
							If ChannelPlaying(e\SoundCHN2) = False Then
								LoadEventSound(e,"SFX\Character\LureSubject\Sniffling.ogg",1)
								e\SoundCHN2 = PlaySound_Strict(e\Sound2)
							EndIf
						EndIf
						
						If e\EventState3 => 2500 Then
							
							If e\EventState2 = 1 And e\EventState3-FPSfactor < 2500 Then
								PositionEntity(Curr106\Collider, EntityX(e\room\Objects[6], True), EntityY(e\room\Objects[6], True), EntityZ(e\room\Objects[6], True))
								Contained106 = False
								ShowEntity Curr106\obj
								Curr106\Idle = False
								Curr106\State = -11
								e\EventState = 2
								Exit
							EndIf
							
							ShouldPlay = 10
							
							PositionEntity(Curr106\Collider, EntityX(e\room\Objects[5], True), (700.0 + 108.0*(Min(e\EventState3-2500.0,800)/320.0))*RoomScale , EntityZ(e\room\Objects[5], True))
							HideEntity Curr106\obj2
							
							;PointEntity(Curr106\Collider, Camera)
							RotateEntity(Curr106\Collider,0, EntityYaw(e\room\Objects[5],True)+180.0, 0, True)
							Curr106\State = -11
							AnimateNPC(Curr106, 206, 250, 0.1)
							Curr106\Idle = True	
							
							If e\EventState3-FPSfactor < 2500 Then 
								d.Decals = CreateDecal(0, EntityX(e\room\Objects[5], True), 936.0*RoomScale, EntityZ(e\room\Objects[5], True), 90, 0, Rnd(360)) 
								d\Timer = 90000
								d\Alpha = 0.01 : d\AlphaChange = 0.005
								d\Size = 0.1 : d\SizeChange = 0.003	
								
								If e\SoundCHN2 <> 0 Then
									If ChannelPlaying(e\SoundCHN2) Then StopChannel e\SoundCHN2
								EndIf 
								LoadEventSound(e,"SFX\Character\LureSubject\106Bait.ogg",1)
								e\SoundCHN2=PlaySound_Strict(e\Sound2)
							ElseIf e\EventState3-FPSfactor < 2900 And e\EventState3 => 2900 Then
								If FemurBreakerSFX <> 0 Then FreeSound_Strict FemurBreakerSFX : FemurBreakerSFX = 0
								
								d.Decals = CreateDecal(0, EntityX(e\room\Objects[7], True), EntityY(e\room\Objects[7], True) , EntityZ(e\room\Objects[7], True), 0, 0, 0) 
								RotateEntity(d\obj, EntityPitch(e\room\Objects[7], True)+Rand(10,20), EntityYaw(e\room\Objects[7], True)+30, EntityRoll(d\obj))
								MoveEntity d\obj, 0,0.05,0.2 ;0.15
								RotateEntity(d\obj, EntityPitch(e\room\Objects[7], True), EntityYaw(e\room\Objects[7], True), EntityRoll(d\obj))
								
								EntityParent d\obj, e\room\Objects[7]
								;TurnEntity (d\obj, 0, 180, 0)
								
								d\Timer = 90000
								d\Alpha = 0.01 : d\AlphaChange = 0.005
								d\Size = 0.05 : d\SizeChange = 0.002
							ElseIf e\EventState3 > 3200 Then
								;PositionEntity e\room\Objects[8], 0, 1000.0, 0, True 
								;PositionEntity e\room\Objects[7], 0, 1000.0, 0, True 
								
								If e\EventState2 = True Then ;magnets off -> 106 caught
									Contained106 = True
								Else ;magnets off -> 106 comes out and attacks
									PositionEntity(Curr106\Collider, EntityX(e\room\Objects[6], True), EntityY(e\room\Objects[6], True), EntityZ(e\room\Objects[6], True))
									
									Contained106 = False
									ShowEntity Curr106\obj
									Curr106\Idle = False
									Curr106\State = -11
									
									e\EventState = 2
									Exit
								EndIf
							EndIf
							
						EndIf 
						
					EndIf
					
					If e\EventState2 Then
						PositionEntity (e\room\Objects[6],EntityX(e\room\Objects[6],True),CurveValue(-980.0*RoomScale + Sin(Float(MilliSecs2())*0.04)*0.07,EntityY(e\room\Objects[6],True),200.0),EntityZ(e\room\Objects[6],True),True)
						RotateEntity(e\room\Objects[6], Sin(Float(MilliSecs2())*0.03), EntityYaw(e\room\Objects[6],True), -Sin(Float(MilliSecs2())*0.025), True)
					Else
						PositionEntity (e\room\Objects[6],EntityX(e\room\Objects[6],True),CurveValue(-1280.0*RoomScale,EntityY(e\room\Objects[6],True),200.0),EntityZ(e\room\Objects[6],True),True)
						RotateEntity(e\room\Objects[6], 0, EntityYaw(e\room\Objects[6],True), 0, True)
					EndIf
				Else
					If PlayerRoom\RoomTemplate\Name = "pocketdimension" Or PlayerRoom\RoomTemplate\Name = "dimension1499" Then
						If (e\SoundCHN2<>0) Then
							If ChannelPlaying(e\SoundCHN2) Then StopChannel e\SoundCHN2
						EndIf
						If (e\SoundCHN<>0) Then
							If ChannelPlaying(e\SoundCHN) Then StopChannel e\SoundCHN
						EndIf
					ElseIf PlayerRoom\RoomTemplate\Name = "room860" Then
						For e2.Events = Each Events
							If e2\EventName = "room860" Then
								If e2\EventState = 1.0 Then
									If (e\SoundCHN2<>0) Then
										If ChannelPlaying(e\SoundCHN2) Then StopChannel e\SoundCHN2
									EndIf
									If (e\SoundCHN<>0) Then
										If ChannelPlaying(e\SoundCHN) Then StopChannel e\SoundCHN
									EndIf
								EndIf
								Exit
							EndIf
						Next
					EndIf
				EndIf
				
			Case "room205"
				
				If PlayerRoom = e\room Then
					If e\EventState=0 Or e\room\Objects[0]=0 Then
						If e\EventStr = "" And QuickLoadPercent = -1
							QuickLoadPercent = 0
							QuickLoad_CurrEvent = e
							e\EventStr = "load0"
						EndIf
						
						If e\room\Objects[3]<>0
							HideEntity(e\room\Objects[3])
							HideEntity(e\room\Objects[4])
							HideEntity(e\room\Objects[5])
							HideEntity(e\room\Objects[6])
						EndIf
						
						If e\room\RoomDoors[1]\open = True
							e\EventState = 1
							GiveAchievement(Achv205)
						EndIf
					Else
						ShouldPlay = 16
						If (e\EventState<65) Then
							If (Distance(EntityX(Collider), EntityZ(Collider), EntityX(e\room\Objects[0],True), EntityZ(e\room\Objects[0],True))<2.0) Then
								PlaySound_Strict(LoadTempSound("SFX\SCP\205\Enter.ogg"))
								
								e\EventState = Max(e\EventState, 65)
								
								ShowEntity(e\room\Objects[3])
								ShowEntity(e\room\Objects[4])
								ShowEntity(e\room\Objects[5])
								HideEntity(e\room\Objects[6])
								
								SetAnimTime(e\room\Objects[3], 492)
								SetAnimTime(e\room\Objects[4], 434)
								SetAnimTime(e\room\Objects[5], 434)
								
								e\room\RoomDoors[0]\open = False
							EndIf
							
							If e\EventState>7 Then
								If (Rand(0,300)=1) Then
									e\room\RoomDoors[0]\open = Not e\room\RoomDoors[0]\open
								EndIf
							EndIf 
							
							e\EventState2 = e\EventState2 + FPSfactor							
						EndIf
						
						
						Select e\EventState
							Case 1
								ShowEntity e\room\Objects[1]
								HideEntity(e\room\Objects[5])
								HideEntity(e\room\Objects[4])
								HideEntity(e\room\Objects[3])
								;sitting
								ShowEntity(e\room\Objects[6])
								Animate2(e\room\Objects[6], AnimTime(e\room\Objects[6]), 526, 530, 0.2)
								If e\EventState2 > 20*70 Then e\EventState = e\EventState+1
							Case 3
								ShowEntity e\room\Objects[1]
								HideEntity(e\room\Objects[5])
								HideEntity(e\room\Objects[4])
								HideEntity(e\room\Objects[3])
								;laying down
								ShowEntity(e\room\Objects[6])
								Animate2(e\room\Objects[6], AnimTime(e\room\Objects[6]), 377, 525, 0.2)
								If e\EventState2 > 30*70 Then e\EventState = e\EventState+1
							Case 5
								ShowEntity e\room\Objects[1]
								HideEntity(e\room\Objects[5])
								HideEntity(e\room\Objects[4])
								HideEntity(e\room\Objects[3])
								;standing
								ShowEntity(e\room\Objects[6])
								Animate2(e\room\Objects[6], AnimTime(e\room\Objects[6]), 228, 376, 0.2)
								If e\EventState2 > 40*70 Then 
									e\EventState = e\EventState+1
									PlaySound2(LoadTempSound("SFX\SCP\205\Horror.ogg"), Camera, e\room\Objects[6], 10, 0.3)
								EndIf	
							Case 7
								ShowEntity e\room\Objects[1]
								ShowEntity(e\room\Objects[6])
								HideEntity(e\room\Objects[4])
								HideEntity(e\room\Objects[3])
								;first demon appears
								ShowEntity(e\room\Objects[5])
								;le sexy demon pose
								Animate2(e\room\Objects[5], AnimTime(e\room\Objects[5]), 500, 648, 0.2)
								;TurnEntity(e\room\Objects[6], 0.0, DeltaYaw(e\room\Objects[6], e\room\Objects[5])*0.01, 0.0, True)
								If e\EventState2 > 60*70 Then 
									e\EventState = e\EventState+1
									PlaySound2(LoadTempSound("SFX\SCP\205\Horror.ogg"), Camera, e\room\Objects[6], 10, 0.5)
								EndIf
							Case 9
								ShowEntity e\room\Objects[1]
								ShowEntity(e\room\Objects[6])
								ShowEntity(e\room\Objects[5])
								HideEntity(e\room\Objects[3])
								;second demon appears
								ShowEntity(e\room\Objects[4])
								;idle
								Animate2(e\room\Objects[4], AnimTime(e\room\Objects[4]), 2, 200, 0.2)
								Animate2(e\room\Objects[5], AnimTime(e\room\Objects[5]), 4, 125, 0.2)
								
								;TurnEntity(e\room\Objects[6], 0.0, DeltaYaw(e\room\Objects[6], e\room\Objects[4])*0.01, 0.0, True)
								
								If e\EventState2 > 80*70 Then 
									e\EventState = e\EventState+1
									PlaySound_Strict(LoadTempSound("SFX\SCP\205\Horror.ogg"))
								EndIf
							Case 11
								ShowEntity e\room\Objects[1]
								ShowEntity(e\room\Objects[6])
								ShowEntity(e\room\Objects[5])
								ShowEntity(e\room\Objects[4])
								;third demon
								ShowEntity(e\room\Objects[3])
								;idle
								Animate2(e\room\Objects[3], AnimTime(e\room\Objects[3]), 2, 226, 0.2)
								Animate2(e\room\Objects[4], AnimTime(e\room\Objects[4]), 2, 200, 0.2)
								Animate2(e\room\Objects[5], AnimTime(e\room\Objects[5]), 4, 125, 0.2)
								
								;TurnEntity(e\room\Objects[6], 0.0, DeltaYaw(e\room\Objects[5], e\room\Objects[4])*0.01, 0.0, True)
								
								If e\EventState2 > 85*70 Then e\EventState = e\EventState+1
							Case 13
								ShowEntity e\room\Objects[1]
								ShowEntity(e\room\Objects[6])
								ShowEntity(e\room\Objects[5])
								ShowEntity(e\room\Objects[4])
								ShowEntity(e\room\Objects[3])
								If (AnimTime(e\room\Objects[6])<>227) Then SetAnimTime(e\room\Objects[6], 227)
								
								Animate2(e\room\Objects[3], AnimTime(e\room\Objects[3]), 2, 491, 0.05)
								Animate2(e\room\Objects[4], AnimTime(e\room\Objects[4]), 197, 433, 0.05)
								Animate2(e\room\Objects[5], AnimTime(e\room\Objects[5]), 2, 433, 0.05)
							Case 66
								ShowEntity e\room\Objects[1]
								Animate2(e\room\Objects[3], AnimTime(e\room\Objects[3]), 492, 534, 0.1, False)
								Animate2(e\room\Objects[4], AnimTime(e\room\Objects[4]), 434, 466, 0.1, False)
								Animate2(e\room\Objects[5], AnimTime(e\room\Objects[5]), 434, 494, 0.1, False)
								
								If AnimTime(e\room\Objects[3])>515 Then
									;MoveEntity(e\room\Objects[3], 0,-FPSfactor*0.001,0)
									;MoveEntity(e\room\Objects[4], 0,-FPSfactor*0.001,0)
									;MoveEntity(e\room\Objects[5], 0,-FPSfactor*0.001,0)
									If AnimTime(e\room\Objects[3])>533 Then 
										e\EventState = 67
										e\EventState2 = 0										
										e\EventState3 = 0
										HideEntity e\room\Objects[1]
									EndIf
								EndIf
							Case 67
								If (Rand(150)=1) Then
									DeathMSG = "The SCP-205 cycle seems to have resumed its normal course after the anomalies observed during "
									DeathMSG = DeathMSG + "[REDACTED]. The body of subject D-9341 was discovered inside the chamber. "
									DeathMSG = DeathMSG + "The subject exhibits signs of blunt force trauma typical for personnel who have "
									DeathMSG = DeathMSG + "entered the chamber when the lights are off."
									
									Injuries=Injuries+Rnd(0.4,0.8)
									PlaySound_Strict DamageSFX(Rand(2,3))
									CameraShake = 0.5
									
									e\EventState2 = Rnd(-0.1, 0.1)
									e\EventState3 = Rnd(-0.1, 0.1)
									
									If (Injuries>5.0) Kill()
								EndIf
								
								TranslateEntity(Collider, e\EventState2,0,e\EventState3)
								e\EventState2 = CurveValue(e\EventState2, 0, 10.0)								
								e\EventState3 = CurveValue(e\EventState3, 0, 10.0)
							Default
								If (Rand(3)=1) Then
									HideEntity e\room\Objects[1]
								Else
									ShowEntity e\room\Objects[1]
								EndIf
								
								e\EventState3 = e\EventState3 + FPSfactor
								If (e\EventState3>50) Then
									ShowEntity e\room\Objects[1]
									e\EventState = e\EventState+1
									e\EventState3=0
								EndIf
						End Select
					EndIf
				Else If (e\room\Objects[3]<>0)
					HideEntity(e\room\Objects[3])
					HideEntity(e\room\Objects[4])
					HideEntity(e\room\Objects[5])
					HideEntity(e\room\Objects[6])
				Else
					e\EventState = 0
					e\EventStr = ""
				EndIf
				;[End block]
			Case "room860"
				
				
				;e\EventState = is the player in the forest
				;e\EventState2 = which side of the door did the player enter from
				;e\EventState3 = monster spawn timer
				
				Local fr.Forest=e\room\fr
				
				If PlayerRoom = e\room And fr<>Null Then 
					
					;Local dp.DrawPortal
					
					If e\EventState=1.0 Then ;the player is in the forest
						CurrStepSFX = 2
						
						Curr106\Idle = True
						
						;ShowEntity fr\DetailEntities[0]
						;ShowEntity fr\DetailEntities[1]
						
						UpdateForest(fr,Collider)
						
						If e\EventStr = "" And QuickLoadPercent = -1
							QuickLoadPercent = 0
							QuickLoad_CurrEvent = e
							e\EventStr = "load0"
						EndIf
						
						If e\room\NPC[0]<>Null Then
							If (e\room\NPC[0]\State2 = 1 And e\room\NPC[0]\State>1) Or e\room\NPC[0]\State>2 ;the monster is chasing the player
								ShouldPlay = 12
							Else
								ShouldPlay = 9
							EndIf
						EndIf
						
						;the player fell
						If (Not NoClip)
							If EntityY(Collider)<=28.5 Then 
								Kill() 
								BlinkTimer=-2
							ElseIf EntityY(Collider)>EntityY(fr\Forest_Pivot,True)+0.5
								MoveEntity(Collider, 0, ((EntityY(fr\Forest_Pivot,True)+0.5) - EntityY(Collider))*FPSfactor, 0)
							EndIf
						EndIf
						
						If e\room\NPC[0]<>Null
							If e\room\NPC[0]\State = 0 Or EntityDistance(Collider, e\room\NPC[0]\Collider)>20.0 Then
								e\EventState3 = e\EventState3 + (1+CurrSpeed)* FPSfactor
								If (e\EventState3 Mod 500) < 10.0 And ((e\EventState3-FPSfactor) Mod 500) > 490.0 Then
									;If e\EventState3 > 3500 And Rnd(10000)<e\EventState3 Then
									If e\EventState3 > 3000-(500*SelectedDifficulty\aggressiveNPCs) And Rnd(10000+(500*SelectedDifficulty\aggressiveNPCs)) < e\EventState3
										e\room\NPC[0]\State=2
										PositionEntity e\room\NPC[0]\Collider, 0,-110,0
										;e\EventState3=e\EventState3-Rnd(2000,3000)
										e\EventState3=e\EventState3-Rnd(1000,2000-(500*SelectedDifficulty\aggressiveNPCs))
										DebugLog "attack"
									Else
										e\room\NPC[0]\State=1
										PositionEntity e\room\NPC[0]\Collider, 0,-110,0
										DebugLog "spawn"
									EndIf
								EndIf
							EndIf
						EndIf
						
						;If KeyHit(25) Then
						;	e\room\NPC[0]\State=2
						;	PositionEntity e\room\NPC[0]\Collider, 0,-110,0
						;	e\EventState3=e\EventState3-Rnd(2000,3000)
						;EndIf
						
						For i = 0 To 1
							If EntityDistance(fr\Door[i], Collider)<0.5 Then
								If EntityInView(fr\Door[i], Camera) Then
									DrawHandIcon = True
									If MouseHit1 Then
										If i=e\EventState2 Then
											BlinkTimer = -10
											
											PlaySound_Strict(LoadTempSound("SFX\Door\WoodenDoorOpen.ogg"))
											
											RotateEntity e\room\Objects[3], 0, 0, 0
											RotateEntity e\room\Objects[4], 0, 180, 0
											;SetAnimTime e\room\Objects[3], 0.0
											;SetAnimTime e\room\Objects[4], 0.0
											
											;dp.DrawPortal=e\room\dp;Object.DrawPortal(e\room\Objects[0])
											PositionEntity Collider, EntityX(e\room\Objects[2],True),0.5,EntityZ(e\room\Objects[2],True)
											
											RotateEntity Collider, 0, EntityYaw(e\room\obj,True)+e\EventState2*180, 0
											MoveEntity Collider, 0,0,1.5
											
											ResetEntity Collider
											
											UpdateDoorsTimer = 0
											UpdateDoors()
											
											SecondaryLightOn = PrevSecondaryLightOn
											;SecondaryLightOn = 0.0
											
											e\EventState = 0.0
											e\EventState3 = 0.0
										Else
											PlaySound_Strict(LoadTempSound("SFX\Door\WoodenDoorBudge.ogg"))
											Msg = "The door will not budge."
											MsgTimer = 70*5
										EndIf
									EndIf
								EndIf
							EndIf
						Next
						
						If e\room\NPC[0]<>Null
							x = Max(1.0-(e\room\NPC[0]\State3/300.0),0.1)
						Else
							x = 2.0
						EndIf
						
						If (Not DebugHUD)
							CameraClsColor Camera,98*x,133*x,162*x
							CameraRange Camera,RoomScale,8.5
							CameraFogRange Camera,0.5,8.0
							CameraFogColor Camera,98*x,133*x,162*x
						EndIf
						
					Else
						
						If (Not Contained106) Then Curr106\Idle = False
						
						;dp.DrawPortal=e\room\dp;Object.DrawPortal(e\room\Objects[0])
						
						;HideEntity fr\DetailEntities[0]
						;HideEntity fr\DetailEntities[1]
						
						If EntityYaw(e\room\Objects[3])=0.0 Then
							HideEntity fr.Forest\Forest_Pivot
							If (Abs(Distance(EntityX(e\room\Objects[3],True),EntityZ(e\room\Objects[3],True),EntityX(Collider,True),EntityZ(Collider,True)))<1.0) Then
								DrawHandIcon = True
								
								If SelectedItem = Null Then
									If MouseHit1 Then
										PlaySound_Strict(LoadTempSound("SFX\Door\WoodenDoorBudge.ogg"))
										Msg = "The door will not budge."
										MsgTimer = 5*70
									EndIf
								ElseIf SelectedItem\itemtemplate\tempname="scp860" 
									If MouseHit1 Then
										PlaySound_Strict(LoadTempSound("SFX\Door\WoodenDoorOpen.ogg"))
										ShowEntity fr.Forest\Forest_Pivot
										SelectedItem = Null
										
										BlinkTimer = -10
										
										e\EventState=1.0
										
										;reset monster spawn timer
										e\EventState3 = 0.0
										
										If e\room\NPC[0]<>Null Then
											;reset monster to the (hidden) idle state
											e\room\NPC[0]\State = 0
										EndIf
										
										PrevSecondaryLightOn = SecondaryLightOn
										SecondaryLightOn = True
										
										pvt = CreatePivot()
										PositionEntity pvt, EntityX(Camera),EntityY(Camera),EntityZ(Camera)
										PointEntity pvt, e\room\obj
										ang# = WrapAngle(EntityYaw(pvt)-EntityYaw(e\room\obj,True))
										If ang > 90 And ang < 270 Then
											PositionEntity Collider,EntityX(fr\Door[0],True),EntityY(fr\Door[0],True)+EntityY(Collider,True)+0.5,EntityZ(fr\Door[0],True),True
											RotateEntity Collider, 0.0, EntityYaw(fr\Door[0],True)-180, 0.0, True
											MoveEntity Collider, -0.5,0.0,0.5
											e\EventState2 = 1
										Else
											PositionEntity Collider,EntityX(fr\Door[1],True),EntityY(fr\Door[1],True)+EntityY(Collider,True)+0.5,EntityZ(fr\Door[1],True),True
											RotateEntity Collider, 0.0, EntityYaw(fr\Door[1],True)-180, 0.0, True
											MoveEntity Collider, -0.5,0.0,0.5
											e\EventState2 = 0
										EndIf
										FreeEntity pvt
										
										ResetEntity Collider
									EndIf
								EndIf
							EndIf
						EndIf
						
					EndIf
					
				Else
					If (fr=Null) Then
						RemoveEvent(e)
					Else
						If (fr\Forest_Pivot<>0) Then HideEntity fr\Forest_Pivot
					EndIf
				EndIf
				
				
				
			Case "room966"
				
				If PlayerRoom = e\room Then
					Select e\EventState
						Case 0
							;a dirty workaround to hide the pause when loading 966 model
							If QuickLoadPercent = -1
								;LightBlink = 5.0
								e\EventState = 1
								;PlaySound_Strict LightSFX
								QuickLoadPercent = 0
								QuickLoad_CurrEvent = e
							EndIf
						Case 2
							e\EventState = 2
							RemoveEvent (e)
					End Select
				EndIf
				
			Case "room1123"
				
				If PlayerRoom = e\room Then
					;the event is started when the player picks up SCP-1123 (in Items.bb/UpdateItems())
					If e\EventState>0 And e\EventState<7 Then
						CanSave = False
					EndIf
					If e\EventState = 1 Then
						;If e\SoundCHN = 0 Then
						;	e\SoundCHN = 
						;Else
						;	If Not ChannelPlaying(e\SoundCHN) Then e\SoundCHN = PlaySound_Strict(moddedambience)
						;End If
						
						;Saving Injuries and Bloodloss, so that the player won't be healed automatically
						PrevInjuries = Injuries
						PrevBloodloss = Bloodloss
						PrevSecondaryLightOn = SecondaryLightOn
						SecondaryLightOn = True
						
						e\room\NPC[0] = CreateNPC(NPCtypeD, EntityX(e\room\Objects[6],True),EntityY(e\room\Objects[6],True),EntityZ(e\room\Objects[6],True))
						;e\room\NPC[1] = CreateNPC(NPCtypeD, EntityX(e\room\Objects[7],True),EntityY(e\room\Objects[7],True),EntityZ(e\room\Objects[7],True))
						
						nazi = LoadAnimMesh_Strict("GFX\npcs\naziofficer.b3d")
						scale# = 0.5 / MeshWidth(nazi)
						
						FreeEntity e\room\NPC[0]\obj
						e\room\NPC[0]\obj = CopyEntity(nazi)
						ScaleEntity e\room\NPC[0]\obj, scale, scale, scale
						
						;FreeEntity e\room\NPC[1]\obj
						;e\room\NPC[1]\obj = CopyEntity(nazi)
						;ScaleEntity e\room\NPC[1]\obj, scale, scale, scale
						
						FreeEntity nazi
						PositionEntity Collider, EntityX(e\room\Objects[4],True),EntityY(e\room\Objects[4],True),EntityZ(e\room\Objects[4],True),True
						ResetEntity Collider
						;PlaySound_Strict(HorrorSFX(9))
						CameraShake = 1.0
						BlurTimer = 1200
						Injuries = 1.0
						e\EventState = 2
						
					ElseIf e\EventState = 2
						e\EventState2 = e\EventState2 + FPSfactor
						
						PointEntity e\room\NPC[0]\Collider, Collider
						BlurTimer = Max(BlurTimer, 100)
						
						If e\EventState2>200 And e\EventState2-FPSfactor=<200 Then 							
							e\Sound = LoadSound_Strict("SFX\Music\1123.ogg");
							e\SoundCHN = PlaySound_Strict(e\Sound)
						EndIf
						
						If e\EventState2 > 1000 Then
							If e\Sound2=0 Then
								e\Sound2 = LoadSound_Strict("SFX\Door\1123DoorOpen.ogg")
								e\SoundCHN2 = PlaySound_Strict(e\Sound2)
							EndIf
							RotateEntity e\room\Objects[11], 0, CurveAngle(10, EntityYaw(e\room\Objects[11],0), 40), 0,False
							If e\EventState2=>1040 And e\EventState2-FPSfactor<1040 Then 
								PlaySound2(LoadTempSound("SFX\SCP\1123\Officer1.ogg"), Camera, e\room\NPC[0]\obj)
							ElseIf e\EventState2=>1400 And e\EventState2-FPSfactor<1400 Then 
								PlaySound2(LoadTempSound("SFX\SCP\1123\Officer2.ogg"), Camera, e\room\NPC[0]\obj)
							EndIf
							e\room\NPC[0]\State = 3
							AnimateNPC(e\room\NPC[0],3,26,0.2,True)
							;Animate2(e\room\Objects[4], AnimTime(e\room\Objects[4]), 0, 8, 0.1, False)
							If EntityDistance(Collider, e\room\Objects[4])>392*RoomScale Then
								BlinkTimer = -10
								BlurTimer = 500
								PositionEntity Collider, EntityX(e\room\Objects[5],True),EntityY(e\room\Objects[5],True),EntityZ(e\room\Objects[5],True),True
								RotateEntity Collider, 0, EntityYaw(e\room\obj,True)+180, 0
								ResetEntity(Collider)
								e\EventState = 3
							EndIf
							
						EndIf
					ElseIf e\EventState=3
						If e\room\RoomDoors[0]\openstate>160 Then
							If e\Sound=0 Then e\Sound = LoadSound_Strict("SFX\Music\1123.ogg")
							e\SoundCHN = PlaySound_Strict(e\Sound)
							
							PositionEntity e\room\NPC[0]\Collider, EntityX(e\room\Objects[7],True),EntityY(e\room\Objects[7],True),EntityZ(e\room\Objects[7],True)
							ResetEntity e\room\NPC[0]\Collider
							
							e\EventState=4
						EndIf
					ElseIf e\EventState=4
						
						;PointEntity e\room\NPC[1]\Collider, Collider
						
						TFormPoint EntityX(Collider),EntityY(Collider),EntityZ(Collider),0,e\room\obj
						
						If TFormedX()<256 And TFormedZ()>-480 Then
							e\room\RoomDoors[0]\open = False
						EndIf
						
						If EntityYaw(e\room\Objects[13],False)=0 Then
							DebugLog "aaaaaaaa"
							If EntityDistance(Collider, e\room\Objects[12])<1.0 Then
								DrawHandIcon = True
								If MouseHit1 Then
									RotateEntity e\room\Objects[13], 0, 1, 0, False
									RotateEntity e\room\Objects[11], 0, 90, 0, False
									PlaySound_Strict(LoadTempSound("SFX\SCP\1123\Horror.ogg"))
								EndIf
							EndIf							
						Else
							DebugLog "bbbbbbb"
							RotateEntity e\room\Objects[13], 0, CurveAngle(90, EntityYaw(e\room\Objects[13], False), 40), 0
							If EntityYaw(e\room\Objects[13], False)>30 Then
								e\room\NPC[0]\State = 3
								PointEntity e\room\NPC[0]\Collider, Collider
								AnimateNPC(e\room\NPC[0], 27, 54, 0.5, False)
								If e\room\NPC[0]\Frame => 54 Then
									e\EventState = 5
									e\EventState2 = 0
									PositionEntity Collider, EntityX(e\room\obj,True),0.3,EntityZ(e\room\obj,True),True
									ResetEntity Collider									
									BlinkTimer = -10
									BlurTimer = 500	
									Injuries = 1.5
									Bloodloss = 70
								;PlaySound_Strict(LoadTempSound("SFX\Door\WoodenDoorClose.ogg"))							
								EndIf								
							EndIf
							
						EndIf
						
						;RemoveNPC(e\room\NPC[0])
						;RemoveNPC(e\room\NPC[1])
						;RemoveEvent(e)
					ElseIf e\EventState = 5
						e\EventState2 = e\EventState2 + FPSfactor
						If e\EventState2 > 500 Then 
							RotateEntity e\room\Objects[9],0,90,0,False
							RotateEntity e\room\Objects[13],0,0,0,False
							
							x = (EntityX(e\room\Objects[8], True)+EntityX(e\room\Objects[12], True))/2
							y = EntityY(e\room\Objects[5], True)
							z = (EntityZ(e\room\Objects[8], True)+EntityZ(e\room\Objects[12], True))/2
							PositionEntity Collider, x,y,z, True
							ResetEntity(Collider)
							
							x = (EntityX(Collider, True)+EntityX(e\room\Objects[12], True))/2
							z = (EntityZ(Collider, True)+EntityZ(e\room\Objects[12], True))/2
							
							PositionEntity e\room\NPC[0]\Collider, x,y+0.2,z
							ResetEntity e\room\NPC[0]\Collider
							
							Injuries = 1.5
							Bloodloss = 70
							
							BlinkTimer = -10
							
							de.Decals = CreateDecal(3, EntityX(Collider), 512*RoomScale + 0.0005, EntityZ(Collider),90,Rnd(360),0)
							de\size = 0.5 : ScaleSprite de\obj, de\size, de\size
							
							e\room\NPC[0]\Sound = LoadSound_Strict("SFX\SCP\1123\Officer3.ogg")
							
							e\EventState = 6
						EndIf
					ElseIf e\EventState = 6
						PointEntity e\room\NPC[0]\Collider, Collider
						AnimateNPC(e\room\NPC[0], 75, 128, 0.04, True)	
						If e\room\NPC[0]\Sound<>0 Then 
							If e\room\NPC[0]\SoundChn<>0 Then
								If (Not ChannelPlaying(e\room\NPC[0]\SoundChn)) Then 
									PlaySound_Strict(LoadTempSound("SFX\SCP\1123\Gunshot.ogg"))
									e\EventState = 7
									FreeSound_Strict e\room\NPC[0]\Sound : e\room\NPC[0]\Sound=0	
								EndIf
							EndIf
							
							If e\room\NPC[0]\Sound<>0 Then e\room\NPC[0]\SoundChn = LoopSound2(e\room\NPC[0]\Sound, e\room\NPC[0]\SoundChn, Camera, e\room\NPC[0]\Collider, 7.0)
						EndIf
					ElseIf e\EventState=7
						PositionEntity Collider, EntityX(e\room\obj,True),0.3,EntityZ(e\room\obj,True),True
						ResetEntity Collider
						ShowEntity Light
						LightFlash = 6
						BlurTimer = 500	
						Injuries = PrevInjuries
						Bloodloss = PrevBloodloss
						SecondaryLightOn = PrevSecondaryLightOn
						RotateEntity e\room\Objects[9],0,0,0,False
						
						PrevInjuries = 0
						PrevBloodloss = 0
						PrevSecondaryLightOn = 0.0
						Crouch = False
						CanSave = True
						For i = 0 To MaxItemAmount-1
							If Inventory(i) <> Null Then
								If Inventory(i)\itemtemplate\name = "Leaflet"
									RemoveItem(Inventory(i))
									Exit
								EndIf
							EndIf
						Next
						
						GiveAchievement(Achv1123)
						
						RemoveNPC(e\room\NPC[0])
						RemoveEvent(e)						
					End If
				EndIf
				
				
				
				
			Case "testroom"
				
				If e <> Null Then
					If PlayerRoom = e\room Then
						If e\EventState = 0 Then
							e\room\Objects[7]=LoadAnimMesh_Strict("GFX\npcs\scp-1048.b3d")
							ScaleEntity e\room\Objects[7], 0.05,0.05,0.05
							
							TFormPoint EntityX(Collider),EntityY(Collider),EntityZ(Collider),0,e\room\obj
							If TFormedZ()=0 Then temp = -1 Else temp = -Sgn(TFormedZ())
							TFormPoint -720,0,816*temp,e\room\obj,0
							PositionEntity(e\room\Objects[7],TFormedX(),0,TFormedZ())
							
							RotateEntity e\room\Objects[7],-90,e\room\angle-90,0
							SetAnimTime e\room\Objects[7],297
							e\EventState = 1
						EndIf
						If EntityDistance(Collider, e\room\Objects[6]) < 2.5 And e\EventState > 0 Then
							PlaySound_Strict(LoadTempSound("SFX\SCP\079\TestroomWarning.ogg"))
							For i = 0 To 5
								em.Emitters = CreateEmitter(EntityX(e\room\Objects[i], True), EntityY(e\room\Objects[i], True), EntityZ(e\room\Objects[i], True), 0)
								TurnEntity(em\Obj, 90, 0, 0, True)
								;entityParent(em\obj, e\room\obj)
								em\RandAngle = 5
								em\Speed = 0.042
								em\SizeChange = 0.0025									
							Next
							;Delete e
							e\EventState = e\EventState * -1
						EndIf
						If e\room\Objects[7]<>0 Then
							Animate2(e\room\Objects[7],AnimTime(e\room\Objects[7]),284,295,0.3)
							MoveEntity e\room\Objects[7],0,-0.008*FPSfactor,0
							TFormPoint EntityX(e\room\Objects[7]),EntityY(e\room\Objects[7]),EntityZ(e\room\Objects[7]),0,e\room\obj
							
							If Abs(TFormedX())>725 Then
								FreeEntity(e\room\Objects[7])
								e\room\Objects[7]=0
								e\EventState = e\EventState *2
							EndIf
						EndIf
						If e\EventState = -2 Then RemoveEvent(e)
					EndIf
				End If
				
			Case "tunnel2smoke"
				
				If PlayerRoom = e\room Then
					If e\room\dist < 3.5 Then
						PlaySound2(BurstSFX, Camera, e\room\obj) 
						For i = 0 To 1
							em.Emitters = CreateEmitter(EntityX(e\room\Objects[i],True),EntityY(e\room\Objects[i],True), EntityZ(e\room\Objects[i],True),0)
							TurnEntity(em\Obj, 90, 0, 0, True)
							EntityParent(em\Obj, e\room\obj)
							em\Size = 0.05
							em\RandAngle = 10
							em\Speed = 0.06
							em\SizeChange = 0.007
							;EntityParent(em\Obj, e\room\obj)
							
							For z = 0 To Ceil(3.3333*(ParticleAmount+1))
								p.Particles = CreateParticle(EntityX(em\Obj, True), 448*RoomScale, EntityZ(em\Obj, True), Rand(em\MinImage, em\MaxImage), em\Size, em\Gravity, em\LifeTime)
								p\speed = em\Speed
								RotateEntity(p\pvt, Rnd(360), Rnd(360), 0, True)
								p\size = 0.05
								p\SizeChange = 0.008
							Next
							
						Next
						RemoveEvent(e)
					End If					
				EndIf
				
				
			Case "tunnel2"
				
				If PlayerRoom = e\room Then
					If Curr173\Idle > 1 Then
						RemoveEvent(e)
						Exit
					Else		
						If e\EventState = 0 Then
							If Distance(EntityX(Collider), EntityZ(Collider), EntityX(e\room\obj), EntityZ(e\room\obj)) < 3.5 Then
								PlaySound_Strict(LightSFX)
								
								LightBlink = Rnd(0.0,1.0)*(e\EventState/200)
								e\EventState = 1
							End If
						End If	
					EndIf
				EndIf
				
				If e\EventState > 0 And e\EventState < 200 Then
					BlinkTimer = -10
					If e\EventState > 30 Then 
						LightBlink = 1.0 
						If e\EventState-FPSfactor =< 30 Then 
							PlaySound_Strict LoadTempSound("SFX\ambient\general\ambient3.ogg")
						EndIf
					EndIf
					If e\EventState-FPSfactor =< 100 And e\EventState > 100 Then
						PlaySound_Strict LoadTempSound("SFX\ambient\general\ambient6.ogg")
						PositionEntity(Curr173\Collider, EntityX(e\room\obj), 0.6, EntityZ(e\room\obj))
						ResetEntity(Curr173\Collider)					
						Curr173\Idle = True		
					EndIf
					LightBlink = 1.0
					e\EventState = e\EventState + FPSfactor
				ElseIf e\EventState <> 0 Then
					BlinkTimer = BLINKFREQ
					
					Curr173\Idle = False
					RemoveEvent(e)
				EndIf
				
			Case "tunnel106"
				
				If e\EventState = 0 Then
					If e\room\dist < 5.0 And e\room\dist > 0 Then
						If Curr106\State >= 0 Then
							e\EventState = 1
						Else
							If Curr106\State <= -10 And EntityDistance(Curr106\Collider,Collider)>5 And (Not EntityInView(Curr106\obj,Camera)) Then
								e\EventState = 1
								e\EventState2 = 1
							EndIf
						EndIf
					ElseIf Contained106
						RemoveEvent(e)
					EndIf
				ElseIf e\EventState = 1
					
					If e\room\dist < 3.0 Or Rand(7000)=1 Then
						e\EventState = 2
						d.Decals = CreateDecal(0, EntityX(e\room\obj), 445.0*RoomScale, EntityZ(e\room\obj), -90, Rand(360), 0)
						d\Size = Rnd(0.5, 0.7) : EntityAlpha(d\obj, 0.7) : d\ID = 1 : ScaleSprite(d\obj, d\Size, d\Size)
						EntityAlpha(d\obj, Rnd(0.7, 0.85))
						
						PlaySound_Strict HorrorSFX(10)
					ElseIf e\room\dist > 8.0
						If Rand(5) = 1 Then
							Curr106\Idle = False
							RemoveEvent(e)
						Else
							Curr106\Idle = False
							Curr106\State = -10000
							RemoveEvent(e)
						End If
					EndIf
				Else
					If e\EventState2 = 1 Then
						ShouldPlay = 10
					EndIf
					e\EventState = e\EventState+FPSfactor
					If e\EventState <= 180 Then
						PositionEntity(Curr106\Collider, EntityX(e\room\obj, True), EntityY(Collider) + 1.0 - Min(Sin(e\EventState)*1.5,1.1), EntityZ(e\room\obj, True), True)
						PointEntity(Curr106\Collider, Camera)
						AnimateNPC(Curr106, 55, 104, 0.1)
						Curr106\Idle = True
						Curr106\State = 1
						ResetEntity(Curr106\Collider)
						Curr106\DropSpeed = 0
						PositionEntity(Curr106\obj, EntityX(Curr106\Collider), EntityY(Curr106\Collider) - 0.15, EntityZ(Curr106\Collider))
						RotateEntity Curr106\obj, 0, EntityYaw(Curr106\Collider), 0
						ShowEntity Curr106\obj
					ElseIf e\EventState > 180 And e\EventState < 300 Then
						Curr106\Idle = False
						Curr106\State = -10
						PositionEntity(Curr106\Collider, EntityX(e\room\obj, True), -3.0, EntityZ(e\room\obj, True), True)
						Curr106\PathTimer = 70*10
						Curr106\PathStatus = 0
						Curr106\PathLocation = 0
						de.Decals = CreateDecal(0, EntityX(e\room\obj, True), 0.01, EntityZ(e\room\obj, True), 90, Rand(360), 0)
						de\Size = 0.05 : de\SizeChange = 0.01 : EntityAlpha(de\obj, 0.8) : UpdateDecals
						e\EventState = 300
					ElseIf e\EventState < 800
						If EntityY(Curr106\Collider)>=EntityY(Collider)-0.05 Then
							RemoveEvent(e)
						Else
							TranslateEntity Curr106\Collider, 0, ((EntityY(Collider,True) - 0.11) - EntityY(Curr106\Collider)) / 50.0, 0
							If EntityY(Curr106\Collider)<-0.1 Then
								Curr106\CurrSpeed = 0.0
							EndIf
						EndIf
					Else
						RemoveEvent(e)
					EndIf
					
				EndIf
				
				
			Case "testroom173"
				
				If PlayerRoom = e\room	
					If Curr173\Idle = 0 Then 
						If e\EventState = 0 Then
							If e\room\RoomDoors[0]\open = True
							PositionEntity(Curr173\Collider, EntityX(e\room\Objects[0], True), 0.5, EntityZ(e\room\Objects[0], True))
							ResetEntity(Curr173\Collider)
							e\EventState = 1
							EndIf
						Else
							If e\room\Objects[2]=0
								Local Glasstex = LoadTexture_Strict("GFX\map\glass.png",1+2)
								e\room\Objects[2] = CreateSprite()
								EntityTexture(e\room\Objects[2],Glasstex)
								SpriteViewMode(e\room\Objects[2],2)
								ScaleSprite(e\room\Objects[2],182.0*RoomScale*0.5, 192.0*RoomScale*0.5)
								pvt% = CreatePivot(e\room\obj)
								;PositionEntity pvt%,-595.0,224.0,-208.0,False
								PositionEntity pvt%,-632.0,224.0,-208.0,False
								PositionEntity(e\room\Objects[2], EntityX(pvt,True), EntityY(pvt,True), EntityZ(pvt,True))
								FreeEntity pvt
								RotateEntity e\room\Objects[2],0,e\room\angle,0
								TurnEntity(e\room\Objects[2],0,180,0)
								EntityParent(e\room\Objects[2], e\room\obj)
								FreeTexture Glasstex
							EndIf
							
							ShowEntity (e\room\Objects[2])
							;start a timer for 173 breaking through the window
							e\EventState = e\EventState + 1
							dist# = EntityDistance(Collider, e\room\Objects[1])
							If dist <1.0 Then
								;if close, increase the timer so that 173 is ready to attack
								e\EventState = Max(e\EventState, 70*12)
							ElseIf dist > 1.4
								;if the player moves a bit further and blinks, 173 attacks
								If e\EventState > 70*12 And BlinkTimer =< -10 Then
									If (EntityDistance(Curr173\Collider, e\room\Objects[0]) > 5.0) Then
										;if 173 is far away from the room (perhaps because the player 
										;left and 173 moved to some other room?) -> disable the event
										RemoveEvent(e)
									Else
										PlaySound2(LoadTempSound("SFX\General\GlassBreak.ogg"), Camera, Curr173\obj) 
										FreeEntity(e\room\Objects[2])
										e\room\Objects[2]=0
										PositionEntity(Curr173\Collider, EntityX(e\room\Objects[1], True), 0.5, EntityZ(e\room\Objects[1], True))
										ResetEntity(Curr173\Collider)
										RemoveEvent(e)
									EndIf
								EndIf	
							EndIf
						End If
					EndIf
				End If	
				
			Case "toiletguard"
				
				If e\EventState = 0 Then
					If e\room\dist < 8.0  And e\room\dist > 0 Then e\EventState = 1
				ElseIf e\EventState = 1
					e\room\NPC[0]=CreateNPC(NPCtypeGuard, EntityX(e\room\Objects[1],True), EntityY(e\room\Objects[1],True)+0.5, EntityZ(e\room\Objects[1],True))
					PointEntity e\room\NPC[0]\Collider, e\room\obj
					RotateEntity e\room\NPC[0]\Collider, 0, EntityYaw(e\room\NPC[0]\Collider)-20,0, True
					
					SetNPCFrame (e\room\NPC[0], 287)
					e\room\NPC[0]\State = 8
					
					e\EventState = 2	
				Else
					If e\Sound = 0 Then e\Sound = LoadSound_Strict("SFX\Character\Guard\SuicideGuard1.ogg")
					If e\room\dist < 15.0 And e\room\dist >= 4.0 Then 
						e\SoundCHN = LoopSound2(e\Sound, e\SoundCHN, Camera, e\room\NPC[0]\Collider, 15.0)
						
					ElseIf e\room\dist<4.0 And PlayerSoundVolume > 1.0
						If e\EventState2=0
							;Y=0.01
							de.Decals = CreateDecal(3,  EntityX(e\room\Objects[2],True), EntityY(e\room\Objects[2],True), EntityZ(e\room\Objects[2],True),0,e\room\angle+270,0)
							de\Size = 0.3 : ScaleSprite (de\obj, de\size, de\size)
							
							;de.Decals = CreateDecal(17,  EntityX(e\room\Objects[2],True), 0.01, EntityZ(e\room\Objects[2],True),90,Rnd(360),0)
							;de\Size = 0.1 : de\maxsize = 0.45 : de\sizechange = 0.0002 : UpdateDecals()
							
							e\EventState2 = 1
						EndIf
						If e\SoundCHN2 = 0
							StopChannel(e\SoundCHN)
							FreeSound_Strict(e\Sound)
							e\room\NPC[0]\Sound = LoadSound_Strict("SFX\Character\Guard\SuicideGuard2.ogg")
							e\SoundCHN2 = PlaySound2(e\room\NPC[0]\Sound, Camera, e\room\NPC[0]\Collider, 15.0)
						EndIf
						UpdateSoundOrigin(e\SoundCHN2,Camera,e\room\NPC[0]\Collider,15.0)
						If (Not ChannelPlaying(e\SoundCHN2)) Then RemoveEvent(e)
					EndIf
				EndIf
				
				
			Case "008"
				
				If PlayerRoom = e\room Then	
					GiveAchievement(Achv008)=True
					;container open
					If e\EventState = 0 Then
						If Curr173\Idle<2 And EntityDistance(Curr173\Collider,Collider)>HideDistance ;Just making sure that 173 is far away enough to spawn him to this room
							PositionEntity Curr173\Collider, EntityX(e\room\Objects[3],True),0.5,EntityZ(e\room\Objects[3],True),True
							ResetEntity Curr173\Collider
						EndIf
						e\EventState = 1
					ElseIf e\EventState = 1
						e\SoundCHN = LoopSound2(AlarmSFX(0), e\SoundCHN, Camera, e\room\Objects[0], 5.0)
						
						If (MilliSecs2() Mod 1000)<500 Then
							ShowEntity e\room\Objects[5] 
						Else
							HideEntity e\room\Objects[5]
						EndIf
						
						dist = EntityDistance(Collider, e\room\Objects[0])
						If dist<2.0 Then 
							e\room\RoomDoors[0]\locked = True
							e\room\RoomDoors[1]\locked = True
							
							If e\EventState2=0 Then
								ShowEntity e\room\Objects[2]
								If EntityDistance(Curr173\Collider,e\room\Objects[4])<3.0
									If (BlinkTimer<-10 Or (Not EntityInView(Curr173\obj,Camera))) And Curr173\Idle = 0 Then
										PositionEntity Curr173\Collider, EntityX(e\room\Objects[4],True),0.5,EntityZ(e\room\Objects[4],True),True
										ResetEntity Curr173\Collider
										
										HideEntity e\room\Objects[2]
										
										If (Not WearingHazmat) Then
											Injuries=Injuries+0.1
											If Infect=0 Then Infect=1
											Msg = "The window shattered and a piece of glass cut your arm."
											MsgTimer = 70*8
										EndIf
										
										PlaySound2(LoadTempSound("SFX\General\GlassBreak.ogg"), Camera, e\room\Objects[0]) 
										
										e\EventState2=1
									EndIf
								EndIf
							EndIf
							
							If dist<1.0 Then
								If EntityInView(e\room\Objects[0], Camera) Then
									DrawHandIcon = True
									
									If MouseDown1 Then
										DrawArrowIcon(2) = True
										RotateEntity(e\room\Levers[0], Max(Min(EntityPitch(e\room\Levers[0])+Max(Min(-mouse_y_speed_1,10.0),-10), 89), 35), EntityYaw(e\room\Levers[0]), 0)
									EndIf
								EndIf
							EndIf
							
							If (Not WearingHazmat) And Bloodloss>0.0
								If Infect=0
									Infect=1
									DebugLog "Infected player"
								EndIf
							EndIf
						EndIf
						
						If EntityPitch(e\room\Levers[0],True)<40 Then 
							e\EventState = 2
							PlaySound_Strict LeverSFX
						Else
							p.Particles = CreateParticle(EntityX(e\room\Objects[0],True),EntityY(e\room\Objects[0],True),EntityZ(e\room\Objects[0],True), 6, 0.02, -0.12)
							RotateEntity (p\pvt,-90,0,0,True)
							TurnEntity(p\pvt, Rnd(-26,26), Rnd(-26,26), Rnd(360))
							
							p\SizeChange = 0.012
							p\Achange = -0.015
						EndIf		
					Else
						HideEntity e\room\Objects[5]
						e\room\RoomDoors[0]\locked = False
						e\room\RoomDoors[1]\locked = False
						e\room\RoomDoors[2]\locked = False
						
						RotateEntity (e\room\Levers[0],CurveAngle(1,EntityPitch(e\room\Levers[0],True),15.0),EntityYaw(e\room\Levers[0],True),0,True)
						
						If EntityPitch(e\room\Levers[0],True)=<1.0 Then
							RemoveEvent(e)
						EndIf
					EndIf
				EndIf
				
			Case "106victim"
				
				If (Not Contained106) Then
					If PlayerRoom = e\room Then
						If e\EventState = 0 Then
							de.Decals = CreateDecal(0, EntityX(e\room\obj), 799.0*RoomScale, EntityZ(e\room\obj), -90, Rand(360), 0)
							de\Size = 0.05 : de\SizeChange = 0.0015 : EntityAlpha(de\obj, 0.8) : UpdateDecals()			
							PlaySound2(DecaySFX(3), Camera, de\obj, 15.0)
							e\EventState=1
						EndIf
					EndIf
					
					If e\EventState > 0 Then 
						If e\room\NPC[0]=Null Then
							e\EventState=e\EventState+FPSfactor
						EndIf
						If e\EventState>200 Then
							If e\room\NPC[0]=Null Then
								e\room\NPC[0]=CreateNPC(NPCtypeD, EntityX(e\room\obj), 900.0*RoomScale, EntityZ(e\room\obj))
								RotateEntity e\room\NPC[0]\Collider, 0, Rnd(360), 0, True
								ChangeNPCTextureID(e\room\NPC[0],5)
								e\room\NPC[0]\State=6
								
								PlaySound_Strict HorrorSFX(0)
								PlaySound2(DecaySFX(2), Camera, e\room\NPC[0]\Collider, 15.0)
							EndIf
							
							e\room\NPC[0]\FallingPickDistance = 0.0
							EntityType e\room\NPC[0]\Collider,HIT_PLAYER
							If EntityY(e\room\NPC[0]\Collider)>0.35 Then
								AnimateNPC(e\room\NPC[0], 1, 10, 0.12, False)
								dist# = EntityDistance(Collider,e\room\NPC[0]\Collider)
								If dist<0.8 Then ;get the player out of the way
									fdir# = point_direction(EntityX(Collider,True),EntityZ(Collider,True),EntityX(e\room\NPC[0]\Collider,True),EntityZ(e\room\NPC[0]\Collider,True))
									TranslateEntity Collider,Cos(-fdir+90)*(dist-0.8)*(dist-0.8),0,Sin(-fdir+90)*(dist-0.8)*(dist-0.8)
								EndIf
								
								If EntityY(e\room\NPC[0]\Collider)>0.6 Then EntityType e\room\NPC[0]\Collider,0
							Else
								e\EventState=e\EventState+FPSfactor
								AnimateNPC(e\room\NPC[0], 11, 19, 0.25, False)
								If e\Sound=0 Then 
									;e\Sound = LoadSound("SFX\General\BodyFall.ogg")
									LoadEventSound(e,"SFX\General\BodyFall.ogg")
									PlaySound_Strict e\Sound
									
									de.Decals = CreateDecal(0, EntityX(e\room\obj), 0.001, EntityZ(e\room\obj), 90, Rand(360), 0)
									de\Size = 0.4 : EntityAlpha(de\obj, 0.8) : UpdateDecals()			
								EndIf
								
								If e\EventState>400 Then
									If e\Sound<>0 Then FreeSound_Strict e\Sound : e\Sound=0
									RemoveEvent(e)
								EndIf								
							EndIf
							
						EndIf
					EndIf
					
				EndIf
				
				
			Case "106sinkhole"
				
				If e\EventState=0 Then
					de.Decals = CreateDecal(0, EntityX(e\room\obj)+Rnd(-0.5,0.5), 0.01, EntityZ(e\room\obj)+Rnd(-0.5,0.5), 90, Rand(360), 0)
					de\Size = 2.5 : ScaleSprite(de\obj, de\Size, de\Size);
					
					e\EventState=1
				ElseIf PlayerRoom = e\room
					If e\Sound=0 Then
						e\Sound=LoadSound_Strict("SFX/Room/Sinkhole.ogg")
					Else
						e\SoundCHN = LoopSound2(e\Sound, e\SoundCHN, Camera, e\room\obj, 4.5, 1.5)
					EndIf
					dist = Distance(EntityX(Collider),EntityZ(Collider),EntityX(e\room\obj),EntityZ(e\room\obj))
					If dist < 2.0 Then
						CurrStepSFX=1
						CurrSpeed = CurveValue(0.0, CurrSpeed, Max(dist*50,1.0))	
						CrouchState = (2.0-dist)/2.0
						
						If dist<0.5 Then
							If e\EventState2 = 0 Then
								PlaySound_Strict(LoadTempSound("SFX/Room/SinkholeFall.ogg"))
							EndIf
							
							CurrSpeed = CurveValue(0.0, CurrSpeed, Max(dist*50,1.0))
							
							x = CurveValue(EntityX(e\room\obj),EntityX(Collider),10.0)
							y = CurveValue(EntityY(e\room\obj)-e\EventState2,EntityY(Collider),25.0)
							z = CurveValue(EntityZ(e\room\obj),EntityZ(Collider),10.0)
							PositionEntity Collider, x, y, z, True
							
							DropSpeed = 0
							
							ResetEntity Collider
							
							e\EventState2=Min(e\EventState2+FPSfactor/200.0,2.0)
							
							LightBlink = Min(e\EventState2*5,10.0)
							BlurTimer = e\EventState2*500
							
							If e\EventState2 = 2.0 Then MoveToPocketDimension()
						EndIf
					EndIf
				Else 
					e\EventState2=0
				EndIf
				
				
				
			Case "682roar"
				
				If e\EventState = 0 Then
					If PlayerRoom = e\room Then e\EventState = 70 * Rand(300,1000)
				ElseIf PlayerRoom\RoomTemplate\Name <> "pocketdimension" And PlayerRoom\RoomTemplate\Name <> "room860" And PlayerRoom\RoomTemplate\Name <> "room1123" And PlayerRoom\RoomTemplate\Name <> "dimension1499" 
					e\EventState = e\EventState-FPSfactor
					
					If e\EventState < 17*70 Then
						If	e\EventState+FPSfactor => 17*70 Then LoadEventSound(e,"SFX\SCP\682\Roar.ogg") : e\SoundCHN = PlaySound_Strict(e\Sound) ;e\Sound = LoadSound_Strict("SFX\SCP\682\Roar.ogg")
						If e\EventState > 17*70 - 3*70 Then CameraShake = 0.5
						If e\EventState < 17*70 - 7.5*70 And e\EventState > 17*70 - 11*70 Then CameraShake = 2.0				
						If e\EventState < 70 Then 
							If e\Sound<>0 Then FreeSound_Strict (e\Sound) 
							RemoveEvent(e)
						EndIf
					EndIf
				EndIf
				
				
			Case "914"
				
				If PlayerRoom = e\room Then
					;GiveAchievement(Achv914)
					
					If e\room\RoomDoors[2]\open
						GiveAchievement(Achv914)
						e\EventState2=1
					EndIf
					
					If e\EventState2=1
						ShouldPlay = 22
					EndIf
					
					EntityPick(Camera, 1.0)
					If PickedEntity() = e\room\Objects[0] Then
						DrawHandIcon = True
						If MouseHit1 Then GrabbedEntity = e\room\Objects[0]
					ElseIf PickedEntity() = e\room\Objects[1]
						DrawHandIcon = True
						If MouseHit1 Then GrabbedEntity = e\room\Objects[1]
					EndIf
					
					If MouseDown1 Or MouseHit1 Then
						If GrabbedEntity <> 0 Then ;avain
							If GrabbedEntity = e\room\Objects[0] Then
								If e\EventState = 0 Then
									DrawHandIcon = True
									TurnEntity(GrabbedEntity, 0, 0, -mouse_x_speed_1 * 2.5)
									
									angle = WrapAngle(EntityRoll(e\room\Objects[0]))
									If angle > 181 Then DrawArrowIcon(3) = True
									DrawArrowIcon(1) = True
									
									If angle < 90 Then
										RotateEntity(GrabbedEntity, 0, 0, 361.0)
									ElseIf angle < 180
										RotateEntity(GrabbedEntity, 0, 0, 180)
									EndIf
									
									If angle < 181 And angle > 90 Then
										For it.Items = Each Items
											If it\collider <> 0 And it\Picked = False Then
												If Abs(EntityX(it\collider) - (e\room\x - 712.0 * RoomScale)) < 200.0 Then
													If Abs(EntityY(it\collider) - (e\room\y + 648.0 * RoomScale)) < 104.0 Then
														e\EventState = 1
														e\SoundCHN = PlaySound2(MachineSFX, Camera, e\room\Objects[1])
														e\room\RoomDoors[1]\SoundCHN = PlaySound2(LoadTempSound("SFX\SCP\914\DoorClose.ogg"), Camera, e\room\RoomDoors[1]\obj)
														Exit
													EndIf
												End If
											End If
										Next
									EndIf
								End If
							ElseIf GrabbedEntity = e\room\Objects[1]
								If e\EventState = 0 Then
									DrawHandIcon = True
									TurnEntity(GrabbedEntity, 0, 0, -mouse_x_speed_1 * 2.5)
									
									angle# = WrapAngle(EntityRoll(e\room\Objects[1]))
									DrawArrowIcon(3) = True
									DrawArrowIcon(1) = True
									
									If angle > 90 Then
										If angle < 180 Then
											RotateEntity(GrabbedEntity, 0, 0, 90.0)
										ElseIf angle < 270
											RotateEntity(GrabbedEntity, 0, 0, 270)
										EndIf
									EndIf
									
								End If
							End If
						End If
					Else
						GrabbedEntity = 0
					End If
					
					Local setting$ = ""
					
					If GrabbedEntity <> e\room\Objects[1] Then
						angle# = WrapAngle(EntityRoll(e\room\Objects[1]))
						If angle < 22.5 Then
							angle = 0
							setting = "1:1"
						ElseIf angle < 67.5
							angle = 40
							setting = "coarse"
						ElseIf angle < 180
							angle = 90
							setting = "rough"
						ElseIf angle > 337.5
							angle = 359 - 360
							setting = "1:1"
						ElseIf angle > 292.5
							angle = 320 - 360
							setting = "fine"
						Else
							angle = 270 - 360
							setting = "very fine"
						End If
						RotateEntity(e\room\Objects[1], 0, 0, CurveValue(angle, EntityRoll(e\room\Objects[1]), 20))
					EndIf
					
					For i% = 0 To 1
						If GrabbedEntity = e\room\Objects[i] Then
							If Not EntityInView(e\room\Objects[i], Camera) Then
								GrabbedEntity = 0
							ElseIf EntityDistance(e\room\Objects[i], Camera) > 1.0
								GrabbedEntity = 0
							End If
						End If
					Next
					
					If e\EventState > 0 Then
						e\EventState = e\EventState + FPSfactor
						
						
						e\room\RoomDoors[1]\open = False
						If e\EventState > 70 * 2 Then
							If e\room\RoomDoors[0]\open=True Then
								e\room\RoomDoors[0]\SoundCHN = PlaySound2(LoadTempSound("SFX\SCP\914\DoorClose.ogg"), Camera, e\room\RoomDoors[0]\obj)
							EndIf
							
							e\room\RoomDoors[0]\open = False
						EndIf
						
						If Distance(EntityX(Collider), EntityZ(Collider), EntityX(e\room\Objects[2], True), EntityZ(e\room\Objects[2], True)) < (170.0 * RoomScale) Then
							
							If setting = "rough" Or setting = "coarse" Then
								If e\EventState > 70 * 2.6 And e\EventState - FPSfactor2 < 70 * 2.6 Then PlaySound_Strict Death914SFX
							EndIf
							
							If e\EventState > 70 * 3 Then
								Select setting
									Case "rough"
										KillTimer = Min(-1, KillTimer)
										BlinkTimer = -10
										If e\SoundCHN <> 0 Then StopChannel e\SoundCHN
										DeathMSG = Chr(34)+"A heavily mutilated corpse found inside the output booth of SCP-914. DNA testing identified the corpse as Class D Subject D-9341. "
										DeathMSG = DeathMSG + "The subject had obviously been "+Chr(34)+"refined"+Chr(34)+" by SCP-914 on the "+Chr(34)+"Rough"+Chr(34)+" setting, but we are still confused as to how he "
										DeathMSG = DeathMSG + "ended up inside the intake booth and who or what wound the key."+Chr(34)
									Case "coarse"
										BlinkTimer = -10
										If e\EventState - FPSfactor2 < 70 * 3 Then PlaySound_Strict Use914SFX
									Case "1:1"
										BlinkTimer = -10
										If e\EventState - FPSfactor2 < 70 * 3 Then PlaySound_Strict Use914SFX
									Case "fine", "very fine"
										BlinkTimer = -10
										If e\EventState - FPSfactor2 < 70 * 3 Then PlaySound_Strict Use914SFX	
								End Select
							End If
						EndIf
						
						If e\EventState > (6 * 70) Then	
							RotateEntity(e\room\Objects[0], EntityPitch(e\room\Objects[0]), EntityYaw(e\room\Objects[0]), CurveAngle(0, EntityRoll(e\room\Objects[0]),10.0))
						Else
							RotateEntity(e\room\Objects[0], EntityPitch(e\room\Objects[0]), EntityYaw(e\room\Objects[0]), 180)
						EndIf
						
						If e\EventState > (12 * 70) Then							
							For it.Items = Each Items
								If it\collider <> 0 And it\Picked = False Then
									If Distance(EntityX(it\collider), EntityZ(it\collider), EntityX(e\room\Objects[2], True), EntityZ(e\room\Objects[2], True)) < (180.0 * RoomScale) Then
										Use914(it, setting, EntityX(e\room\Objects[3], True), EntityY(e\room\Objects[3], True), EntityZ(e\room\Objects[3], True))
										
									End If
								End If
							Next
							
							If Distance(EntityX(Collider), EntityZ(Collider), EntityX(e\room\Objects[2], True), EntityZ(e\room\Objects[2], True)) < (160.0 * RoomScale) Then
								Select setting
									Case "coarse"
										Injuries = 4.0
										Msg = "You notice countless small incisions all around your body. They are bleeding heavily."
										MsgTimer = 70*8
									Case "1:1"
										InvertMouse = (Not InvertMouse)
									Case "fine", "very fine"
										SuperMan = True
								End Select
								BlurTimer = 1000
								PositionEntity(Collider, EntityX(e\room\Objects[3], True), EntityY(e\room\Objects[3], True) + 1.0, EntityZ(e\room\Objects[3], True))
								ResetEntity(Collider)
								DropSpeed = 0
							EndIf								
							
							e\room\RoomDoors[0]\open = True
							e\room\RoomDoors[1]\open = True
							RotateEntity(e\room\Objects[0], 0, 0, 0)
							e\EventState = 0
							
							Local opensfx914 = LoadTempSound("SFX\SCP\914\DoorOpen.ogg")
							e\room\RoomDoors[0]\SoundCHN = PlaySound2(opensfx914, Camera, e\room\RoomDoors[0]\obj)
							e\room\RoomDoors[1]\SoundCHN = PlaySound2(opensfx914, Camera, e\room\RoomDoors[1]\obj)
						End If
					End If
					
				EndIf
				UpdateSoundOrigin(e\SoundCHN,Camera,e\room\Objects[1])
				
			Case "1048a"
				
				
				If e\room\Objects[0]=0 Then
					If PlayerRoom<>e\room And BlinkTimer<-10 Then
						dist = Distance(EntityX(Collider),EntityZ(Collider), EntityX(e\room\obj),EntityZ(e\room\obj))
						If (dist<16.0) Then
							For e2.Events = Each Events
								If e2\EventName = e\EventName Then
									If e2\room <> e\room Then
										If e2\room\Objects[0]<>0 Then
											e\room\Objects[0]=CopyEntity(e2\room\Objects[0])
											Exit
										EndIf
									EndIf
								EndIf
							Next
							If e\room\Objects[0]=0 Then
								e\room\Objects[0] =	LoadAnimMesh_Strict("GFX\npcs\scp-1048a.b3d")
							EndIf
							ScaleEntity e\room\Objects[0], 0.05,0.05,0.05
							SetAnimTime(e\room\Objects[0], 2)
							PositionEntity(e\room\Objects[0], EntityX(e\room\obj), 0.0, EntityZ(e\room\obj))
							
							RotateEntity(e\room\Objects[0], -90.0, Rnd(0.0, 360.0), 0.0)
							
							e\Sound = LoadSound_Strict("SFX\SCP\1048A\Shriek.ogg")
							e\Sound2 = LoadSound_Strict("SFX\SCP\1048A\Growth.ogg")
							
							e\EventState = 1
						EndIf
					EndIf
				Else
					e\EventState3 = 1
					Select e\EventState
						Case 1
							Animate2(e\room\Objects[0], AnimTime(e\room\Objects[0]), 2.0, 395.0, 1.0)
							
							If (EntityDistance(Collider, e\room\Objects[0])<2.5) Then e\EventState = 2
						Case 2
							Local prevFrame# = AnimTime(e\room\Objects[0]) 
							Animate2(e\room\Objects[0], prevFrame, 2.0, 647.0, 1.0, False)
							
							If (prevFrame <= 400.0 And AnimTime(e\room\Objects[0])>400.0) Then
								e\SoundCHN = PlaySound_Strict(e\Sound)
							EndIf
							
							Local volume# = Max(1.0 - Abs(prevFrame - 600.0)/100.0, 0.0)
							
							BlurTimer = volume*1000.0
							CameraShake = volume*10.0
							
							PointEntity(e\room\Objects[0], Collider)
							RotateEntity(e\room\Objects[0], -90.0, EntityYaw(e\room\Objects[0]), 0.0)
							
							If (prevFrame>646.0) Then
								If (PlayerRoom = e\room) Then
									e\EventState = 3	
									PlaySound_Strict e\Sound2
									
									Msg = "Something is growing all around your body."
									MsgTimer = 70.0 * 3.0
								Else
									e\EventState3 = 70*30
								EndIf
							EndIf
						Case 3
							e\EventState2 = e\EventState2 + FPSfactor
							
							BlurTimer = e\EventState2*2.0
							
							If (e\EventState2>250.0 And e\EventState2-FPSfactor <= 250.0) Then
								Select Rand(3)
									Case 1
										Msg = "Ears are growing all over your body."
									Case 2
										Msg = "Ear-like organs are growing all over your body."
									Case 3
										Msg = "Ears are growing all over your body. They are crawling on your skin."
								End Select
								
								MsgTimer = 70.0 * 3.0
							Else If (e\EventState2>600.0 And e\EventState2-FPSfactor <= 600.0)
								Select Rand(4)
									Case 1
										Msg = "It is becoming difficult to breathe."
									Case 2
										Msg = "You have excellent hearing now. Also, you are dying."
									Case 3
										Msg = "The ears are growing inside your body."
									Case 4
										Msg = Chr(34)+"Can't... Breathe..."+Chr(34)
								End Select
								
								MsgTimer = 70.0 * 5.0
							EndIf
							
							If (e\EventState2>70*15) Then
								DeathMSG = "A dead body covered in ears was found in [REDACTED]. Subject was presumably attacked by an instance of SCP-1048-A and suffocated to death by the ears. "
								DeathMSG = DeathMSG + "Body was sent for autopsy."
								Kill()
								e\EventState = 4
								RemoveEvent(e)
							EndIf
					End Select 
					
					If (e <> Null) Then
						If PlayerRoom <> e\room Then
							If e\EventState3>0 Then
								e\EventState3 = e\EventState3+FPSfactor
								
								If e\EventState3>70*25 Then
									FreeEntity(e\room\Objects[0])
									e\room\Objects[0]=0
									RemoveEvent(e)
								EndIf
							EndIf
						EndIf
					EndIf
				EndIf
				
				
			;New Events in SCP:CB version 1.3 - ENDSHN
			Case "room4tunnels"
				
				If e\room\dist < 10.0 And e\room\dist > 0 Then
					e\room\NPC[0]=CreateNPC(NPCtypeD, EntityX(e\room\obj,True)+1.0, 0.5, EntityZ(e\room\obj,True)+1.0)
					e\room\NPC[0]\texture = "GFX\npcs\body1.jpg"
					tex = LoadTexture_Strict(e\room\NPC[0]\texture)
					EntityTexture(e\room\NPC[0]\obj, tex)
					FreeTexture tex
					;EntityTexture e\room\NPC[0]\obj,NTF_BodyTextures(0)
					
					RotateEntity e\room\NPC[0]\Collider, 0, EntityYaw(e\room\obj)-(Rand(20,60)),0, True	
					
					SetNPCFrame e\room\NPC[0], 19
					e\room\NPC[0]\State=8
					
					;Delete e
					RemoveEvent(e)
				EndIf
				
			Case "room2gw_b"
				
				If e\room\dist < 8
					If e\EventState = 0 Then
						e\room\NPC[0]=CreateNPC(NPCtypeGuard, EntityX(e\room\Objects[2],True), EntityY(e\room\Objects[2],True)+0.5, EntityZ(e\room\Objects[2],True))
						PointEntity e\room\NPC[0]\Collider, e\room\obj
						RotateEntity e\room\NPC[0]\Collider, 0, EntityYaw(e\room\NPC[0]\Collider),0, True
						SetNPCFrame(e\room\NPC[0], 288)
						e\room\NPC[0]\State = 8
						
						e\EventState = 1
					EndIf
					
					;WIP
					p.Particles = CreateParticle(EntityX(e\room\Objects[0],True), EntityY(e\room\Objects[0],True), EntityZ(e\room\Objects[0],True), 6, 0.2, 0, 10)
					p\speed = 0.01
					RotateEntity(p\pvt, -60, e\room\angle-90, 0)
					
					p\Achange = -0.02
					
					e\SoundCHN = LoopSound2(AlarmSFX(3),e\SoundCHN,Camera,e\room\Objects[3],5)
				EndIf
				
			Case "room2scps2"
				
				;If PlayerRoom = e\room
				If e\room\dist < 15
					If Contained106 Then e\EventState = 2.0
					If Curr106\State < 0 Then e\EventState = 2.0
					
					If e\EventState < 2.0
						If e\EventState = 0.0
							LoadEventSound(e,"SFX\Character\Scientist/EmilyScream/ogg")
							e\SoundCHN = PlaySound2(e\Sound, Camera, e\room\Objects[0], 100, 1.0)
							de.Decals = CreateDecal(0, EntityX(e\room\Objects[0],True), e\room\y+2.0*RoomScale, EntityZ(e\room\Objects[0],True), 90, Rand(360), 0)
							de\Size = 0.5 : EntityAlpha(de\obj, 0.8)
							EntityFX de\obj,1
							e\EventState = 1.0
						ElseIf e\EventState = 1.0
							If (Not ChannelPlaying(e\SoundCHN))
								e\EventState = 2.0
								e\room\RoomDoors[0]\locked = False
							Else
								UpdateSoundOrigin(e\SoundCHN,Camera,e\room\Objects[0],100,1.0)
							EndIf
						EndIf
					Else
						DebugLog "Removed 'room2scps2' event"
						e\room\RoomDoors[0]\locked = False
						de.Decals = CreateDecal(0, EntityX(e\room\Objects[0],True), e\room\y+2.0*RoomScale, EntityZ(e\room\Objects[0],True), 90, Rand(360), 0)
						de\Size = 0.5 : EntityAlpha(de\obj, 0.8)
						EntityFX de\obj,1
						RemoveEvent(e)
					EndIf
				EndIf
				
			Case "room1162"
				
				;e\EventState = A variable to determine the "nostalgia" items
				;- 0.0 = No nostalgia item
				;- 1.0 = Lost key
				;- 2.0 = Disciplinary Hearing DH-S-4137-17092
				;- 3.0 = Coin
				;- 4.0 = Movie Ticket
				;- 5.0 = Old Badge
				;e\EventState2 = Defining which slot from the Inventory should be picked
				;e\EventState3 = A check for if a item should be removed
				;- 0.0 = no item "trade" will happen
				;- 1.0 = item "trade" will happen
				;- 2.0 = the player doesn't has any items in the Inventory, giving him heavily Injuries and giving him a random item
				;- 3.0 = player got a memorial item (to explain a bit D-9341's background)
				;- 3.1 = player got a memorial item + injuries (because he didn't had any item in his inventory before)
				If PlayerRoom = e\room
					
					GrabbedEntity = 0
					
					e\EventState = 0
					
					Local Pick1162% = True
					Local pp% = CreatePivot(e\room\obj)
					PositionEntity pp,976,128,-640,False
					
					For it.Items = Each Items
						If (Not it\Picked)
							If EntityDistance(it\collider,e\room\Objects[0])<0.75
								Pick1162% = False
							EndIf
						EndIf
					Next
					
					If EntityDistance(e\room\Objects[0],Collider)<0.75 And Pick1162%
						DrawHandIcon = True
						If MouseHit1 Then GrabbedEntity = e\room\Objects[0]
					EndIf
					
					If GrabbedEntity <> 0
						e\EventState2 = Rand(0,MaxItemAmount-1)
						If Inventory(e\EventState2)<>Null
							;randomly picked item slot has an item in it, using this slot
							e\EventState3 = 1.0
							DebugLog "pick1"
						Else
							;randomly picked item slot is empty, getting the first available slot
							For i = 0 To MaxItemAmount-1
								Local isSlotEmpty% = (Inventory((i+e\EventState2) Mod MaxItemAmount) = Null)
								
								If (Not isSlotEmpty) Then
									;successful
									e\EventState2 = (i+e\EventState2) Mod MaxItemAmount
								EndIf
								
								If Rand(8)=1 Then
									If isSlotEmpty Then
										e\EventState3 = 3.1
									Else
										e\EventState3 = 3.0
									EndIf
									
									e\EventState = Rand(1,5)
									
									;Checking if the selected nostalgia item already exists or not
									Local itemName$ = ""
									Select (e\EventState)
										Case 1
											itemName = "Lost Key"
										Case 2
											itemName = "Disciplinary Hearing DH-S-4137-17092"
										Case 3
											itemName = "Coin"
										Case 4
											itemName = "Movie Ticket"
										Case 5
											itemName = "Old Badge"
									End Select
									
									Local itemExists% = False
									For it.Items = Each Items
										If (it\name = itemName) Then
											itemExists = True
											e\EventState3 = 1.0
											e\EventState = 0.0
											Exit
										EndIf
									Next
									
									If ((Not itemExists) And (Not isSlotEmpty)) Exit
								Else
									If isSlotEmpty Then
										e\EventState3 = 2.0
									Else
										e\EventState3 = 1.0
										Exit
									EndIf
								EndIf
							Next
						EndIf
					EndIf
					
					
					;trade successful
					If e\EventState3 = 1.0
						Local shouldCreateItem% = False
						
						For itt.ItemTemplates = Each ItemTemplates
							If (IsItemGoodFor1162(itt)) Then
								Select Inventory(e\EventState2)\itemtemplate\tempname
									Case "key"
										If itt\tempname = "key1" Or itt\tempname = "key2" And Rand(2)=1
											shouldCreateItem = True
											DebugLog "lostkey"
										EndIf
									Case "paper","oldpaper"
										If itt\tempname = "paper" And Rand(12)=1 Then
											shouldCreateItem = True
											DebugLog "paper"
										EndIf
									Case "gasmask","gasmask3","supergasmask","hazmatsuit","hazmatsuit2","hazmatsuit3"
										If itt\tempname = "gasmask" Or itt\tempname = "gasmask3" Or itt\tempname = "supergasmask" Or itt\tempname = "hazmatsuit" Or itt\tempname = "hazmatsuit2" Or itt\tempname = "hazmatsuit3" And Rand(2)=1
											shouldCreateItem = True
											DebugLog "gasmask hazmat"
										EndIf
									Case "key1","key2","key3"
										If itt\tempname = "key1" Or itt\tempname = "key2" Or itt\tempname = "key3" Or itt\tempname = "misc" And Rand(6)=1
											shouldCreateItem = True
											DebugLog "key"
										EndIf
									Case "vest","finevest"
										If itt\tempname = "vest" Or itt\tempname = "finevest" And Rand(1)=1
											shouldCreateItem = True
											DebugLog "vest"
										EndIf
									Default
										If itt\tempname = "misc" And Rand(6)=1
											shouldCreateItem = True
											DebugLog "default"
										EndIf
								End Select
							EndIf
							
							If (shouldCreateItem) Then
								RemoveItem(Inventory(e\EventState2))
								it=CreateItem(itt\name,itt\tempname,EntityX(pp,True),EntityY(pp,True),EntityZ(pp,True))
								EntityType(it\collider, HIT_ITEM)
								PlaySound_Strict LoadTempSound("SFX\SCP\1162\Exchange"+Rand(0,4)+".ogg")
								e\EventState3 = 0.0
								
								
								GiveAchievement(Achv1162)
								MouseHit1 = False
								Exit
							EndIf
						Next
					;trade not sucessful (player got in return to injuries a new item)
					ElseIf e\EventState3 = 2.0
						Injuries = Injuries + 5.0
						pvt = CreatePivot()
						PositionEntity pvt, EntityX(Collider),EntityY(Collider)-0.05,EntityZ(Collider)
						TurnEntity pvt, 90, 0, 0
						EntityPick(pvt,0.3)
						de.decals = CreateDecal(3, PickedX(), PickedY()+0.005, PickedZ(), 90, Rand(360), 0)
						de\size = 0.75 : ScaleSprite de\obj, de\size, de\size
						FreeEntity pvt
						For itt.ItemTemplates = Each ItemTemplates
							If IsItemGoodFor1162(itt) And Rand(6)=1
								it = CreateItem(itt\name, itt\tempname, EntityX(pp,True),EntityY(pp,True),EntityZ(pp,True))
								EntityType(it\collider, HIT_ITEM)
								GiveAchievement(Achv1162)
								MouseHit1 = False
								e\EventState3 = 0.0
								If Injuries > 15
									DeathMSG = "A dead Class D subject was discovered within the containment chamber of SCP-1162."
									DeathMSG = DeathMSG + " An autopsy revealed that his right lung was missing, which suggests"
									DeathMSG = DeathMSG + " interaction with SCP-1162."
									PlaySound_Strict LoadTempSound("SFX\SCP\1162\BodyHorrorExchange"+Rand(1,4)+".ogg")
									LightFlash = 5.0
									Kill()
								Else
									PlaySound_Strict LoadTempSound("SFX\SCP\1162\BodyHorrorExchange"+Rand(1,4)+".ogg")
									LightFlash = 5.0
									Msg = "You feel a sudden overwhelming pain in your chest."
									MsgTimer = 70*5
								EndIf
								Exit
							EndIf
						Next
					;trade with nostalgia item
					ElseIf e\EventState3 >= 3.0
						If e\EventState3 < 3.1
							PlaySound_Strict LoadTempSound("SFX\SCP\1162\Exchange"+Rand(0,4)+".ogg")
							RemoveItem(Inventory(e\EventState2))
						Else
							Injuries = Injuries + 5.0
							pvt = CreatePivot()
							PositionEntity pvt, EntityX(Collider),EntityY(Collider)-0.05,EntityZ(Collider)
							TurnEntity pvt, 90, 0, 0
							EntityPick(pvt,0.3)
							de.decals = CreateDecal(3, PickedX(), PickedY()+0.005, PickedZ(), 90, Rand(360), 0)
							de\size = 0.75 : ScaleSprite de\obj, de\size, de\size
							FreeEntity pvt
							If Injuries > 15
								DeathMSG = "A dead Class D subject was discovered within the containment chamber of SCP-1162."
								DeathMSG = DeathMSG + " An autopsy revealed that his right lung was missing, which suggests"
								DeathMSG = DeathMSG + " interaction with SCP-1162."
								PlaySound_Strict LoadTempSound("SFX\SCP\1162\BodyHorrorExchange"+Rand(1,4)+".ogg")
								LightFlash = 5.0
								Kill()
							Else
								PlaySound_Strict LoadTempSound("SFX\SCP\1162\BodyHorrorExchange"+Rand(1,4)+".ogg")
								LightFlash = 5.0
								Msg = "You notice something moving in your pockets and a sudden pain in your chest."
								MsgTimer = 70*5
							EndIf
							e\EventState2 = 0.0
						EndIf
						Select e\EventState
							Case 1
								it = CreateItem("Lost Key","key",EntityX(pp,True),EntityY(pp,True),EntityZ(pp,True))
							Case 2
								it = CreateItem("Disciplinary Hearing DH-S-4137-17092","oldpaper",EntityX(pp,True),EntityY(pp,True),EntityZ(pp,True))
							Case 3
								it = CreateItem("Coin","coin",EntityX(pp,True),EntityY(pp,True),EntityZ(pp,True))
							Case 4
								it = CreateItem("Movie Ticket","ticket",EntityX(pp,True),EntityY(pp,True),EntityZ(pp,True))
							Case 5
								it = CreateItem("Old Badge","badge",EntityX(pp,True),EntityY(pp,True),EntityZ(pp,True))
						End Select
						EntityType(it\collider, HIT_ITEM)
						GiveAchievement(Achv1162)
						MouseHit1 = False
						e\EventState3 = 0.0
					EndIf
					FreeEntity pp
				EndIf
				
			Case "room_gw"
				
				;e\EventState: Determines if the airlock is in operation or not
				;e\EventState2: The timer for the airlocks
				;e\EventState3: Checks if the player had left the airlock or not
				
				e\room\RoomDoors[0]\locked = True
				e\room\RoomDoors[1]\locked = True
				
				Local brokendoor% = False
				If e\room\Objects[1]<>0 Then brokendoor% = True
				
				If PlayerRoom = e\room
					If e\EventState = 0.0
						If EntityDistance(e\room\Objects[0],Collider)<1.4 And e\EventState3 = 0.0
							e\EventState = 1.0
							If brokendoor
								If e\Sound2 <> 0 Then FreeSound_Strict(e\Sound2) : e\Sound2 = 0
								e\Sound2 = LoadSound_Strict("SFX\Door\DoorSparks.ogg")
								e\SoundCHN2 = PlaySound2(e\Sound2,Camera,e\room\Objects[1],5)
							EndIf
							StopChannel e\SoundCHN
							e\SoundCHN = 0
							If e\Sound <> 0 Then FreeSound_Strict(e\Sound) : e\Sound = 0
							e\Sound = LoadSound_Strict("SFX\Door\Airlock.ogg")
							e\room\RoomDoors[0]\locked = False
							e\room\RoomDoors[1]\locked = False
							UseDoor(e\room\RoomDoors[0])
							UseDoor(e\room\RoomDoors[1])
							PlaySound_Strict(AlarmSFX(4))
						ElseIf EntityDistance(e\room\Objects[0],Collider)>2.4
							e\EventState3 = 0.0
						EndIf
					Else
						If e\EventState2 < 70*7
							e\EventState2 = e\EventState2 + FPSfactor
							e\room\RoomDoors[0]\open = False
							e\room\RoomDoors[1]\open = False
							If e\EventState2 < 70*1
								
								If brokendoor
									pvt% = CreatePivot()
									Local d_ent% = e\room\Objects[1]
									PositionEntity(pvt, EntityX(d_ent%,True), EntityY(d_ent%,True)+Rnd(0.0,0.05), EntityZ(d_ent%,True))
									RotateEntity(pvt, 0, EntityYaw(d_ent%,True)+90, 0)
									MoveEntity pvt,0,0,0.2
									
									If ParticleAmount > 0
										For i = 0 To (1+(2*(ParticleAmount-1)))
											p.Particles = CreateParticle(EntityX(pvt), EntityY(pvt), EntityZ(pvt), 7, 0.002, 0, 25)
											p\speed = Rnd(0.01,0.05)
											;RotateEntity(p\pvt, Rnd(-20, 20), Rnd(360), 0)
											RotateEntity(p\pvt, Rnd(-45,0), EntityYaw(pvt)+Rnd(-10.0,10.0), 0)
											
											p\size = 0.0075
											ScaleSprite p\obj,p\size,p\size
											
											;EntityOrder p\obj,-1
											
											p\Achange = -0.05
										Next
									EndIf
									
									FreeEntity pvt
								EndIf
								
							ElseIf e\EventState2 > 70*3 And e\EventState < 70*5.5
								pvt% = CreatePivot(e\room\obj)								
								For i = 0 To 1
									If e\room\RoomTemplate\Name$ = "room3gw"
										If i = 0
											PositionEntity pvt%,-288.0,416.0,320.0,False
										Else
											PositionEntity pvt%,192.0,416.0,320.0,False
										EndIf
									Else
										If i = 0
											PositionEntity pvt%,312.0,416.0,-128.0,False
										Else
											PositionEntity pvt%,312.0,416.0,224.0,False
										EndIf
									EndIf
									
									p.Particles = CreateParticle(EntityX(pvt,True), EntityY(pvt,True), EntityZ(pvt,True),  6, 0.8, 0, 50)
									p\speed = 0.025
									RotateEntity(p\pvt, 90, 0, 0)
									
									p\Achange = -0.02
								Next
								
								FreeEntity pvt
								If e\SoundCHN = 0 Then e\SoundCHN = PlaySound2(e\Sound,Camera,e\room\Objects[0],5)
							EndIf
						Else
							e\EventState = 0.0
							e\EventState2 = 0.0
							e\EventState3 = 1.0
							If e\room\RoomDoors[0]\open = False
								e\room\RoomDoors[0]\locked = False
								e\room\RoomDoors[1]\locked = False
								UseDoor(e\room\RoomDoors[0])
								UseDoor(e\room\RoomDoors[1])
							EndIf
						EndIf
					EndIf
					
					If brokendoor
						If ChannelPlaying(e\SoundCHN2)
							UpdateSoundOrigin(e\SoundCHN2,Camera,e\room\Objects[1],5)
						EndIf
					EndIf
					If ChannelPlaying(e\SoundCHN)
						UpdateSoundOrigin(e\SoundCHN,Camera,e\room\Objects[0],5)
					EndIf
				Else
					e\EventState3 = 0.0
				EndIf
				
			Case "room2sl"
				
				;e\EventState: Determines if the player already entered the room or not (0 = No, 1 = Yes)
				;e\EventState2: Variable used for the SCP-049 event
				;e\EventState3: Checks if Lever is activated or not
				
				;Camera-Spawning Code + SCP-049-Spawning (will now be loaded in the QuickLoadEvents function)
				
				If PlayerRoom = e\room
					If e\EventStr = "" And QuickLoadPercent = -1
						QuickLoadPercent = 0
						QuickLoad_CurrEvent = e
						e\EventStr = 0
					EndIf
				EndIf
				
				
				;SCP-049
				
				If e\EventState = 1
					If e\EventState2 < 0
						If e\EventState2 = -(70*5)
							For sc.SecurityCams = Each SecurityCams
								If sc\room = e\room
									If EntityDistance(sc\ScrObj,Camera)<5.0
										If EntityVisible(sc\ScrObj,Camera)
											e\EventState2 = Min(e\EventState2+FPSfactor,0)
											Exit
										EndIf
									EndIf
								EndIf
							Next
						Else
							e\EventState2 = Min(e\EventState2+FPSfactor,0)
						EndIf
					ElseIf e\EventState2 = 0
						If e\room\NPC[0] <> Null
							;PositionEntity e\room\NPC[0]\Collider,EntityX(e\room\NPC[0]\Collider),EntityY(e\room\Objects[7],True),EntityZ(e\room\NPC[0]\Collider)
							Local AdjDist1# = 0.0
							Local AdjDist2# = 0.0
							Local Adj1% = -1
							Local Adj2% = -1
							For i = 0 To 3
								If e\room\AdjDoor[i]<>Null
									If Adj1 = -1
										AdjDist1# = EntityDistance(e\room\Objects[7],e\room\AdjDoor[i]\frameobj)
										Adj1 = i
									Else
										AdjDist2# = EntityDistance(e\room\Objects[7],e\room\AdjDoor[i]\frameobj)
										Adj2 = i
									EndIf
								EndIf
							Next
							If AdjDist1# > AdjDist2#
								PositionEntity e\room\NPC[0]\Collider,EntityX(e\room\AdjDoor[Adj1]\frameobj),EntityY(e\room\Objects[7],True),EntityZ(e\room\AdjDoor[Adj1]\frameobj)
							Else
								PositionEntity e\room\NPC[0]\Collider,EntityX(e\room\AdjDoor[Adj2]\frameobj),EntityY(e\room\Objects[7],True),EntityZ(e\room\AdjDoor[Adj2]\frameobj)
							EndIf
							PointEntity e\room\NPC[0]\Collider,e\room\obj
							MoveEntity e\room\NPC[0]\Collider,0,0,-1
							ResetEntity e\room\NPC[0]\Collider
							e\room\NPC[0]\HideFromNVG = False
							e\room\NPC[0]\PathX = EntityX(e\room\NPC[0]\Collider)
							e\room\NPC[0]\PathZ = EntityZ(e\room\NPC[0]\Collider)
							e\room\NPC[0]\State = 5
							DebugLog "aaaaaaaaa"
							e\EventState2 = 1
						EndIf
					ElseIf e\EventState2 = 1
						If e\room\NPC[0]\PathStatus <> 1
							e\room\NPC[0]\PathStatus = FindPath(e\room\NPC[0],EntityX(e\room\Objects[15],True),EntityY(e\room\Objects[15],True),EntityZ(e\room\Objects[15],True))
						Else
							DebugLog "bbbbbbbbb"
							e\EventState2 = 2
						EndIf
					ElseIf e\EventState2 = 2
						If e\room\NPC[0]\PathStatus <> 1
							e\room\NPC[0]\State3 = 1.0
							e\EventState2 = 3
							e\room\NPC[0]\PathTimer# = 0.0
							DebugLog "ccccccccc"
						Else
							If EntityDistance(e\room\NPC[0]\Collider,e\room\RoomDoors[0]\frameobj) < 5.0
								e\room\RoomDoors[0]\locked = True
								e\room\RoomDoors[1]\locked = True
								If e\room\NPC[0]\Reload = 0
									PlaySound_Strict LoadTempSound("SFX\Door\DoorOpen079.ogg")
									DebugLog "079 - OPEN DOORS IN ROOM2SL"
									e\room\NPC[0]\Reload = 1
								EndIf
								If (Not e\room\RoomDoors[0]\open)
									e\room\RoomDoors[0]\open = True
									sound=Rand(0, 2)
									PlaySound2(OpenDoorSFX(0,sound),Camera,e\room\RoomDoors[0]\obj)
								EndIf
								If (Not e\room\RoomDoors[1]\open)
									e\room\RoomDoors[1]\open = True
									sound=Rand(0, 2)
									PlaySound2(OpenDoorSFX(0,sound),Camera,e\room\RoomDoors[1]\obj)
								EndIf
							EndIf
							If e\room\NPC[0]\Reload = 1
								e\room\NPC[0]\DropSpeed = 0
							EndIf
						EndIf
						
						If e\room\NPC[0]\State <> 5
							e\EventState2 = 7
							DebugLog "fffffffff"
						EndIf
					ElseIf e\EventState2 = 3
						If e\room\NPC[0]\State <> 5
							e\EventState2 = 7
							DebugLog "fffffffff"
						EndIf
						
						If MeNPCSeesPlayer(e\room\NPC[0],True)=2
							e\EventState2 = 4
							DebugLog "ddddddddd"
						EndIf
						
						If e\room\NPC[0]\PathStatus <> 1
							;If e\room\NPC[0]\PathTimer# < 70*3
							If e\room\NPC[0]\PathTimer# = 0.0
								;e\room\NPC[0]\PathTimer# = e\room\NPC[0]\PathTimer# + FPSfactor
								If e\room\NPC[0]\PrevState = 1 Then
									If (e\room\NPC[0]\SoundChn2 = 0) Then
										e\room\NPC[0]\Sound2 = LoadSound_Strict("SFX\SCP\049\Room2SL1.ogg")
										e\room\NPC[0]\SoundChn2 = PlaySound2(e\room\NPC[0]\Sound2, Camera, e\room\NPC[0]\Collider)
									Else
										If (Not ChannelPlaying(e\room\NPC[0]\SoundChn2))
											e\room\NPC[0]\PathTimer# = 1.0
											e\room\NPC[0]\SoundChn2 = 0
										EndIf
									EndIf
								ElseIf e\room\NPC[0]\PrevState = 2
									If e\room\NPC[0]\State3 = 3 Then
										If (e\room\NPC[0]\SoundChn2 = 0) Then
											e\room\NPC[0]\Sound2 = LoadSound_Strict("SFX\SCP\049\Room2SL2.ogg")
											e\room\NPC[0]\SoundChn2 = PlaySound2(e\room\NPC[0]\Sound2, Camera, e\room\NPC[0]\Collider)
										Else
											If (Not ChannelPlaying(e\room\NPC[0]\SoundChn2))
												e\room\NPC[0]\PathTimer# = 1.0
												e\room\NPC[0]\SoundChn2 = 0
											EndIf
										EndIf
									Else
										If e\room\NPC[0]\Frame >= 1118
											e\room\NPC[0]\PathTimer# = 1.0
										EndIf
									EndIf
								EndIf
							Else
								Select e\room\NPC[0]\State3
									Case 1
										e\room\NPC[0]\PathStatus = FindPath(e\room\NPC[0],EntityX(e\room\Objects[16],True),EntityY(e\room\Objects[16],True),EntityZ(e\room\Objects[16],True))
										e\room\NPC[0]\PrevState = 1
										DebugLog "Path1"
									Case 2
										e\room\NPC[0]\PathStatus = FindPath(e\room\NPC[0],EntityX(e\room\Objects[15],True),EntityY(e\room\Objects[15],True),EntityZ(e\room\Objects[15],True))
										e\room\NPC[0]\PrevState = 2
										DebugLog "Path2"
									Case 3
										e\room\NPC[0]\PathStatus = FindPath(e\room\NPC[0],EntityX(e\room\Objects[17],True),EntityY(e\room\Objects[17],True),EntityZ(e\room\Objects[17],True))
										e\room\NPC[0]\PrevState = 2
										DebugLog "Path3"
									Case 4
										e\room\NPC[0]\PathStatus = FindPath(e\room\NPC[0],e\room\NPC[0]\PathX,0.1,e\room\NPC[0]\PathZ)
										e\room\NPC[0]\PrevState = 2
										DebugLog "Path4"
									Case 5
										e\EventState2 = 5
								End Select
								e\room\NPC[0]\PathTimer# = 0.0
								e\room\NPC[0]\State3 = e\room\NPC[0]\State3 + 1
							EndIf
						EndIf
					ElseIf e\EventState2 = 4
						If e\room\NPC[0]\State <> 5
							e\EventState2 = 7
							e\room\NPC[0]\State3 = 6.0
							DebugLog "fffffffff"
						EndIf
					ElseIf e\EventState2 = 5
						;RemoveNPC(e\room\NPC[0])
						DebugLog "ddddddddd"
						e\room\NPC[0]\State = 2
						For r.Rooms = Each Rooms
							If r <> PlayerRoom
								If (EntityDistance(r\obj,e\room\NPC[0]\Collider)<HideDistance*2 And EntityDistance(r\obj,e\room\NPC[0]\Collider)>HideDistance)
									e\room\NPC[0]\PathStatus = FindPath(e\room\NPC[0],EntityX(r\obj),EntityY(r\obj),EntityZ(r\obj))
									e\room\NPC[0]\PathTimer = 0.0
									If e\room\NPC[0]\PathStatus = 1 Then e\EventState2 = 6
									Exit
								EndIf
							EndIf
						Next
					ElseIf e\EventState2 = 6
						If MeNPCSeesPlayer(e\room\NPC[0],True) Or e\room\NPC[0]\State2 > 0 Or e\room\NPC[0]\LastSeen > 0
							DebugLog "fffffffff"
							e\EventState2 = 7
						Else
							;Still playing the Music for SCP-049 (in the real, SCP-049's State will be set to 2, causing it to stop playing the chasing track)
							If PlayerRoom = e\room Then
								ShouldPlay = 20
							EndIf
							If e\room\NPC[0]\PathStatus<>1
								e\room\NPC[0]\Idle = 70*60 ;(Making SCP-049 idle for one minute (twice as fast for aggressive NPCs = True))
								PositionEntity e\room\NPC[0]\Collider,0,500,0
								ResetEntity e\room\NPC[0]\Collider
								DebugLog "eeeeeeeee"
								e\EventState2 = 7
							EndIf
						EndIf
					;ElseIf e\EventState2 = 7
					;	e\room\RoomDoors[0]\locked = False
					;	e\room\RoomDoors[1]\locked = False
					;	e\EventState2 = 8
					EndIf
					
					If e\room\NPC[0]<>Null
						If e\EventState2 < 7
							If e\EventState2 > 2
								If Abs(EntityY(e\room\RoomDoors[0]\frameobj)-EntityY(e\room\NPC[0]\Collider))>1.0
									If Abs(EntityY(e\room\RoomDoors[0]\frameobj)-EntityY(Collider))<1.0
										If e\room\RoomDoors[0]\open
											e\room\RoomDoors[0]\open = False
											e\room\RoomDoors[0]\fastopen = 1
											PlaySound_Strict LoadTempSound("SFX\Door\DoorClose079.ogg")
											DebugLog "079 - CLOSE DOOR AT HALLWAY IN ROOM2SL"
										EndIf
									EndIf
								Else
									If e\room\RoomDoors[0]\open = False
										e\room\RoomDoors[0]\fastopen = 0
										e\room\RoomDoors[0]\open = True
										sound=Rand(0, 2)
										PlaySound2(OpenDoorSFX(0,sound),Camera,e\room\RoomDoors[0]\obj)
										PlaySound_Strict LoadTempSound("SFX\Door\DoorOpen079.ogg")
										DebugLog "079 - OPEN DOOR AT HALLWAY IN ROOM2SL"
									EndIf
								EndIf
							EndIf
							
							;If e\EventState2 > 0 Then CanSave% = False
						Else
							If e\room\RoomDoors[0]\open = False
								e\room\RoomDoors[0]\fastopen = 0
								e\room\RoomDoors[0]\open = True
								sound=Rand(0, 2)
								PlaySound2(OpenDoorSFX(0,sound),Camera,e\room\RoomDoors[0]\obj)
								PlaySound_Strict LoadTempSound("SFX\Door\DoorOpen079.ogg")
								DebugLog "079 - OPEN DOOR AT HALLWAY IN ROOM2SL"
							EndIf
						EndIf
					EndIf
				EndIf
				
				
				;Other code
				
				If PlayerRoom = e\room Then
					;Lever for checkpoint locking (might have a function in the future for the case if the checkpoint needs to be locked again)
					e\EventState3 = UpdateLever(e\room\Levers[0])
					If e\EventState3 = 1 Then
						UpdateCheckpointMonitors(0)
						If MonitorTimer# < 50 Then
							EntityTexture e\room\Objects[20],e\room\Textures[0],1
						Else
							EntityTexture e\room\Objects[20],e\room\Textures[0],2
						EndIf
					Else
						TurnCheckpointMonitorsOff(0)
						EntityTexture e\room\Objects[20],e\room\Textures[0],0
					EndIf
					
					;Checking if the monitors and such should be rendered or not
					If Abs(EntityY(e\room\RoomDoors[0]\frameobj)-EntityY(Collider))>1.0 Then
						For i = 0 To 14
							If e\room\Objects[i]<>0 And i<>7 Then
								ShowEntity e\room\Objects[i]
							EndIf
						Next
						For sc.SecurityCams = Each SecurityCams
							If sc\room = e\room Then
								If sc\ScrObj<>0
									ShowEntity sc\ScrObj
								EndIf
								If sc\ScrOverlay<>0
									ShowEntity sc\ScrOverlay
								EndIf
								Exit
							EndIf
						Next
						For i = 0 To 3
							If PlayerRoom\Adjacent[i]<>Null Then
								EntityAlpha(GetChild(PlayerRoom\Adjacent[i]\obj,2),0)
							EndIf
						Next
					Else
						For i = 0 To 14
							If e\room\Objects[i]<>0 And i<>7 Then
								HideEntity e\room\Objects[i]
							EndIf
						Next
						For sc.SecurityCams = Each SecurityCams
							If sc\room = e\room Then
								If sc\ScrObj<>0
									HideEntity sc\ScrObj
								EndIf
								If sc\ScrOverlay<>0
									HideEntity sc\ScrOverlay
								EndIf
								Exit
							EndIf
						Next
					EndIf
				EndIf
				
				For e2.Events = Each Events
					If e2\EventName = "008"
						If e2\EventState = 2
							EntityTexture e\room\Objects[21],e\room\Textures[0],3
						Else
							EntityTexture e\room\Objects[21],e\room\Textures[1],6
						EndIf
					EndIf
				Next
				
				
				
			Case "096spawn"
				
				Local xspawn#,zspawn#,place%
				If e\room\dist < HideDistance
					;Checking some statements in order to determine if SCP-096 can spawn in this room
					
					If e\EventState <> 2
						If Curr096<>Null
							If EntityDistance(Curr096\Collider,Collider)<40
								e\EventState = 2
								DebugLog "Failed to spawn SCP-096 in room "+e\room\RoomTemplate\Name$
								DebugLog "- SCP-096 too close to player"
							EndIf
							
							For e2.Events = Each Events
								If e2\EventName = "room2servers"
									If e2\EventState > 0 And e2\room\NPC[0]<>Null
										e\EventState = 2
										DebugLog "Failed to spawn SCP-096 in room "+e\room\RoomTemplate\Name$
										DebugLog "- room2servers event still in progress"
										Exit
									EndIf
								EndIf
							Next
							
							For r.Rooms = Each Rooms
   								If r\RoomTemplate\Name = "checkpoint1"
									If r\dist < 10
										e\EventState = 2
										DebugLog "Failed to spawn SCP-096 in room "+e\room\RoomTemplate\Name$
										DebugLog "- too close to checkpoint1"
										Exit
									EndIf
								EndIf
							Next
							
							If Curr096\State <> 5
								e\EventState = 2
								DebugLog "Failed to spawn SCP-096 in room "+e\room\RoomTemplate\Name$
								DebugLog "- SCP-096 enraged"
							EndIf
							
							If EntityDistance(Curr096\Collider,e\room\obj)>EntityDistance(Curr096\Collider,Collider)
								e\EventState = 2
								DebugLog "Failed to spawn SCP-096 in room "+e\room\RoomTemplate\Name$
								DebugLog "- Room is too far away"
							EndIf
						EndIf
						For e2.Events = Each Events
							If e2\EventName = "room2servers"
								If e2\EventState = 0 ;And (Abs(e2\room\dist-e\room\dist)<HideDistance)
									e\EventState = 2
									DebugLog "Failed to spawn SCP-096 in room "+e\room\RoomTemplate\Name$
									DebugLog "- room2servers event not activated + room is too close to room2servers"
									Exit
								EndIf
							EndIf
						Next
						If PlayerRoom = e\room Then e\EventState = 2
					EndIf
					
					
					
					If e\EventState = 0
						Select e\room\RoomTemplate\Name
							Case "room4pit","room3pit","room3z2","room4tunnels","room3tunnel"
								If e\room\RoomTemplate\Name$ = "room4pit" Or e\room\RoomTemplate\Name$ = "room4tunnels"
									place% = Rand(0,3)
								Else
									place% = Rand(0,2)
								EndIf
								
								If place% = 0
									xspawn# = -608.0
									zspawn# = 0.0
								ElseIf place% = 1
									xspawn# = 0.0
									zspawn# = -608.0
								ElseIf place% = 2
									xspawn# = 608.0
									zspawn# = 0.0
								Else
									xspawn# = 0.0
									zspawn# = 608.0
								EndIf
							Default
								xspawn# = Rnd(-100,100)
								zspawn# = Rnd(-100,100)
						End Select
						pvt% = CreatePivot(e\room\obj)
						PositionEntity pvt%,xspawn#,0,zspawn#
						If Curr096 = Null
							Curr096 = CreateNPC(NPCtype096,EntityX(pvt%,True),e\room\y+0.5,EntityZ(pvt%,True))
							DebugLog EntityY(Curr096\Collider)
						Else
							PositionEntity Curr096\Collider,EntityX(pvt%,True),e\room\y+0.5,EntityZ(pvt%,True)
							ResetEntity Curr096\Collider
						EndIf
						PointEntity Curr096\Collider,Collider
						RotateEntity Curr096\Collider,0,EntityYaw(Curr096\Collider)+180,0
						FreeEntity pvt%
						Curr096\State = 5
						
						DebugLog "SCP-096 successfully placed in "+Chr(34)+e\room\RoomTemplate\Name+Chr(34)
						e\EventState = 1
					ElseIf e\EventState = 1
						PointEntity Curr096\Collider,Collider
						RotateEntity Curr096\Collider,0,EntityYaw(Curr096\Collider)+180,0
						
						If EntityDistance(Curr096\Collider,Collider)<HideDistance*0.5
							If EntityVisible(Curr096\Collider,Camera)
								PointEntity Curr096\Collider,Collider
								RotateEntity Curr096\Collider,0,EntityYaw(Curr096\Collider)+Rnd(170,190),0
								e\EventState = 2
							EndIf
						EndIf
					ElseIf e\EventState = 3
						e\EventState = 2
					EndIf
				Else
					If e\EventState = 2
						If Rand(-1,1+(2*SelectedDifficulty\aggressiveNPCs))>0 Then
							e\EventState = 0
						Else
							e\EventState = 3
						EndIf
					EndIf
				EndIf
				
			Case "medibay"
				
				;e\EventState: Determines if the player has entered the room or not
				;	- 0 : Not entered
				;	- 1 : Has entered
				;e\EventState2: A timer for the zombie wake up
				
				;Hiding/Showing the props in this room
				If PlayerRoom <> e\room
					HideEntity e\room\Objects[0]
				Else
					ShowEntity e\room\Objects[0]
					;Setup
					If e\EventState = 0
						e\room\NPC[0] = CreateNPC(NPCtype008,EntityX(e\room\Objects[3],True),0.5,EntityZ(e\room\Objects[3],True))
						RotateEntity e\room\NPC[0]\Collider,0,e\room\angle-90,0
						e\EventState = 1
					EndIf
					
					If EntityDistance(e\room\NPC[0]\Collider,Collider)<1.2
						If e\EventState2 = 0
							LightBlink = 12.0
							PlaySound_Strict LightSFX
							e\EventState2 = FPSfactor
						EndIf
					EndIf
				EndIf
				
				If e\EventState2 > 0 And e\EventState2 < 70*4
					e\EventState2 = e\EventState2 + FPSfactor
				ElseIf e\EventState2 >= 70*4
					If e\room\NPC[0]\State = 0
						e\room\NPC[0]\State = 2
					EndIf
				EndIf
				
			Case "dimension1499"
				
				If PlayerRoom<>e\room
					If e\room\Objects[0]<>0
						For i = 1 To 15
							HideEntity e\room\Objects[i]
						Next
					EndIf
					If EntityY(Collider)>EntityY(e\room\obj)-0.5
						PlayerRoom = e\room
					EndIf
				EndIf
				If e\EventState = 2.0
					If e\SoundCHN<>0 Then
						StopStream_Strict(e\SoundCHN)
						StopChannel(e\SoundCHN2)
						e\SoundCHN = 0
						e\SoundCHN2 = 0
					EndIf
					HideEntity NTF_1499Sky
					HideChunks()
					For n.NPCs = Each NPCs
						If n\NPCtype = NPCtype1499
							RemoveNPC(n)
							;n\Idle = True
						EndIf
					Next
					For du.Dummy1499 = Each Dummy1499
						FreeEntity(du\obj)
						Delete du
					Next
					If e\EventState3 < 70*30 Then
						e\EventState3 = 0.0
					EndIf
					e\EventState = 1.0
					If e\Sound2 <> 0 Then
						FreeSound_Strict e\Sound2
						e\Sound2 = 0
					EndIf
				EndIf
				
			Case "room2offices035"
				
				Local is035released = False
				
				For e2.Events = Each Events
					If e2<>e And e2\EventName="room035"
						If e2\EventState<0.0
							is035released=True
							Exit
						EndIf
					EndIf
				Next
				
				If is035released
					If e\room\dist < 8
						If e\room\NPC[0]=Null
							e\room\NPC[0]=CreateNPC(NPCtypeD,e\room\x,0.5,e\room\z)
							RotateEntity e\room\NPC[0]\Collider,0,e\room\angle+180,0
							MoveEntity e\room\NPC[0]\Collider,0,0,-0.5
							e\room\NPC[0]\State = 3
							e\room\NPC[0]\texture = "GFX\npcs\035victim.jpg"
							ChangeNPCTextureID(e\room\NPC[0],7)
							SetNPCFrame(e\room\NPC[0],19)
						EndIf
						If e\room\NPC[1]=Null
							If EntityDistance(e\room\NPC[0]\Collider,Collider)<2.5
								e\room\NPC[1]=CreateNPC(NPCtypeTentacle,EntityX(e\room\NPC[0]\Collider),0.0,EntityZ(e\room\NPC[0]\Collider))
								RotateEntity e\room\NPC[1]\Collider,0,e\room\angle,0
								MoveEntity e\room\NPC[1]\Collider,0,0,0.6
							EndIf
						EndIf
					Else
						If e\room\dist>HideDistance
							If e\room\NPC[1]<>Null
								RemoveNPC(e\room\NPC[1])
								e\room\NPC[1]=Null
							EndIf
						EndIf
					EndIf
				EndIf
				
			Case "room1archive"
				
				If e\EventState = 0
					e\EventState = Rand(1,3)
				Else
					e\room\RoomDoors[0]\KeyCard = e\EventState
				EndIf
				
			Case "room2shaft"
                
                If e\EventState = 0 Then
                    e\room\NPC[0]=CreateNPC(NPCtypeGuard, EntityX(e\room\Objects[1],True), EntityY(e\room\Objects[1],True)+0.5, EntityZ(e\room\Objects[1],True))
                    RotateEntity e\room\NPC[0]\Collider, 0, e\room\angle+180,0, True
					
                    SetNPCFrame (e\room\NPC[0], 286)
                    e\room\NPC[0]\State = 8
                    
                    e\EventState = 1
                EndIf
				
				If PlayerRoom=e\room Then
					UpdateButton(e\room\Objects[2])
					If ClosestButton = e\room\Objects[2] And MouseHit1 Then
						Msg = "The elevator appears to be broken."
						PlaySound2(ButtonSFX2, Camera, e\room\Objects[2])
						MsgTimer = 5*70
						MouseHit1=0
					EndIf
				EndIf
                
			Case "room1lifts"
				
				If PlayerRoom=e\room Then
					For i = 0 To 1
						UpdateButton(e\room\Objects[i])
						If ClosestButton = e\room\Objects[i] And MouseHit1 Then
							Msg = "The elevator appears to be broken."
							PlaySound2(ButtonSFX2, Camera, e\room\Objects[i])
							MsgTimer = 5*70
							MouseHit1=0
						EndIf
					Next
				EndIf
				
		End Select
		
		If e<>Null Then
			CatchErrors(Chr(34)+e\EventName+Chr(34)+" event")
		Else
			CatchErrors("Deleted event")
		EndIf
	Next
	
	;This here is necessary because the 294 drinks with explosion effect didn't worked anymore - ENDSHN
	If ExplosionTimer > 0 Then
		ExplosionTimer = ExplosionTimer+FPSfactor
		
		If ExplosionTimer < 140.0 Then
			If ExplosionTimer-FPSfactor < 5.0 Then
				ExplosionSFX = LoadSound_Strict("SFX\Ending\GateB\Nuke1.ogg")
				PlaySound_Strict ExplosionSFX
				CameraShake = 10.0
				ExplosionTimer = 5.0
			EndIf
			
			CameraShake = CurveValue(ExplosionTimer/60.0,CameraShake, 50.0)
		Else
			CameraShake = Min((ExplosionTimer/20.0),20.0)
			If ExplosionTimer-FPSfactor < 140.0 Then
				BlinkTimer = 1.0
				ExplosionSFX = LoadSound_Strict("SFX\Ending\GateB\Nuke2.ogg")
				PlaySound_Strict ExplosionSFX				
				For i = 0 To (10+(10*(ParticleAmount+1)))
					p.Particles = CreateParticle(EntityX(Collider)+Rnd(-0.5,0.5),EntityY(Collider)-Rnd(0.2,1.5),EntityZ(Collider)+Rnd(-0.5,0.5),0, Rnd(0.2,0.6), 0.0, 350)	
					RotateEntity p\pvt,-90,0,0,True
					p\speed = Rnd(0.05,0.07)
				Next
			EndIf
			LightFlash = Min((ExplosionTimer-140.0)/10.0,5.0)
			
			If ExplosionTimer > 160 Then KillTimer = Min(KillTimer,-0.1)
			If ExplosionTimer > 500 Then ExplosionTimer = 0
			
			;a dirty workaround to prevent the collider from falling down into the facility once the nuke goes off,
			;causing the UpdateEvent function to be called again and crashing the game
			PositionEntity Collider, EntityX(Collider), 200, EntityZ(Collider)
		EndIf
	EndIf
	
}

function UpdateDimension1499() {
	Local e.Events,n.NPCs,n2.NPCs,r.Rooms,it.Items,i%,j%,du.Dummy1499,du2.Dummy1499,temp%,scale#,x%,y%
	
	For e.Events = Each Events
		If e\EventName = "dimension1499"
			
			;e\EventState: If player entered dimension (will be resetted after the player leaves it)
				;0: The player never entered SCP-1499
				;1: The player had already entered the dimension at least once
				;2: The player is in dimension
			;e\EventState2: Used to count the amount of times the player has entered the 1499 dimension (for a little spawning event)
			;e\EventState3: Variable used for the 1499 church event
			If PlayerRoom = e\room Then
				If e\EventState < 2.0
					;1499 random generator
					
					If e\EventState = 0.0
						If e\EventStr = "" And QuickLoadPercent = -1
							QuickLoadPercent = 0
							QuickLoad_CurrEvent = e
							e\EventStr = "load0"
						EndIf
					Else
						e\EventState = 2.0
					EndIf
					
					;For n.NPCs = Each NPCs
					;	If n\NPCtype = NPCtype1499
					;		n\Idle = False
					;		n\State = 0
					;		;If Rand(2)=1 Then n\State2 = 500*3
					;		n\Angle = Rnd(360)
					;		PositionEntity n\Collider,EntityX(n\Collider)+Rnd(-60.0,60.0),EntityY(n\Collider)+0.05,EntityZ(n\Collider)+Rnd(-60.0,60.0)
					;		ResetEntity n\Collider
					;	EndIf
					;Next
					Local value% = Rand(2,3)
					If e\EventState2 = value% Or e\EventState2=4 Then
						For i = -1 To 1
							For j = -1 To 1
								If i<>0 And j<>0 Then
									n.NPCs = CreateNPC(NPCtype1499,EntityX(Collider)+(0.75*i),EntityY(Collider)+0.05,EntityZ(Collider)+(0.75*j))
									PointEntity n\Collider,Collider
									RotateEntity n\Collider,0,EntityYaw(n\Collider),0
									n\State = 2
								ElseIf i<>0 Or j<>0 Then
									n.NPCs = CreateNPC(NPCtype1499,EntityX(Collider)+i,EntityY(Collider)+0.05,EntityZ(Collider)+j)
									PointEntity n\Collider,Collider
									RotateEntity n\Collider,0,EntityYaw(n\Collider),0
									n\State = 2
								EndIf
							Next
						Next
						e\EventState2 = 5
					EndIf
					If e\EventState3 < 70*30 Then
						;Guards at the entrance to church
						n.NPCs = CreateNPC(NPCtype1499,e\room\x+4055.0*RoomScale,e\room\y+240.0*RoomScale,e\room\z+1884.0*RoomScale)
						n\PrevState = 3
						n\Angle = 270
						RotateEntity n\Collider,0,n\Angle,0
						n2.NPCs = CreateNPC(NPCtype1499,e\room\x+4055.0*RoomScale,e\room\y+240.0*RoomScale,e\room\z+2876.0*RoomScale)
						n2\PrevState = 3
						n2\Angle = 270
						RotateEntity n2\Collider,0,n2\Angle,0
						n\Target = n2
						n2\Target = n
						e\room\NPC[2] = n
						e\room\NPC[3] = n2
						;More guards
						n.NPCs = CreateNPC(NPCtype1499,e\room\x-1877.0*RoomScale,e\room\y+192.0*RoomScale,e\room\z+1071.0*RoomScale)
						n\PrevState = 3
						n\Angle = 270
						RotateEntity n\Collider,0,n\Angle,0
						n2.NPCs = CreateNPC(NPCtype1499,e\room\x-1877.0*RoomScale,e\room\y+192.0*RoomScale,e\room\z+3503.0*RoomScale)
						n2\PrevState = 3
						n2\Angle = 270
						RotateEntity n2\Collider,0,n2\Angle,0
						n\Target = n2
						n2\Target = n
						e\room\NPC[4] = n
						e\room\NPC[5] = n2
						;Guard at stairs
						n.NPCs = CreateNPC(NPCtype1499,e\room\x-2761.0*RoomScale,e\room\y+240.0*RoomScale,e\room\z+3204.0*RoomScale)
						n\PrevState = 1
						n\Angle = 180
						RotateEntity n\Collider,0,n\Angle,0
						n\Speed = 0.0
						;King
						n.NPCs = CreateNPC(NPCtype1499,e\room\x-1917.0*RoomScale,e\room\y+1904.0*RoomScale,e\room\z+2308.0*RoomScale)
						n\PrevState = 2
						n\Angle = 270
						RotateEntity n\Collider,0,n\Angle,0
						tex = LoadTexture_Strict("GFX\npcs\1499_King.jpg")
						EntityTexture n\obj,tex
						FreeTexture tex
						e\room\NPC[0] = n
						;Guard next to king
						n.NPCs = CreateNPC(NPCtype1499,e\room\x-1917.0*RoomScale,e\room\y+1904.0*RoomScale,e\room\z+2052.0*RoomScale)
						n\PrevState = 1
						n\Angle = 270
						RotateEntity n\Collider,0,n\Angle,0
						e\room\NPC[1] = n
						;1499-1 instances praying in church
						;Zone 1
						For x=0 To 7
							For y=0 To 2
								du = New Dummy1499
								For n.NPCs = Each NPCs
									If n\NPCtype = NPCtype1499 And n\PrevState<>2 Then
										du\obj = CopyEntity(n\obj)
										Exit
									EndIf
								Next
								scale# = (GetINIFloat("DATA\NPCs.ini", "SCP-1499-1", "scale") / 4.0) * Rnd(0.8,1.0)
								ScaleEntity du\obj, scale#,scale#,scale#
								EntityFX du\obj,1
								du\anim = Rand(0,1)
								;2560=x		768=z
								;1687.0
								PositionEntity du\obj,Max(Min((e\room\x+(1887.0-((2560.0/7.0)*x))*RoomScale)+Rnd(-0.5,0.5),e\room\x+1887.0*RoomScale),e\room\x-873.0*RoomScale),e\room\y,Max(Min((e\room\z+(1796.0-(384.0*y))*RoomScale)+Rnd(-0.5,0.5),e\room\z+1796.0*RoomScale),e\room\z+1028.0*RoomScale)
								RotateEntity du\obj,0,270,0
								EntityAutoFade du\obj,25,39
							Next
						Next
						;Zone 2
						For x=0 To 6
							For y=0 To 2
								du = New Dummy1499
								For n.NPCs = Each NPCs
									If n\NPCtype = NPCtype1499 And n\PrevState<>2 Then
										du\obj = CopyEntity(n\obj)
										Exit
									EndIf
								Next
								scale# = (GetINIFloat("DATA\NPCs.ini", "SCP-1499-1", "scale") / 4.0) * Rnd(0.8,1.0)
								ScaleEntity du\obj, scale#,scale#,scale#
								EntityFX du\obj,1
								du\anim = Rand(0,1)
								;2048=x		768=z
								;1175.0
								PositionEntity du\obj,Max(Min((e\room\x+(1375.0-((2048.0/6.0)*x))*RoomScale)+Rnd(-0.5,0.5),e\room\x+1375.0*RoomScale),e\room\x-873.0*RoomScale),e\room\y,Max(Min((e\room\z+(3588-(384.0*y))*RoomScale)+Rnd(-0.5,0.5),e\room\z+3588.0*RoomScale),e\room\z+2820.0*RoomScale)
								RotateEntity du\obj,0,270,0
								EntityAutoFade du\obj,25,39
							Next
						Next
						;4055, 240, 2084
						;4055, 240, 3076
						;-2761, 240, 3204 for stairs guard
						;-1449, 240, 1092
						;-1449, 240, 3524
						;-1917, 1904, 2052 - guard
						;-1917, 1904, 2308 - king
						
						;1687, 240, 1028
						;1687, 240, 1796
						;-873, 240, 1796
						;-873, 240, 1028
						;that's the First zone
						;1175, 240, 2820
						;1175, 240, 3588
						;-873, 240, 3588
						;-873, 240, 2820
						;that's For second zone
					Else
						HideEntity e\room\Levers[1]
					EndIf
					
					For i = 0 To 14
						n.NPCs = CreateNPC(NPCtype1499,EntityX(Collider)+Rnd(-20,20),EntityY(Collider)+0.1,EntityZ(Collider)+Rnd(-20,20))
						If Rand(2)=1 Then n\State2 = 500*3
						n\Angle = Rnd(360)
						n\State2 = 0
						If EntityDistance(n\Collider,Collider)<10.0 Then
							n\State = 2
						EndIf
					Next
				EndIf
				
				;PositionEntity e\room\Objects[0],0,800,0
				If (Not DebugHUD)
					CameraFogRange Camera,40,80
					CameraFogColor Camera,96,97,104
					CameraClsColor Camera,96,97,104
					CameraRange Camera,0.05,90
				Else
					CameraFogRange Camera,120,120
					CameraFogColor Camera,96,97,104
					CameraClsColor Camera,96,97,104
					CameraRange Camera,0.05,120
				EndIf
				
				For r.Rooms = Each Rooms
					HideEntity r\obj
				Next
				ShowEntity e\room\obj
				If QuickLoadPercent = 100 Or QuickLoadPercent = -1
					UpdateChunks(e\room,15)
					ShowEntity NTF_1499Sky
					Update1499Sky()
					ShouldPlay = 18
					If EntityY(Collider)<800.0
						PositionEntity Collider,EntityX(Collider),800.5,EntityZ(Collider),True
						ResetEntity Collider
					EndIf
					;A hacky fix to make items not fall that are in dimension1499
					For it.Items = Each Items
						If EntityY(it\collider)>750.0
							If EntityY(it\collider)<800.0
								PositionEntity it\collider,EntityX(it\collider),800.5,EntityZ(it\collider)
								ResetEntity it\collider
							EndIf
						EndIf
					Next
					For du = Each Dummy1499
						If e\EventState3 < 70*30 Then
							If du\anim=0 Then
								;321-361
								If AnimTime(du\obj)<=360.5 Then
									Animate2(du\obj,AnimTime(du\obj),321,361,0.2,False)
								;362-402
								ElseIf AnimTime(du\obj)>361.5 And AnimTime(du\obj)<=401.5 Then
									Animate2(du\obj,AnimTime(du\obj),362,402,0.2,False)
								Else
									temp = Rand(0,1)
									If temp=0 Then
										SetAnimTime(du\obj,321)
									Else
										SetAnimTime(du\obj,362)
									EndIf
								EndIf
							Else
								;413-453
								If AnimTime(du\obj)<=452.5 Then
									Animate2(du\obj,AnimTime(du\obj),413,453,0.2,False)
								;454-498
								ElseIf AnimTime(du\obj)>453.5 And AnimTime(du\obj)<=497.5 Then
									Animate2(du\obj,AnimTime(du\obj),454,498,0.2,False)
								Else
									temp = Rand(0,1)
									If temp=0 Then
										SetAnimTime(du\obj,413)
									Else
										SetAnimTime(du\obj,454)
									EndIf
								EndIf
							EndIf
						Else
							If du\anim=0 Then
								If AnimTime(du\obj)<=411.5 And AnimTime(du\obj)>320.5 Then
									Animate2(du\obj,AnimTime(du\obj),403,412,0.2,False)
								Else
									Animate2(du\obj,AnimTime(du\obj),296,320,0.2,True)
								EndIf
							Else
								If AnimTime(du\obj)<=507.5 And AnimTime(du\obj)>320.5 Then
									Animate2(du\obj,AnimTime(du\obj),499,508,0.2,False)
								Else
									Animate2(du\obj,AnimTime(du\obj),296,320,0.2,True)
								EndIf
							EndIf
							Local pvt = CreatePivot()
							PositionEntity pvt,EntityX(du\obj),EntityY(du\obj),EntityZ(du\obj),True
							PointEntity pvt,Collider
							RotateEntity du\obj,0,CurveAngle(EntityYaw(pvt),EntityYaw(du\obj)-180,10.0)+180,0
							FreeEntity pvt
						EndIf
					Next
					;-56,0,2287
					;X distance: 2160
					;Z distance: 1408
					
					;Player is inside the church
					If e\EventState3 < 70*10 Then
						If Abs(EntityX(Collider)-(e\room\x-56.0*RoomScale))<2160.0*RoomScale Then
							If Abs(EntityZ(Collider)-(e\room\z+2287.0*RoomScale))<1408.0*RoomScale Then
								e\EventState3 = e\EventState3 + FPSfactor
								;CurrMusicVolume = 1.0
							EndIf
						EndIf
					ElseIf e\EventState3 >= 70*10 And e\EventState3 < 70*20 Then
						For i = 0 To 1
							e\room\NPC[i]\Reload = 1
						Next
						e\EventState3 = 70*20
					ElseIf e\EventState3 = 70*20
						If e\room\NPC[0]\Frame > 854.5 Then
							For i = 2 To 5
								If i = 2
									If e\room\NPC[i]\Sound <> 0 Then FreeSound_Strict e\room\NPC[i]\Sound : e\room\NPC[i]\Sound = 0
									e\room\NPC[i]\Sound = LoadSound_Strict("SFX\SCP\1499\Triggered.ogg")
									e\room\NPC[i]\SoundChn = PlaySound2(e\room\NPC[i]\Sound, Camera, e\room\NPC[i]\Collider,50.0)
								EndIf
								e\room\NPC[i]\State = 1
								e\room\NPC[i]\Frame = 203
							Next
							e\EventState3 = 70*30
						EndIf
					EndIf
					
					;If Abs(EntityX(Collider)-(e\room\x-56.0*RoomScale))<2160.0*RoomScale Then
					;	If Abs(EntityZ(Collider)-(e\room\z+2287.0*RoomScale))<1408.0*RoomScale Then
					;		ShouldPlay = 66
					;	EndIf
					;EndIf
					
					If e\room\NPC[0]<>Null Then
						ShowEntity e\room\Levers[1]
						If e\EventState3 < 70*30 Then
							ShouldPlay = 66
							If NowPlaying = 66 Then
								If e\SoundCHN = 0 Then
									e\Sound2 = LoadSound_Strict("SFX\Music\HaveMercyOnMe(Choir).ogg")
									e\SoundCHN = StreamSound_Strict("SFX\Music\HaveMercyOnMe(NoChoir).ogg",MusicVolume)
									e\SoundCHN_isStream = True
								EndIf
								;If e\SoundCHN2<>0 Then
								;	UpdateStreamSoundOrigin(e\SoundCHN2,Camera,e\room\Levers[0])
								;EndIf
							EndIf
							If e\Sound2<>0 Then
								e\SoundCHN2 = LoopSound2(e\Sound2,e\SoundCHN2,Camera,e\room\Levers[0],10,MusicVolume)
							EndIf
						Else
							ShouldPlay = 19
							If e\SoundCHN<>0 Then
								StopStream_Strict(e\SoundCHN)
								StopChannel(e\SoundCHN2)
								e\SoundCHN = 0
								e\SoundCHN2 = 0
							EndIf
							If e\Sound2 <> 0 Then
								FreeSound_Strict e\Sound2
								e\Sound2 = 0
							EndIf
						EndIf
					EndIf
					
					If EntityDistance(Collider,e\room\obj)>40.0
						For du.Dummy1499 = Each Dummy1499
							HideEntity du\obj
						Next
					Else
						For du.Dummy1499 = Each Dummy1499
							ShowEntity du\obj
						Next
					EndIf
				Else
					DropSpeed = 0
				EndIf
				CurrStepSFX=3
				PlayerFallingPickDistance = 0.0
			Else
				If e\EventState = 2.0
					If e\SoundCHN<>0 Then
						StopStream_Strict(e\SoundCHN)
						StopChannel(e\SoundCHN2)
						e\SoundCHN = 0
						e\SoundCHN2 = 0
					EndIf
					HideEntity NTF_1499Sky
					HideChunks()
					For n.NPCs = Each NPCs
						If n\NPCtype = NPCtype1499
							RemoveNPC(n)
							;n\Idle = True
						EndIf
					Next
					For du.Dummy1499 = Each Dummy1499
						FreeEntity du\obj
						Delete du
					Next
					If e\EventState3 < 70*30 Then
						e\EventState3 = 0.0
					EndIf
					e\EventState = 1.0
					If e\Sound2 <> 0 Then
						FreeSound_Strict e\Sound2
						e\Sound2 = 0
					EndIf
				EndIf
			EndIf
			
		EndIf
	Next
	
}

function UpdateEndings() {
	Local e.Events,n.NPCs,r.Rooms,i,pvt,p.Particles
	
	For e.Events = Each Events
		Select e\EventName
			Case "exit1"
				
				If PlayerRoom = e\room Then
					
					If EntityY(Collider)>1040.0*RoomScale Then
						
						;For r.Rooms = Each Rooms
						;	HideEntity r\obj
						;Next					
						ShowEntity e\room\obj
						
						;Curr106\State = 20000
						;Curr106\Idle = True
						
						If e\EventState = 0 Then
							DrawLoading(0,True)
							
							For i = 0 To MaxRoomLights-1
								If e\room\LightSprites[i]<>0 Then 
									EntityFX e\room\LightSprites[i], 1+8
								EndIf
							Next
							
							For n.NPCs = Each NPCs
								RemoveNPC(n)
							Next
							Curr173 = Null
							Curr106 = Null
							Curr096 = Null
							Curr5131 = Null
							
							CameraFogMode(Camera, 0)
							SecondaryLightOn = True
							
							;Music(5) = LoadSound_Strict("SFX\Music\GateB1.ogg")
							DrawLoading(60,True)
							;Music(6) = LoadSound_Strict("SFX\Music\GateB2.ogg")
							DrawLoading(90,True)
							
							e\room\NPC[0] = CreateNPC(NPCtypeApache, e\room\x, 100.0, e\room\z)
							e\room\NPC[0]\State = 1
							
							e\room\NPC[1] = CreateNPC(NPCtypeGuard, EntityX(e\room\Objects[4],True),EntityY(e\room\Objects[4],True)+0.2,EntityZ(e\room\Objects[4],True))
							e\room\NPC[1]\State = 0
							e\room\NPC[1]\State2 = 10
							
							
							pvt = CreatePivot()
							PositionEntity pvt, EntityX(e\room\Objects[0],True), EntityY(e\room\Objects[0],True), EntityZ(e\room\Objects[0],True)
							
							e\room\Objects[0] = LoadMesh_Strict("GFX\map\exit1terrain.b3d", e\room\obj)
							ScaleEntity e\room\Objects[0],RoomScale,RoomScale,RoomScale,True
							RotateEntity e\room\Objects[0],0,e\room\angle,0,True
							PositionEntity(e\room\Objects[0], EntityX(pvt), EntityY(pvt), EntityZ(pvt), True)
							
							FreeEntity pvt
							
							Delay 100
							
							Sky = sky_CreateSky("GFX\map\sky\sky")
							RotateEntity Sky,0,e\room\angle-90,0
							
							e\EventState = 1.0
							
							For n.NPCs = Each NPCs
								If n\NPCtype = NPCtypeMTF
									RemoveNPC(n)
								EndIf
							Next
							
							DrawLoading(100,True)
						Else
							
							UpdateSky()
							
							If e\EventState < 2.0 And SelectedEnding = "" Then 
								If e\room\NPC[0]\State = 2 Then
									ShouldPlay = 6
								Else
									e\EventState2=(e\EventState2+FPSfactor) Mod 3600
									PositionEntity(e\room\NPC[0]\Collider, EntityX(e\room\obj,True)+Cos(e\EventState2/10)*6000.0*RoomScale,14000*RoomScale,EntityZ(e\room\obj,True)+Sin(e\EventState2/10)*6000.0*RoomScale)
									RotateEntity e\room\NPC[0]\Collider,7.0,(e\EventState2/10),20.0											
									ShouldPlay = 5
								EndIf
								
								If EntityDistance(Collider, e\room\Objects[10])<320*RoomScale Then
									e\EventState = 2.0
									e\room\RoomDoors[2]\open = False
									e\room\RoomDoors[2]\locked = 6
									e\room\RoomDoors[3]\open = False
									e\room\RoomDoors[3]\locked = 6
									
									e\room\NPC[2] = CreateNPC(NPCtypeApache, EntityX(e\room\Objects[9],True),EntityY(e\room\Objects[9],True)+0.5,EntityZ(e\room\Objects[9],True))
									e\room\NPC[2]\State = 3
									
									e\room\NPC[3] = CreateNPC(NPCtypeApache, EntityX(e\room\Objects[7],True),EntityY(e\room\Objects[7],True)-2.0,EntityZ(e\room\Objects[7],True))
									e\room\NPC[3]\State = 3
									
									e\room\NPC[0]\State = 3
									
									;e\SoundCHN = PlaySound_Strict (LoadTempSound("SFX\Ending\GateB\682Battle.ogg"))
									PlayAnnouncement("SFX\Ending\GateB\682Battle.ogg")
								EndIf								
							Else
								ShouldPlay = 6
								e\EventState=e\EventState+FPSfactor
								
								If e\EventState < 40.0*70 Then 	
									e\room\NPC[0]\EnemyX = EntityX(e\room\Objects[11],True)+Sin(MilliSecs2()/25.0)*3
									e\room\NPC[0]\EnemyY = EntityY(e\room\Objects[11],True)+Cos(MilliSecs()/85.0)+9.0
									e\room\NPC[0]\EnemyZ = EntityZ(e\room\Objects[11],True)+Cos(MilliSecs()/25.0)*3
									
									e\room\NPC[2]\EnemyX = EntityX(e\room\Objects[11],True)+Sin(MilliSecs2()/23.0)*3
									e\room\NPC[2]\EnemyY = EntityY(e\room\Objects[11],True)+Cos(MilliSecs()/83.0)+5.0
									e\room\NPC[2]\EnemyZ = EntityZ(e\room\Objects[11],True)+Cos(MilliSecs()/23.0)*3
									
									If e\room\NPC[3]\State = 3 Then 
										e\room\NPC[3]\EnemyX = EntityX(e\room\Objects[11],True)+Sin(MilliSecs2()/20.0)*3
										e\room\NPC[3]\EnemyY = EntityY(e\room\Objects[11],True)+Cos(MilliSecs()/80.0)+3.5
										e\room\NPC[3]\EnemyZ = EntityZ(e\room\Objects[11],True)+Cos(MilliSecs()/20.0)*3
									EndIf
								EndIf
							EndIf
							
							
							If e\EventState > 0.6*70 And e\EventState < 42.2*70 Then 
								If e\EventState < 0.7*70 Then
									CameraShake = 0.5
								ElseIf e\EventState > 3.2*70 And e\EventState < 3.3*70	
									CameraShake = 0.5
								ElseIf e\EventState > 6.1*70 And e\EventState < 6.2*70	
									CameraShake = 0.5
								ElseIf e\EventState < 10.8*70 And e\EventState < 10.9*70	
									CameraShake = 0.5
								ElseIf e\EventState > 12.1*70 And e\EventState < 12.3*70
									CameraShake = 1.0
								ElseIf e\EventState > 13.3*70 And e\EventState < 13.5*70
									CameraShake = 1.5
								ElseIf e\EventState > 16.5*70 And e\EventState < 18.5*70
									CameraShake = 3.0
								ElseIf e\EventState > 21.5*70 And e\EventState < 24.0*70	
									CameraShake = 2.0
								ElseIf e\EventState > 25.5*70 And e\EventState < 27.0*70	
									CameraShake = 2.0	
								ElseIf e\EventState > 31.0*70 And e\EventState < 31.5*70	
									CameraShake = 0.5	
								ElseIf e\EventState > 35.0*70 And e\EventState < 36.5*70	
									CameraShake = 1.5		
									If e\EventState-FPSfactor =< 35.0*70 Then
										e\SoundCHN = StreamSound_Strict("SFX\Ending\GateB\DetonatingAlphaWarheads.ogg",SFXVolume,0)
										e\SoundCHN_isStream = True
									EndIf									
								ElseIf e\EventState > 39.5*70 And e\EventState < 39.8*70		
									CameraShake = 1.0
								ElseIf e\EventState > 42.0*70
									CameraShake = 0.5
									
									;helicopters leave
									e\room\NPC[0]\EnemyX = EntityX(e\room\Objects[19],True)+4.0
									e\room\NPC[0]\EnemyY = EntityY(e\room\Objects[19],True)+4.0
									e\room\NPC[0]\EnemyZ = EntityZ(e\room\Objects[19],True)+4.0
									
									e\room\NPC[2]\EnemyX = EntityX(e\room\Objects[19],True)
									e\room\NPC[2]\EnemyY = EntityY(e\room\Objects[19],True)
									e\room\NPC[2]\EnemyZ = EntityZ(e\room\Objects[19],True)
									
								EndIf
							EndIf
							
							If e\EventState => 45.0*70 Then
								If e\EventState < 75.0*70 Then
									If e\SoundCHN2=0
										e\SoundCHN2 = StreamSound_Strict("SFX\Ending\GateB\Siren.ogg",SFXVolume,Mode)
										e\SoundCHN2_isStream = True
									EndIf
								Else
									If SelectedEnding = "" Then
									    ShouldPlay = 66
										
										StopStream_Strict(e\SoundCHN)
										StopStream_Strict(e\SoundCHN2)
										
										temp = True
										For e2.Events = Each Events
											If e2\EventName = "room2nuke" Then
												temp = e2\EventState
												Exit
											EndIf
										Next
										
										If temp = 1 Then ;remote detonation on -> explode
											ExplosionTimer = Max(ExplosionTimer, 0.1)
											SelectedEnding = "B2"
										Else
											;LoadEventSound(e,"SFX\Ending\GateB\AlphaWarheadsFail.ogg")
											;e\SoundCHN = PlaySound_Strict(e\Sound)
											PlayAnnouncement("SFX\Ending\GateB\AlphaWarheadsFail.ogg")
											
											For i = 0 To 1
												n.NPCs = CreateNPC(NPCtypeMTF, EntityX(e\room\Objects[18],True)+(i*0.4),EntityY(e\room\Objects[18],True)+0.29,EntityZ(e\room\Objects[18],True)+(i*0.4))
											Next
											
											n.NPCs = CreateNPC(NPCtypeMTF, EntityX(e\room\RoomDoors[2]\obj,True),EntityY(e\room\RoomDoors[2]\obj,True)+0.29,(EntityZ(e\room\RoomDoors[2]\obj,True)+EntityZ(e\room\RoomDoors[3]\obj,True))/2)
											
											For n.NPCs = Each NPCs
												If n\NPCtype = NPCtypeMTF Then
													n\LastSeen = (70*Rnd(30,35))
													n\State = 3
													n\State2 = 10
													n\EnemyX = EntityX(Collider)
													n\EnemyY = EntityY(Collider)
													n\EnemyZ = EntityZ(Collider)
												EndIf
											Next
											
											DebugLog "MTF Units spawned!"
											
											e\EventState = 85.0*70
											
											SelectedEnding = "B3"
										EndIf
										
										;EndIf										
									Else
										If SelectedEnding = "B3" Then
											e\room\NPC[0]\EnemyX = EntityX(e\room\Objects[11],True)+Sin(MilliSecs2()/25.0)*3
											e\room\NPC[0]\EnemyY = EntityY(e\room\Objects[11],True)+Cos(MilliSecs()/85.0)+9.0
											e\room\NPC[0]\EnemyZ = EntityZ(e\room\Objects[11],True)+Cos(MilliSecs()/25.0)*3
											
											e\room\NPC[2]\EnemyX = EntityX(e\room\Objects[11],True)+Sin(MilliSecs2()/23.0)*3
											e\room\NPC[2]\EnemyY = EntityY(e\room\Objects[11],True)+Cos(MilliSecs()/83.0)+5.0
											e\room\NPC[2]\EnemyZ = EntityZ(e\room\Objects[11],True)+Cos(MilliSecs()/23.0)*3
											
											e\room\RoomDoors[5]\open = True
											
											;Update the MTF Units everytime they cannot detect the player
											If e\EventState3 = 0.0
												For n.NPCs = Each NPCs
													If n\NPCtype = NPCtypeMTF
														If n\State = 5
															n\State = 3
															n\PathStatus = FindPath(n, EntityX(Collider),EntityY(Collider),EntityZ(Collider))
															n\PathTimer = 70*Rand(15,20)
															n\LastSeen = 70*300
														EndIf
														If EntityDistance(n\Collider,Collider)<3.0
															n\State = 5
															n\PathStatus = 0
															n\PathTimer = 0
															n\CurrSpeed = 0
														EndIf
													EndIf
												Next
											EndIf
											
											For n.NPCs = Each NPCs
												If n\NPCtype = NPCtypeMTF
													If n\State = 5 And EntityDistance(n\Collider,Collider)<3.0
														If e\EventState3 = 0.0
															PlaySound_Strict LoadTempSound("SFX\Ending\GateB\PlayerDetect.ogg")
															e\EventState3 = e\EventState3 + FPSfactor
															For n2.NPCs = Each NPCs
																If n2\NPCtype = n\NPCtype
																	n2\State = 5
																	n2\PathStatus = 0
																	n2\PathTimer = 0
																	n2\CurrSpeed = 0
																EndIf
															Next
															Exit
														EndIf
													EndIf
												EndIf
											Next
											
											If e\EventState3 > 0.0 And e\EventState3 <= 500.0
												e\EventState3 = e\EventState3 + FPSfactor
												UnableToMove% = True
												For n.NPCs = Each NPCs
													If n\NPCtype = NPCtypeMTF
														n\EnemyX = EntityX(Collider)
														n\EnemyY = EntityY(Collider)
														n\EnemyZ = EntityZ(Collider)
														n\BoneToManipulate = "spine"
														n\ManipulateBone = True
														n\ManipulationType = 1
														n\Gravity = 0
														n\GravityMult = 0
													EndIf
												Next
											ElseIf e\EventState3 > 500.0
												ent% = LoadSprite("GFX\blooddrop1.png",1+2)
												EntityFX ent%,1+2+8
												ScaleSprite ent%,1.5,1.5
												ShouldPlay = 0
												CurrSpeed = 0
												PlaySound_Strict LoadTempSound("SFX\Ending\GateB\Gunshot.ogg")
												GodMode = 0
												NoClip = 0
												KillTimer = -0.1
												DeathMSG = ""
												Kill()
												BlinkTimer = -10
												
												For n.NPCs = Each NPCs
													If n\NPCtype = NPCtypeMTF
														RemoveNPC(n)
													EndIf
												Next
												RemoveEvent(e)
												Exit
											EndIf
											
										EndIf
									EndIf
									
									
								EndIf
							EndIf
							
							If e\EventState > 26.5*70 Then
								If e\room\Objects[12] = 0 Then
									e\room\Objects[12] = LoadMesh_Strict("GFX\NPCs\682arm.b3d")
									ScaleEntity e\room\Objects[12], 0.15,0.15,0.15
									temp = (Min(((EntityDistance(e\room\NPC[3]\Collider,Collider)/RoomScale)-3000.0)/4,1000)+12192.0)*RoomScale
									PositionEntity e\room\Objects[12],EntityX(e\room\NPC[3]\Collider),12192.0*RoomScale,EntityZ(e\room\NPC[3]\Collider)
									RotateEntity e\room\Objects[12],0,e\room\angle+Rnd(-10,10),0,True
									TurnEntity e\room\Objects[12], 0,0,180
								Else
									If WrapAngle(EntityRoll(e\room\Objects[12]))<340.0 Then 
										angle# = WrapAngle(EntityRoll(e\room\Objects[12]))
										TurnEntity e\room\Objects[12], 0,0,(5.0+Abs(Sin(angle))*2)*FPSfactor
										If angle < 270 And WrapAngle(EntityRoll(e\room\Objects[12]))=> 270 Then
											PlaySound_Strict LoadTempSound("SFX\Character\Apache\Crash1.ogg")
											e\room\NPC[3]\State = 4
											e\room\NPC[3]\State2 = 1.0
											e\room\NPC[3]\EnemyX = EntityX(e\room\Objects[7],True)
											e\room\NPC[3]\EnemyY = EntityY(e\room\Objects[7],True)-2.5
											e\room\NPC[3]\EnemyZ = EntityZ(e\room\Objects[7],True)
											
											em.Emitters = CreateEmitter(EntityX(e\room\NPC[3]\Collider), EntityY(e\room\NPC[3]\Collider), EntityZ(e\room\NPC[3]\Collider),0)
											em\Room = PlayerRoom
											em\RandAngle = 45
											em\Gravity = -0.18
											em\LifeTime = 400
											em\SizeChange = Rnd(0.005,0.007)
											em\Achange = -0.004
											TurnEntity(em\Obj, -80+20*i, 0, 0)
											EntityParent em\Obj, e\room\NPC[3]\Collider
											
											If ParticleAmount > 0
												For i = 0 To (3+(4*(ParticleAmount-1)))
													p.Particles = CreateParticle(EntityX(e\room\NPC[3]\Collider),EntityY(e\room\NPC[3]\Collider),EntityZ(e\room\NPC[3]\Collider), 0, Rnd(0.5,1.0), -0.1, 200)
													p\speed = 0.01
													p\SizeChange = 0.01
													p\A = 1.0
													p\Achange = -0.005
													RotateEntity p\pvt, Rnd(360),Rnd(360),0
													MoveEntity p\pvt, 0,0,0.3
												Next
												
												For i = 0 To (6+(6*(ParticleAmount-1)))
													p.Particles = CreateParticle(EntityX(e\room\NPC[3]\Collider),EntityY(e\room\NPC[3]\Collider),EntityZ(e\room\NPC[3]\Collider), 0, 0.02, 0.003, 200)
													p\speed = 0.04
													p\A = 1.0
													p\Achange = -0.005
													RotateEntity p\pvt, Rnd(360),Rnd(360),0
												Next
											EndIf
										EndIf
									Else
										HideEntity e\room\Objects[12]
									EndIf
								EndIf
							EndIf
							
							
							;0.5
							;2.1
							;3.3
							;6.5 - 8.5
							;11.5-14
							;15.5-17
							;21
							;25-26.5
							;29.5
							;32
						EndIf
						
						;dist = Max(Min(EntityDistance(Collider, e\room\objects[3])/10000.0,1.0),0.0)
						;EntityAlpha Fog, 1.0-dist
						HideEntity Fog
						CameraFogRange Camera, 5,45
						
						angle = Max(Sin(EntityYaw(Collider)),0.0)
						;250,230,200
						CameraFogColor (Camera,200+(angle*50),200+(angle*30),200)
						CameraClsColor (Camera,200+(angle*50),200+(angle*30),200)					
						CameraRange(Camera, 0.05, 60)
						
						AmbientLight (140, 140, 140)
						
						If ParticleAmount > 0
							If Rand(3) = 1 Then
								p.Particles = CreateParticle(EntityX(Camera)+Rnd(-2.0,2.0), EntityY(Camera)+Rnd(0.9,2.0), EntityZ(Camera)+Rnd(-2.0,2.0), 2, 0.006, 0, 300)
								p\speed = Rnd(0.002,0.003)
								RotateEntity(p\pvt, Rnd(-20, 20), e\room\angle-90+Rnd(-15,15),0, 0)
								
								p\SizeChange = -0.00001
							EndIf
						EndIf
						
						;Helicopter spots or player is within range. --> Start shooting.
						If (e\room\NPC[1]\State <> 1) Then
							If ((EntityDistance(e\room\NPC[1]\Collider,Collider) < 15.0) Or EntityVisible(e\room\NPC[0]\Collider,Collider)) Then
								e\room\NPC[1]\State = 1
								e\room\NPC[1]\State3 = 1
							EndIf
						EndIf
						
						;Below roof or inside catwalk. --> Stop shooting.
						If (EntityDistance(e\room\NPC[1]\Collider,Collider) < 8.9) Or (EntityDistance(e\room\Objects[5],Collider) < 16.9) Then
							e\room\NPC[1]\State3 = 0
						Else
							e\room\NPC[1]\State3 = 1
						EndIf
					EndIf
				EndIf
				
			Case "gatea"
				
				If PlayerRoom = e\room Then 
					For r.Rooms = Each Rooms
						HideEntity r\obj
					Next					
					ShowEntity e\room\obj
					
					If e\EventState = 0 Then
						DrawLoading(0)
						e\room\Objects[0] = LoadMesh_Strict("GFX\MAP\gateatunnel.b3d")
						PositionEntity e\room\Objects[0], EntityX(e\room\obj,True),EntityY(e\room\obj,True),EntityZ(e\room\obj,True)
						ScaleEntity (e\room\Objects[0],RoomScale,RoomScale,RoomScale)
						EntityType e\room\Objects[0], HIT_MAP
						EntityPickMode e\room\Objects[0], 3
						EntityParent(e\room\Objects[0],e\room\obj)
						
						DrawLoading(30)
						
						For i = 0 To e\room\MaxLights
							If e\room\LightSprites[i]<>0 Then 
								EntityFX e\room\LightSprites[i], 1+8
							EndIf
						Next
						
						For n.NPCs = Each NPCs
							If n <> Curr106 And n <> Curr173
								RemoveNPC(n)
							EndIf
						Next
						Curr173\Idle = True
						Curr096 = Null
						Curr5131 = Null
						
						CameraFogMode(Camera, 0)
						SecondaryLightOn = True
						
						HideDistance = 35.0
						
						For i = 2 To 4
							e\room\NPC[i] = CreateNPC(NPCtypeApache, e\room\x, e\room\y+11, e\room\z)
							e\room\NPC[i]\State = (Not Contained106)
						Next
						
						CreateConsoleMsg("WARNING! Teleporting away from this area may cause bugs or crashing.")
						
						Sky = sky_CreateSky("GFX\map\sky\sky")
						RotateEntity Sky,0,e\room\angle,0
						
						DrawLoading(60)
						
						For i = 0 To 1
							e\room\NPC[i] = CreateNPC(NPCtypeGuard, EntityX(e\room\Objects[i+5],True),EntityY(e\room\Objects[i+5],True),EntityZ(e\room\Objects[i+5],True))
							e\room\NPC[i]\State = 0
							PointEntity e\room\NPC[i]\Collider, e\room\Objects[3]
						Next
						
						For i = 7 To 8
							e\room\NPC[i] = CreateNPC(NPCtypeMTF, EntityX(e\room\Objects[i],True)+0.8,EntityY(e\room\Objects[i],True),EntityZ(e\room\Objects[i],True)+0.8)
							e\room\NPC[i]\State = 5
							e\room\NPC[i]\PrevState = 1
							PointEntity e\room\NPC[i]\Collider, e\room\Objects[3]
						Next	
						
						For i = 5 To 6
							e\room\NPC[i] = CreateNPC(NPCtypeMTF, EntityX(e\room\Objects[i+2],True),EntityY(e\room\Objects[i+2],True),EntityZ(e\room\Objects[i+2],True))
							e\room\NPC[i]\State = 5
							e\room\NPC[i]\PrevState = 1
							PointEntity e\room\NPC[i]\Collider, e\room\Objects[3]
						Next		
						
						If Contained106 Then
							e\room\RoomDoors[2]\locked = True
							
							PositionEntity e\room\NPC[5]\Collider, EntityX(e\room\Objects[15],True)+(i-6)*0.2,EntityY(e\room\Objects[15],True),EntityZ(e\room\Objects[15],True)+(i-6)*0.2, True
							ResetEntity e\room\NPC[5]\Collider
							
						EndIf
						
						xtemp#=EntityX(e\room\Objects[9],True)
						ztemp#=EntityZ(e\room\Objects[9],True)
						FreeEntity e\room\Objects[9]
						
						e\room\Objects[9] = LoadMesh_Strict("GFX\map\lightgunbase.b3d")
						ScaleEntity e\room\Objects[9], RoomScale,RoomScale,RoomScale
						EntityFX(e\room\Objects[9],0)
						PositionEntity(e\room\Objects[9], xtemp, e\room\y+992.0*RoomScale, ztemp)
						e\room\Objects[10] = LoadMesh_Strict("GFX\map\lightgun.b3d")
						EntityFX(e\room\Objects[10],0)
						ScaleEntity e\room\Objects[10], RoomScale,RoomScale,RoomScale
						PositionEntity(e\room\Objects[10], xtemp, e\room\y+(992.0+288.0)*RoomScale, ztemp-176.0*RoomScale,True)
						EntityParent e\room\Objects[10],e\room\Objects[9]
						RotateEntity e\room\Objects[9], 0, 48, 0
						RotateEntity e\room\Objects[10], 40, 0, 0
						
						For temp = 0 To 20
							For i = 0 To 1
								TranslateEntity e\room\NPC[i]\Collider, 0, -0.04, 0
							Next							
							For i = 5 To 8
								TranslateEntity e\room\NPC[i]\Collider, 0, -0.04, 0
							Next
						Next
						
						ResetEntity Collider
						e\EventState = 1.0
						
						RotateEntity Collider,0,EntityYaw(Collider)+(e\room\angle+180),0
						
						If (Not Contained106) Then PlaySound_Strict LoadTempSound("SFX\Ending\GateA\106Escape.ogg") 
						
						DrawLoading(100)
					Else
						
						ShouldPlay = 17
						
						e\EventState = e\EventState+FPSfactor
						HideEntity Fog
						CameraFogRange Camera, 5,30
						
						angle = Max(Sin(EntityYaw(Collider)+90),0.0)
						;240,220,200
						CameraFogColor (Camera,200+(angle*40),200+(angle*20),200)
						CameraClsColor (Camera,200+(angle*40),200+(angle*20),200)		
						CameraRange(Camera, 0.05, 30)
						
						AmbientLight (140, 140, 140)
						
						For i = 2 To 4
							If e\room\NPC[i]<>Null Then 
								If e\room\NPC[i]\State < 2 Then 
									PositionEntity(e\room\NPC[i]\Collider, EntityX(e\room\Objects[3],True)+Cos(e\EventState/10+(120*i))*6000.0*RoomScale,e\room\y+11,EntityZ(e\room\Objects[3],True)+Sin(e\EventState/10+(120*i))*6000.0*RoomScale)
									RotateEntity e\room\NPC[i]\Collider,7.0,(e\EventState/10+(120*i)),20.0
								EndIf
							EndIf
						Next
						
						UpdateSky()
						
						If e\EventState=>350 Then
							If Contained106=False Then
								If e\EventState-FPSfactor < 350
									Curr106\State = -0.1
									;Curr106\Idle = True
									SetNPCFrame(Curr106, 110.0)
									PositionEntity (Curr106\Collider, EntityX(e\room\Objects[3],True),EntityY(Collider)-50.0,EntityZ(e\room\Objects[3],True),True)
									PositionEntity (Curr106\obj, EntityX(e\room\Objects[3],True),EntityY(Collider)-50.0,EntityZ(e\room\Objects[3],True),True)
									de.Decals = CreateDecal(0, EntityX(e\room\Objects[3],True),EntityY(e\room\Objects[3],True)+0.01,EntityZ(e\room\Objects[3],True), 90, Rand(360), 0)
									de\Size = 0.05 : de\SizeChange = 0.001 : EntityAlpha(de\obj, 0.8) : UpdateDecals() 
									PlaySound_Strict (HorrorSFX(5))
									PlaySound_Strict DecaySFX(0)
								ElseIf Curr106\State < 0
									HideEntity Curr106\obj2
									Curr106\PathTimer = 70*100
									
									If Curr106\State3 = 0 Then
										If Curr106\PathStatus <> 1 Then
											PositionEntity Curr106\Collider,EntityX(e\room\Objects[3],True),EntityY(Curr106\Collider),EntityZ(e\room\Objects[3],True),True
											If Curr106\State =< -10 Then
												dist# = EntityY(Curr106\Collider)
												PositionEntity Curr106\Collider,EntityX(Curr106\Collider),EntityY(e\room\Objects[3],True),EntityZ(Curr106\Collider),True
												;Curr106\PathStatus = FindPath(Curr106, EntityX(e\room\Objects[4],True),EntityY(e\room\Objects[4],True),EntityZ(e\room\Objects[4],True))
												Curr106\PathStatus = FindPath(Curr106,EntityX(e\room\NPC[5]\Collider,True),EntityY(e\room\NPC[5]\Collider,True),EntityZ(e\room\NPC[5]\Collider,True))
												Curr106\PathTimer = 70*200
												PositionEntity Curr106\Collider,EntityX(Curr106\Collider),dist,EntityZ(Curr106\Collider),True
												ResetEntity Curr106\Collider
												Curr106\PathLocation = 1
												;Curr106\Idle = False
											;Else	
												;PositionEntity (Curr106\Collider, EntityX(e\room\Objects[3],True),EntityY(e\room\Objects[3],True),EntityZ(e\room\Objects[3],True),True)
												;Curr106\Idle = True
												;Animate2(Curr106\obj, AnimTime(Curr106\obj), 110, 259, 0.15, False)
												;If AnimTime(Curr106\obj)=>259 Then Curr106\Idle = False													
												
											EndIf
										Else
											Curr106\PathTimer = 70*200
											For i = 2 To 4 ;helicopters start attacking 106
												e\room\NPC[i]\State = 3 
												e\room\NPC[i]\EnemyX = EntityX(Curr106\obj,True)
												e\room\NPC[i]\EnemyY = EntityY(Curr106\obj,True)+5.0
												e\room\NPC[i]\EnemyZ = EntityZ(Curr106\obj,True)
											Next
											
											For i = 5 To 8
												e\room\NPC[i]\State = 5
												e\room\NPC[i]\EnemyX = EntityX(Curr106\obj,True)
												e\room\NPC[i]\EnemyY = EntityY(Curr106\obj,True)+0.4
												e\room\NPC[i]\EnemyZ = EntityZ(Curr106\obj,True)											
											Next
											
											pvt=CreatePivot()
											PositionEntity pvt, EntityX(e\room\Objects[10],True),EntityY(e\room\Objects[10],True),EntityZ(e\room\Objects[10],True)
											PointEntity pvt, Curr106\Collider
											RotateEntity(e\room\Objects[9],0,CurveAngle(EntityYaw(pvt),EntityYaw(e\room\Objects[9],True),150.0),0,True)
											RotateEntity(e\room\Objects[10],CurveAngle(EntityPitch(pvt),EntityPitch(e\room\Objects[10],True),200.0),EntityYaw(e\room\Objects[9],True),0, True)
											
											FreeEntity pvt
											
											If FPSfactor > 0 Then ;decals under 106
												If ((e\EventState-FPSfactor) Mod 100.0)=<50.0 And (e\EventState Mod 100.0)>50.0 Then
													de.Decals = CreateDecal(0, EntityX(Curr106\Collider,True),EntityY(e\room\Objects[3],True)+0.01,EntityZ(Curr106\Collider,True), 90, Rand(360), 0)
													de\Size = 0.2 : de\SizeChange = 0.004 : de\timer = 90000 : EntityAlpha(de\obj, 0.8) : UpdateDecals() 											
												EndIf
											EndIf
										EndIf
									EndIf
									
									dist# = Distance(EntityX(Curr106\Collider),EntityZ(Curr106\Collider),EntityX(e\room\Objects[4],True),EntityZ(e\room\Objects[4],True))
									
									Curr106\CurrSpeed = CurveValue(0, Curr106\CurrSpeed, Max(5*dist,2.0))
									If dist < 15.0 Then
										If e\SoundCHN2 = 0 Then
											e\SoundCHN2 = PlaySound_Strict (LoadTempSound("SFX\Ending\GateA\Franklin.ogg"))
										EndIf
										
										If dist<0.4 Then
											Curr106\PathStatus = 0
											Curr106\PathTimer = 70*200
											If Curr106\State3=0 Then 
												SetNPCFrame(Curr106, 259.0)
												If e\Sound <> 0 Then FreeSound_Strict e\Sound : e\Sound = 0
												LoadEventSound(e,"SFX\Ending\GateA\106Retreat.ogg")
												e\SoundCHN = PlaySound2(e\Sound, Camera, Curr106\Collider, 35.0)
											EndIf
											
											If FPSfactor > 0 Then ;106:n alle ilmestyy decaleita
												If ((e\EventState-FPSfactor) Mod 160.0)=<50.0 And (e\EventState Mod 160.0)>50.0 Then
													de.Decals = CreateDecal(0, EntityX(Curr106\Collider,True),EntityY(e\room\Objects[3],True)+0.01,EntityZ(Curr106\Collider,True), 90, Rand(360), 0)
													de\Size = 0.05 : de\SizeChange = 0.004 : de\timer = 90000 : EntityAlpha(de\obj, 0.8) : UpdateDecals() 											
												EndIf
											EndIf
											
											AnimateNPC(Curr106, 259, 110, -0.1, False)
											
											Curr106\State3 = Curr106\State3+FPSfactor
											PositionEntity(Curr106\Collider, EntityX(Curr106\Collider,True),CurveValue(EntityY(e\room\Objects[3],True)-(Curr106\State3/4500.0),EntityY(Curr106\Collider,True),100.0),EntityZ(Curr106\Collider,True))
											If Curr106\State3>700.0 Then
												Curr106\State = 100000
												e\EventState2 = 0
												For i = 5 To 8
													e\room\NPC[i]\State = 1
												Next
												For i = 2 To 4 ;helicopters attack the player
													e\room\NPC[i]\State = 2
												Next
												HideEntity Curr106\obj
											EndIf
										Else
											If dist < 8.5 Then 
												If e\EventState2=0;ChannelPlaying(e\SoundCHN2) = 0 Then
													e\SoundCHN2 = PlaySound_Strict (LoadTempSound("SFX\Ending\GateA\HIDTurret.ogg"))
													e\EventState2 = 1
												ElseIf e\EventState2>0
													e\EventState2=e\EventState2+FPSfactor
													If e\EventState2=> 7.5*70 Then
														If e\EventState2-FPSfactor < 7.5*70 Then
															p.Particles = CreateParticle(EntityX(Curr106\obj,True),EntityY(Curr106\obj,True)+0.4, EntityZ(Curr106\obj,True), 4, 7.0, 0, (6.7*70))
															p\speed = 0.0
															p\A = 1.0
															EntityParent p\pvt, Curr106\Collider, True
															
															p.Particles = CreateParticle(EntityX(e\room\Objects[10],True),EntityY(e\room\Objects[10],True),EntityZ(e\room\Objects[10],True), 4, 2.0, 0, (6.7*70))
															RotateEntity p\pvt, EntityPitch(e\room\Objects[10],True),EntityYaw(e\room\Objects[10],True),0,True
															MoveEntity p\pvt, 0, 92.0*RoomScale, 512.0*RoomScale
															p\speed = 0.0
															p\A = 1.0
															EntityParent p\pvt, e\room\Objects[10], True
														ElseIf e\EventState2 < 14.3*70
															CameraShake = 0.5
															LightFlash = 0.3+EntityInView(e\room\Objects[10],Camera)*0.5
														EndIf
													EndIf
												EndIf
												
												If ParticleAmount > 0
													For i = 0 To Rand(2,2+(6*(ParticleAmount-1)))-Int(dist)
														p.Particles = CreateParticle(EntityX(Curr106\obj,True),EntityY(Curr106\obj,True)+Rnd(0.4,0.9), EntityZ(Curr106\obj), 0, 0.006, -0.002, 40)
														p\speed = 0.005
														p\A = 0.8
														p\Achange = -0.01
														RotateEntity p\pvt, -Rnd(70,110), Rnd(360),0	
													Next										
												EndIf
											EndIf
											
											
										EndIf
									EndIf
								EndIf
								
								If e\EventState3 = 0.0 Then 
									If Abs(EntityY(Collider)-EntityY(e\room\Objects[11],True))<1.0 Then
										If Distance(EntityX(Collider),EntityZ(Collider),EntityX(e\room\Objects[11],True),EntityZ(e\room\Objects[11],True)) < 12.0 Then
											Curr106\State = 100000
											HideEntity Curr106\obj
											
											;MTF spawns at the tunnel entrance
											For i = 5 To 8
												e\room\NPC[i]\State = 3
												PositionEntity e\room\NPC[i]\Collider, EntityX(e\room\Objects[15],True)+(i-6)*0.3,EntityY(e\room\Objects[15],True),EntityZ(e\room\Objects[15],True)+(i-6)*0.3, True
												ResetEntity e\room\NPC[i]\Collider
												
												e\room\NPC[i]\PathStatus = FindPath(e\room\NPC[i], EntityX(Collider),EntityY(Collider)+0.2,EntityZ(Collider))
												e\room\NPC[i]\PathTimer = 70*2
												e\room\NPC[i]\LastSeen = 70*100
											Next
											e\room\NPC[5]\Sound = LoadSound_Strict("SFX\Character\MTF\ThereHeIs1.ogg")
											PlaySound2(e\room\NPC[5]\Sound, Camera, e\room\NPC[5]\Collider, 25.0)
											
											e\room\RoomDoors[2]\open = True
											
											For i = 2 To 4
												RemoveNPC(e\room\NPC[i])
												e\room\NPC[i]=Null
											Next
											
											e\EventState3 = 1.0
										EndIf
									EndIf
								ElseIf e\EventState3 = 1.0
									
									For i = 5 To 8
										If EntityDistance(e\room\NPC[i]\Collider,Collider)> 4.0 Then
											e\room\NPC[i]\State = 3
										Else
											e\room\NPC[i]\State = 1
										EndIf
									Next
									
									If Abs(EntityY(Collider)-EntityY(e\room\Objects[11],True))<1.0 Then
										If Distance(EntityX(Collider),EntityZ(Collider),EntityX(e\room\Objects[11],True),EntityZ(e\room\Objects[11],True)) < 7.0 Then
											e\room\Objects[12] = LoadMesh_Strict("GFX\npcs\s2.b3d")
											EntityColor e\room\Objects[12], 0,0,0
											ScaleMesh (e\room\Objects[12], 0.32/21.3, 0.32/21.3, 0.32/21.3)
											PositionEntity e\room\Objects[12], EntityX(e\room\Objects[11],True), EntityY(e\room\Objects[11],True), EntityZ(e\room\Objects[11],True)
											
											e\room\Objects[17] = CopyEntity(e\room\Objects[12])
											PositionEntity e\room\Objects[17], EntityX(e\room\obj,True)-3968*RoomScale, EntityY(e\room\Objects[11],True), EntityZ(e\room\obj,True)-1920*RoomScale
											
											obj = CopyEntity(e\room\Objects[12])
											PositionEntity obj, EntityX(e\room\obj,True)-4160*RoomScale, EntityY(e\room\Objects[11],True), EntityZ(e\room\obj,True)-1920*RoomScale
											EntityParent obj,e\room\Objects[17]
											
											obj = CopyEntity(e\room\Objects[12])
											PositionEntity obj, EntityX(e\room\obj,True)-4064*RoomScale, EntityY(e\room\Objects[11],True), EntityZ(e\room\obj,True)-2112*RoomScale
											EntityParent obj,e\room\Objects[17]
											
											e\SoundCHN = PlaySound2(LoadTempSound("SFX\Ending\GateA\Bell1.ogg"), Camera, e\room\Objects[12])
											
											p.Particles = CreateParticle(EntityX(e\room\Objects[11],True),EntityY(Camera,True), EntityZ(e\room\Objects[11],True), 4, 8.0, 0, 50)
											p\speed = 0.15
											p\A = 0.5
											p.Particles = CreateParticle(EntityX(e\room\Objects[11],True),EntityY(Camera,True), EntityZ(e\room\Objects[11],True), 4, 8.0, 0, 50)
											p\speed = 0.25
											p\A = 0.5
											PointEntity p\pvt, Collider
											
											CameraShake = 1.0
											LightFlash = 1.0
											
											e\EventState3 = 2.0
										EndIf
									EndIf
								Else
									e\EventState3=e\EventState3+FPSfactor
									PointEntity e\room\Objects[12], Collider
									RotateEntity e\room\Objects[12], 0, EntityYaw(e\room\Objects[12]), 0
									
									Stamina = -5.0
									
									BlurTimer = Sin(e\EventState3*0.7)*1000.0
									
									If KillTimer = 0 Then 
										CameraZoom(Camera, 1.0+Sin(e\EventState3*0.8)*0.2)
										
										dist = EntityDistance(Collider,e\room\Objects[11])
										If dist < 6.5 Then
											PositionEntity(Collider, CurveValue(EntityX(e\room\Objects[11],True),EntityX(Collider),dist*80),EntityY(Collider),CurveValue(EntityZ(e\room\Objects[0],True),EntityZ(Collider),dist*80))
										EndIf
									EndIf
									
									;tunneli menee umpeen
									If e\EventState3>50 And e\EventState3<230 Then
										CameraShake = Sin(e\EventState3-50)*3
										TurnEntity e\room\Objects[13], 0, (Sin(e\EventState3-50)*-0.85)*FPSfactor, 0, True
										TurnEntity e\room\Objects[14], 0, (Sin(e\EventState3-50)*0.85)*FPSfactor, 0, True
										
										For i = 5 To 8
											PositionEntity (e\room\NPC[i]\Collider, CurveValue(EntityX(e\room\RoomDoors[2]\frameobj,True), EntityX(e\room\NPC[i]\Collider,True),50.0),EntityY(e\room\NPC[i]\Collider,True),CurveValue(EntityZ(e\room\RoomDoors[2]\frameobj,True), EntityZ(e\room\NPC[i]\Collider,True),50.0),True)
											ResetEntity e\room\NPC[i]\Collider
										Next
									EndIf
									
									If e\EventState3=>230.0 Then
										If e\EventState3-FPSfactor<230.0 Then
											e\SoundCHN = PlaySound_Strict(LoadTempSound("SFX\Ending\GateA\CI.ogg"))
										EndIf
										
										If ChannelPlaying(e\SoundCHN)=False And SelectedEnding="" Then
											PlaySound_Strict LoadTempSound("SFX\Ending\GateA\Bell2.ogg")
											
											p.Particles = CreateParticle(EntityX(e\room\Objects[11],True),EntityY(Camera,True), EntityZ(e\room\Objects[11],True), 4, 8.0, 0, 50)
											p\speed = 0.15
											p\A = 0.5
											p.Particles = CreateParticle(EntityX(e\room\Objects[11],True),EntityY(Camera,True), EntityZ(e\room\Objects[11],True), 4, 8.0, 0, 50)
											p\speed = 0.25
											p\A = 0.5
											
											SelectedEnding = "A1"
											GodMode = 0
											NoClip = 0
											KillTimer = -0.1
											DeathMSG = ""
											Kill()
										EndIf
										
										If SelectedEnding <> "" Then
											CameraShake=CurveValue(2.0,CameraShake,10.0)
											LightFlash = CurveValue(2.0,LightFlash,8.0);Min(Abs(KillTimer)/100.0,1.0)
										EndIf
										
									EndIf
								EndIf
								
							Else ;contained106 = true
								
								If e\EventState2 = 0 Then
									;PositionEntity (e\room\NPC[5]\Collider, EntityX(e\room\obj,True)-3408*RoomScale, EntityY(e\room\obj,True)-796*RoomScale, EntityZ(e\room\obj,True)+4976, True)
									;ResetEntity e\room\NPC[5]\Collider
									e\EventState2 = 1
									
									For i = 5 To 8
										e\room\NPC[i]\State = 3
										
										e\room\NPC[i]\PathStatus = FindPath(e\room\NPC[i], EntityX(e\room\obj)-1.0+2.0*(i Mod 2),EntityY(Collider)+0.2,EntityZ(e\room\obj)-2.0*(i Mod 2))
										e\room\NPC[i]\PathTimer = 70*Rand(15,20)
										e\room\NPC[i]\LastSeen = 70*300
									Next
								Else
									
									For i = 5 To 8
										If e\room\NPC[i]\State = 5
											e\room\NPC[i]\EnemyX = EntityX(Collider)
											e\room\NPC[i]\EnemyY = EntityY(Collider)
											e\room\NPC[i]\EnemyZ = EntityZ(Collider)
										Else
											If EntityDistance(e\room\NPC[i]\Collider,Collider)<6.0
												e\room\NPC[i]\State = 5
												e\room\NPC[i]\CurrSpeed = 0
											EndIf
										EndIf
									Next
									
									If e\EventState2=<1 Then
										For i = 5 To 8
											If e\room\NPC[i]\State = 5 Then
												For temp = 5 To 8
													e\room\NPC[temp]\State = 5
													e\room\NPC[temp]\EnemyX = EntityX(Collider)
													e\room\NPC[temp]\EnemyY = EntityY(Collider)
													e\room\NPC[temp]\EnemyZ = EntityZ(Collider)
													e\room\NPC[temp]\PathTimer = 70*Rand(7,10)
													e\room\NPC[temp]\Reload = 2000
													UnableToMove% = True
												Next
												
												If e\EventState2=1 Then
													e\SoundCHN = PlaySound_Strict (LoadTempSound("SFX\Ending\GateA\STOPRIGHTTHERE.ogg"))
													e\EventState2=2			
												EndIf
											Else
												e\room\NPC[i]\LastSeen = 70*300
												e\room\NPC[i]\Reload = 2000
												e\room\NPC[i]\State3 = 70*145											
											EndIf
										Next										
									Else
										
										ShouldPlay = 0
										CurrSpeed = 0
										If ChannelPlaying(e\SoundCHN)=False Then
											PlaySound_Strict IntroSFX(9)
											SelectedEnding = "A2"
											GodMode = 0
											NoClip = 0
											KillTimer = -0.1
											DeathMSG = ""
											Kill()
											BlinkTimer = -10
											RemoveEvent(e)
											Exit
										EndIf
									EndIf									
									
								EndIf
								
							EndIf
						EndIf
						
					EndIf
				Else
					HideEntity e\room\obj
				EndIf
				
		End Select
	Next
	
	If ExplosionTimer > 0 Then
		ExplosionTimer = ExplosionTimer+FPSfactor
		
		If ExplosionTimer < 140.0 Then
			If ExplosionTimer-FPSfactor < 5.0 Then
				ExplosionSFX = LoadSound_Strict("SFX\Ending\GateB\Nuke1.ogg")
				PlaySound_Strict ExplosionSFX
				CameraShake = 10.0
				ExplosionTimer = 5.0
			EndIf
			
			CameraShake = CurveValue(ExplosionTimer/60.0,CameraShake, 50.0)
		Else
			CameraShake = Min((ExplosionTimer/20.0),20.0)
			If ExplosionTimer-FPSfactor < 140.0 Then
				BlinkTimer = 1.0
				ExplosionSFX = LoadSound_Strict("SFX\Ending\GateB\Nuke2.ogg")
				PlaySound_Strict ExplosionSFX				
				For i = 0 To (10+(10*(ParticleAmount+1)))
					p.Particles = CreateParticle(EntityX(Collider)+Rnd(-0.5,0.5),EntityY(Collider)-Rnd(0.2,1.5),EntityZ(Collider)+Rnd(-0.5,0.5),0, Rnd(0.2,0.6), 0.0, 350)	
					RotateEntity p\pvt,-90,0,0,True
					p\speed = Rnd(0.05,0.07)
				Next
			EndIf
			LightFlash = Min((ExplosionTimer-140.0)/10.0,5.0)
			
			If ExplosionTimer > 160 Then KillTimer = Min(KillTimer,-0.1)
			If ExplosionTimer > 500 Then ExplosionTimer = 0
			
			;a dirty workaround to prevent the collider from falling down into the facility once the nuke goes off,
			;causing the UpdateEvent function to be called again and crashing the game
			PositionEntity Collider, EntityX(Collider), 200, EntityZ(Collider)
		EndIf
		
	EndIf
	
}



function RemoveEvent(e: Events) {
	if (e.Sound!=0) {
		FreeSound_Strict(e.Sound)
	}
	if (e.Sound2!=0) {
		FreeSound_Strict(e.Sound2)
	}
	if (e.img!=0) {
		FreeImage(e.img)
	}
	Delete (e)
}

Collisions(HIT_PLAYER, HIT_MAP, 2, 2)
Collisions(HIT_PLAYER, HIT_PLAYER, 1, 3)
Collisions(HIT_ITEM, HIT_MAP, 2, 2)
Collisions(HIT_APACHE, HIT_APACHE, 1, 2)
Collisions(HIT_178, HIT_MAP, 2, 2)
Collisions(HIT_178, HIT_178, 1, 3)
Collisions(HIT_DEAD, HIT_MAP, 2, 2)

export function MilliSecs2() {
	let retVal: int = MilliSecs()
	if (retVal < 0) {retVal = retVal + 2147483648}
	return retVal
}

DrawLoading(90, true)

//----------------------------------- meshes and textures ----------------------------------------------------------------

export var FogTexture: int
export var Fog: int
export var GasMaskTexture: int
export var GasMaskOverlay: int
export var InfectTexture: int
export var InfectOverlay: int
export var DarkTexture: int
export var Dark: int
export var Collider: int
export var Head: int

export var FogNVTexture: int
export var NVTexture: int
export var NVOverlay: int

export var TeslaTexture: int

export var LightTexture: int
export var Light: int
export var LightSpriteTex: int[] = new Array(5)
export var DoorOBJ: int
export var DoorFrameOBJ: int

export var LeverOBJ: int
export var LeverBaseOBJ: int

export var DoorColl: int
export var ButtonOBJ: int
export var ButtonKeyOBJ: int
export var ButtonCodeOBJ: int
export var ButtonScannerOBJ: int

export var DecalTextures: int[] = new Array(20)

export var Monitor: int
export var MonitorTexture: int
export var CamBaseOBJ: int
export var CamOBJ: int

var LiquidObj: int,MTFObj: int,GuardObj: int,ClassDObj: int
var ApacheObj: int,ApacheRotorObj: int

var UnableToMove: boolean = false
var ShouldEntitiesFall: boolean = true
var PlayerFallingPickDistance: float = 10.0

var Save_MSG: string = ""
var Save_MSG_Timer: float = 0.0
var Save_MSG_Y: float = 0.0

var MTF_CameraCheckTimer: float = 0.0
var MTF_CameraCheckDetected: boolean = false

//---------------------------------------------------------------------------------------------------


const CurrentGameVersion: string = "1.3.10"

var MenuBack: int = LoadImage_Strict("GFX/menu/back.jpg")
var MenuText: int = LoadImage_Strict("GFX/menu/scptext.jpg")
var Menu173: int = LoadImage_Strict("GFX/menu/173back.jpg")
MenuWhite = LoadImage_Strict("GFX/menu/menuwhite.jpg")
MenuBlack = LoadImage_Strict("GFX/menu/menublack.jpg")
MaskImage (MenuBlack, 255,255,0)
var QuickLoadIcon: int = LoadImage_Strict("GFX/menu/QuickLoading.png")

ResizeImage(MenuBack, ImageWidth(MenuBack) * MenuScale, ImageHeight(MenuBack) * MenuScale)
ResizeImage(MenuText, ImageWidth(MenuText) * MenuScale, ImageHeight(MenuText) * MenuScale)
ResizeImage(Menu173, ImageWidth(Menu173) * MenuScale, ImageHeight(Menu173) * MenuScale)
ResizeImage(QuickLoadIcon, ImageWidth(QuickLoadIcon) * MenuScale, ImageHeight(QuickLoadIcon) * MenuScale)

for (let i of range(4)) {
	ArrowIMG[i] = LoadImage_Strict("GFX/menu/arrow.png")
	RotateImage(ArrowIMG[i], 90 * i)
	HandleImage(ArrowIMG[i], 0, 0)
}

var RandomSeed: string

var MenuBlinkTimer: int[] = new Array(2)
var MenuBlinkDuration: int[] = new Array(2)

MenuBlinkTimer[0] = 1
MenuBlinkTimer[1] = 1

var MenuStr: string
var MenuStrX: int
var MenuStrY: int

var MainMenuTab: int


var IntroEnabled: int = GetINIInt(OptionFile, "options", "intro enabled")

var SelectedInputBox: int

var SavePath: string = "Saves/"
var SaveMSG: string

//nykyisen tallennuksen nimi ja samalla miss kansiossa tallennustiedosto sijaitsee saves-kansiossa
var CurrSave: string

var SaveGameAmount: int
var SaveGames: string[] = new Array(SaveGameAmount+1) 
var SaveGameTime: string[] = new Array(SaveGameAmount + 1)
var SaveGameDate: string[] = new Array(SaveGameAmount + 1)
var SaveGameVersion: string[] = new Array(SaveGameAmount + 1)

var SavedMapsAmount: int = 0
var SavedMaps: string[] = new Array(SavedMapsAmount+1)
var SavedMapsAuthor: string[] = new Array(SavedMapsAmount+1)

var SelectedMap: string

LoadSaveGames()

var CurrLoadGamePage: int = 0

function UpdateMainMenu() {
	let x: int
	let y: int
	let width: int
	let height: int
	let temp: int
	
	Color (0,0,0)
	Rect (0,0,GraphicWidth,GraphicHeight,true)
	
	ShowPointer()
	
	DrawImage(MenuBack, 0, 0)
	
	if ((MilliSecs2() % MenuBlinkTimer(0)) >= Rand(MenuBlinkDuration(0))) {
		DrawImage(Menu173, GraphicWidth - ImageWidth(Menu173), GraphicHeight - ImageHeight(Menu173))
	}
	
	If Rand(300) = 1 Then
		MenuBlinkTimer(0) = Rand(4000, 8000)
		MenuBlinkDuration(0) = Rand(200, 500)
	End If
	
	AASetFont Font1
	
	MenuBlinkTimer(1)=MenuBlinkTimer(1)-FPSfactor
	if (MenuBlinkTimer(1) < MenuBlinkDuration(1)) {
		Color(50, 50, 50)
		AAText(MenuStrX + Rand(-5, 5), MenuStrY + Rand(-5, 5), MenuStr, true)
		if (MenuBlinkTimer(1) < 0) {
			MenuBlinkTimer(1) = Rand(700, 800)
			MenuBlinkDuration(1) = Rand(10, 35)
			MenuStrX = Rand(700, 1000) * MenuScale
			MenuStrY = Rand(100, 600) * MenuScale
			
			switch (Rand(0, 22)) {
				case 0, 2, 3:
					MenuStr = "DON'T BLINK"
				case 4, 5:
					MenuStr = "Secure. Contain. Protect."
				case 6, 7, 8:
					MenuStr = "You want happy endings? Fuck you."
				case 9, 10, 11:
					MenuStr = "Sometimes we would have had time to scream."
				case 12, 19:
					MenuStr = "NIL"
				case 13:
					MenuStr = "NO"
				case 14:
					MenuStr = "black white black white black white gray"
				case 15:
					MenuStr = "Stone does not care"
				case 16:
					MenuStr = "9341"
				case 17:
					MenuStr = "It controls the doors"
				case 18:
					MenuStr = "e8m106]af173o+079m895w914"
				case 20:
					MenuStr = "It has taken over everything"
				case 21:
					MenuStr = "The spiral is growing"
				case 22:
					MenuStr = Chr(34)+"Some kind of gestalt effect due to massive reality damage."+Chr(34)
			}
		}
	}
	
	AASetFont (Font2)
	
	DrawImage(MenuText, GraphicWidth / 2 - ImageWidth(MenuText) / 2, GraphicHeight - 20 * MenuScale - ImageHeight(MenuText))
	
	if (GraphicWidth > 1240 * MenuScale) {
		DrawTiledImageRect(MenuWhite, 0, 5, 512, 7 * MenuScale, 985.0 * MenuScale, 407.0 * MenuScale, (GraphicWidth - 1240 * MenuScale) + 300, 7 * MenuScale)
	}
	
	if (!MouseDown1) {
		OnSliderID = 0
	}
	
	if (MainMenuTab = 0) {
		for (i of range(4)) {
			temp = false
			x = 159 * MenuScale
			y = (286 + 100 * i) * MenuScale
			
			width = 400 * MenuScale
			height = 70 * MenuScale
			
			temp = (MouseHit1 && MouseOn(x, y, width, height))
			
			let txt: string
			switch (i) {
				case 0:
					txt = "NEW GAME"
					RandomSeed = ""
					if (temp) {
						if (Rand(15)=1) {
							switch (Rand(13)) {
								case 1 :
									RandomSeed = "NIL"
								case 2:
									RandomSeed = "NO"
								case 3:
									RandomSeed = "d9341"
								case 4:
									RandomSeed = "5CP_I73"
								case 5:
									RandomSeed = "DONTBLINK"
								case 6:
									RandomSeed = "CRUNCH"
								case 7:
									RandomSeed = "die"
								case 8:
									RandomSeed = "HTAED"
								case 9:
									RandomSeed = "rustledjim"
								case 10:
									RandomSeed = "larry"
								case 11:
									RandomSeed = "JORGE"
								case 12:
									RandomSeed = "dirtymetal"
								case 13:
									RandomSeed = "whatpumpkin"
							}
						} else {
							n = Rand(4,8)
							for (i of range(1, n + 1)) {
								if (Rand(3)=1) {
									RandomSeed = RandomSeed + Rand(0,9)
								} else {
									RandomSeed = RandomSeed + Chr(Rand(97,122))
								}
							}							
						}
						
						MainMenuTab = 1
					}
				case 1:
					txt = "LOAD GAME"
					if (temp) {
						LoadSaveGames()
						MainMenuTab = 2
					}
				case 2:
					txt = "OPTIONS"
					if (temp) {MainMenuTab = 3}
				case 3:
					txt = "QUIT"
					if (temp) {
						FSOUND_Stream_Stop(CurrMusicStream)
						End()
					}
			}
			
			DrawButton(x, y, width, height, txt)			
		}	
		
	} else {
		
		x = 159 * MenuScale
		y = 286 * MenuScale
		
		width = 400 * MenuScale
		height = 70 * MenuScale
		
		DrawFrame(x, y, width, height)
		
		if (DrawButton(x + width + 20 * MenuScale, y, 580 * MenuScale - width - 20 * MenuScale, height, "BACK", false)) {
			switch (MainMenuTab) {
				case 1:
					PutINIValue(OptionFile, "options", "intro enabled", IntroEnabled)
					MainMenuTab = 0
				case 2:
					CurrLoadGamePage = 0
					MainMenuTab = 0
				case 3,5,6,7: //save the options:
					SaveOptionsINI()
					
					UserTrackCheck = 0
					UserTrackCheck2 = 0
					
					AntiAlias (Opt_AntiAlias)
					MainMenuTab = 0
				case 4: //move back to the "new game" tab:
					MainMenuTab = 1
					CurrLoadGamePage = 0
					MouseHit1 = false
				default:
					MainMenuTab = 0
			}
		}
		
		switch (MainMenuTab) {
			case 1: // New game
				//[Block]
				
				x = 159 * MenuScale
				y = 286 * MenuScale
				
				width = 400 * MenuScale
				height = 70 * MenuScale
				
				Color(255, 255, 255)
				AASetFont (Font2)
				AAText(x + width / 2, y + height / 2, "NEW GAME", true, true)
				
				x = 160 * MenuScale
				y = y + height + 20 * MenuScale
				width = 580 * MenuScale
				height = 330 * MenuScale
				
				DrawFrame(x, y, width, height)				
				
				AASetFont (Font1)
				
				AAText (x + 20 * MenuScale, y + 20 * MenuScale, "Name:")
				CurrSave = InputBox(x + 150 * MenuScale, y + 15 * MenuScale, 200 * MenuScale, 30 * MenuScale, CurrSave, 1)
				CurrSave = Left(CurrSave, 15)
				CurrSave = Replace(CurrSave,":","")
				CurrSave = Replace(CurrSave,".","")
				CurrSave = Replace(CurrSave,"/","")
				CurrSave = Replace(CurrSave,"\\","")
				CurrSave = Replace(CurrSave,"<","")
				CurrSave = Replace(CurrSave,">","")
				CurrSave = Replace(CurrSave,"|","")
				CurrSave = Replace(CurrSave,"?","")
				CurrSave = Replace(CurrSave,Chr(34),"")
				CurrSave = Replace(CurrSave,"*","")
				
				Color (255,255,255)
				if (SelectedMap = "") {
					AAText (x + 20 * MenuScale, y + 60 * MenuScale, "Map seed:")
					RandomSeed = Left(InputBox(x+150*MenuScale, y+55*MenuScale, 200*MenuScale, 30*MenuScale, RandomSeed, 3),15)	
				} else {
					AAText (x + 20 * MenuScale, y + 60 * MenuScale, "Selected map:")
					Color (255, 255, 255)
					Rect(x+150*MenuScale, y+55*MenuScale, 200*MenuScale, 30*MenuScale)
					Color (0, 0, 0)
					Rect(x+150*MenuScale+2, y+55*MenuScale+2, 200*MenuScale-4, 30*MenuScale-4)
					
					Color (255, 0,0)
					if (Len(SelectedMap)>15) {
						AAText(x+150*MenuScale + 100*MenuScale, y+55*MenuScale + 15*MenuScale, Left(SelectedMap,14)+"...", true, true)
					} else {
						AAText(x+150*MenuScale + 100*MenuScale, y+55*MenuScale + 15*MenuScale, SelectedMap, true, true)
					}
					
					if (DrawButton(x+370*MenuScale, y+55*MenuScale, 120*MenuScale, 30*MenuScale, "Deselect", false)) {
						SelectedMap=""
					}
				}	
				
				AAText(x + 20 * MenuScale, y + 110 * MenuScale, "Enable intro sequence:")
				IntroEnabled = DrawTick(x + 280 * MenuScale, y + 110 * MenuScale, IntroEnabled)	
				
				//Local modeName$, modeDescription$, selectedDescription$
				AAText (x + 20 * MenuScale, y + 150 * MenuScale, "Difficulty:")				
				for (i of range(SAFE, CUSTOM + 1)) {
					if (DrawTick(x + 20 * MenuScale, y + (180+30*i) * MenuScale, (SelectedDifficulty = difficulties(i)))) {
						SelectedDifficulty = difficulties(i)
					}
					Color(difficulties(i).r,difficulties(i).g,difficulties(i).b)
					AAText(x + 60 * MenuScale, y + (180+30*i) * MenuScale, difficulties(i)\name)
				}
				
				Color(255, 255, 255)
				DrawFrame(x + 150 * MenuScale,y + 155 * MenuScale, 410*MenuScale, 150*MenuScale)
				
				if (SelectedDifficulty.customizable) {
					SelectedDifficulty.permaDeath =  DrawTick(x + 160 * MenuScale, y + 165 * MenuScale, (SelectedDifficulty.permaDeath))
					AAText(x + 200 * MenuScale, y + 165 * MenuScale, "Permadeath")
					
					if (DrawTick(x + 160 * MenuScale, y + 195 * MenuScale, SelectedDifficulty.saveType = SAVEANYWHERE && (!SelectedDifficulty.permaDeath), SelectedDifficulty.permaDeath)) {
						SelectedDifficulty.saveType = SAVEANYWHERE
					} else {
						SelectedDifficulty.saveType = SAVEONSCREENS
					}
					
					AAText(x + 200 * MenuScale, y + 195 * MenuScale, "Save anywhere")	
					
					SelectedDifficulty.aggressiveNPCs =  DrawTick(x + 160 * MenuScale, y + 225 * MenuScale, SelectedDifficulty.aggressiveNPCs)
					AAText(x + 200 * MenuScale, y + 225 * MenuScale, "Aggressive NPCs")
					
					//Other factor's difficulty
					Color (255,255,255)
					DrawImage (ArrowIMG(1),x + 155 * MenuScale, y+251*MenuScale)
					if (MouseHit1) {
						if (ImageRectOverlap(ArrowIMG(1),x + 155 * MenuScale, y+251*MenuScale, ScaledMouseX(),ScaledMouseY(),0,0)) {
							if (SelectedDifficulty.otherFactors < HARD) {
								SelectedDifficulty.otherFactors = SelectedDifficulty.otherFactors + 1
							} else {
								SelectedDifficulty.otherFactors = EASY
							}
							PlaySound_Strict(ButtonSFX)
						}
					}
					Color (255,255,255)
					switch (SelectedDifficulty.otherFactors) {
						case EASY:
							AAText(x + 200 * MenuScale, y + 255 * MenuScale, "Other difficulty factors: Easy")
						case NORMAL:
							AAText(x + 200 * MenuScale, y + 255 * MenuScale, "Other difficulty factors: Normal")
						case HARD:
							AAText(x + 200 * MenuScale, y + 255 * MenuScale, "Other difficulty factors: Hard")
					}
				} else {
					RowText(SelectedDifficulty.description, x+160*MenuScale, y+160*MenuScale, (410-20)*MenuScale, 200)					
				}
				
				if (DrawButton(x, y + height + 20 * MenuScale, 160 * MenuScale, 70 * MenuScale, "Load map", false)) {
					MainMenuTab = 4
					LoadSavedMaps()
				}
				
				AASetFont (Font2)
				
				if (DrawButton(x + 420 * MenuScale, y + height + 20 * MenuScale, 160 * MenuScale, 70 * MenuScale, "START", false)) {
					if (CurrSave = "") {CurrSave = "untitled"}
					
					if (RandomSeed = "") {
						RandomSeed = Abs(MilliSecs())
					}
					
					SeedRnd (GenerateSeedNumber(RandomSeed))
					
					let SameFound: boolean = false
					
					for (i of range(1, SaveGameAmount + 1)) {
						if (SaveGames(i - 1) = CurrSave) {
							SameFound = SameFound + 1
						}
					}
						
					if (SameFound > 0) {
						CurrSave = CurrSave + " (" + (SameFound + 1) + ")"
					}
					
					LoadEntities()
					LoadAllSounds()
					InitNewGame()
					MainMenuOpen = false
					FlushKeys()
					FlushMouse()
					
					PutINIValue(OptionFile, "options", "intro enabled", IntroEnabled%)
					
				}
				
				//[End Block]
			case 2: //load game
				//[Block]
				
				y = y + height + 20 * MenuScale
				width = 580 * MenuScale
				//height = 300 * MenuScale
				height = 510 * MenuScale
				
				DrawFrame(x, y, width, height)
				
				x = 159 * MenuScale
				y = 286 * MenuScale
				
				width = 400 * MenuScale
				height = 70 * MenuScale
				
				Color(255, 255, 255)
				AASetFont (Font2)
				AAText(x + width / 2, y + height / 2, "LOAD GAME", true, true)
				
				x = 160 * MenuScale
				y = y + height + 20 * MenuScale
				width = 580 * MenuScale
				height = 296 * MenuScale
				
				//AASetFont Font1	
				
				AASetFont (Font2)
				
				if (CurrLoadGamePage < Ceil(Float(SaveGameAmount)/6.0)-1 && SaveMSG == "") { 
					if (DrawButton(x+530*MenuScale, y + 510*MenuScale, 50*MenuScale, 55*MenuScale, ">")) {
						CurrLoadGamePage = CurrLoadGamePage+1
					}
				} else {
					DrawFrame(x+530*MenuScale, y + 510*MenuScale, 50*MenuScale, 55*MenuScale)
					Color(100, 100, 100)
					AAText(x+555*MenuScale, y + 537.5*MenuScale, ">", true, true)
				}
				if (CurrLoadGamePage > 0 && SaveMSG == "") {
					if (DrawButton(x, y + 510*MenuScale, 50*MenuScale, 55*MenuScale, "<")) {
						CurrLoadGamePage = CurrLoadGamePage-1
					}
				} else {
					DrawFrame(x, y + 510*MenuScale, 50*MenuScale, 55*MenuScale)
					Color(100, 100, 100)
					AAText(x+25*MenuScale, y + 537.5*MenuScale, "<", true, true)
				}
				
				DrawFrame(x+50*MenuScale,y+510*MenuScale,width-100*MenuScale,55*MenuScale)
				
				AAText(x+(width/2.0),y+536*MenuScale,"Page "+Int(Max((CurrLoadGamePage+1),1))+"/"+Int(Max((Int(Ceil(Float(SaveGameAmount)/6.0))),1)),true,true)
				
				AASetFont (Font1)
				
				if (CurrLoadGamePage > Ceil(Float(SaveGameAmount)/6.0)-1) {
					CurrLoadGamePage = CurrLoadGamePage - 1
				}
				
				if (SaveGameAmount = 0) {
					AAText (x + 20 * MenuScale, y + 20 * MenuScale, "No saved games.")
				} else {
					x = x + 20 * MenuScale
					y = y + 20 * MenuScale
					
					for (i of range((1+(6*CurrLoadGamePage)), 6+(6*CurrLoadGamePage) + 1)) {
						if (i <= SaveGameAmount) {
							DrawFrame(x,y,540* MenuScale, 70* MenuScale)
							
							if (SaveGameVersion(i - 1) != CompatibleNumber && SaveGameVersion(i - 1) != CurrentGameVersion) {
								Color (255,0,0)
							} else {
								Color (255,255,255)
							}
							
							AAText(x + 20 * MenuScale, y + 10 * MenuScale, SaveGames(i - 1))
							AAText(x + 20 * MenuScale, y + (10+18) * MenuScale, SaveGameTime(i - 1)) //y + (10+23) * MenuScale
							AAText(x + 120 * MenuScale, y + (10+18) * MenuScale, SaveGameDate(i - 1))
							AAText(x + 20 * MenuScale, y + (10+36) * MenuScale, SaveGameVersion(i - 1))
							
							if (SaveMSG = "") {
								if (SaveGameVersion(i - 1) != CompatibleNumber && SaveGameVersion(i - 1) != CurrentGameVersion) {
									DrawFrame(x + 280 * MenuScale, y + 20 * MenuScale, 100 * MenuScale, 30 * MenuScale)
									Color(255, 0, 0)
									AAText(x + 330 * MenuScale, y + 34 * MenuScale, "Load", true, true)
								} else {
									if (DrawButton(x + 280 * MenuScale, y + 20 * MenuScale, 100 * MenuScale, 30 * MenuScale, "Load", false)) {
										LoadEntities()
										LoadAllSounds()
										LoadGame(SavePath + SaveGames(i - 1) + "/")
										CurrSave = SaveGames(i - 1)
										InitLoadGame()
										MainMenuOpen = false
									}
								}
								
								if (DrawButton(x + 400 * MenuScale, y + 20 * MenuScale, 100 * MenuScale, 30 * MenuScale, "Delete", false)) {
									SaveMSG = SaveGames(i - 1)
									DebugLog (SaveMSG)
									Exit()
								}
							} else {
								DrawFrame(x + 280 * MenuScale, y + 20 * MenuScale, 100 * MenuScale, 30 * MenuScale)
								if (SaveGameVersion(i - 1) != CompatibleNumber && SaveGameVersion(i - 1) != CurrentGameVersion) {
									Color(255, 0, 0)
								} else {
									Color(100, 100, 100)
								}
								AAText(x + 330 * MenuScale, y + 34 * MenuScale, "Load", true, true)
								
								DrawFrame(x + 400 * MenuScale, y + 20 * MenuScale, 100 * MenuScale, 30 * MenuScale)
								Color(100, 100, 100)
								AAText(x + 450 * MenuScale, y + 34 * MenuScale, "Delete", true, true)
							}
							
							y = y + 80 * MenuScale
						} else {
							Exit
						}
					}
					
					if (SaveMSG != "") {
						x = 740 * MenuScale
						y = 376 * MenuScale
						DrawFrame(x, y, 420 * MenuScale, 200 * MenuScale)
						RowText("Are you sure you want to delete this save?", x + 20 * MenuScale, y + 15 * MenuScale, 400 * MenuScale, 200 * MenuScale)
						//AAText(x + 20 * MenuScale, y + 15 * MenuScale, "Are you sure you want to delete this save?")
						if (DrawButton(x + 50 * MenuScale, y + 150 * MenuScale, 100 * MenuScale, 30 * MenuScale, "Yes", false)) {
							DeleteFile(CurrentDir() + SavePath + SaveMSG + "\save.txt")
							DeleteDir(CurrentDir() + SavePath + SaveMSG)
							SaveMSG = ""
							LoadSaveGames()
						}
						if (DrawButton(x + 250 * MenuScale, y + 150 * MenuScale, 100 * MenuScale, 30 * MenuScale, "No", false)) {
							SaveMSG = ""
						}
					}
				}

				//[End Block]
			case 3,5,6,7: //options
				//[Block]
				
				x = 159 * MenuScale
				y = 286 * MenuScale
				
				width = 400 * MenuScale
				height = 70 * MenuScale
				
				Color(255, 255, 255)
				AASetFont (Font2)
				AAText(x + width / 2, y + height / 2, "OPTIONS", true, true)
				
				x = 160 * MenuScale
				y = y + height + 20 * MenuScale
				width = 580 * MenuScale
				height = 60 * MenuScale
				DrawFrame(x, y, width, height)
				
				Color (0,255,0)
				if (MainMenuTab = 3) {
					Rect(x+15*MenuScale,y+10*MenuScale,(width/5)+10*MenuScale,(height/2)+10*MenuScale,true)
				} else if (MainMenuTab = 5) {
					Rect(x+155*MenuScale,y+10*MenuScale,(width/5)+10*MenuScale,(height/2)+10*MenuScale,true)
				} else if (MainMenuTab = 6) {
					Rect(x+295*MenuScale,y+10*MenuScale,(width/5)+10*MenuScale,(height/2)+10*MenuScale,true)
				} else if (MainMenuTab = 7) {
					Rect(x+435*MenuScale,y+10*MenuScale,(width/5)+10*MenuScale,(height/2)+10*MenuScale,true)
				}
				
				Color (255,255,255)
				if (DrawButton(x+20*MenuScale,y+15*MenuScale,width/5,height/2, "GRAPHICS", false)) {
					MainMenuTab = 3
				}
				if (DrawButton(x+160*MenuScale,y+15*MenuScale,width/5,height/2, "AUDIO", false)) {
					MainMenuTab = 5
				}
				if (DrawButton(x+300*MenuScale,y+15*MenuScale,width/5,height/2, "CONTROLS", false)) {
					MainMenuTab = 6
				}
				if (DrawButton(x+440*MenuScale,y+15*MenuScale,width/5,height/2, "ADVANCED", false)) {
					MainMenuTab = 7
				}
				
				AASetFont (Font1)
				y = y + 70 * MenuScale
				
				if (MainMenuTab != 5) {
					UserTrackCheck = 0
					UserTrackCheck2 = 0
				}
				
				let tx: float = x+width
				let ty: float = y
				let tw: float = 400*MenuScale
				let th: float = 150*MenuScale
				
				//DrawOptionsTooltip(tx,ty,tw,th,"")
				
				if (MainMenuTab = 3) { //Graphics
					//[Block]
					//height = 380 * MenuScale
					height = 330 * MenuScale
					DrawFrame(x, y, width, height)
					
					y=y+20*MenuScale
					
					Color (255,255,255)
					AAText(x + 20 * MenuScale, y, "Enable bump mapping:")	
					BumpEnabled = DrawTick(x + 310 * MenuScale, y + MenuScale, BumpEnabled)
					if (MouseOn(x + 310 * MenuScale, y + MenuScale, 20*MenuScale,20*MenuScale) && OnSliderID==0) {
						DrawOptionsTooltip(tx,ty,tw,th,"bump")
					}
					
					y=y+30*MenuScale
					
					Color (255,255,255)
					AAText(x + 20 * MenuScale, y, "VSync:")
					Vsync = DrawTick(x + 310 * MenuScale, y + MenuScale, Vsync)
					if (MouseOn(x+310*MenuScale,y+MenuScale,20*MenuScale,20*MenuScale) && OnSliderID==0) {
						DrawOptionsTooltip(tx,ty,tw,th,"vsync")
					}
					
					y=y+30*MenuScale
					
					Color (255,255,255)
					AAText(x + 20 * MenuScale, y, "Anti-aliasing:")
					Opt_AntiAlias = DrawTick(x + 310 * MenuScale, y + MenuScale, Opt_AntiAlias)
					if (MouseOn(x+310*MenuScale,y+MenuScale,20*MenuScale,20*MenuScale) && OnSliderID==0) {
						DrawOptionsTooltip(tx,ty,tw,th,"antialias")
					}
					
					y=y+30*MenuScale //40
					
					Color (255,255,255)
					AAText(x + 20 * MenuScale, y, "Enable room lights:")
					EnableRoomLights = DrawTick(x + 310 * MenuScale, y + MenuScale, EnableRoomLights)
					if (MouseOn(x+310*MenuScale,y+MenuScale,20*MenuScale,20*MenuScale) && OnSliderID == 0) {
						DrawOptionsTooltip(tx,ty,tw,th,"roomlights")
					}
					
					y=y+30*MenuScale
					
					ScreenGamma = (SlideBar(x + 310*MenuScale, y+6*MenuScale, 150*MenuScale, ScreenGamma*50.0)/50.0)
					Color (255,255,255)
					AAText(x + 20 * MenuScale, y, "Screen gamma")
					if (MouseOn(x+310*MenuScale,y+6*MenuScale,150*MenuScale+14,20) && OnSliderID == 0) {
						DrawOptionsTooltip(tx,ty,tw,th,"gamma",ScreenGamma)
					}
					
					y=y+50*MenuScale
					
					Color (255,255,255)
					AAText(x + 20 * MenuScale, y, "Particle amount:")
					ParticleAmount = Slider3(x+310*MenuScale,y+6*MenuScale,150*MenuScale,ParticleAmount,2,"MINIMAL","REDUCED","FULL")
					if ((MouseOn(x + 310 * MenuScale, y-6*MenuScale, 150*MenuScale+14, 20) && OnSliderID == 0) || OnSliderID == 2) {
						DrawOptionsTooltip(tx,ty,tw,th,"particleamount",ParticleAmount)
					}
					
					y=y+50*MenuScale
					
					Color (255,255,255)
					AAText(x + 20 * MenuScale, y, "Texture LOD Bias:")
					TextureDetails = Slider5(x+310*MenuScale,y+6*MenuScale,150*MenuScale,TextureDetails,3,"0.8","0.4","0.0","-0.4","-0.8")
					switch (TextureDetails) {
						case 0:
							TextureFloat = 0.8
						case 1:
							TextureFloat = 0.4
						case 2:
							TextureFloat = 0.0
						case 3:
							TextureFloat = -0.4
						case 4:
							TextureFloat = -0.8
					}
					TextureLodBias (TextureFloat)
					if ((MouseOn(x+310*MenuScale,y-6*MenuScale,150*MenuScale+14,20) && OnSliderID == 0) || OnSliderID == 3) {
						DrawOptionsTooltip(tx,ty,tw,th+100*MenuScale,"texquality")
					}
					
					y=y+50*MenuScale
					
					Color (255,255,255)
					AAText(x + 20 * MenuScale, y, "Save textures in the VRAM:")
					EnableVRam = DrawTick(x + 310 * MenuScale, y + MenuScale, EnableVRam)
					if (MouseOn(x+310*MenuScale,y+MenuScale,20*MenuScale,20*MenuScale) && OnSliderID == 0) {
						DrawOptionsTooltip(tx,ty,tw,th,"vram")
					}
					
					//[End Block]
				} else if (MainMenuTab == 5) { //Audio
					//[Block]
					height = 220 * MenuScale
					DrawFrame(x, y, width, height)	
					
					y = y + 20*MenuScale
					
					MusicVolume = (SlideBar(x + 310*MenuScale, y-4*MenuScale, 150*MenuScale, MusicVolume*100.0)/100.0)
					Color (255,255,255)
					AAText(x + 20 * MenuScale, y, "Music volume:")
					if (MouseOn(x+310*MenuScale,y-4*MenuScale,150*MenuScale+14,20)) {
						DrawOptionsTooltip(tx,ty,tw,th,"musicvol",MusicVolume)
					}
					
					y = y + 40*MenuScale
					
					PrevSFXVolume = (SlideBar(x + 310*MenuScale, y-4*MenuScale, 150*MenuScale, SFXVolume*100.0)/100.0)
					SFXVolume = PrevSFXVolume
					Color (255,255,255)
					AAText(x + 20 * MenuScale, y, "Sound volume:")
					if (MouseOn(x+310*MenuScale,y-4*MenuScale,150*MenuScale+14,20)) {
						DrawOptionsTooltip(tx,ty,tw,th,"soundvol",PrevSFXVolume)
					}
					
					y = y + 30*MenuScale
					
					Color (255,255,255)
					AAText (x + 20 * MenuScale, y, "Sound auto-release:")
					EnableSFXRelease = DrawTick(x + 310 * MenuScale, y + MenuScale, EnableSFXRelease)
					if (EnableSFXRelease_Prev != EnableSFXRelease) {
						if (EnableSFXRelease) {
							for (snd of Sound.each) {
								for (i of range(32)) {
									if (snd.channels[i]!=0) {
										if (ChannelPlaying(snd.channels[i])) {
											StopChannel(snd.channels[i])
										}
									}
								}
								if (snd.internalHandle!=0) {
									FreeSound (snd.internalHandle)
									snd.internalHandle = 0
								}
								snd.releaseTime = 0
							}
						} else {
							for (snd of Sound.each) {
								if (snd.internalHandle = 0) {
									snd.internalHandle = LoadSound(snd.name)
								}
							}
						}
						EnableSFXRelease_Prev = EnableSFXRelease
					}
					if (MouseOn(x+310*MenuScale,y+MenuScale,20*MenuScale,20*MenuScale)) {
						DrawOptionsTooltip(tx,ty,tw,th+220*MenuScale,"sfxautorelease")
					}
					y = y + 30*MenuScale
					
					Color (255,255,255)
					AAText (x + 20 * MenuScale, y, "Enable user tracks:")
					EnableUserTracks = DrawTick(x + 310 * MenuScale, y + MenuScale, EnableUserTracks)
					if (MouseOn(x+310*MenuScale,y+MenuScale,20*MenuScale,20*MenuScale)) {
						DrawOptionsTooltip(tx,ty,tw,th,"usertrack")
					}
					
					if (EnableUserTracks) {
						y = y + 30 * MenuScale
						Color (255,255,255)
						AAText (x + 20 * MenuScale, y, "User track mode:")
						UserTrackMode = DrawTick(x + 310 * MenuScale, y + MenuScale, UserTrackMode)
						if (UserTrackMode) {
							AAText (x + 350 * MenuScale, y + MenuScale, "Repeat")
						} else {
							AAText (x + 350 * MenuScale, y + MenuScale, "Random")
						}
						if (MouseOn(x+310*MenuScale,y+MenuScale,20*MenuScale,20*MenuScale)) {
							DrawOptionsTooltip(tx,ty,tw,th,"usertrackmode")
						}
						if (DrawButton(x + 20 * MenuScale, y + 30 * MenuScale, 190 * MenuScale, 25 * MenuScale, "Scan for User Tracks",false)) {
							DebugLog ("User Tracks Check Started")
							
							UserTrackCheck = 0
							UserTrackCheck2 = 0
							
							Dir=ReadDir("SFX/Radio/UserTracks/")
							while (true) {
								file = NextFile(Dir)
								if (file$="") {Exit()}
								if (FileType("SFX/Radio/UserTracks/"+file$) = 1) {
									UserTrackCheck = UserTrackCheck + 1
									test = LoadSound("SFX/Radio/UserTracks/"+file$)
									if (test != 0) {
										UserTrackCheck2 = UserTrackCheck2 + 1
									}
									FreeSound(test)
								}
							}
							CloseDir (Dir)
							
							DebugLog ("User Tracks Check Ended")
						}
						if (MouseOn(x+20*MenuScale,y+30*MenuScale,190*MenuScale,25*MenuScale)) {
							DrawOptionsTooltip(tx,ty,tw,th,"usertrackscan")
						}
						if (UserTrackCheck > 0) {
							AAText (x + 20 * MenuScale, y + 100 * MenuScale, "User tracks found ("+UserTrackCheck2+"/"+UserTrackCheck+" successfully loaded)")
						}
					} else {
						UserTrackCheck%=0
					}
					//[End Block]
				} else if (MainMenuTab = 6) { //Controls
					//[Block]
					height = 270 * MenuScale
					DrawFrame(x, y, width, height)	
					
					y = y + 20*MenuScale
					
					MouseSens = (SlideBar(x + 310*MenuScale, y-4*MenuScale, 150*MenuScale, (MouseSens+0.5)*100.0)/100.0)-0.5
					Color(255, 255, 255)
					AAText(x + 20 * MenuScale, y, "Mouse sensitivity:")
					if (MouseOn(x+310*MenuScale,y-4*MenuScale,150*MenuScale+14,20)) {
						DrawOptionsTooltip(tx,ty,tw,th,"mousesensitivity",MouseSens)
					}
					
					y = y + 40*MenuScale
					
					Color(255, 255, 255)
					AAText(x + 20 * MenuScale, y, "Invert mouse Y-axis:")
					InvertMouse = DrawTick(x + 310 * MenuScale, y + MenuScale, InvertMouse)
					if (MouseOn(x+310*MenuScale,y+MenuScale,20*MenuScale,20*MenuScale)) {
						DrawOptionsTooltip(tx,ty,tw,th,"mouseinvert")
					}
					
					y = y + 40*MenuScale
					
					MouseSmooth = (SlideBar(x + 310*MenuScale, y-4*MenuScale, 150*MenuScale, (MouseSmooth)*50.0)/50.0)
					Color(255, 255, 255)
					AAText(x + 20 * MenuScale, y, "Mouse smoothing:")
					if (MouseOn(x+310*MenuScale,y-4*MenuScale,150*MenuScale+14,20)) {
						DrawOptionsTooltip(tx,ty,tw,th,"mousesmoothing",MouseSmooth)
					}
					
					Color(255, 255, 255)
					
					y = y + 30*MenuScale
					AAText(x + 20 * MenuScale, y, "Control configuration:")
					y = y + 10*MenuScale
					
					AAText(x + 20 * MenuScale, y + 20 * MenuScale, "Move Forward")
					InputBox(x + 160 * MenuScale, y + 20 * MenuScale,100*MenuScale,20*MenuScale,KeyName[Min(KEY_UP,210)],5)		
					AAText(x + 20 * MenuScale, y + 40 * MenuScale, "Strafe Left")
					InputBox(x + 160 * MenuScale, y + 40 * MenuScale,100*MenuScale,20*MenuScale,KeyName[Min(KEY_LEFT,210)],3)	
					AAText(x + 20 * MenuScale, y + 60 * MenuScale, "Move Backward")
					InputBox(x + 160 * MenuScale, y + 60 * MenuScale,100*MenuScale,20*MenuScale,KeyName[Min(KEY_DOWN,210)],6)				
					AAText(x + 20 * MenuScale, y + 80 * MenuScale, "Strafe Right")
					InputBox(x + 160 * MenuScale, y + 80 * MenuScale,100*MenuScale,20*MenuScale,KeyName[Min(KEY_RIGHT,210)],4)	
					AAText(x + 20 * MenuScale, y + 100 * MenuScale, "Quick Save")
					InputBox(x + 160 * MenuScale, y + 100 * MenuScale,100*MenuScale,20*MenuScale,KeyName[Min(KEY_SAVE,210)],11)
					
					AAText(x + 280 * MenuScale, y + 20 * MenuScale, "Manual Blink")
					InputBox(x + 470 * MenuScale, y + 20 * MenuScale,100*MenuScale,20*MenuScale,KeyName[Min(KEY_BLINK,210)],7)				
					AAText(x + 280 * MenuScale, y + 40 * MenuScale, "Sprint")
					InputBox(x + 470 * MenuScale, y + 40 * MenuScale,100*MenuScale,20*MenuScale,KeyName[Min(KEY_SPRINT,210)],8)
					AAText(x + 280 * MenuScale, y + 60 * MenuScale, "Open/Close Inventory")
					InputBox(x + 470 * MenuScale, y + 60 * MenuScale,100*MenuScale,20*MenuScale,KeyName[Min(KEY_INV,210)],9)
					AAText(x + 280 * MenuScale, y + 80 * MenuScale, "Crouch")
					InputBox(x + 470 * MenuScale, y + 80 * MenuScale,100*MenuScale,20*MenuScale,KeyName[Min(KEY_CROUCH,210)],10)	
					AAText(x + 280 * MenuScale, y + 100 * MenuScale, "Open/Close Console")
					InputBox(x + 470 * MenuScale, y + 100 * MenuScale,100*MenuScale,20*MenuScale,KeyName[Min(KEY_CONSOLE,210)],12)
					
					if (MouseOn(x+20*MenuScale,y,width-40*MenuScale,120*MenuScale)) {
						DrawOptionsTooltip(tx,ty,tw,th,"controls")
					}
					let key
					for (let i of range(228)) {
						if (KeyHit(i)) {
							key = i
							Exit()
						}
					}
					if (key != 0) {
						switch (SelectedInputBox) {
							case 3:
								KEY_LEFT = key
							case 4:
								KEY_RIGHT = key
							case 5:
								KEY_UP = key
							case 6:
								KEY_DOWN = key
							case 7:
								KEY_BLINK = key
							case 8:
								KEY_SPRINT = key
							case 9:
								KEY_INV = key
							case 10:
								KEY_CROUCH = key
							case 11:
								KEY_SAVE = key
							case 12:
								KEY_CONSOLE = key
						}
						SelectedInputBox = 0
					}
					//[End Block]
				} else if (MainMenuTab = 7) { //Advanced
					//[Block]
					height = 320 * MenuScale
					DrawFrame(x, y, width, height)	
					
					y = y + 20*MenuScale
					
					Color (255,255,255				)
					AAText(x + 20 * MenuScale, y, "Show HUD:")	
					HUDenabled = DrawTick(x + 310 * MenuScale, y + MenuScale, HUDenabled)
					if (MouseOn(x+310*MenuScale,y+MenuScale,20*MenuScale,20*MenuScale)) {
						DrawOptionsTooltip(tx,ty,tw,th,"hud")
					}
					
					y=y+30*MenuScale
					
					Color (255,255,255)
					AAText(x + 20 * MenuScale, y, "Enable console:")
					CanOpenConsole = DrawTick(x + 310 * MenuScale, y + MenuScale, CanOpenConsole)
					if (MouseOn(x+310*MenuScale,y+MenuScale,20*MenuScale,20*MenuScale)) {
						DrawOptionsTooltip(tx,ty,tw,th,"consoleenable")
					}
					
					y = y + 30*MenuScale
					
					Color (255,255,255)
					AAText(x + 20 * MenuScale, y, "Open console on error:")
					ConsoleOpening = DrawTick(x + 310 * MenuScale, y + MenuScale, ConsoleOpening)
					if (MouseOn(x+310*MenuScale,y+MenuScale,20*MenuScale,20*MenuScale)) {
						DrawOptionsTooltip(tx,ty,tw,th,"consoleerror")
					}
					
					y = y + 50*MenuScale
					
					Color (255,255,255)
					AAText(x + 20 * MenuScale, y, "Achievement popups:")
					AchvMSGenabled = DrawTick(x + 310 * MenuScale, y + MenuScale, AchvMSGenabled)
					if (MouseOn(x+310*MenuScale,y+MenuScale,20*MenuScale,20*MenuScale)) {
						DrawOptionsTooltip(tx,ty,tw,th,"achpopup")
					}
					
					y = y + 50*MenuScale
					
					Color (255,255,255)
					AAText(x + 20 * MenuScale, y, "Show FPS:")
					ShowFPS = DrawTick(x + 310 * MenuScale, y + MenuScale, ShowFPS)
					if (MouseOn(x+310*MenuScale,y+MenuScale,20*MenuScale,20*MenuScale)) {
						DrawOptionsTooltip(tx,ty,tw,th,"showfps")
					}
					
					y = y + 30*MenuScale
					
					Color (255,255,255)
					AAText(x + 20 * MenuScale, y, "Framelimit:")
					Color (255,255,255)
					if (DrawTick(x + 310 * MenuScale, y, CurrFrameLimit > 0.0)) {
						CurrFrameLimit = (SlideBar(x + 150*MenuScale, y+30*MenuScale, 100*MenuScale, CurrFrameLimit*99.0)/99.0)
						CurrFrameLimit = Max(CurrFrameLimit, 0.01)
						Framelimit = 19+(CurrFrameLimit*100.0)
						Color (255,255,0)
						AAText(x + 25 * MenuScale, y + 25 * MenuScale, Framelimit%+" FPS")
					} else {
						CurrFrameLimit = 0.0
						Framelimit = 0
					}
					if (MouseOn(x+310*MenuScale,y+MenuScale,20*MenuScale,20*MenuScale)) {
						DrawOptionsTooltip(tx,ty,tw,th,"framelimit",Framelimit)
					}
					if (MouseOn(x+150*MenuScale,y+30*MenuScale,100*MenuScale+14,20)) {
						DrawOptionsTooltip(tx,ty,tw,th,"framelimit",Framelimit)
					}
					
					y = y + 80*MenuScale
					
					Color (255,255,255)
					AAText(x + 20 * MenuScale, y, "Antialiased text:")
					AATextEnable = DrawTick(x + 310 * MenuScale, y + MenuScale, AATextEnable)
					if (AATextEnable_Prev != AATextEnable) {
						for (let font of AAFont.each) {
							FreeFont (font.lowResFont)
							if (!AATextEnable) {
								FreeTexture (font.texture)
								FreeImage (font.backup)
							}
							Delete (font)
						}
						if (!AATextEnable) {
							FreeEntity (AATextCam)
						}
						InitAAFont()
						Font1 = AALoadFont("GFX/font/cour/Courier New.ttf", Int(18 * (GraphicHeight / 1024.0)), 0,0,0)
						Font2 = AALoadFont("GFX/font/courbd/Courier New.ttf", Int(58 * (GraphicHeight / 1024.0)), 0,0,0)
						Font3 = AALoadFont("GFX/font/DS-DIGI/DS-Digital.ttf", Int(22 * (GraphicHeight / 1024.0)), 0,0,0)
						Font4 = AALoadFont("GFX/font/DS-DIGI/DS-Digital.ttf", Int(60 * (GraphicHeight / 1024.0)), 0,0,0)
						Font5 = AALoadFont("GFX/font/Journal/Journal.ttf", Int(58 * (GraphicHeight / 1024.0)), 0,0,0)
						ConsoleFont = AALoadFont("Blitz", Int(22 * (GraphicHeight / 1024.0)), 0,0,0,1)
						AATextEnable_Prev = AATextEnable
					}
					if (MouseOn(x+310*MenuScale,y+MenuScale,20*MenuScale,20*MenuScale)) {
						DrawOptionsTooltip(tx,ty,tw,th,"antialiastext")
					}
					//[End Block]
				}
				//[End Block]
			case 4: // load map
				//[Block]
				y = y + height + 20 * MenuScale
				width = 580 * MenuScale
				height = 510 * MenuScale
				
				DrawFrame(x, y, width, height)
				
				x = 159 * MenuScale
				y = 286 * MenuScale
				
				width = 400 * MenuScale
				height = 70 * MenuScale
				
				Color(255, 255, 255)
				AASetFont (Font2)
				AAText(x + width / 2, y + height / 2, "LOAD MAP", true, true)
				
				x = 160 * MenuScale
				y = y + height + 20 * MenuScale
				width = 580 * MenuScale
				height = 350 * MenuScale
				
				AASetFont (Font2)
				
				tx = x+width
				ty = y
				tw = 400*MenuScale
				th = 150*MenuScale
				
				if (CurrLoadGamePage < Ceil(Float(SavedMapsAmount)/6.0)-1) {
					if (DrawButton(x+530*MenuScale, y + 510*MenuScale, 50*MenuScale, 55*MenuScale, ">")) {
						CurrLoadGamePage = CurrLoadGamePage+1
					}
				} else {
					DrawFrame(x+530*MenuScale, y + 510*MenuScale, 50*MenuScale, 55*MenuScale)
					Color(100, 100, 100)
					AAText(x+555*MenuScale, y + 537.5*MenuScale, ">", true, true)
				}
				if (CurrLoadGamePage > 0) {
					if (DrawButton(x, y + 510*MenuScale, 50*MenuScale, 55*MenuScale, "<")) {
						CurrLoadGamePage = CurrLoadGamePage-1
					}
				} else {
					DrawFrame(x, y + 510*MenuScale, 50*MenuScale, 55*MenuScale)
					Color(100, 100, 100)
					AAText(x+25*MenuScale, y + 537.5*MenuScale, "<", true, true)
				}
				
				DrawFrame(x+50*MenuScale,y+510*MenuScale,width-100*MenuScale,55*MenuScale)
				
				AAText(x+(width/2.0),y+536*MenuScale,"Page "+Int(Max((CurrLoadGamePage+1),1))+"/"+Int(Max((Int(Ceil(Float(SavedMapsAmount)/6.0))),1)),true,true)
				
				AASetFont(Font1)
				
				if (CurrLoadGamePage > Ceil(Float(SavedMapsAmount)/6.0)-1) {
					CurrLoadGamePage = CurrLoadGamePage - 1
				}
				
				AASetFont(Font1)
				
				if (SavedMaps(0)="") {
					AAText (x + 20 * MenuScale, y + 20 * MenuScale, "No saved maps. Use the Map Creator to create new maps.")
				} else {
					x = x + 20 * MenuScale
					y = y + 20 * MenuScale
					for (i of range((1+(6*CurrLoadGamePage)), 6+(6*CurrLoadGamePage) + 1)) {
						if (i <= SavedMapsAmount) {
							DrawFrame(x,y,540* MenuScale, 70* MenuScale)
							
							AAText(x + 20 * MenuScale, y + 10 * MenuScale, SavedMaps(i - 1))
							AAText(x + 20 * MenuScale, y + (10+27) * MenuScale, SavedMapsAuthor(i - 1))
							
							if (DrawButton(x + 400 * MenuScale, y + 20 * MenuScale, 100 * MenuScale, 30 * MenuScale, "Load", false)) {
								SelectedMap=SavedMaps(i - 1)
								MainMenuTab = 1
							}
							if (MouseOn(x + 400 * MenuScale, y + 20 * MenuScale, 100*MenuScale,30*MenuScale)) {
								DrawMapCreatorTooltip(tx,ty,tw,th,SavedMaps(i-1))
							}
							
							y = y + 80 * MenuScale
						} else {
							Exit()
						}
					}
				}
				//[End Block]
		}
		
	}
	
	Color(255,255,255)
	AASetFont(ConsoleFont)
	AAText(20,GraphicHeight-30,"v"+VersionNumber)
	
	//DrawTiledImageRect(MenuBack, 985 * MenuScale, 860 * MenuScale, 200 * MenuScale, 20 * MenuScale, 1200 * MenuScale, 866 * MenuScale, 300, 20 * MenuScale)
	
	if (Fullscreen) {
		DrawImage(CursorIMG, ScaledMouseX(),ScaledMouseY())
	}
	
	AASetFont(Font1)
}

function UpdateLauncher() {
	MenuScale = 1
	
	Graphics3DExt(LauncherWidth, LauncherHeight, 0, 2)

	//InitExt
	
	SetBuffer (BackBuffer())
	
	RealGraphicWidth = GraphicWidth
	RealGraphicHeight = GraphicHeight
	
	Font1 = LoadFont_Strict("GFX/font/cour/Courier New.ttf", 18, 0,0,0)
	SetFont (Font1)
	MenuWhite = LoadImage_Strict("GFX/menu/menuwhite.jpg")
	MenuBlack = LoadImage_Strict("GFX/menu/menublack.jpg")	
	MaskImage (MenuBlack, 255,255,0)
	LauncherIMG = LoadImage_Strict("GFX/menu/launcher.jpg")
	ButtonSFX = LoadSound_Strict("SFX/Interact/Button.ogg")
	let i: int	
	
	for (i of range(4)) {
		ArrowIMG(i) = LoadImage_Strict("GFX/menu/arrow.png")
		RotateImage(ArrowIMG(i), 90 * i)
		HandleImage(ArrowIMG(i), 0, 0)
	}
	
	for (i of range(1, TotalGFXModes + 1)) {
		let samefound: boolean = false
		for (n of range(TotalGFXModes)) {
			if (GfxModeWidths(n) == GfxModeWidth(i) && GfxModeHeights(n) == GfxModeHeight(i)) {
				samefound = true
				Exit
			}
		}
		if (samefound = false) {
			if (GraphicWidth == GfxModeWidth(i) && GraphicHeight == GfxModeHeight(i)) {
				SelectedGFXMode = GFXModes
			}
			GfxModeWidths(GFXModes) = GfxModeWidth(i)
			GfxModeHeights(GFXModes) = GfxModeHeight(i)
			GFXModes=GFXModes+1 
		}
	}
	
	BlinkMeterIMG = LoadImage_Strict("GFX/blinkmeter.jpg")
	CheckForUpdates()
	
	AppTitle ("SCP - Containment Breach Launcher")
	
	while (true) {
		
		//Cls
		Color(0,0,0)
		Rect(0,0,LauncherWidth,LauncherHeight,true)
		
		MouseHit1 = MouseHit(1)
		
		Color(255, 255, 255)
		DrawImage(LauncherIMG, 0, 0)
		
		BBText(20, 240 - 65, "Resolution: ")
		
		let x: int = 40
		let y: int = 270 - 65
		for (i of range(GFXModes)) {
			Color(0, 0, 0)
			if (SelectedGFXMode = i) {Rect(x - 1, y - 1, 100, 20, false)}
			
			BBText(x, y, (GfxModeWidths(i) + "x" + GfxModeHeights(i)))
			if (MouseOn(x - 1, y - 1, 100, 20)) {
				Color(100, 100, 100)
				Rect(x - 1, y - 1, 100, 20, false)
				if (MouseHit1) {SelectedGFXMode = i}
			}
			
			y=y+20
			if (y >= 250 - 65 + (LauncherHeight - 80 - 260)) {
				y = 270 - 65
				x=x+100
			}
		}
		
		//-----------------------------------------------------------------
		Color(255, 255, 255)
		x = 30
		y = 369
		Rect(x - 10, y, 340, 95)
		BBText(x - 10, y - 25, "Graphics:")
		
		y=y+10
		for (i of range(1, CountGfxDrivers() + 1)) {
			Color(0, 0, 0)
			if (SelectedGFXDriver = i) {Rect(x - 1, y - 1, 290, 20, false)}
			LimitText(GfxDriverName(i), x, y, 290, false)
			if (MouseOn(x - 1, y - 1, 290, 20)) {
				Color(100, 100, 100)
				Rect(x - 1, y - 1, 290, 20, false)
				if (MouseHit1) {
					SelectedGFXDriver = i
				}
			}
			
			y=y+20
		}
		
		Fullscreen = DrawTick(40 + 430 - 15, 260 - 55 + 5 - 8, Fullscreen, BorderlessWindowed)
		BorderlessWindowed = DrawTick(40 + 430 - 15, 260 - 55 + 35, BorderlessWindowed)
		lock = false

		if (BorderlessWindowed || (!Fullscreen)) {
			lock = true
		}
		Bit16Mode = DrawTick(40 + 430 - 15, 260 - 55 + 65 + 8, Bit16Mode,lock)
		LauncherEnabled = DrawTick(40 + 430 - 15, 260 - 55 + 95 + 8, LauncherEnabled)

		if (BorderlessWindowed) {
 		   Color(255, 0, 0)
 		   Fullscreen = false
		} else {
  		  Color(255, 255, 255)
		}

		BBText(40 + 430 + 15, 262 - 55 + 5 - 8, "Fullscreen")
		Color(255, 255, 255)
		BBText(40 + 430 + 15, 262 - 55 + 35 - 8, "Borderless",false,false)
		BBText(40 + 430 + 15, 262 - 55 + 35 + 12, "windowed mode",false,false)

		if (BorderlessWindowed || (!Fullscreen)) {
 		   Color(255, 0, 0)
 		   Bit16Mode = false
		} else {
		    Color(255, 255, 255)
		}

		BBText(40 + 430 + 15, 262 - 55 + 65 + 8, "16 Bit")
		Color(255, 255, 255)
		BBText(40 + 430 + 15, 262 - 55 + 95 + 8, "Use launcher")
		
		if (!BorderlessWindowed) {
			if (Fullscreen) {
				BBText(40+ 260 + 15, 262 - 55 + 140, "Current Resolution: "+(GfxModeWidths[SelectedGFXMode] + "x" + GfxModeHeights[SelectedGFXMode] + "," + (16+(16*(!Bit16Mode)))))
			} else {
				BBText(40+ 260 + 15, 262 - 55 + 140, "Current Resolution: "+(GfxModeWidths[SelectedGFXMode] + "x" + GfxModeHeights[SelectedGFXMode] + ",32"))
			}
		} else {
			BBText(40+ 260 + 15, 262 - 55 + 140, "Current Resolution: "+GfxModeWidths[SelectedGFXMode] + "x" + GfxModeHeights[SelectedGFXMode] + ",32")
			if (GfxModeWidths[SelectedGFXMode]<G_viewport_width) {
				BBText(40+ 260 + 65, 262 - 55 + 160, "(upscaled to")
				BBText(40+ 260 + 65, 262 - 55 + 180, G_viewport_width + "x" + G_viewport_height + ",32)")
		 	} else if (GfxModeWidths[SelectedGFXMode]>G_viewport_width) {
				BBText(40+ 260 + 65, 262 - 55 + 160, "(downscaled to")
				BBText(40+ 260 + 65, 262 - 55 + 180, G_viewport_width + "x" + G_viewport_height + ",32)")
			}
		}
		
		UpdateCheckEnabled = DrawTick(LauncherWidth - 275, LauncherHeight - 50, UpdateCheckEnabled)
		Color(255,255,255)
		BBText(LauncherWidth-250,LauncherHeight-70,"Check for")
		BBText(LauncherWidth-250,LauncherHeight-50,"updates on")
		BBText(LauncherWidth-250,LauncherHeight-30,"launch")
		
		if (DrawButton(LauncherWidth - 30 - 90, LauncherHeight - 50 - 55, 100, 30, "LAUNCH", false, false, false)) {
			GraphicWidth = GfxModeWidths(SelectedGFXMode)
			GraphicHeight = GfxModeHeights(SelectedGFXMode)
			RealGraphicWidth = GraphicWidth
			RealGraphicHeight = GraphicHeight
			break
		}
		
		if (DrawButton(LauncherWidth - 30 - 90, LauncherHeight - 50, 100, 30, "EXIT", false, false, false)) {End()}
		Flip()
	}
	
	PutINIValue(OptionFile, "options", "width", GfxModeWidths(SelectedGFXMode))
	PutINIValue(OptionFile, "options", "height", GfxModeHeights(SelectedGFXMode))
	if (Fullscreen) {
		PutINIValue(OptionFile, "options", "fullscreen", "true")
	} else {
		PutINIValue(OptionFile, "options", "fullscreen", "false")
	}
	if (LauncherEnabled) {
		PutINIValue(OptionFile, "launcher", "launcher enabled", "true")
	} else {
		PutINIValue(OptionFile, "launcher", "launcher enabled", "false")
	}
	if (BorderlessWindowed) {
		PutINIValue(OptionFile, "options", "borderless windowed", "true")
	} else {
		PutINIValue(OptionFile, "options", "borderless windowed", "false")
	}
	if (Bit16Mode) {
		PutINIValue(OptionFile, "options", "16bit", "true")
	} else {
		PutINIValue(OptionFile, "options", "16bit", "false")
	}
	PutINIValue(OptionFile, "options", "gfx driver", SelectedGFXDriver)
	if (UpdateCheckEnabled) {
		PutINIValue(OptionFile, "options", "check for updates", "true")
	} else {
		PutINIValue(OptionFile, "options", "check for updates", "false")
	}
	
}


function DrawTiledImageRect(img: int, srcX: int, srcY: int, srcwidth: float, srcheight: float, x: int, y: int, width: int, height: int) {
	
	let x2: int = x
	while (x2 < x+width) {
		let y2: int = y
		while (y2 < y+height) {
			if (x2 + srcwidth > x + width) {
				srcwidth = srcwidth - Max((x2 + srcwidth) - (x + width), 1)
			}
			if (y2 + srcheight > y + height) {
				srcheight = srcheight - Max((y2 + srcheight) - (y + height), 1)
			}
			DrawImageRect(img, x2, y2, srcX, srcY, srcwidth, srcheight)
			y2 = y2 + srcheight
		}
		x2 = x2 + srcwidth
	}
}

class LoadingScreens {
	imgpath: string
	img: int
	ID: int
	title: string
	alignx: int
	aligny: int
	disablebackground: int
	txt: string[] = new Array(5)
	txtamount: int
}

function InitLoadingScreens(file: string) {
	let TemporaryString: string
	let i: int
	let ls: LoadingScreens
	
	let f = OpenFile(file)
	
	while (!Eof(f)) {
		TemporaryString = Trim(ReadLine(f))
		if (Left(TemporaryString,1) = "[") {
			TemporaryString = Mid(TemporaryString, 2, Len(TemporaryString) - 2)
			
			ls.LoadingScreens = new LoadingScreens()
			LoadingScreenAmount=LoadingScreenAmount+1
			ls.ID = LoadingScreenAmount
			
			ls.title = TemporaryString
			ls.imgpath = GetINIString(file, TemporaryString, "image path")
			
			for (i of range(5)) {
				ls.txt[i] = GetINIString(file, TemporaryString, "text"+(i+1))
				if (ls.txt[i] != "") {ls.txtamount=ls.txtamount+1}
			}
			
			ls.disablebackground = GetINIInt(file, TemporaryString, "disablebackground")
			
			switch (Lower(GetINIString(file, TemporaryString, "align x"))) {
				case "left":
					ls.alignx = -1
				case "middle", "center":
					ls.alignx = 0
				case "right" :
					ls.alignx = 1
			} 
			
			switch (Lower(GetINIString(file, TemporaryString, "align y"))) {
				case "top", "up":
					ls.aligny = -1
				case "middle", "center":
					ls.aligny = 0
				case "bottom", "down":
					ls.aligny = 1
			} 			
			
		}
	}
	
	CloseFile (f)
}

function DrawLoading(percent: int, shortloading: boolean = false) {
	
	let x: int
	let y: int
	
	if (percent = 0) {
		LoadingScreenText=0
		
		temp = Rand(1,LoadingScreenAmount)
		for (ls of LoadingScreens.each) {
			if (ls.id = temp) {
				if (ls.img=0) {
					ls.img = LoadImage_Strict("Loadingscreens/"+ls.imgpath)
				}
				SelectedLoadingScreen = ls 
				Exit()
			}
		}
	}	
	
	firstloop = true
	do { 
		
		ClsColor (0,0,0)
		Cls()
				
		if (percent > 20) {
			UpdateMusic()
		}
		
		if (shortloading = false) {
			if (percent > (100.0 / SelectedLoadingScreen.txtamount)*(LoadingScreenText+1)) {
				LoadingScreenText=LoadingScreenText+1
			}
		}
		
		if (!SelectedLoadingScreen.disablebackground) {
			DrawImage (LoadingBack, GraphicWidth/2 - ImageWidth(LoadingBack)/2, GraphicHeight/2 - ImageHeight(LoadingBack)/2)
		}	
		
		if (SelectedLoadingScreen.alignx = 0) {
			x = GraphicWidth/2 - ImageWidth(SelectedLoadingScreen.img)/2 
		} else if (SelectedLoadingScreen.alignx = 1) {
			x = GraphicWidth - ImageWidth(SelectedLoadingScreen.img)
		} else {
			x = 0
		}
		
		if (SelectedLoadingScreen.aligny = 0) {
			y = GraphicHeight/2 - ImageHeight(SelectedLoadingScreen.img)/2 
		} else if (SelectedLoadingScreen.aligny = 1) {
			y = GraphicHeight - ImageHeight(SelectedLoadingScreen.img)
		} else {
			y = 0
		}
		
		DrawImage (SelectedLoadingScreen.img, x, y)
		
		let width: int = 300, height: int = 20
		x = GraphicWidth / 2 - width / 2
		y = GraphicHeight / 2 + 30 - 100
		
		Rect(x, y, width+4, height, false)
		for (i of range(1, Int((width - 2) * (percent / 100.0) / 10) + 1)) {
			DrawImage(BlinkMeterIMG, x + 3 + 10 * (i - 1), y + 3)
		}
		
		if (SelectedLoadingScreen.title = "CWM") {
			
			if (!shortloading) {
				if (firstloop) {
					if (percent = 0) {
						PlaySound_Strict (LoadTempSound("SFX/SCP/990/cwm1.cwm"))
					} else if (percent = 100) {
						PlaySound_Strict (LoadTempSound("SFX/SCP/990/cwm2.cwm"))
					}
				}
			}
			
			AASetFont (Font2)
			strtemp$ = ""
			temp = Rand(2,9)
			for (i of range(temp + 1)) {
				strtemp$ = STRTEMP + Chr(Rand(48,122))
			}
			AAText(GraphicWidth / 2, GraphicHeight / 2 + 80, strtemp, true, true)
			
			if (percent = 0) {
				if (Rand(5)=1) {
					switch (Rand(2)) {
						case 1:
							SelectedLoadingScreen.txt[0] = "It will happen on " + CurrentDate() + "."
						case 2:
							SelectedLoadingScreen.txt[0] = CurrentTime()
					}
				} else {
					switch (Rand(13)) {
						case 1:
							SelectedLoadingScreen.txt[0] = "A very fine radio might prove to be useful."
						case 2:
							SelectedLoadingScreen.txt[0] = "ThIS PLaCE WiLL BUrN"
						case 3:
							SelectedLoadingScreen.txt[0] = "You cannot control it."
						case 4:
							SelectedLoadingScreen.txt[0] = "eof9nsd3jue4iwe1fgj"
						case 5:
							SelectedLoadingScreen.txt[0] = "YOU NEED TO TRUST IT"
						case 6 :
							SelectedLoadingScreen.txt[0] = "Look my friend in the eye when you address him, isn't that the way of the gentleman?"
						case 7:
							SelectedLoadingScreen.txt[0] = "???____??_???__????n?"
						case 8, 9:
							SelectedLoadingScreen.txt[0] = "Jorge has been expecting you."
						case 10:
							SelectedLoadingScreen.txt[0] = "???????????"
						case 11:
							SelectedLoadingScreen.txt[0] = "Make her a member of the midnight crew."
						case 12:
							SelectedLoadingScreen.txt[0] = "oncluded that coming here was a mistake. We have to turn back."
						case 13:
							SelectedLoadingScreen.txt[0] = "This alloy contains the essence of my life."
					}
				}
			}
			
			strtemp$ = SelectedLoadingScreen.txt[0]
			temp = Int(Len(SelectedLoadingScreen.txt[0])-Rand(5))
			for (i of range(Rand(10,15) + 1)) {
				strtemp$ = Replace(SelectedLoadingScreen.txt[0],Mid(SelectedLoadingScreen.txt[0],Rand(1,Len(strtemp)-1),1),Chr(Rand(130,250)))
			}		
			AASetFont (Font1)
			RowText(strtemp, GraphicWidth / 2-200, GraphicHeight / 2 +120,400,300,true)		
		} else {
			
			Color (0,0,0)
			AASetFont (Font2)
			AAText(GraphicWidth / 2 + 1, GraphicHeight / 2 + 80 + 1, SelectedLoadingScreen.title, true, true)
			AASetFont (Font1)
			RowText(SelectedLoadingScreen.txt[LoadingScreenText], GraphicWidth / 2-200+1, GraphicHeight / 2 +120+1,400,300,true)
			
			Color (255,255,255)
			AASetFont (Font2)
			AAText(GraphicWidth / 2, GraphicHeight / 2 +80, SelectedLoadingScreen.title, true, true)
			AASetFont (Font1)
			RowText(SelectedLoadingScreen.txt[LoadingScreenText], GraphicWidth / 2-200, GraphicHeight / 2 +120,400,300,true)
			
		}
		
		Color (0,0,0)
		AAText(GraphicWidth / 2 + 1, GraphicHeight / 2 - 100 + 1, "LOADING - " + percent + " %", true, true)
		Color (255,255,255)
		AAText(GraphicWidth / 2, GraphicHeight / 2 - 100, "LOADING - " + percent + " %", true, true)
		
		if (percent = 100) {
			if (firstloop && SelectedLoadingScreen.title != "CWM") {
				PlaySound_Strict (LoadTempSound(("SFX/Horror/Horror8.ogg")))
			}
			AAText(GraphicWidth / 2, GraphicHeight - 50, "PRESS ANY KEY TO CONTINUE", true, true)
		} else {
			FlushKeys()
			FlushMouse()
		}
		
		if (BorderlessWindowed) {
			if ((RealGraphicWidth != GraphicWidth) || (RealGraphicHeight != GraphicHeight)) {
				SetBuffer (TextureBuffer(fresize_texture))
				ClsColor (0,0,0)
				Cls()
				CopyRect (0,0,GraphicWidth,GraphicHeight,1024-GraphicWidth/2,1024-GraphicHeight/2,BackBuffer(),TextureBuffer(fresize_texture))
				SetBuffer (BackBuffer())
				ClsColor (0,0,0)
				Cls()
				ScaleRender(0,0,2050.0 / Float(GraphicWidth) * AspectRatioRatio, 2050.0 / Float(GraphicWidth) * AspectRatioRatio)
				//might want to replace Float(GraphicWidth) with Max(GraphicWidth,GraphicHeight) if portrait sizes cause issues
				//everyone uses landscape so it's probably a non-issue
			}
		}
		
		//not by any means a perfect solution
		//Not even proper gamma correction but it's a nice looking alternative that works in windowed mode
		if (ScreenGamma>1.0) {
			CopyRect (0,0,RealGraphicWidth,RealGraphicHeight,1024-RealGraphicWidth/2,1024-RealGraphicHeight/2,BackBuffer(),TextureBuffer(fresize_texture))
			EntityBlend (fresize_image,1)
			ClsColor (0,0,0)
			Cls()
			ScaleRender(-1.0/Float(RealGraphicWidth),1.0/Float(RealGraphicWidth),2048.0 / Float(RealGraphicWidth),2048.0 / Float(RealGraphicWidth))
			EntityFX (fresize_image,1+32)
			EntityBlend (fresize_image,3)
			EntityAlpha (fresize_image,ScreenGamma-1.0)
			ScaleRender(-1.0/Float(RealGraphicWidth),1.0/Float(RealGraphicWidth),2048.0 / Float(RealGraphicWidth),2048.0 / Float(RealGraphicWidth))
		} else if (ScreenGamma<1.0) { //todo: maybe optimize this if it's too slow, alternatively give players the option to disable gamma
			CopyRect (0,0,RealGraphicWidth,RealGraphicHeight,1024-RealGraphicWidth/2,1024-RealGraphicHeight/2,BackBuffer(),TextureBuffer(fresize_texture))
			EntityBlend (fresize_image,1)
			ClsColor (0,0,0)
			Cls()
			ScaleRender(-1.0/Float(RealGraphicWidth),1.0/Float(RealGraphicWidth),2048.0 / Float(RealGraphicWidth),2048.0 / Float(RealGraphicWidth))
			EntityFX (fresize_image,1+32)
			EntityBlend (fresize_image,2)
			EntityAlpha (fresize_image,1.0)
			SetBuffer (TextureBuffer(fresize_texture2))
			ClsColor (255*ScreenGamma,255*ScreenGamma,255*ScreenGamma)
			Cls()
			SetBuffer (BackBuffer())
			ScaleRender(-1.0/Float(RealGraphicWidth),1.0/Float(RealGraphicWidth),2048.0 / Float(RealGraphicWidth),2048.0 / Float(RealGraphicWidth))
			SetBuffer(TextureBuffer(fresize_texture2))
			ClsColor (0,0,0)
			Cls()
			SetBuffer(BackBuffer())
		}
		EntityFX (fresize_image,1)
		EntityBlend (fresize_image,1)
		EntityAlpha (fresize_image,1.0)
		
		Flip (false)
		
		firstloop = false
		if (percent != 100) {
			Exit()
		}
		
 	} while (!((GetKey() != 0 || MouseHit(1))))
}



function rInput(aString: string): string {
	let value: int = GetKey()
	let length: int = Len(aString$)
	
	if (value = 8) {
		value = 0
		if (length > 0) {
			aString$ = Left(aString, length - 1)
		}
	}
	
	if (value = 13 || value == 0) {
		return aString
	} else if (value > 0 && value < 7 || value > 26 && value < 32 || value == 9) {
		return aString
	} else {
		aString$ = aString$ + Chr(value)
		return aString
	}
}

function InputBox(x: int, y: int, width: int, height: int, Txt: string, ID: int = 0) : string {
	//TextBox(x,y,width,height,Txt$)
	Color (255, 255, 255)
	DrawTiledImageRect(MenuWhite, (x % 256), (y % 256), 512, 512, x, y, width, height)
	//Rect(x, y, width, height)
	Color (0, 0, 0)
	
	let MouseOnBox: boolean = false
	if (MouseOn(x, y, width, height)) {
		Color(50, 50, 50)
		MouseOnBox = true
		if (MouseHit1) {
			SelectedInputBox = ID
			FlushKeys()
		}
	}
	
	Rect(x + 2, y + 2, width - 4, height - 4)
	Color (255, 255, 255)	
	
	if ((!MouseOnBox) && MouseHit1 && SelectedInputBox == ID) {
		SelectedInputBox = 0
	}
	
	if (SelectedInputBox = ID) {
		Txt = rInput(Txt)
		if ((MilliSecs2() % 800) < 400) {
			Rect (x + width / 2 + AAStringWidth(Txt) / 2 + 2, y + height / 2 - 5, 2, 12)
		}
	}	
	
	AAText(x + width / 2, y + height / 2, Txt, true, true)
	
	return Txt
}

function DrawFrame(x: int, y: int, width: int, height: int, xoffset: int=0, yoffset: int=0) {
	Color (255, 255, 255)
	DrawTiledImageRect(MenuWhite, xoffset, (y % 256), 512, 512, x, y, width, height)
	
	DrawTiledImageRect(MenuBlack, yoffset, (y % 256), 512, 512, x+3*MenuScale, y+3*MenuScale, width-6*MenuScale, height-6*MenuScale)	
}

function DrawButton(x: int, y: int, width: int, height: int, txt$, bigfont: boolean = true, waitForMouseUp: boolean=false, usingAA: boolean=true) : int {
	let clicked: boolean = false
	
	DrawFrame (x, y, width, height)
	if (MouseOn(x, y, width, height)) {
		Color(30, 30, 30)
		if ((MouseHit1 && (!waitForMouseUp)) || (MouseUp1 && waitForMouseUp)) {
			clicked = true
			PlaySound_Strict(ButtonSFX)
		}
		Rect(x + 4, y + 4, width - 8, height - 8)	
	} else {
		Color(0, 0, 0)
	}
	
	Color (255, 255, 255)
	if (usingAA) {
		if (bigfont) {
			AASetFont(Font2)
		} else {
			AASetFont(Font1)
		}
		AAText(x + width / 2, y + height / 2, txt, true, true)
	} else {
		if (bigfont) {
			SetFont(Font2)
		} else {
			SetFont(Font1)
		}
		BBText(x + width / 2, y + height / 2, txt, true, true)
	}
	
	return clicked
}

function DrawButton2(x: int, y: int, width: int, height: int, txt$, bigfont: boolean = true) : int {
	let clicked: boolean = false
	
	DrawFrame (x, y, width, height)
	let hit: int = MouseHit(1)
	if (MouseOn(x, y, width, height)) {
		Color(30, 30, 30)
		if (hit) {
			clicked = true
			PlaySound_Strict(ButtonSFX)
		}
		Rect(x + 4, y + 4, width - 8, height - 8)	
	} else {
		Color(0, 0, 0)
	}
	
	Color (255, 255, 255)
	if (bigfont) {
		SetFont(Font2)
	} else {
		SetFont(Font1)
	}
	BBText(x + width / 2, y + height / 2, txt, true, true)
	
	return clicked
}

function DrawTick(x: int, y: int, selected: int, locked: boolean = false): int {
	let width: int = 20 * MenuScale
	let height: int = 20 * MenuScale
	
	Color (255, 255, 255)
	DrawTiledImageRect(MenuWhite, (x % 256), (y % 256), 512, 512, x, y, width, height)
	
	let Highlight: int = MouseOn(x, y, width, height) && (!locked)
	
	if (Highlight) {
		Color(50, 50, 50)
		if (MouseHit1) {
			selected = (!selected)
			PlaySound_Strict (ButtonSFX)
		}
	} else {
		Color(0, 0, 0)		
	}
	
	Rect(x + 2, y + 2, width - 4, height - 4)
	
	if (selected) {
		if (Highlight) {
			Color (255,255,255)
		} else {
			Color (200,200,200)
		}
		DrawTiledImageRect(MenuWhite, (x % 256), (y % 256), 512, 512, x + 4, y + 4, width - 8, height - 8)
	}
	
	Color (255, 255, 255)
	
	return selected
}

function SlideBar(x: int, y: int, width: int, value: float): float {
	
	if (MouseDown1 && OnSliderID == 0) {
		if (ScaledMouseX() >= x && ScaledMouseX() <= x + width + 14 && ScaledMouseY() >= y && ScaledMouseY() <= y + 20) {
			value = Min(Max((ScaledMouseX() - x) * 100 / width, 0), 100)
		}
	}
	
	Color (255,255,255)
	Rect(x, y, width + 14, 20,false)
	
	DrawImage(BlinkMeterIMG, x + width * value / 100.0 +3, y+3)
	
	Color (170,170,170 )
	AAText (x - 50 * MenuScale, y + 4*MenuScale, "LOW")					
	AAText (x + width + 38 * MenuScale, y+4*MenuScale, "HIGH")	
	
	return value
}

function RowText(A: string, X, Y, W, H, align: int = 0, Leading: float = 1) {
	//Display A$ starting at X,Y - no wider than W And no taller than H (all in pixels).
	//Leading is optional extra vertical spacing in pixels
	
	if (H<1) {H=2048}
	
	let LinesShown = 0
	let Height = AAStringHeight(A$) + Leading
	let b: string
	
	while (Len(A) > 0) {
		let space = Instr(A$, " ")
		if (space = 0) {space = Len(A$)}
		let temp$ = Left(A$, space)
		let trimmed$ = Trim(temp) //we might ignore a final space 
		let extra = 0 //we haven't ignored it yet
		//ignore final space If doing so would make a word fit at End of Line:
		if ((AAStringWidth (b$ + temp$) > W) && (AAStringWidth (b$ + trimmed$) <= W)) {
			temp = trimmed
			extra = 1
		}
		
		if (AAStringWidth (b$ + temp$) > W) { //too big, so Print what will fit
			if (align) {
				AAText(X + W / 2 - (AAStringWidth(b) / 2), LinesShown * Height + Y, b)
			} else {
				AAText(X, LinesShown * Height + Y, b)
			}		
			
			LinesShown = LinesShown + 1
			b$=""
		} else { //append it To b$ (which will eventually be printed) And remove it from A$
			b$ = b$ + temp$
			A$ = Right(A$, Len(A$) - (Len(temp$) + extra))
		}
		
		if (((LinesShown + 1) * Height) > H) {break} //the Next Line would be too tall, so leave
	}
	
	if ((b$ != "") && ((LinesShown + 1) <= H)) {
		if (align) {
			AAText(X + W / 2 - (AAStringWidth(b) / 2), LinesShown * Height + Y, b) //Print any remaining Text If it'll fit vertically
		} else {
			AAText(X, LinesShown * Height + Y, b) //Print any remaining Text If it'll fit vertically
		}
	}
}

function RowText2(A$, X, Y, W, H, align: int = 0, Leading: float = 1) {
	//Display A$ starting at X,Y - no wider than W And no taller than H (all in pixels).
	//Leading is optional extra vertical spacing in pixels
	
	if (H<1) {H=2048}
	
	let LinesShown = 0
	let Height = StringHeight(A$) + Leading
	let b: string
	
	while (Len(A) > 0) {
		let space = Instr(A$, " ")
		if (space = 0) {space = Len(A$)}
		let temp$ = Left(A$, space)
		let trimmed$ = Trim(temp) //we might ignore a final space 
		let extra = 0 //we haven't ignored it yet
		//ignore final space If doing so would make a word fit at End of Line:
		if ((StringWidth (b$ + temp$) > W) && (StringWidth (b$ + trimmed$) <= W)) {
			temp = trimmed
			extra = 1
		}
		
		if (StringWidth (b$ + temp$) > W) { //too big, so Print what will fit
			if (align) {
				BBText(X + W / 2 - (StringWidth(b) / 2), LinesShown * Height + Y, b)
			} else {
				BBText(X, LinesShown * Height + Y, b)
			}
			
			LinesShown = LinesShown + 1
			b$=""
		} else { //append it To b$ (which will eventually be printed) And remove it from A$
			b$ = b$ + temp$
			A$ = Right(A$, Len(A$) - (Len(temp$) + extra))
		}
		
		if (((LinesShown + 1) * Height) > H) {break} //the Next Line would be too tall, so leave
	}
	
	if ((b != "") && (LinesShown + 1 <= H)) {
		if (align) {
			BBText(X + W / 2 - (StringWidth(b) / 2), LinesShown * Height + Y, b) //Print any remaining BBText If it'll fit vertically
		} else {
			BBText(X, LinesShown * Height + Y, b) //Print any remaining Text If it'll fit vertically
		}
	}
	
}

function GetLineAmount(A$, W, H, Leading: float = 1) {
	//Display A$ starting at X,Y - no wider than W And no taller than H (all in pixels).
	//Leading is optional extra vertical spacing in pixels
	
	if (H<1) {
		H=2048
	}
	
	let LinesShown = 0
	let Height = AAStringHeight(A$) + Leading
	let b$
	
	while (Len(A) > 0) {
		let space = Instr(A$, " ")
		if (space = 0) {space = Len(A)}
		let temp: string = Left(A, space)
		let trimmed: string = Trim(temp) //we might ignore a final space 
		let extra = 0 //we haven't ignored it yet
		//ignore final space If doing so would make a word fit at End of Line:
		if ((AAStringWidth (b$ + temp$) > W) && (AAStringWidth (b$ + trimmed$) <= W)) {
			temp = trimmed
			extra = 1
		}
		
		if (AAStringWidth (b$ + temp$) > W) { //too big, so Print what will fit
			
			LinesShown = LinesShown + 1
			b$=""
		} else { //append it To b$ (which will eventually be printed) And remove it from A$
			b$ = b$ + temp$
			A$ = Right(A$, Len(A$) - (Len(temp$) + extra))
		}
		
		if (((LinesShown + 1) * Height) > H) {break} //the Next Line would be too tall, so leave
	}
	
	return LinesShown+1
}

function GetLineAmount2(A: string, W, H, Leading: float = 1) {
	//Display A$ starting at X,Y - no wider than W And no taller than H (all in pixels).
	//Leading is optional extra vertical spacing in pixels
	
	if (H<1) {H=2048}
	
	let LinesShown = 0
	let Height = StringHeight(A$) + Leading
	let b$
	
	while (Len(A) > 0) {
		let space = Instr(A$, " ")
		if (space = 0) {space = Len(A$)}
		let temp: string = Left(A, space)
		let trimmed: string = Trim(temp) //we might ignore a final space 
		let extra = 0 //we haven't ignored it yet
		//ignore final space If doing so would make a word fit at End of Line:
		if ((StringWidth (b$ + temp$) > W) && (StringWidth (b$ + trimmed$) <= W)) {
			temp = trimmed
			extra = 1
		}
		
		if (StringWidth (b$ + temp$) > W) { //too big, so Print what will fit
			
			LinesShown = LinesShown + 1
			b$=""
		} else { //append it To b$ (which will eventually be printed) And remove it from A$
			b$ = b$ + temp$
			A$ = Right(A$, Len(A$) - (Len(temp$) + extra))
		}
		
		if (((LinesShown + 1) * Height) > H) {Exit()} //the Next Line would be too tall, so leave
	}
	
	return LinesShown+1	
}

function LimitText(txt: string, x: int, y: int, width: int, usingAA: boolean = true): int {
	let TextLength: int
	let UnFitting: int
	let LetterWidth: int
	if (usingAA) {
		if (txt == "" || width == 0) {return 0}
		TextLength = AAStringWidth(txt)
		UnFitting = TextLength - width
		if (UnFitting <= 0) {
			AAText(x, y, txt)
		} else { //ei mahdu
			LetterWidth = TextLength / Len(txt)
			
			AAText(x, y, Left(txt, Max(Len(txt) - UnFitting / LetterWidth - 4, 1)) + "...")
		}
	} else {
		if (txt == "" || width == 0) {return 0}
		TextLength = StringWidth(txt)
		UnFitting = TextLength - width
		if (UnFitting <= 0) {
			BBText(x, y, txt)
		} else { //ei mahdu
			LetterWidth = TextLength / Len(txt)
			
			BBText(x, y, Left(txt, Max(Len(txt) - UnFitting / LetterWidth - 4, 1)) + "...")
		}
	}
}

function DrawTooltip(message: string) {
	let scale: float = GraphicHeight/768.0
	
	let width = (AAStringWidth(message$))+20*MenuScale
	
	Color (25,25,25)
	Rect(ScaledMouseX()+20,ScaledMouseY(),width,19*scale,true)
	Color (150,150,150)
	Rect(ScaledMouseX()+20,ScaledMouseY(),width,19*scale,false)
	AASetFont (Font1)
	AAText(ScaledMouseX()+(20*MenuScale)+(width/2),ScaledMouseY()+(12*MenuScale), message$, true, true)
}

var QuickLoadPercent: int = -1
var QuickLoadPercent_DisplayTimer: float = 0
var QuickLoad_CurrEvent: Events

function DrawQuickLoading() {
	
	if (QuickLoadPercent > -1) {
		MidHandle (QuickLoadIcon)
		DrawImage (QuickLoadIcon,GraphicWidth-90,GraphicHeight-150)
		Color (255,255,255)
		AASetFont (Font1)
		AAText (GraphicWidth-100,GraphicHeight-90,"LOADING: "+QuickLoadPercent+"%",1)
		if (QuickLoadPercent > 99) {
			if (QuickLoadPercent_DisplayTimer < 70) {
				QuickLoadPercent_DisplayTimer = Min(QuickLoadPercent_DisplayTimer+FPSfactor,70)
			} else {
				QuickLoadPercent = -1
			}
		}
		QuickLoadEvents()
	} else {
		QuickLoadPercent = -1
		QuickLoadPercent_DisplayTimer = 0
		QuickLoad_CurrEvent = Null
	}	
}

function DrawOptionsTooltip(x: int,y: int,width: int,height: int,option: string,value: float = 0,ingame: boolean = false) {
	let fx: float = x+6*MenuScale
	let fy: float = y+6*MenuScale
	let fw: float = width-12*MenuScale
	let fh: float = height-12*MenuScale
	let lines: int = 0
	let lines2: int = 0
	let txt: string = ""
	let txt2: string = ""
	let R: int = 0
	let G: int = 0
	let B: int = 0
	let usetestimg: int = false
	let extraspace: int = 0
	
	AASetFont (Font1)
	Color (255,255,255)
	switch (Lower(option)) {
		//Graphic options
		case "bump":
			txt = Chr(34)+"Bump mapping"+Chr(34)+" is used to simulate bumps and dents by distorting the lightmaps."
			txt2 = "This option cannot be changed in-game."
			R = 255
		case "vsync":
			txt = Chr(34)+"Vertical sync"+Chr(34)+" waits for the display to finish its current refresh cycle before calculating the next frame, preventing issues such as "
			txt = txt + "screen tearing. This ties the game's frame rate to your display's refresh rate and may cause some input lag."
		case "antialias":
			txt = Chr(34)+"Anti-Aliasing"+Chr(34)+" is used to smooth the rendered image before displaying in order to reduce aliasing around the edges of models."
			txt2 = "This option only takes effect in fullscreen."
			R = 255
		case "roomlights":
			txt = "Toggles the artificial lens flare effect generated over specific light sources."
		case "gamma":
			txt = Chr(34)+"Gamma correction"+Chr(34)+" is used to achieve a good brightness factor to balance out your display's gamma if the game appears either too dark or bright. "
			txt = txt + "Setting it too high or low can cause the graphics to look less detailed."
			R = 255
			G = 255
			B = 255
			txt2 = "Current value: "+Int(value*100)+"% (default is 100%)"
		case "texquality":
			txt = Chr(34)+"Texture LOD Bias"+Chr(34)+" affects the distance at which texture detail will change to prevent aliasing. Change this option if textures flicker or look too blurry."
		case "particleamount":
			txt = "Determines the amount of particles that can be rendered per tick."
			switch (value) {
				case 0:
					R = 255
					txt2 = "Only smoke emitters will produce particles."
				case 1:
					R = 255
					G = 255
					txt2 = "Only a few particles will be rendered per tick."
				case 2:
					G = 255
					txt2 = "All particles are rendered."
			}
		case "vram":
			txt = "Textures that are stored in the Video-RAM will load faster, but this also has negative effects on the texture quality as well."
			txt2 = "This option cannot be changed in-game."
			R = 255
			//[End Block]
		//Sound options
			//[Block]
		case "musicvol":
			txt = "Adjusts the volume of background music. Sliding the bar fully to the left will mute all music."
			R = 255
			G = 255
			B = 255
			txt2 = "Current value: "+Int(value*100)+"% (default is 50%)"
		case "soundvol":
			txt = "Adjusts the volume of sound effects. Sliding the bar fully to the left will mute all sounds."
			R = 255
			G = 255
			B = 255
			txt2 = "Current value: "+Int(value*100)+"% (default is 100%)"
		case "sfxautorelease":
			txt = Chr(34)+"Sound auto-release"+Chr(34)+" will free a sound from memory if it not used after 5 seconds. Prevents memory allocation issues."
			R = 255
			txt2 = "This option cannot be changed in-game."
		case "usertrack":
			txt = "Toggles the ability to play custom tracks over channel 1 of the radio. These tracks are loaded from the " + Chr(34) + "SFX/Radio/UserTracks/" + Chr(34)
			txt = txt + " directory. Press " + Chr(34) + "1" + Chr(34) + " when the radio is selected to change track."
			R = 255
			txt2 = "This option cannot be changed in-game."
		case "usertrackmode":
			txt = "Sets the playing mode for the custom tracks. "+Chr(34)+"Repeat"+Chr(34)+" plays every file in alphabetical order. "+Chr(34)+"Random"+Chr(34)+" chooses the "
			txt = txt + "next track at random."
			R = 255
			G = 255
			txt2 = "Note that the random mode does not prevent previously played tracks from repeating."
		case "usertrackscan":
			txt = "Re-checks the user tracks directory for any new or removed sound files."
			//[End Block]
		//Control options	
			//[Block]
		case "mousesensitivity":
			txt = "Adjusts the speed of the mouse pointer."
			R = 255
			G = 255
			B = 255
			txt2 = "Current value: "+Int((0.5+value)*100)+"% (default is 50%)"
		case "mouseinvert":
			txt = Chr(34)+"Invert mouse Y-axis"+Chr(34)+" is self-explanatory."
		case "mousesmoothing":
			txt = "Adjusts the amount of smoothing of the mouse pointer."
			R = 255
			G = 255
			B = 255
			txt2 = "Current value: "+Int(value*100)+"% (default is 100%)"
		case "controls":
			txt = "Configure the in-game control scheme."
			//[End Block]
		//Advanced options	
			//[Block]
		case "hud":
			txt = "Display the blink and stamina meters."
		case "consoleenable":
			txt = "Toggles the use of the developer console. Can be used in-game by pressing " + KeyName(KEY_CONSOLE) + "."
		case "consoleerror":
			txt = Chr(34)+"Open console on error"+Chr(34)+" is self-explanatory."
		case "achpopup":
			txt = "Displays a pop-up notification when an achievement is unlocked."
		case "showfps":
			txt = "Displays the frames per second counter at the top left-hand corner."
		case "framelimit":
			txt = "Limits the frame rate that the game can run at to a desired value."
			if (value > 0 && value < 60) {
				R = 255
				G = 255
				txt2 = "Usually, 60 FPS or higher is preferred. If you are noticing excessive stuttering at this setting, try lowering it to make your framerate more consistent."
			}
		case "antialiastext":
			txt = Chr(34)+"Antialiased text"+Chr(34)+" smooths out the text before displaying. Makes text easier to read at high resolutions."
			//[End Block]
	}
	
	lines = GetLineAmount(txt,fw,fh)
	if (usetestimg) {
		extraspace = 210*MenuScale
	}
	if (txt2$ = "") {
		DrawFrame(x,y,width,((AAStringHeight(txt)*lines)+(10+lines)*MenuScale)+extraspace)
	} else {
		lines2 = GetLineAmount(txt2,fw,fh)
		DrawFrame(x,y,width,(((AAStringHeight(txt)*lines)+(10+lines)*MenuScale)+(AAStringHeight(txt2)*lines2)+(10+lines2)*MenuScale)+extraspace)
	}
	RowText(txt,fx,fy,fw,fh)
	if (txt2 != "") {
		Color (R,G,B)
		RowText(txt2,fx,(fy+(AAStringHeight(txt)*lines)+(5+lines)*MenuScale),fw,fh)
	}
	if (usetestimg) {
		MidHandle (Menu_TestIMG)
		if (txt2$ = "") {
			DrawImage (Menu_TestIMG,x+(width/2),y+100*MenuScale+((AAStringHeight(txt)*lines)+(10+lines)*MenuScale))
		} else {
			DrawImage (Menu_TestIMG,x+(width/2),y+100*MenuScale+(((AAStringHeight(txt)*lines)+(10+lines)*MenuScale)+(AAStringHeight(txt2)*lines2)+(10+lines2)*MenuScale))
		}
	}
}

function DrawMapCreatorTooltip(x: int,y: int,width: int,height: int,mapname: string) {
	let fx: float = x+6*MenuScale
	let fy: float = y+6*MenuScale
	let fw: float = width-12*MenuScale
	let fh: float = height-12*MenuScale
	let lines: int = 0
	
	AASetFont (Font1)
	Color (255,255,255)
	
	let txt: string[] = new Array(5)
	if (Right(mapname,6)="cbmap2") {
		txt[0] = Left(mapname$,Len(mapname$)-7)
		let f: int = OpenFile("Map Creator/Maps/"+mapname$)
		
		let author$ = ReadLine(f)
		let descr$ = ReadLine(f)
		ReadByte(f)
		ReadByte(f)
		let ramount: int = ReadInt(f)
		if (ReadInt(f) > 0) {
			let hasForest: boolean = true
		} else {
			hasForest = false
		}
		if (ReadInt(f) > 0) {
			let hasMT: boolean = true
		} else {
			hasMT = false
		}
		
		CloseFile (f)
	} else {
		txt[0] = Left(mapname,Len(mapname)-6)
		author = "[Unknown]"
		descr = "[No description]"
		ramount = 0
		hasForest = false
		hasMT = false
	}
	txt[1] = "Made by: " + author
	txt[2] = "Description: "+descr$
	if (ramount > 0) {
		txt[3] = "Room amount: "+ramount
	} else {
		txt[3] = "Room amount: [Unknown]"
	}
	if (hasForest) {
		txt[4] = "Has custom forest: Yes"
	} else {
		txt[4] = "Has custom forest: No"
	}
	if (hasMT) {
		txt[5] = "Has custom maintenance tunnel: Yes"
	} else {
		txt[5] = "Has custom maintenance tunnel: No"
	}
	
	lines = GetLineAmount(txt[2],fw,fh)
	DrawFrame(x,y,width,(AAStringHeight(txt[0])*6)+AAStringHeight(txt[2])*lines+5*MenuScale)
	
	Color (255,255,255)
	AAText(fx,fy,txt[0])
	AAText(fx,fy+AAStringHeight(txt[0]),txt[1])
	RowText(txt[2],fx,fy+(AAStringHeight(txt[0])*2),fw,fh)
	AAText(fx,fy+((AAStringHeight(txt[0])*2)+AAStringHeight(txt[2])*lines+5*MenuScale),txt[3])
	AAText(fx,fy+((AAStringHeight(txt[0])*3)+AAStringHeight(txt[2])*lines+5*MenuScale),txt[4])
	AAText(fx,fy+((AAStringHeight(txt[0])*4)+AAStringHeight(txt[2])*lines+5*MenuScale),txt[5])
}

function ChangeMenu_TestIMG(change: string) {
	
	if (Menu_TestIMG != 0) {FreeImage (Menu_TestIMG)}
	AmbientLightRoomTex = CreateTexture(2,2,257)
	TextureBlend (AmbientLightRoomTex,5)
	SetBuffer(TextureBuffer(AmbientLightRoomTex))
	ClsColor (0,0,0)
	Cls()
	SetBuffer (BackBuffer())
	Menu_TestIMG = Create3DIcon(200,200,"GFX/map/room3z3_opt.rmesh",0,-0.75,1,0,0,0,menuroomscale,menuroomscale,menuroomscale,true)
	ScaleImage (Menu_TestIMG,MenuScale,MenuScale)
	MaskImage(Menu_TestIMG,255,0,255)
	FreeTexture (AmbientLightRoomTex)
	AmbientLightRoomTex = 0
	
	CurrMenu_TestIMG = change$
}

var OnSliderID: int = 0

function Slider3(x: int,y: int,width: int,value: int,ID: int,val1: string,val2: string,val3: string) {
	
	if (MouseDown1) {
		if ((ScaledMouseX() >= x) && (ScaledMouseX() <= x+width+14) && (ScaledMouseY() >= y-8) && (ScaledMouseY() <= y+10)) {
			OnSliderID = ID
		}
	}
	
	Color (200,200,200)
	Rect(x,y,width+14,10,true)
	Rect(x,y-8,4,14,true)
	Rect(x+(width/2)+5,y-8,4,14,true)
	Rect(x+width+10,y-8,4,14,true)
	
	if (ID = OnSliderID) {
		if (ScaledMouseX() <= x+8) {
			value = 0
		} else if ((ScaledMouseX() >= x+width/2) && (ScaledMouseX() <= x+(width/2)+8)) {
			value = 1
		} else if ((ScaledMouseX() >= x+width)) {
			value = 2
		}
		Color (0,255,0)
		Rect(x,y,width+14,10,true)
	} else {
		if ((ScaledMouseX() >= x) && (ScaledMouseX() <= x+width+14) && (ScaledMouseY() >= y-8) && (ScaledMouseY() <= y+10)) {
			Color (0,200,0)
			Rect(x,y,width+14,10,false)
		}
	}
	
	if (value == 0) {
		DrawImage(BlinkMeterIMG,x,y-8)
 	} else if (value == 1) {
		DrawImage(BlinkMeterIMG,x+(width/2)+3,y-8)
	} else {
		DrawImage(BlinkMeterIMG,x+width+6,y-8)
	}
	
	Color(170,170,170)
	if (value == 0) {
		AAText(x+2,y+10+MenuScale,val1,true)
 	} else if (value == 1) {
		AAText(x+(width/2)+7,y+10+MenuScale,val2,true)
	} else {
		AAText(x+width+12,y+10+MenuScale,val3,true)
	}
	
	return value
	
}

function Slider4(x: int,y: int,width: int,value: int,ID: int,val1: string,val2: string,val3: string,val4: string) {
	
	if (MouseDown1) {
		if ((ScaledMouseX() >= x) && (ScaledMouseX() <= x+width+14) && (ScaledMouseY() >= y-8) && (ScaledMouseY() <= y+10)) {
			OnSliderID = ID
		}
	}
	
	Color(200,200,200)
	Rect(x,y,width+14,10,true)
	Rect(x,y-8,4,14,true) //1
	Rect(x+(width*(1.0/3.0))+(10.0/3.0),y-8,4,14,true) //2
	Rect(x+(width*(2.0/3.0))+(20.0/3.0),y-8,4,14,true) //3
	Rect(x+width+10,y-8,4,14,true) //4
	
	if (ID == OnSliderID) {
		if (ScaledMouseX() <= x+8) {
			value = 0
		} else if ((ScaledMouseX() >= x+width*(1.0/3.0)) && (ScaledMouseX() <= x+width*(1.0/3.0)+8)) {
			value = 1
		} else if ((ScaledMouseX() >= x+width*(2.0/3.0)) && (ScaledMouseX() <= x+width*(2.0/3.0)+8)) {
			value = 2
		} else if ((ScaledMouseX() >= x+width)) {
			value = 3
		}
		Color(0,255,0)
		Rect(x,y,width+14,10,true)
	} else {
		if ((ScaledMouseX() >= x) && (ScaledMouseX() <= x+width+14) && (ScaledMouseY() >= y-8) && (ScaledMouseY() <= y+10)) {
			Color(0,200,0)
			Rect(x,y,width+14,10,false)
		}
	}
	
	if (value == 0) {
		DrawImage(BlinkMeterIMG,x,y-8)
 	} else if (value == 1) {
		DrawImage(BlinkMeterIMG,x+width*(1.0/3.0)+2,y-8)
 	} else if (value == 2) {
		DrawImage(BlinkMeterIMG,x+width*(2.0/3.0)+4,y-8)
	} else {
		DrawImage(BlinkMeterIMG,x+width+6,y-8)
	}
	
	Color(170,170,170)
	if (value == 0) {
		AAText(x+2,y+10+MenuScale,val1,true)
 	} else if (value == 1) {
		AAText(x+width*(1.0/3.0)+2+(10.0/3.0),y+10+MenuScale,val2,true)
 	} else if (value == 2) {
		AAText(x+width*(2.0/3.0)+2+((10.0/3.0)*2),y+10+MenuScale,val3,true)
	} else {
		AAText(x+width+12,y+10+MenuScale,val4,true)
	}
	
	return value
}

function Slider5(x: int,y: int,width: int,value: int,ID: int,val1: string,val2: string,val3: string,val4: string,val5: string) {
	
	if (MouseDown1) {
		if ((ScaledMouseX() >= x) && (ScaledMouseX() <= x+width+14) && (ScaledMouseY() >= y-8) && (ScaledMouseY() <= y+10)) {
			OnSliderID = ID
		}
	}
	
	Color (200,200,200)
	Rect(x,y,width+14,10,true)
	Rect(x,y-8,4,14,true) //1
	Rect(x+(width/4)+2.5,y-8,4,14,true) //2
	Rect(x+(width/2)+5,y-8,4,14,true) //3
	Rect(x+(width*0.75)+7.5,y-8,4,14,true) //4
	Rect(x+width+10,y-8,4,14,true) //5
	
	if (ID = OnSliderID) {
		if (ScaledMouseX() <= x+8) {
			value = 0
		} else if ((ScaledMouseX() >= x+width/4) && (ScaledMouseX() <= x+(width/4)+8)) {
			value = 1
		} else if ((ScaledMouseX() >= x+width/2) && (ScaledMouseX() <= x+(width/2)+8)) {
			value = 2
		} else if ((ScaledMouseX() >= x+width*0.75) && (ScaledMouseX() <= x+(width*0.75)+8)) {
			value = 3
		} else if ((ScaledMouseX() >= x+width)) {
			value = 4
		}
		Color (0,255,0)
		Rect(x,y,width+14,10,true)
	} else {
		if ((ScaledMouseX() >= x) && (ScaledMouseX() <= x+width+14) && (ScaledMouseY() >= y-8) && (ScaledMouseY() <= y+10)) {
			Color (0,200,0)
			Rect(x,y,width+14,10,false)
		}
	}
	
	if (value = 0) {
		DrawImage(BlinkMeterIMG,x,y-8)
	} else if (value = 1) {
		DrawImage(BlinkMeterIMG,x+(width/4)+1.5,y-8)
	} else if (value = 2) {
		DrawImage(BlinkMeterIMG,x+(width/2)+3,y-8)
	} else if (value = 3) {
		DrawImage(BlinkMeterIMG,x+(width*0.75)+4.5,y-8)
	} else {
		DrawImage(BlinkMeterIMG,x+width+6,y-8)
	}
	
	Color (170,170,170)
	if (value = 0) {
		AAText(x+2,y+10+MenuScale,val1,true)
 	} else if (value = 1) {
		AAText(x+(width/4)+4.5,y+10+MenuScale,val2,true)
 	} else if (value = 2) {
		AAText(x+(width/2)+7,y+10+MenuScale,val3,true)
 	} else if (value = 3) {
		AAText(x+(width*0.75)+9.5,y+10+MenuScale,val4,true)
	} else {
		AAText(x+width+12,y+10+MenuScale,val5,true)
	}
	
	return value
}

function Slider7(x: int,y: int,width: int,value: int,ID: int,val1: string,val2: string,val3: string,val4: string,val5: string,val6: string,val7: string) {
	
	if (MouseDown1) {
		if ((ScaledMouseX() >= x) && (ScaledMouseX() <= x+width+14) && (ScaledMouseY() >= y-8) && (ScaledMouseY() <= y+10)) {
			OnSliderID = ID
		}
	}
	
	Color (200,200,200)
	Rect(x,y,width+14,10,true)
	Rect(x,y-8,4,14,true) //1
	Rect(x+(width*(1.0/6.0))+(10.0/6.0),y-8,4,14,true) //2
	Rect(x+(width*(2.0/6.0))+(20.0/6.0),y-8,4,14,true) //3
	Rect(x+(width*(3.0/6.0))+(30.0/6.0),y-8,4,14,true) //4
	Rect(x+(width*(4.0/6.0))+(40.0/6.0),y-8,4,14,true) //5
	Rect(x+(width*(5.0/6.0))+(50.0/6.0),y-8,4,14,true) //6
	Rect(x+width+10,y-8,4,14,true) //7
	
	if (ID = OnSliderID) {
		if (ScaledMouseX() <= x+8) {
			value = 0
		} else if ((ScaledMouseX() >= x+(width*(1.0/6.0))) && (ScaledMouseX() <= x+(width*(1.0/6.0))+8)) {
			value = 1
		} else if ((ScaledMouseX() >= x+(width*(2.0/6.0))) && (ScaledMouseX() <= x+(width*(2.0/6.0))+8)) {
			value = 2
		} else if ((ScaledMouseX() >= x+(width*(3.0/6.0))) && (ScaledMouseX() <= x+(width*(3.0/6.0))+8)) {
			value = 3
		} else if ((ScaledMouseX() >= x+(width*(4.0/6.0))) && (ScaledMouseX() <= x+(width*(4.0/6.0))+8)) {
			value = 4
		} else if ((ScaledMouseX() >= x+(width*(5.0/6.0))) && (ScaledMouseX() <= x+(width*(5.0/6.0))+8)) {
			value = 5
		} else if ((ScaledMouseX() >= x+width)) {
			value = 6
		}
		Color (0,255,0)
		Rect(x,y,width+14,10,true)
	} else {
		if ((ScaledMouseX() >= x) && (ScaledMouseX() <= x+width+14) && (ScaledMouseY() >= y-8) && (ScaledMouseY() <= y+10)) {
			Color (0,200,0)
			Rect(x,y,width+14,10,false)
		}
	}
	
	if (value = 0) {
		DrawImage(BlinkMeterIMG,x,y-8)
	} else if (value = 1) {
		DrawImage(BlinkMeterIMG,x+(width*(1.0/6.0))+1,y-8)
	} else if (value = 2) {
		DrawImage(BlinkMeterIMG,x+(width*(2.0/6.0))+2,y-8)
	} else if (value = 3) {
		DrawImage(BlinkMeterIMG,x+(width*(3.0/6.0))+3,y-8)
	} else if (value = 4) {
		DrawImage(BlinkMeterIMG,x+(width*(4.0/6.0))+4,y-8)
	} else if (value = 5) {
		DrawImage(BlinkMeterIMG,x+(width*(5.0/6.0))+5,y-8)
	} else {
		DrawImage(BlinkMeterIMG,x+width+6,y-8)
	}
	
	Color (170,170,170)
	if (value = 0) {
		AAText(x+2,y+10+MenuScale,val1,true)
	} else if (value = 1) {
		AAText(x+(width*(1.0/6.0))+2+(10.0/6.0),y+10+MenuScale,val2,true)
	} else if (value = 2) {
		AAText(x+(width*(2.0/6.0))+2+((10.0/6.0)*2),y+10+MenuScale,val3,true)
	} else if (value = 3) {
		AAText(x+(width*(3.0/6.0))+2+((10.0/6.0)*3),y+10+MenuScale,val4,true)
	} else if (value = 4) {
		AAText(x+(width*(4.0/6.0))+2+((10.0/6.0)*4),y+10+MenuScale,val5,true)
	} else if (value = 5) {
		AAText(x+(width*(5.0/6.0))+2+((10.0/6.0)*5),y+10+MenuScale,val6,true)
	} else {
		AAText(x+width+12,y+10+MenuScale,val7,true)
	}
	
	return value
}

export var OnBar: int
export var ScrollBarY: float = 0.0
export var ScrollMenuHeight: float = 0.0

function DrawScrollBar(x, y, width, height, barx, bary, barwidth, barheight, bar: float, dir = 0): float {
	//0 = vaakasuuntainen, 1 = pystysuuntainen
	
	let MouseSpeedX = MouseXSpeed()
	let MouseSpeedY = MouseYSpeed()
	
	Color(0, 0, 0)
	//Rect(x, y, width, height)
	Button(barx, bary, barwidth, barheight, "")
	
	if (dir = 0) { //vaakasuunnassa
		if (height > 10) {
			Color (250,250,250)
			Rect(barx + barwidth / 2, bary + 5*MenuScale, 2*MenuScale, barheight - 10)
			Rect(barx + barwidth / 2 - 3*MenuScale, bary + 5*MenuScale, 2*MenuScale, barheight - 10)
			Rect(barx + barwidth / 2 + 3*MenuScale, bary + 5*MenuScale, 2*MenuScale, barheight - 10)
		}
	} else { //pystysuunnassa
		if (width > 10) {
			Color (250,250,250)
			Rect(barx + 4*MenuScale, bary + barheight / 2, barwidth - 10*MenuScale, 2*MenuScale)
			Rect(barx + 4*MenuScale, bary + barheight / 2 - 3*MenuScale, barwidth - 10*MenuScale, 2*MenuScale)
			Rect(barx + 4*MenuScale, bary + barheight / 2 + 3*MenuScale, barwidth - 10*MenuScale, 2*MenuScale)
		}
	}
	
	if (MouseX()>barx && MouseX()<barx+barwidth) {
		if (MouseY()>bary && MouseY()<bary+barheight) {
			OnBar = true
		} else {
			if (!MouseDown1) {
				OnBar = false
			}
		}
	} else {
		if (!MouseDown1) {
			OnBar = false
		}
	}
	
	if (MouseDown1) {
		if (OnBar) {
			if (dir = 0) {
				return Min(Max(bar + MouseSpeedX / Float(width - barwidth), 0), 1)
			} else {
				return Min(Max(bar + MouseSpeedY / Float(height - barheight), 0), 1)
			}
		}
	}
	
	return bar
}

function Button(x,y,width,height,txt: string, disabled: boolean = false): int {
	let Pushed = false
	
	Color (50, 50, 50)
	if (!disabled) { 
		if (MouseX() > x && MouseX() < x+width) {
			if (MouseY() > y && MouseY() < y+height) {
				if (MouseDown1) {
					Pushed = true
					Color(50*0.6, 50*0.6, 50*0.6)
				} else {
					Color(Min(50*1.2,255),Min(50*1.2,255),Min(50*1.2,255))
				}
			}
		}
	}
	
	if (Pushed) {
		Rect (x,y,width,height)
		Color (133,130,125)
		Rect (x+1*MenuScale,y+1*MenuScale,width-1*MenuScale,height-1*MenuScale,false)
		Color (10,10,10)
		Rect (x,y,width,height,false)
		Color (250,250,250)
		Line (x,y+height-1*MenuScale,x+width-1*MenuScale,y+height-1*MenuScale)
		Line (x+width-1*MenuScale,y,x+width-1*MenuScale,y+height-1*MenuScale)
	} else {
		Rect (x,y,width,height)
		Color (133,130,125)
		Rect (x,y,width-1*MenuScale,height-1*MenuScale,false)
		Color (250,250,250)
		Rect (x,y,width,height,false)
		Color (10,10,10)
		Line (x,y+height-1,x+width-1,y+height-1)
		Line (x+width-1,y,x+width-1,y+height-1)
	}
	
	Color (255,255,255)
	if (disabled) {Color(70,70,70)}
	BBText(x+width/2, y+height/2-1*MenuScale, txt, true, true)
	
	Color (0,0,0)
	
	if (Pushed && MouseHit1) {
		PlaySound_Strict (ButtonSFX)
		return true
	}
}
MainMenuOpen = true

//---------------------------------------------------------------------------------------------------

class MEMORYSTATUS {
    dwLength: int
    dwMemoryLoad: int
    dwTotalPhys: int
    dwAvailPhys: int
    dwTotalPageFile: int
    dwAvailPageFile: int
    dwTotalVirtual: int
    dwAvailVirtual: int
}

var m: MEMORYSTATUS = new MEMORYSTATUS()

FlushKeys()
FlushMouse()

DrawLoading(100, true)

LoopDelay = MilliSecs()

var UpdateParticles_Time: float = 0.0

var CurrTrisAmount: int

var Input_ResetTime: float = 0

class SCP427 {
	Using: int
	Timer: float
	Sound: any[] = new Array(1)
	SoundCHN: any[] = new Array(1)
}

var I_427: SCP427 = new SCP427()

class MapZones {
	Transition: int[] = new Array(1)
	HasCustomForest: int
	HasCustomMT: int
}

var I_Zone: MapZones = new MapZones()


// Main Loop
while (true) {
	
	Cls()
	
	CurTime = MilliSecs2()
	ElapsedTime = (CurTime - PrevTime) / 1000.0
	PrevTime = CurTime
	PrevFPSFactor = FPSfactor
	FPSfactor = Max(Min(ElapsedTime * 70, 5.0), 0.2)
	FPSfactor2 = FPSfactor
	
	if (MenuOpen || InvOpen || OtherOpen || ConsoleOpen || SelectedDoor || SelectedScreen || Using294) {
		FPSfactor = 0
	}
	
	if (Framelimit > 0) {
	    //Framelimit
		let WaitingTime: int = (1000.0 / Framelimit) - (MilliSecs2() - LoopDelay)
		Delay (WaitingTime)
		
		LoopDelay = MilliSecs2()
	}
	
	//Counting the fps
	if (CheckFPS < MilliSecs2()) {
		FPS = ElapsedLoops
		ElapsedLoops = 0
		CheckFPS = MilliSecs2()+1000
	}
	ElapsedLoops = ElapsedLoops + 1
	
	if (Input_ResetTime<=0.0) {
		DoubleClick = false
		MouseHit1 = MouseHit(1)
		if (MouseHit1) {
			if (MilliSecs2() - LastMouseHit1 < 800) {
				DoubleClick = true
			}
			LastMouseHit1 = MilliSecs2()
		}
		
		let prevmousedown1 = MouseDown1
		MouseDown1 = MouseDown(1)
		if (prevmousedown1 && !MouseDown1) {MouseUp1 = true} else {MouseUp1 = false}
		
		MouseHit2 = MouseHit(2)
		
		if ((!MouseDown1) && (!MouseHit1)) {GrabbedEntity = 0}
	} else {
		Input_ResetTime = Max(Input_ResetTime-FPSfactor,0.0)
	}
	
	UpdateMusic()
	if (EnableSFXRelease) {AutoReleaseSounds()}
	
	if (MainMenuOpen) {
		if (ShouldPlay == 21) {
			EndBreathSFX = LoadSound("SFX/Ending/MenuBreath.ogg")
			EndBreathCHN = PlaySound(EndBreathSFX)
			ShouldPlay = 66
		} else if (ShouldPlay = 66) {
			if (!ChannelPlaying(EndBreathCHN)) {
				FreeSound(EndBreathSFX)
				ShouldPlay = 11
			}
		} else {
			ShouldPlay = 11
		}
		UpdateMainMenu()
	} else {
		UpdateStreamSounds()
		
		ShouldPlay = Min(PlayerZone,2)
		
		DrawHandIcon = false
		
		RestoreSanity = true
		ShouldEntitiesFall = true
		
		if (FPSfactor > 0 && PlayerRoom.RoomTemplate.Name != "dimension1499") {UpdateSecurityCams()}
		
		if (PlayerRoom.RoomTemplate.Name != "pocketdimension" && PlayerRoom.RoomTemplate.Name != "gatea" && PlayerRoom.RoomTemplate.Name != "exit1" && !MenuOpen && !ConsoleOpen && !InvOpen) {
			
			if (Rand(1500) == 1) {
				for (i of range(6)) {
					if (AmbientSFX(i,CurrAmbientSFX)!=0) {
						if (ChannelPlaying(AmbientSFXCHN)=0) {
							FreeSound_Strict(AmbientSFX(i,CurrAmbientSFX))
							AmbientSFX(i,CurrAmbientSFX) = 0
						}
					}			
				}
				
				PositionEntity (SoundEmitter, EntityX(Camera) + Rnd(-1.0, 1.0), 0.0, EntityZ(Camera) + Rnd(-1.0, 1.0))
				
				if (Rand(3) == 1) {
					PlayerZone = AreaName.General
				}
				
				if (PlayerRoom.RoomTemplate.Name = "173") {
					PlayerZone = AreaName.PreBreach
				} else if (PlayerRoom.RoomTemplate.Name = "room860") {
					for (let e of Events.each) {
						if (e.EventName == "room860") {
							if (e.EventState == 1.0) {
								PlayerZone = AreaName.Forest
								PositionEntity (SoundEmitter, EntityX(SoundEmitter), 30.0, EntityZ(SoundEmitter))
							}
							
							break
						}
					}
				}
				
				CurrAmbientSFX = Rand(0,AmbientSFXAmount(PlayerZone)-1)
				
				switch (PlayerZone) {
					case 0,1,2:
						if (AmbientSFX(PlayerZone,CurrAmbientSFX)=0) {
							AmbientSFX(PlayerZone,CurrAmbientSFX)=LoadSound_Strict("SFX/Ambient/Zone"+(PlayerZone+1)+"/ambient"+(CurrAmbientSFX+1)+".ogg")
						}
					case 3:
						if (AmbientSFX(PlayerZone,CurrAmbientSFX)=0) {
							AmbientSFX(PlayerZone,CurrAmbientSFX)=LoadSound_Strict("SFX/Ambient/General/ambient"+(CurrAmbientSFX+1)+".ogg")
						}
					case 4:
						if (AmbientSFX(PlayerZone,CurrAmbientSFX)=0) {
							AmbientSFX(PlayerZone,CurrAmbientSFX)=LoadSound_Strict("SFX/Ambient/Pre-breach/ambient"+(CurrAmbientSFX+1)+".ogg")
						}
					case 5:
						if (AmbientSFX(PlayerZone,CurrAmbientSFX)=0) {
							AmbientSFX(PlayerZone,CurrAmbientSFX)=LoadSound_Strict("SFX/Ambient/Forest/ambient"+(CurrAmbientSFX+1)+".ogg")
						}
				}
				
				AmbientSFXCHN = PlaySound2(AmbientSFX(PlayerZone,CurrAmbientSFX), Camera, SoundEmitter)
			}
			UpdateSoundOrigin(AmbientSFXCHN,Camera, SoundEmitter)
			
			if (Rand(50000) == 3) {
				let RN: string = PlayerRoom.RoomTemplate.Name$
				if (RN$ != "room860" && RN$ != "room1123" && RN$ != "173" && RN$ != "dimension1499") {
					if (FPSfactor > 0) {LightBlink = Rnd(1.0,2.0)}
					PlaySound_Strict(LoadTempSound("SFX/SCP/079/Broadcast"+Rand(1,7)+".ogg"))
				} 
			}
		}
		
		UpdateCheckpoint1 = false
		UpdateCheckpoint2 = false
		
		if ((!MenuOpen) && (!InvOpen) && (OtherOpen == Null) && (SelectedDoor == Null) && (ConsoleOpen == false) && (Using294 == false) && (SelectedScreen == Null) && EndingTimer >= 0) {
			LightVolume = CurveValue(TempLightVolume, LightVolume, 50.0)
			CameraFogRange(Camera, CameraFogNear*LightVolume,CameraFogFar*LightVolume)
			CameraFogColor(Camera, 0,0,0)
			CameraFogMode (Camera,1)
			CameraRange(Camera, 0.05, Min(CameraFogFar*LightVolume*1.5,28))	
			if (PlayerRoom.RoomTemplate.Name!="pocketdimension") {
				CameraClsColor(Camera, 0,0,0)
			}
			
			AmbientLight (Brightness, Brightness, Brightness)
			PlayerSoundVolume = CurveValue(0.0, PlayerSoundVolume, 5.0)
			
			CanSave = true
			UpdateDeafPlayer()
			UpdateEmitters()
			MouseLook()
			if (PlayerRoom.RoomTemplate.Name == "dimension1499" && QuickLoadPercent > 0 && QuickLoadPercent < 100) {
				ShouldEntitiesFall = false
			}
			MovePlayer()
			InFacility = CheckForPlayerInFacility()
			if (PlayerRoom.RoomTemplate.Name = "dimension1499") {
				if (QuickLoadPercent == -1 || QuickLoadPercent == 100) {
					UpdateDimension1499()
				}
				UpdateLeave1499()
			} else if (PlayerRoom.RoomTemplate.Name = "gatea" || (PlayerRoom.RoomTemplate.Name="exit1" && EntityY(Collider)>1040.0*RoomScale)) {
				UpdateDoors()
				if (QuickLoadPercent == -1 || QuickLoadPercent == 100) {
					UpdateEndings()
				}
				UpdateScreens()
				UpdateRoomLights(Camera)
			} else {
				UpdateDoors()
				if (QuickLoadPercent = -1 || QuickLoadPercent == 100) {
					UpdateEvents()
				}
				UpdateScreens()
				TimeCheckpointMonitors()
				Update294()
				UpdateRoomLights(Camera)
			}
			UpdateDecals()
			UpdateMTF()
			UpdateNPCs()
			UpdateItems()
			UpdateParticles()
			Use427()
			UpdateMonitorSaving()
			//Added a simple code for updating the Particles function depending on the FPSFactor (still WIP, might not be the final version of it) - ENDSHN
			UpdateParticles_Time = Min(1,UpdateParticles_Time+FPSfactor)
			if (UpdateParticles_Time == 1) {
				UpdateDevilEmitters()
				UpdateParticles_Devil()
				UpdateParticles_Time=0
			}
		}
		
		if (InfiniteStamina) {
			Stamina = Min(100, Stamina + (100.0-Stamina)*0.01*FPSfactor)
		}
		
		if (FPSfactor=0) {
			UpdateWorld(0)
		} else {
			UpdateWorld()
			ManipulateNPCBones()
		}
		RenderWorld2()
		
		BlurVolume = Min(CurveValue(0.0, BlurVolume, 20.0),0.95)
		if (BlurTimer > 0.0) {
			BlurVolume = Max(Min(0.95, BlurTimer / 1000.0), BlurVolume)
			BlurTimer = Max(BlurTimer - FPSfactor, 0.0)
		}
		
		UpdateBlur(BlurVolume)
		
		//[Block]
		
		let darkA: float = 0.0
		if (!MenuOpen)  {
			if (Sanity < 0) {
				if (RestoreSanity) {
					Sanity = Min(Sanity + FPSfactor, 0.0)
				}
				if (Sanity < -200) { 
					darkA = Max(Min((-Sanity - 200) / 700.0, 0.6), darkA)
					if (KillTimer >= 0) { 
						HeartBeatVolume = Min(Abs(Sanity+200)/500.0,1.0)
						HeartBeatRate = Max(70 + Abs(Sanity+200)/6.0,HeartBeatRate)
					}
				}
			}
			
			if (EyeStuck > 0) {
				BlinkTimer = BLINKFREQ
				EyeStuck = Max(EyeStuck-FPSfactor,0)
				
				if (EyeStuck < 9000) {BlurTimer = Max(BlurTimer, (9000-EyeStuck)*0.5)}
				if (EyeStuck < 6000) {darkA = Min(Max(darkA, (6000-EyeStuck)/5000.0),1.0)}
				if (EyeStuck < 9000 && EyeStuck+FPSfactor >= 9000) { 
					Msg = "The eyedrops are causing your eyes to tear up."
					MsgTimer = 70*6
				}
			}
			
			if (BlinkTimer < 0) {
				if (BlinkTimer > -5) {
					darkA = Max(darkA, Sin(Abs(BlinkTimer * 18.0)))
				} else if (BlinkTimer > -15) {
					darkA = 1.0
				} else {
					darkA = Max(darkA, Abs(Sin(BlinkTimer * 18.0)))
				}
				
				if (BlinkTimer <= -20) {
					//Randomizes the frequency of blinking. Scales with difficulty.
					switch (SelectedDifficulty.otherFactors) {
						case EASY:
							BLINKFREQ = Rnd(490,700)
						case NORMAL:
							BLINKFREQ = Rnd(455,665)
						case HARD:
							BLINKFREQ = Rnd(420,630)
					}
					BlinkTimer = BLINKFREQ
				}
				
				BlinkTimer = BlinkTimer - FPSfactor
			} else {
				BlinkTimer = BlinkTimer - FPSfactor * 0.6 * BlinkEffect
				if (EyeIrritation > 0) {
					BlinkTimer=BlinkTimer-Min(EyeIrritation / 100.0 + 1.0, 4.0) * FPSfactor
				}
				
				darkA = Max(darkA, 0.0)
			}
			
			EyeIrritation = Max(0, EyeIrritation - FPSfactor)
			
			if (BlinkEffectTimer > 0) {
				BlinkEffectTimer = BlinkEffectTimer - (FPSfactor/70)
			} else {
				if (BlinkEffect != 1.0) {BlinkEffect = 1.0}
			}
			
			LightBlink = Max(LightBlink - (FPSfactor / 35.0), 0)
			if (LightBlink > 0) {darkA = Min(Max(darkA, LightBlink * Rnd(0.3, 0.8)), 1.0)}
			
			if (Using294) {darkA=1.0}
			
			if (!WearingNightVision) {
				darkA = Max((1.0-SecondaryLightOn)*0.9, darkA)
			}
			
			if (KillTimer < 0) {
				InvOpen = false
				SelectedItem = Null
				SelectedScreen = Null
				SelectedMonitor = Null
				BlurTimer = Abs(KillTimer*5)
				KillTimer=KillTimer-(FPSfactor*0.8)
				if (KillTimer < -360) {
					MenuOpen = true 
					if (SelectedEnding != "") {EndingTimer = Min(KillTimer,-0.1)}
				}
				darkA = Max(darkA, Min(Abs(KillTimer / 400.0), 1.0))
			}
			
			if (FallTimer < 0) {
				if (SelectedItem != Null) {
					if (Instr(SelectedItem.itemtemplate.tempname,"hazmatsuit") || Instr(SelectedItem.itemtemplate.tempname,"vest")) {
						if (WearingHazmat == 0 && WearingVest == 0) {
							DropItem(SelectedItem)
						}
					}
				}
				InvOpen = false
				SelectedItem = Null
				SelectedScreen = Null
				SelectedMonitor = Null
				BlurTimer = Abs(FallTimer*10)
				FallTimer = FallTimer-FPSfactor
				darkA = Max(darkA, Min(Abs(FallTimer / 400.0), 1.0))				
			}
			
			if (SelectedItem != Null) {
				if (SelectedItem.itemtemplate.tempname = "navigator" || SelectedItem.itemtemplate.tempname == "nav") {darkA = Max(darkA, 0.5)}
			}
			if (SelectedScreen != Null) {darkA = Max(darkA, 0.5)}
			
			EntityAlpha(Dark, darkA)	
		}
		
		if (LightFlash > 0) {
			ShowEntity (Light)
			EntityAlpha(Light, Max(Min(LightFlash + Rnd(-0.2, 0.2), 1.0), 0.0))
			LightFlash = Max(LightFlash - (FPSfactor / 70.0), 0)
		} else {
			HideEntity (Light)
		}
		
		EntityColor (Light,255,255,255)
		
		//[End block]
		
		if (KeyHit(KEY_INV) && VomitTimer >= 0) {
			if (!UnableToMove && !IsZombie && !Using294) {
				let W: string = ""
				let V: float = 0
				if (SelectedItem!=Null) {
					W = SelectedItem.itemtemplate.tempname
					V = SelectedItem.state
				}
				if ((W!="vest" && W!="finevest" && W!="hazmatsuit" && W!="hazmatsuit2" && W!="hazmatsuit3") || V == 0 || V == 100) {
					if (InvOpen) {
						ResumeSounds()
						MouseXSpeed()
						MouseYSpeed()
						MouseZSpeed()
						mouse_x_speed_1 = 0.0
						mouse_y_speed_1 = 0.0
					} else {
						PauseSounds()
					}
					InvOpen = !InvOpen
					if (OtherOpen != Null) {
						OtherOpen=Null
					}
					SelectedItem = Null
				}
			}
		}
		
		if (KeyHit(KEY_SAVE)) {
			if (SelectedDifficulty.saveType = SAVEANYWHERE) {
				RN$ = PlayerRoom.RoomTemplate.Name$
				if (RN$ = "173" || (RN$ = "exit1" && EntityY(Collider)>1040.0*RoomScale) || RN$ == "gatea") {
					Msg = "You cannot save in this location."
					MsgTimer = 70 * 4
					//SetSaveMSG("You cannot save in this location.")
				} else if ((!CanSave) || QuickLoadPercent > -1) {
					Msg = "You cannot save at this moment."
					MsgTimer = 70 * 4
					//SetSaveMSG("You cannot save at this moment.")
					if (QuickLoadPercent > -1) {
						Msg = Msg + " (game is loading)"
						//Save_MSG = Save_MSG + " (game is loading)"
					}
				} else {
					SaveGame(SavePath + CurrSave + "\\")
				}
			} else if (SelectedDifficulty.saveType = SAVEONSCREENS) {
				if (SelectedScreen == Null && SelectedMonitor == Null) {
					Msg = "Saving is only permitted on clickable monitors scattered throughout the facility."
					MsgTimer = 70 * 4
				} else {
					RN$ = PlayerRoom.RoomTemplate.Name$
					if (RN$ == "173" || (RN$ == "exit1" && EntityY(Collider)>1040.0*RoomScale) || RN$ == "gatea") {
						Msg = "You cannot save in this location."
						MsgTimer = 70 * 4
						//SetSaveMSG("You cannot save in this location.")
					} else if ((!CanSave) || QuickLoadPercent > -1) {
						Msg = "You cannot save at this moment."
						MsgTimer = 70 * 4
						//SetSaveMSG("You cannot save at this moment.")
						if (QuickLoadPercent > -1) {
							Msg = Msg + " (game is loading)"
							//Save_MSG = Save_MSG + " (game is loading)"
						}
					} else {
						if (SelectedScreen != Null) {
							GameSaved = false
							Playable = true
							DropSpeed = 0
						}
						SaveGame(SavePath + CurrSave + "\\")
					}
				}
			} else {
				Msg = "Quick saving is disabled."
				MsgTimer = 70 * 4
			}
		} else if (SelectedDifficulty.saveType = SAVEONSCREENS && (SelectedScreen != Null || SelectedMonitor != Null)) {
			if ((Msg!="Game progress saved." && Msg!="You cannot save in this location."&& Msg!="You cannot save at this moment.") || MsgTimer<=0) {
				Msg = "Press "+KeyName(KEY_SAVE)+" to save."
				MsgTimer = 70*4
			}
			
			if (MouseHit2) {SelectedMonitor = Null}
		}
		
		if (KeyHit(KEY_CONSOLE)) {
			if (CanOpenConsole) {
				if (ConsoleOpen) {
					UsedConsole = true
					ResumeSounds()
					MouseXSpeed()
					MouseYSpeed()
					MouseZSpeed()
					mouse_x_speed_1 = 0.0
					mouse_y_speed_1 = 0.0
				} else {
					PauseSounds()
				}
				ConsoleOpen = !ConsoleOpen
				FlushKeys()
			}
		}
		
		DrawGUI()
		
		if (EndingTimer < 0) {
			if (SelectedEnding != "") {DrawEnding()}
		} else {
			DrawMenu()			
		}
		
		UpdateConsole()
		
		if (PlayerRoom != Null) {
			if (PlayerRoom.RoomTemplate.Name == "173") {
				for (e of Events.each) {
					if (e.EventName == "173") {
						if (e.EventState3 >= 40 && e.EventState3 < 50) {
							if (InvOpen) {
								Msg = "Double click on the document to view it."
								MsgTimer=70*7
								e.EventState3 = 50
							}
						}
					}
				}
			}
		}
		
		if (MsgTimer > 0) {
			let temp: boolean = false
			if (!InvOpen) {
				if (SelectedItem != Null) {
					if (SelectedItem.itemtemplate.tempname == "paper" || SelectedItem.itemtemplate.tempname == "oldpaper") {
						temp = true
					}
				}
			}
			
			if (!temp) {
				Color (0,0,0)
				AAText((GraphicWidth / 2)+1, (GraphicHeight / 2) + 201, Msg, true, false, Min(MsgTimer / 2, 255)/255.0)
				Color (255,255,255)
				if (Left(Msg,14)="Blitz3D Error!") {
					Color(255,0,0)
				}
				AAText((GraphicWidth / 2), (GraphicHeight / 2) + 200, Msg, true, false, Min(MsgTimer / 2, 255)/255.0)
			} else {
				Color(0,0,0)
				AAText((GraphicWidth / 2)+1, (GraphicHeight * 0.94) + 1, Msg, true, false, Min(MsgTimer / 2, 255)/255.0)
				Color(255,255,255)
				if (Left(Msg,14)="Blitz3D Error!") {
					Color(255,0,0)
				}
				AAText((GraphicWidth / 2), (GraphicHeight * 0.94), Msg, true, false, Min(MsgTimer / 2, 255)/255.0)
			}
			MsgTimer=MsgTimer-FPSfactor2 
		}
		
		Color (255, 255, 255)
		if (ShowFPS) {
			AASetFont (ConsoleFont)
			AAText (20, 20, "FPS: " + FPS)
			AASetFont (Font1)
		}
		
		DrawQuickLoading()
		
		UpdateAchievementMsg()
		//UpdateSaveMSG()
	}
	
	if (BorderlessWindowed) {
		if ((RealGraphicWidth != GraphicWidth) || (RealGraphicHeight != GraphicHeight)) {
			SetBuffer(TextureBuffer(fresize_texture))
			ClsColor(0,0,0)
			Cls()
			CopyRect (0,0,GraphicWidth,GraphicHeight,1024-GraphicWidth/2,1024-GraphicHeight/2,BackBuffer(),TextureBuffer(fresize_texture))
			SetBuffer(BackBuffer())
			ClsColor(0,0,0)
			Cls()
			ScaleRender(0,0,2050.0 / Float(GraphicWidth) * AspectRatioRatio, 2050.0 / Float(GraphicWidth) * AspectRatioRatio)
			//might want to replace Float(GraphicWidth) with Max(GraphicWidth,GraphicHeight) if portrait sizes cause issues
			//everyone uses landscape so it's probably a non-issue
		}
	}
	
	//not by any means a perfect solution
	//Not even proper gamma correction but it's a nice looking alternative that works in windowed mode
	if (ScreenGamma>1.0) {
		CopyRect (0,0,RealGraphicWidth,RealGraphicHeight,1024-RealGraphicWidth/2,1024-RealGraphicHeight/2,BackBuffer(),TextureBuffer(fresize_texture))
		EntityBlend (fresize_image,1)
		ClsColor (0,0,0)
		Cls()
		ScaleRender(-1.0/Float(RealGraphicWidth),1.0/Float(RealGraphicWidth),2048.0 / Float(RealGraphicWidth),2048.0 / Float(RealGraphicWidth))
		EntityFX (fresize_image,1+32)
		EntityBlend (fresize_image,3)
		EntityAlpha (fresize_image,ScreenGamma-1.0)
		ScaleRender(-1.0/Float(RealGraphicWidth),1.0/Float(RealGraphicWidth),2048.0 / Float(RealGraphicWidth),2048.0 / Float(RealGraphicWidth))
	} else if (ScreenGamma<1.0) { //todo: maybe optimize this if it's too slow, alternatively give players the option to disable gamma
		CopyRect (0,0,RealGraphicWidth,RealGraphicHeight,1024-RealGraphicWidth/2,1024-RealGraphicHeight/2,BackBuffer(),TextureBuffer(fresize_texture))
		EntityBlend (fresize_image,1)
		ClsColor (0,0,0)
		Cls()
		ScaleRender(-1.0/Float(RealGraphicWidth),1.0/Float(RealGraphicWidth),2048.0 / Float(RealGraphicWidth),2048.0 / Float(RealGraphicWidth))
		EntityFX (fresize_image,1+32)
		EntityBlend (fresize_image,2)
		EntityAlpha (fresize_image,1.0)
		SetBuffer (TextureBuffer(fresize_texture2))
		ClsColor (255*ScreenGamma,255*ScreenGamma,255*ScreenGamma)
		Cls()
		SetBuffer (BackBuffer())
		ScaleRender(-1.0/Float(RealGraphicWidth),1.0/Float(RealGraphicWidth),2048.0 / Float(RealGraphicWidth),2048.0 / Float(RealGraphicWidth))
		SetBuffer(TextureBuffer(fresize_texture2))
		ClsColor (0,0,0)
		Cls()
		SetBuffer(BackBuffer())
	}
	EntityFX (fresize_image,1)
	EntityBlend (fresize_image,1)
	EntityAlpha (fresize_image,1.0)
	
	CatchErrors("Main loop / uncaught")
	
	if (Vsync == 0) {
		Flip (0)
	} else { 
		Flip (1)
	}
}

function QuickLoadEvents() {
	CatchErrors("Uncaught (QuickLoadEvents)")
	
	if (QuickLoad_CurrEvent == Null) {
		QuickLoadPercent = -1
		return
	}
	
	let e: Events = QuickLoad_CurrEvent
	
	let r: Rooms
	let sc: SecurityCams
	let sc2: SecurityCams
	let scale: float
	let pvt: int
	let n: NPCs
	let tex: int
	let i: int
	let x: float
	let z: float
	
	//might be a good idea to use QuickLoadPercent to determine the "steps" of the loading process 
	//instead of magic values in e\eventState and e\eventStr

	switch (e.EventName) {
		case "room2sl":
			//[Block]
			if (e.EventState = 0 && e.EventStr != "") {
				if (e.EventStr != "" && Left(e.EventStr,4) != "load") {
					QuickLoadPercent = QuickLoadPercent + 5
					if (Int(e.EventStr) > 9) {
						e.EventStr = "load2"
					} else {
						e.EventStr = Int(e.EventStr) + 1
					}
				} else if (e.EventStr = "load2") {
					//For SCP-049
					let skip = false
					if (e.room.NPC[0]=Null) {
						for (n of NPCs.each) {
							if (n.NPCtype = NPCtype049) {
								skip = true
								break
							}
						}
						
						if (!skip) {
							e.room.NPC[0] = CreateNPC(NPCtype049,EntityX(e.room.Objects[7],true),EntityY(e.room.Objects[7],true)+5,EntityZ(e.room.Objects[7],true))
							e.room.NPC[0].HideFromNVG = true
							PositionEntity (e.room.NPC[0].Collider,EntityX(e.room.Objects[7],true),EntityY(e.room.Objects[7],true)+5,EntityZ(e.room.Objects[7],true))
							ResetEntity (e.room.NPC[0].Collider)
							RotateEntity (e.room.NPC[0].Collider,0,e.room.angle+180,0)
							e.room.NPC[0].State = 0
							e.room.NPC[0].PrevState = 2
							
							DebugLog(EntityX(e.room.Objects[7],true)+", "+EntityY(e.room.Objects[7],true)+", "+EntityZ(e.room.Objects[7],true))
						} else {
							DebugLog("Skipped 049 spawning in room2sl")
						}
					}
					QuickLoadPercent = 80
					e.EventStr = "load3"
				} else if (e.EventStr = "load3") {
					
					e.EventState = 1
					if (e.EventState2 = 0) {e.EventState2 = -(70*5)}
					
					QuickLoadPercent = 100
				}
			}
			
		case "room2closets":
			//[Block]
			if (e.EventState == 0) {
				if (e.EventStr == "load0") {
					QuickLoadPercent = 10
					if (e.room.NPC[0] == Null) {
						e.room.NPC[0] = CreateNPC(NPCtypeD, EntityX(e.room.Objects[0],true),EntityY(e.room.Objects[0],true),EntityZ(e.room.Objects[0],true))
					}
					
					ChangeNPCTextureID(e.room.NPC[0],4)
					e.EventStr = "load1"
				} else if (e.EventStr == "load1") {
					QuickLoadPercent = 20
					e.room.NPC[0].Sound=LoadSound_Strict("SFX/Room/Storeroom/Escape1.ogg")
					e.EventStr = "load2"
				} else if (e.EventStr == "load2") {
					QuickLoadPercent = 35
					e.room.NPC[0].SoundChn = PlaySound2(e.room.NPC[0].Sound, Camera, e.room.NPC[0].Collider, 12)
					e.EventStr = "load3"
				} else if (e.EventStr == "load3") {
					QuickLoadPercent = 55
					if (e.room.NPC[1] == Null) {
						e.room.NPC[1] = CreateNPC(NPCtypeD, EntityX(e.room.Objects[1],true),EntityY(e.room.Objects[1],true),EntityZ(e.room.Objects[1],true))
					}
					
					ChangeNPCTextureID(e.room.NPC[1],2)
					e.EventStr = "load4"
				} else if (e.EventStr == "load4") {
					QuickLoadPercent = 80
					e.room.NPC[1].Sound=LoadSound_Strict("SFX/Room/Storeroom/Escape2.ogg")
					e.EventStr = "load5"
				} else if (e.EventStr == "load5") {
					QuickLoadPercent = 100
					PointEntity (e.room.NPC[0].Collider, e.room.NPC[1].Collider)
					PointEntity (e.room.NPC[1].Collider, e.room.NPC[0].Collider)
					
					e.EventState=1
				}
			}
			
		case "room3storage":
			//[Block]
			if (e.room.NPC[0]=Null) {
				e.room.NPC[0]=CreateNPC(NPCtype939, 0,0,0)
				QuickLoadPercent = 20
			} else if (e.room.NPC[1]=Null) {
				e.room.NPC[1]=CreateNPC(NPCtype939, 0,0,0)
				QuickLoadPercent = 50
			} else if (e.room.NPC[2]=Null) {
				e.room.NPC[2]=CreateNPC(NPCtype939, 0,0,0)
				QuickLoadPercent = 100
			} else {
				if (QuickLoadPercent > -1) {
					QuickLoadPercent = 100
				}
			}
			
		case "room049":
			//[Block]
			if (e.EventState = 0) {
				if (e.EventStr = "load0") {
					n.NPCs = CreateNPC(NPCtypeZombie, EntityX(e.room.Objects[4],true),EntityY(e.room.Objects[4],true),EntityZ(e.room.Objects[4],true))
					PointEntity(n.Collider, e.room.obj)
					TurnEntity(n.Collider, 0, 190, 0)
					QuickLoadPercent = 20
					e.EventStr = "load1"
				} else if (e.EventStr = "load1") {
					n.NPCs = CreateNPC(NPCtypeZombie, EntityX(e.room.Objects[5],true),EntityY(e.room.Objects[5],true),EntityZ(e.room.Objects[5],true))
					PointEntity(n.Collider, e.room.obj)
					TurnEntity(n.Collider, 0, 20, 0)
					QuickLoadPercent = 60
					e.EventStr = "load2"
				} else if (e.EventStr = "load2") {
					for (n of NPCs.each) {
						if (n.NPCtype = NPCtype049) {
							e.room.NPC[0]=n
							e.room.NPC[0].State = 2
							e.room.NPC[0].Idle = 1
							e.room.NPC[0].HideFromNVG = true
							PositionEntity (e.room.NPC[0].Collider,EntityX(e.room.Objects[4],true),EntityY(e.room.Objects[4],true)+3,EntityZ(e.room.Objects[4],true))
							ResetEntity (e.room.NPC[0].Collider)
							break
						}
					}
					if (e.room.NPC[0]=Null) {
						n.NPCs = CreateNPC(NPCtype049, EntityX(e.room.Objects[4],true), EntityY(e.room.Objects[4],true)+3, EntityZ(e.room.Objects[4],true))
						PointEntity (n.Collider, e.room.obj)
						n.State = 2
						n.Idle = 1
						n.HideFromNVG = true
						e.room.NPC[0]=n
					}
					QuickLoadPercent = 100
					e.EventState=1
				}
			}
			
		case "room205":
			//[Block]
			if (e.EventState == 0 || e.room.Objects[0] == 0) {
				if (e.EventStr == "load0") {
					e.room.Objects[3] = LoadAnimMesh_Strict("GFX/npcs/205_demon1.b3d")
					QuickLoadPercent = 10
					e.EventStr = "load1"
				} else if (e.EventStr == "load1") {
					e.room.Objects[4] = LoadAnimMesh_Strict("GFX/npcs/205_demon2.b3d")
					QuickLoadPercent = 20
					e.EventStr = "load2"
				} else if (e.EventStr == "load2") {
					e.room.Objects[5] = LoadAnimMesh_Strict("GFX/npcs/205_demon3.b3d")
					QuickLoadPercent = 30
					e.EventStr = "load3"
				} else if (e.EventStr == "load3") {
					e.room.Objects[6] = LoadAnimMesh_Strict("GFX/npcs/205_woman.b3d")
					QuickLoadPercent = 40
					e.EventStr = "load4"
				} else if (e.EventStr == "load4") {
					QuickLoadPercent = 50
					e.EventStr = "load5"
				} else if (e.EventStr == "load5") {
					for (i of range(3, 7)) {
						PositionEntity(e.room.Objects[i], EntityX(e.room.Objects[0],true), EntityY(e.room.Objects[0],true), EntityZ(e.room.Objects[0],true), true)
						RotateEntity(e.room.Objects[i], -90, EntityYaw(e.room.Objects[0],true), 0, true)
						ScaleEntity(e.room.Objects[i], 0.05, 0.05, 0.05, true)
					}
					QuickLoadPercent = 70
					e.EventStr = "load6"
				} else if (e.EventStr == "load6") {
					//GiveAchievement(Achv205)
					
					HideEntity(e.room.Objects[3])
					HideEntity(e.room.Objects[4])
					HideEntity(e.room.Objects[5])
					QuickLoadPercent = 100
					e.EventStr = "loaddone"
					//e.EventState = 1
				}
			}
			
		case "room860":
			//[Block]
			if (e.EventStr == "load0") {
				QuickLoadPercent = 15
				ForestNPC = CreateSprite()
				ScaleSprite (ForestNPC,0.75*(140.0/410.0),0.75)
				SpriteViewMode (ForestNPC,4)
				EntityFX (ForestNPC,1+8)
				ForestNPCTex = LoadAnimTexture("GFX/npcs/AgentIJ.AIJ",1+2,140,410,0,4)
				ForestNPCData[0] = 0
				EntityTexture (ForestNPC,ForestNPCTex,ForestNPCData[0])
				ForestNPCData[1]=0
				ForestNPCData[2]=0
				HideEntity (ForestNPC)
				e.EventStr = "load1"
			} else if (e.EventStr == "load1") {
				QuickLoadPercent = 40
				e.EventStr = "load2"
			} else if (e.EventStr == "load2") {
				QuickLoadPercent = 100
				if (e.room.NPC[0] == Null) {e.room.NPC[0]=CreateNPC(NPCtype860, 0,0,0)}
				e.EventStr = "loaddone"
			}
			
		case "room966":
			//[Block]
			if (e.EventState = 1) {
				e.EventState2 = e.EventState2+FPSfactor
				if (e.EventState2>30) {
					if (e.EventStr = "") {
						CreateNPC(NPCtype966, EntityX(e.room.Objects[0],true), EntityY(e.room.Objects[0],true), EntityZ(e.room.Objects[0],true))
						QuickLoadPercent = 50
						e.EventStr = "load0"
					} else if (e.EventStr = "load0") {
						CreateNPC(NPCtype966, EntityX(e.room.Objects[2],true), EntityY(e.room.Objects[2],true), EntityZ(e.room.Objects[2],true))
						QuickLoadPercent = 100
						e.EventState=2
					}
				} else {
					QuickLoadPercent = Int(e.EventState2)
				}
			}
			
		case "dimension1499":
			//[Block]
			if (e.EventState = 0.0) {
				if (e.EventStr = "load0") {
					QuickLoadPercent = 10
					e.room.Objects[0] = LoadMesh_Strict("GFX/map/dimension1499/1499plane.b3d")
					HideEntity (e.room.Objects[0])
					e.EventStr = "load1"
				} else if (e.EventStr = "load1") {
					QuickLoadPercent = 30
					NTF_1499Sky = sky_CreateSky("GFX/map/sky/1499sky")
					e.EventStr = 1
				} else {
					if (Int(e.EventStr)<16) {
						QuickLoadPercent = QuickLoadPercent + 2
						e.room.Objects[Int(e.EventStr)] = LoadMesh_Strict("GFX/map/dimension1499/1499object"+(Int(e.EventStr))+".b3d")
						HideEntity (e.room.Objects[Int(e.EventStr)])
						e.EventStr = Int(e.EventStr)+1
					} else if (Int(e.EventStr)=16) {
						QuickLoadPercent = 90
						CreateChunkParts(e.room)
						e.EventStr = 17
					} else if (Int(e.EventStr) = 17) {
						QuickLoadPercent = 100
						x = EntityX(e.room.obj)
						z = EntityZ(e.room.obj)
						let ch: Chunk
						for (i of range(-1, 0, 2)) {
							ch = CreateChunk(-1,x*(i*2.5),EntityY(e.room.obj),z,true)
						}
						for (i of range(-1, 0, 2)) {
							ch = CreateChunk(-1,x*(i*2.5),EntityY(e.room.obj),z-40,true)
						}
						e.EventState = 2.0
						e.EventStr = 18
					}
				}
			}
			
	}
	
	CatchErrors("QuickLoadEvents "+e.EventName)
	
}

function Kill() {
	if (GodMode) {return}
	
	if (BreathCHN != 0) {
		if (ChannelPlaying(BreathCHN)) {StopChannel(BreathCHN)}
	}
	
	if (KillTimer >= 0) {
		KillAnim = Rand(0,1)
		PlaySound_Strict(DamageSFX(0))
		if (SelectedDifficulty.permaDeath) {
			DeleteFile(CurrentDir() + SavePath + CurrSave+"/save.txt") 
			DeleteDir(SavePath + CurrSave)
			LoadSaveGames()
		}
		
		KillTimer = Min(-1, KillTimer)
		ShowEntity (Head)
		PositionEntity(Head, EntityX(Camera, true), EntityY(Camera, true), EntityZ(Camera, true), true)
		ResetEntity (Head)
		RotateEntity(Head, 0, EntityYaw(Camera), 0)		
	}
}

function DrawEnding() {
	
	ShowPointer()
	
	FPSfactor = 0
	if (EndingTimer>-2000) {
		EndingTimer=Max(EndingTimer-FPSfactor2,-1111)
	} else {
		EndingTimer=EndingTimer-FPSfactor2
	}
	
	GiveAchievement(Achv055)
	if (!UsedConsole) {GiveAchievement(AchvConsole)}
	if (SelectedDifficulty.name == "Keter") {GiveAchievement(AchvKeter)}
	let x,y,width,height, temp
	let itt: ItemTemplates, r: Rooms
	
	switch (Lower(SelectedEnding)) {
		case "b2", "a1":
			ClsColor(Max(255+(EndingTimer)*2.8,0), Max(255+(EndingTimer)*2.8,0), Max(255+(EndingTimer)*2.8,0))
		default:
			ClsColor(0,0,0)
	}
	
	ShouldPlay = 66
	
	Cls()
	
	if (EndingTimer<-200) {
		
		if (BreathCHN != 0) {
			if (ChannelPlaying(BreathCHN)) {
				StopChannel (BreathCHN)
				Stamina = 100
			}
		}
				
		if (EndingScreen == 0) {
			EndingScreen = LoadImage_Strict("GFX/endingscreen.pt")
			
			ShouldPlay = 23
			CurrMusicVolume = MusicVolume
			
			CurrMusicVolume = MusicVolume
			StopStream_Strict(MusicCHN)
			MusicCHN = StreamSound_Strict("SFX/Music/"+Music(23)+".ogg",CurrMusicVolume,0)
			NowPlaying = ShouldPlay
			
			PlaySound_Strict (LightSFX)
		}
		
		if (EndingTimer > -700) { 
			
			if (Rand(1,150)<Min((Abs(EndingTimer)-200),155)) {
				DrawImage (EndingScreen, GraphicWidth/2-400, GraphicHeight/2-400)
			} else {
				Color(0,0,0)
				Rect (100,100,GraphicWidth-200,GraphicHeight-200)
				Color(255,255,255)
			}
			
			if (EndingTimer+FPSfactor2 > -450 && EndingTimer <= -450) {
				switch (Lower(SelectedEnding)) {
					case "a1", "a2":
						PlaySound_Strict(LoadTempSound("SFX/Ending/GateA/Ending"+SelectedEnding+".ogg"))
					case "b1", "b2", "b3":
						PlaySound_Strict(LoadTempSound("SFX/Ending/GateB/Ending"+SelectedEnding+".ogg"))
				}
			}			
			
		} else {
			
			DrawImage (EndingScreen, GraphicWidth/2-400, GraphicHeight/2-400)
			
			if (EndingTimer < -1000 && EndingTimer > -2000) {
				
				width = ImageWidth(PauseMenuIMG)
				height = ImageHeight(PauseMenuIMG)
				x = GraphicWidth / 2 - width / 2
				y = GraphicHeight / 2 - height / 2
				
				DrawImage(PauseMenuIMG, x, y)
				
				Color(255, 255, 255)
				AASetFont(Font2)
				AAText(x + width / 2 + 40*MenuScale, y + 20*MenuScale, "THE END", true)
				AASetFont(Font1)
				
				if (AchievementsMenu=0) { 
					x = x+132*MenuScale
					y = y+122*MenuScale
					
					let roomamount = 0, roomsfound = 0
					for (r of Rooms.each) {
						roomamount = roomamount + 1
						roomsfound = roomsfound + r.found
					}
					
					let docamount=0, docsfound=0
					for (itt of ItemTemplates.each) {
						if (itt.tempname = "paper") {
							docamount=docamount+1
							docsfound=docsfound+itt.found
						}
					}
					
					let scpsEncountered = 1
					for (i of range(25)) {
						scpsEncountered = scpsEncountered+Achievements(i)
					}
					
					let achievementsUnlocked =0
					for (i of range(MAXACHIEVEMENTS)) {
						achievementsUnlocked = achievementsUnlocked + Achievements(i)
					}
					
					AAText(x, y, "SCPs encountered: " +scpsEncountered)
					AAText(x, y+20*MenuScale, "Achievements unlocked: " + achievementsUnlocked+"/"+(MAXACHIEVEMENTS))
					AAText(x, y+40*MenuScale, "Rooms found: " + roomsfound+"/"+roomamount)
					AAText(x, y+60*MenuScale, "Documents discovered: " +docsfound+"/"+docamount)
					AAText(x, y+80*MenuScale, "Items refined in SCP-914: " +RefinedItems			)
					
					x = GraphicWidth / 2 - width / 2
					y = GraphicHeight / 2 - height / 2
					x = x+width/2
					y = y+height-100*MenuScale
					
					if (DrawButton(x-145*MenuScale,y-200*MenuScale,390*MenuScale,60*MenuScale,"ACHIEVEMENTS", true)) {
						AchievementsMenu = 1
					}
										
					if (DrawButton(x-145*MenuScale,y-100*MenuScale,390*MenuScale,60*MenuScale,"MAIN MENU", true)) {
						ShouldPlay = 24
						NowPlaying = ShouldPlay
						for (i of range(10)) {
							if (TempSounds[i] != 0) {
								FreeSound_Strict (TempSounds[i])
								TempSounds[i]=0
							}
						}
						StopStream_Strict(MusicCHN)
						MusicCHN = StreamSound_Strict("SFX/Music/"+Music(NowPlaying)+".ogg",0.0,Mode)
						SetStreamVolume_Strict(MusicCHN,1.0*MusicVolume)
						FlushKeys()
						EndingTimer=-2000
						InitCredits()
					}
				} else {
					ShouldPlay = 23
					DrawMenu()
				}
			//Credits
			} else if (EndingTimer<=-2000) {
				ShouldPlay = 24
				DrawCredits()
			}
			
		}
		
	}
	
	if (Fullscreen) {DrawImage(CursorIMG, ScaledMouseX(),ScaledMouseY())}
	
	AASetFont (Font1)
}

class CreditsLine {
	txt: string
	id: int
	stay: int
}

var CreditsTimer: float = 0.0
var CreditsScreen: int

function InitCredits() {
	let cl: CreditsLine
	let file: int = OpenFile("Credits.txt")
	let l: string
	
	CreditsFont = LoadFont_Strict("GFX/font/cour/Courier New.ttf", Int(21 * (GraphicHeight / 1024.0)), 0,0,0)
	CreditsFont2 = LoadFont_Strict("GFX/font/courbd/Courier New.ttf", Int(35 * (GraphicHeight / 1024.0)), 0,0,0)
	
	if (CreditsScreen = 0) {
		CreditsScreen = LoadImage_Strict("GFX/creditsscreen.pt")
	}
	
	do {
		l = ReadLine(file)
		cl = new CreditsLine()
		cl.txt = l
 	} while (!Eof(file))
	
	Delete(CreditsLine.each[0])
	CreditsTimer = 0
	
}

function DrawCredits() {
    let credits_Y: float = (EndingTimer+2000)/2+(GraphicHeight+10)
    let cl: CreditsLine
    let id: int
    let endlinesamount: int
	let LastCreditLine: CreditsLine
	
    Cls()
	
	if (Rand(1,300)>1) {
		DrawImage(CreditsScreen, GraphicWidth/2-400, GraphicHeight/2-400)
	}
	
	id = 0
	endlinesamount = 0
	LastCreditLine = Null
	Color (255,255,255)
	for (cl of CreditsLine.each) {
		cl.id = id
		if (Left(cl.txt,1)="*") {
			SetFont (CreditsFont2)
			if (cl.stay=false) {
				Text(GraphicWidth/2,credits_Y+(24*cl.id*MenuScale),Right(cl.txt,Len(cl.txt)-1),true)
			}
		} else if (Left(cl.txt,1)="/") {
			LastCreditLine = Before(cl)
		} else {
			SetFont (CreditsFont)
			if (cl.stay=false) {
				Text(GraphicWidth/2,credits_Y+(24*cl.id*MenuScale),cl.txt,true)
			}
		}
		if (LastCreditLine != Null) {
			if (cl.id>LastCreditLine.id) {
				cl.stay = true
			}
		}
		if (cl.stay) {
			endlinesamount=endlinesamount+1
		}
		id=id+1
	}
	if ((credits_Y+(24*LastCreditLine.id*MenuScale))<-StringHeight(LastCreditLine.txt)) {
		CreditsTimer=CreditsTimer+(0.5*FPSfactor2)
		if (CreditsTimer>=0.0 && CreditsTimer<255.0) {
			Color(Max(Min(CreditsTimer,255),0),Max(Min(CreditsTimer,255),0),Max(Min(CreditsTimer,255),0))
		} else if (CreditsTimer>=255.0) {
			Color(255,255,255)
			if (CreditsTimer>500.0) {
				CreditsTimer=-255.0
			}
		} else {
			Color(Max(Min(-CreditsTimer,255),0),Max(Min(-CreditsTimer,255),0),Max(Min(-CreditsTimer,255),0))
			if (CreditsTimer>=-1.0) {
				CreditsTimer=-1.0
			}
		}
		DebugLog (CreditsTimer)
	}
	if (CreditsTimer != 0.0) {
		for (cl of CreditsLine.each) {
			if (cl.stay) {
				SetFont (CreditsFont)
				if (Left(cl.txt,1)="/") {
					Text (GraphicWidth/2,(GraphicHeight/2)+(endlinesamount/2)+(24*cl.id*MenuScale),Right(cl.txt,Len(cl.txt)-1),true)
				} else {
					Text (GraphicWidth/2,(GraphicHeight/2)+(24*(cl.id-LastCreditLine.id)*MenuScale)-((endlinesamount/2)*24*MenuScale),cl.txt,true)
				}
			}
		}
	}
	
	if (GetKey()) {CreditsTimer=-1}
	
	if (CreditsTimer == -1) {
		FreeFont(CreditsFont)
		FreeFont(CreditsFont2)
		FreeImage(CreditsScreen)
		CreditsScreen = 0
		FreeImage(EndingScreen)
		EndingScreen = 0
		Delete(CreditsLine.each)
        NullGame(false)
        StopStream_Strict(MusicCHN)
        ShouldPlay = 21
        MenuOpen = false
        MainMenuOpen = true
        MainMenuTab = 0
        CurrSave = ""
        FlushKeys()
	}
    
}

//--------------------------------------- player controls -------------------------------------------

function MovePlayer() {
	CatchErrors("Uncaught (MovePlayer)")
	let Sprint: float = 1.0, Speed: float = 0.018, i: int, angle: float
	
	if (SuperMan) {
		Speed = Speed * 3
		
		SuperManTimer=SuperManTimer+FPSfactor
		
		CameraShake = Sin(SuperManTimer / 5.0) * (SuperManTimer / 1500.0)
		
		if (SuperManTimer > 70 * 50) {
			DeathMSG = "A Class D jumpsuit found in [DATA REDACTED]. Upon further examination, the jumpsuit was found to be filled with 12.5 kilograms of blue ash-like substance. "
			DeathMSG = DeathMSG + "Chemical analysis of the substance remains non-conclusive. Most likely related to SCP-914."
			Kill()
			ShowEntity (Fog)
		} else {
			BlurTimer = 500		
			HideEntity (Fog)
		}
	}
	
	if (DeathTimer > 0) {
		DeathTimer=DeathTimer-FPSfactor
		if (DeathTimer < 1) {DeathTimer = -1.0}
	} else if (DeathTimer < 0 ) {
		Kill()
	}
	
	if (CurrSpeed > 0) {
        Stamina = Min(Stamina + 0.15 * FPSfactor/1.25, 100.0)
	} else {
        Stamina = Min(Stamina + 0.15 * FPSfactor*1.25, 100.0)
	}
	
	if (StaminaEffectTimer > 0) {
		StaminaEffectTimer = StaminaEffectTimer - (FPSfactor/70)
	} else if (StaminaEffect != 1.0) {
		StaminaEffect = 1.0
	}
	
	let temp: float
	
	if (PlayerRoom.RoomTemplate.Name != "pocketdimension") { 
		if (KeyDown(KEY_SPRINT)) {
			if (Stamina < 5) {
				temp = 0
				if (WearingGasMask>0 || Wearing1499>0) {temp=1}
				if (ChannelPlaying(BreathCHN)=false) {BreathCHN = PlaySound_Strict(BreathSFX((temp), 0))}
			} else if (Stamina < 50) {
				if (BreathCHN=0) {
					temp = 0
					if (WearingGasMask>0 || Wearing1499>0) {temp=1}
					BreathCHN = PlaySound_Strict(BreathSFX((temp), Rand(1,3)))
					ChannelVolume (BreathCHN, Min((70.0-Stamina)/70.0,1.0)*SFXVolume)
				} else {
					if (ChannelPlaying(BreathCHN)=false) {
						temp = 0
						if (WearingGasMask>0 || Wearing1499>0) {temp=1}
						BreathCHN = PlaySound_Strict(BreathSFX((temp), Rand(1,3)))
						ChannelVolume (BreathCHN, Min((70.0-Stamina)/70.0,1.0)*SFXVolume)
					}
				}
			}
		}
	}
	
	for (i of range(MaxItemAmount)) {
		if (Inventory(i) != Null) {
			if (Inventory(i).itemtemplate.tempname = "finevest") {Stamina = Min(Stamina, 60)}
		}
	}
	
	if (Wearing714) {
		Stamina = Min(Stamina, 10)
		Sanity = Max(-850, Sanity)
	}
	
	if (IsZombie) {Crouch = false}
	
	if (Abs(CrouchState-Crouch)<0.001) {
		CrouchState = Crouch
	} else {
		CrouchState = CurveValue(Crouch, CrouchState, 10.0)
	}
	
	if (!NoClip) { 
		if (((KeyDown(KEY_DOWN) || KeyDown(KEY_UP)) || (KeyDown(KEY_RIGHT) || KeyDown(KEY_LEFT)) && Playable) || ForceMove>0) {
			
			if (Crouch = 0 && (KeyDown(KEY_SPRINT)) && Stamina > 0.0 && (!IsZombie)) {
				Sprint = 2.5
				Stamina = Stamina - FPSfactor * 0.4 * StaminaEffect
				if (Stamina <= 0) {
					Stamina = -20.0
				}
			}
			
			if (PlayerRoom.RoomTemplate.Name = "pocketdimension") {
				if (EntityY(Collider)<2000*RoomScale || EntityY(Collider)>2608*RoomScale) {
					Stamina = 0
					Speed = 0.015
					Sprint = 1.0					
				}
			}	
			
			if (ForceMove>0) {Speed=Speed*ForceMove}
			
			if (SelectedItem != Null) {
				if (SelectedItem.itemtemplate.tempname == "firstaid" || SelectedItem.itemtemplate.tempname == "finefirstaid" || SelectedItem.itemtemplate.tempname == "firstaid2") { 
					Sprint = 0
				}
			}
			
			temp = (Shake % 360)
			let tempchn: int
			if (!UnableToMove) {Shake = (Shake + FPSfactor * Min(Sprint, 1.5) * 7) % 720}
			if (temp < 180 && (Shake % 360) >= 180 && KillTimer>=0) {
				if (CurrStepSFX == 0) {
					temp = GetStepSound(Collider)
					
					if (Sprint = 1.0) {
						PlayerSoundVolume = Max(4.0,PlayerSoundVolume)
						tempchn = PlaySound_Strict(StepSFX(temp, 0, Rand(0, 7)))
						ChannelVolume(tempchn, (1.0-(Crouch*0.6))*SFXVolume)
					} else {
						PlayerSoundVolume = Max(2.5-(Crouch*0.6),PlayerSoundVolume)
						tempchn = PlaySound_Strict(StepSFX(temp, 1, Rand(0, 7)))
						ChannelVolume(tempchn, (1.0-(Crouch*0.6))*SFXVolume)
					}
				} else if (CurrStepSFX == 1) {
					tempchn = PlaySound_Strict(Step2SFX(Rand(0, 2)))
					ChannelVolume(tempchn, (1.0-(Crouch*0.4))*SFXVolume)
				} else if (CurrStepSFX == 2) {
					tempchn = PlaySound_Strict(Step2SFX(Rand(3,5)))
					ChannelVolume(tempchn, (1.0-(Crouch*0.4))*SFXVolume)
				} else if (CurrStepSFX == 3) {
					if (Sprint == 1.0) {
						PlayerSoundVolume = Max(4.0,PlayerSoundVolume)
						tempchn = PlaySound_Strict(StepSFX(0, 0, Rand(0, 7)))
						ChannelVolume(tempchn, (1.0-(Crouch*0.6))*SFXVolume)
					} else {
						PlayerSoundVolume = Max(2.5-(Crouch*0.6),PlayerSoundVolume)
						tempchn = PlaySound_Strict(StepSFX(0, 1, Rand(0, 7)))
						ChannelVolume(tempchn, (1.0-(Crouch*0.6))*SFXVolume)
					}
				}
				
			}	
		}
	} else { //noclip on
		if (KeyDown(KEY_SPRINT)) { 
			Sprint = 2.5
		} else if (KeyDown(KEY_CROUCH)) {
			Sprint = 0.5
		}
	}
	
	if (KeyHit(KEY_CROUCH) && Playable) {Crouch = !Crouch}
	
	let temp2: float = (Speed * Sprint) / (1.0+CrouchState)
	
	if (NoClip) {
		Shake = 0
		CurrSpeed = 0
		CrouchState = 0
		Crouch = 0
		
		RotateEntity (Collider, WrapAngle(EntityPitch(Camera)), WrapAngle(EntityYaw(Camera)), 0)
		
		temp2 = temp2 * NoClipSpeed
		
		if (KeyDown(KEY_DOWN)) {MoveEntity(Collider, 0, 0, -temp2*FPSfactor)}
		if (KeyDown(KEY_UP)) {MoveEntity(Collider, 0, 0, temp2*FPSfactor)}
		
		if (KeyDown(KEY_LEFT)) {MoveEntity(Collider, -temp2*FPSfactor, 0, 0)}
		if (KeyDown(KEY_RIGHT)) {MoveEntity(Collider, temp2*FPSfactor, 0, 0	)}
		
		ResetEntity (Collider)
	} else {
		temp2 = temp2 / Max((Injuries+3.0)/3.0,1.0)
		if (Injuries > 0.5) {
			temp2 = temp2*Min((Sin(Shake/2)+1.2),1.0)
		}
		
		temp = false
		if (!IsZombie) {
			if (KeyDown(KEY_DOWN) && Playable) {
				temp = true 
				angle = 180
				if (KeyDown(KEY_LEFT)) {angle = 135}
				if (KeyDown(KEY_RIGHT)) {angle = -135}
			} else if (KeyDown(KEY_UP) && Playable) {
				temp = true
				angle = 0
				if (KeyDown(KEY_LEFT)) {angle = 45}
				if (KeyDown(KEY_RIGHT)) {angle = -45}
			} else if (ForceMove>0) {
				temp=true
				angle = ForceAngle
			 } else if (Playable) {
				if (KeyDown(KEY_LEFT)) {
					angle = 90
					temp = true
				}
				if (KeyDown(KEY_RIGHT)) {
					angle = -90
					temp = true 
				}
			}
		} else {
			temp=true
			angle = ForceAngle
		}
		
		angle = WrapAngle(EntityYaw(Collider,true)+angle+90.0)
		
		if (temp) {
			CurrSpeed = CurveValue(temp2, CurrSpeed, 20.0)
		} else {
			CurrSpeed = Max(CurveValue(0.0, CurrSpeed-0.1, 1.0),0.0)
		}
		
		if (!UnableToMove) {
			TranslateEntity (Collider, Cos(angle)*CurrSpeed * FPSfactor, 0, Sin(angle)*CurrSpeed * FPSfactor, true)
		}
		
		let CollidedFloor: boolean = false
		for (i of range(1, CountCollisions(Collider) + 1)) {
			if (CollisionY(Collider, i) < EntityY(Collider) - 0.25) {CollidedFloor = true}
		}
		
		if (CollidedFloor) {
			if (DropSpeed < - 0.07) { 
				if (CurrStepSFX=0) {
					PlaySound_Strict(StepSFX(GetStepSound(Collider), 0, Rand(0, 7)))
				} else if (CurrStepSFX == 1) {
					PlaySound_Strict(Step2SFX(Rand(0, 2)))
				} else if (CurrStepSFX == 2) {
					PlaySound_Strict(Step2SFX(Rand(3, 5)))
				} else if (CurrStepSFX == 3) {
					PlaySound_Strict(StepSFX(0, 0, Rand(0, 7)))
				}
				PlayerSoundVolume = Max(3.0,PlayerSoundVolume)
			}
			DropSpeed = 0
		} else {
			if (PlayerFallingPickDistance != 0.0) {
				let pick = LinePick(EntityX(Collider),EntityY(Collider),EntityZ(Collider),0,-PlayerFallingPickDistance,0)
				if (pick) {
					DropSpeed = Min(Max(DropSpeed - 0.006 * FPSfactor, -2.0), 0.0)
				} else {
					DropSpeed = 0
				}
			} else {
				DropSpeed = Min(Max(DropSpeed - 0.006 * FPSfactor, -2.0), 0.0)
			}
		}
		PlayerFallingPickDistance = 10.0
		
		if ((!UnableToMove) && ShouldEntitiesFall) {TranslateEntity (Collider, 0, DropSpeed * FPSfactor, 0)}
	}
	
	ForceMove = false
	
	if (Injuries > 1.0) {
		temp2 = Bloodloss
		BlurTimer = Max(Max(Sin(MilliSecs2()/100.0)*Bloodloss*30.0,Bloodloss*2*(2.0-CrouchState)),BlurTimer)
		if (!I_427.Using && I_427.Timer < 70*360) {
			Bloodloss = Min(Bloodloss + (Min(Injuries,3.5)/300.0)*FPSfactor,100)
		}
		
		if (temp2 <= 60 && Bloodloss > 60) {
			Msg = "You are feeling faint from the amount of blood you have lost."
			MsgTimer = 70*4
		}
	}
	
	UpdateInfect()
	
	if (Bloodloss > 0) {
		if (Rnd(200)<Min(Injuries,4.0)) {
			pvt = CreatePivot()
			PositionEntity (pvt, EntityX(Collider)+Rnd(-0.05,0.05),EntityY(Collider)-0.05,EntityZ(Collider)+Rnd(-0.05,0.05))
			TurnEntity (pvt, 90, 0, 0)
			EntityPick(pvt,0.3)
			de.decals = CreateDecal(Rand(15,16), PickedX(), PickedY()+0.005, PickedZ(), 90, Rand(360), 0)
			de.size = Rnd(0.03,0.08)*Min(Injuries,3.0)
			EntityAlpha(de.obj, 1.0)
			ScaleSprite (de.obj, de.size, de.size)
			tempchn = PlaySound_Strict (DripSFX(Rand(0,2)))
			ChannelVolume (tempchn, Rnd(0.0,0.8)*SFXVolume)
			ChannelPitch (tempchn, Rand(20000,30000))
			
			FreeEntity (pvt)
		}
		
		CurrCameraZoom = Max(CurrCameraZoom, (Sin(Float(MilliSecs2())/20.0)+1.0)*Bloodloss*0.2)
		
		if (Bloodloss > 60) {Crouch = true}
		if (Bloodloss => 100) { 
			Kill()
			HeartBeatVolume = 0.0
		} else if (Bloodloss > 80.0) {
			HeartBeatRate = Max(150-(Bloodloss-80)*5,HeartBeatRate)
			HeartBeatVolume = Max(HeartBeatVolume, 0.75+(Bloodloss-80.0)*0.0125)	
		} else if (Bloodloss > 35.0) {
			HeartBeatRate = Max(70+Bloodloss,HeartBeatRate)
			HeartBeatVolume = Max(HeartBeatVolume, (Bloodloss-35.0)/60.0)			
		}
	}
	
	if (HealTimer > 0) {
		DebugLog (HealTimer)
		HealTimer = HealTimer - (FPSfactor / 70)
		Bloodloss = Min(Bloodloss + (2 / 400.0) * FPSfactor, 100)
		Injuries = Max(Injuries - (FPSfactor / 70) / 30, 0.0)
	}
		
	if (Playable) {
		if (KeyHit(KEY_BLINK)) {BlinkTimer = 0}
		if (KeyDown(KEY_BLINK) && BlinkTimer < - 10) {BlinkTimer = -10}
	}
	
	
	if (HeartBeatVolume > 0) {
		if (HeartBeatTimer <= 0) {
			tempchn = PlaySound_Strict (HeartBeatSFX)
			ChannelVolume (tempchn, HeartBeatVolume*SFXVolume)
			
			HeartBeatTimer = 70.0*(60.0/Max(HeartBeatRate,1.0))
		} else {
			HeartBeatTimer = HeartBeatTimer - FPSfactor
		}
		
		HeartBeatVolume = Max(HeartBeatVolume - FPSfactor*0.05, 0)
	}
	
	CatchErrors("MovePlayer")
}

function MouseLook() {
	let i: int
	
	CameraShake = Max(CameraShake - (FPSfactor / 10), 0)
	
	CameraZoom(Camera, Min(1.0+(CurrCameraZoom/400.0),1.1))
	CurrCameraZoom = Max(CurrCameraZoom - FPSfactor, 0)
	
	if (KillTimer >= 0 && FallTimer >=0) {
		
		HeadDropSpeed = 0
		
		//fixing the black screen bug with some bubblegum code 
		let Zero: float = 0.0
		let Nan1: float = 0.0 / Zero
		if (Int(EntityX(Collider))=Int(Nan1)) {
			
			PositionEntity (Collider, EntityX(Camera, true), EntityY(Camera, true) - 0.5, EntityZ(Camera, true), true)
			Msg = "EntityX(Collider) = NaN, RESETTING COORDINATES    -    New coordinates: "+EntityX(Collider)
			MsgTimer = 300				
		}
		//EndIf
		
		let up: float = (Sin(Shake) / (20.0+CrouchState*20.0))*0.6//, side# = Cos(Shake / 2.0) / 35.0		
		let roll: float = Max(Min(Sin(Shake/2)*2.5*Min(Injuries+0.25,3.0),8.0),-8.0)
		
		//knnetn kameraa sivulle jos pelaaja on vammautunut
		PositionEntity (Camera, EntityX(Collider), EntityY(Collider), EntityZ(Collider))
		RotateEntity (Camera, 0, EntityYaw(Collider), roll*0.5)
		
		MoveEntity (Camera, side, up + 0.6 + CrouchState * -0.3, 0)
		
		//moveentity player, side, up, 0	
		// -- Update the smoothing que To smooth the movement of the mouse.
		mouse_x_speed_1 = CurveValue(MouseXSpeed() * (MouseSens + 0.6) , mouse_x_speed_1, (6.0 / (MouseSens + 1.0))*MouseSmooth) 
		if (Int(mouse_x_speed_1) = Int(Nan1)) {mouse_x_speed_1 = 0}
		if (PrevFPSFactor>0) {
            if (Abs(FPSfactor/PrevFPSFactor-1.0)>1.0) {
                //lag spike detected - stop all camera movement
                mouse_x_speed_1 = 0.0
                mouse_y_speed_1 = 0.0
			}
		}
		if (InvertMouse) {
			mouse_y_speed_1 = CurveValue(-MouseYSpeed() * (MouseSens + 0.6), mouse_y_speed_1, (6.0/(MouseSens+1.0))*MouseSmooth) 
		} else {
			mouse_y_speed_1 = CurveValue(MouseYSpeed () * (MouseSens + 0.6), mouse_y_speed_1, (6.0/(MouseSens+1.0))*MouseSmooth) 
		}

		if (Int(mouse_y_speed_1) == Int(Nan1)) {mouse_y_speed_1 = 0}
		
		let the_yaw: float = ((mouse_x_speed_1)) * mouselook_x_inc / (1.0+WearingVest)
		let the_pitch: float = ((mouse_y_speed_1)) * mouselook_y_inc / (1.0+WearingVest)
		
		TurnEntity (Collider, 0.0, -the_yaw, 0.0) // Turn the user on the Y (yaw) axis.
		user_camera_pitch = user_camera_pitch + the_pitch
		// -- Limit the user//s camera To within 180 degrees of pitch rotation. //EntityPitch()// returns useless values so we need To use a variable To keep track of the camera pitch.
		if (user_camera_pitch > 70.0) {user_camera_pitch = 70.0}
		if (user_camera_pitch < - 70.0) {user_camera_pitch = -70.0}
		
		RotateEntity (Camera, WrapAngle(user_camera_pitch + Rnd(-CameraShake, CameraShake)), WrapAngle(EntityYaw(Collider) + Rnd(-CameraShake, CameraShake)), roll) // Pitch the user//s camera up && down.)
		
		if (PlayerRoom.RoomTemplate.Name == "pocketdimension") {
			if (EntityY(Collider)<2000*RoomScale || EntityY(Collider)>2608*RoomScale) {
				RotateEntity (Camera, WrapAngle(EntityPitch(Camera)),WrapAngle(EntityYaw(Camera)), roll+WrapAngle(Sin(MilliSecs2()/150.0)*30.0)) // Pitch the user//s camera up && down.
			}
		}
		
	} else { 
		HideEntity(Collider)
		PositionEntity(Camera, EntityX(Head), EntityY(Head), EntityZ(Head))
		
		let CollidedFloor: boolean = false
		for (i of range(1, CountCollisions(Head) + 1)) {
			if (CollisionY(Head, i) < EntityY(Head) - 0.01) {CollidedFloor = true}
		}
		
		if (CollidedFloor) {
			HeadDropSpeed = 0
		} else {
			
			if (KillAnim = 0) {
				MoveEntity (Head, 0, 0, HeadDropSpeed)
				RotateEntity(Head, CurveAngle(-90.0, EntityPitch(Head), 20.0), EntityYaw(Head), EntityRoll(Head))
				RotateEntity(Camera, CurveAngle(EntityPitch(Head) - 40.0, EntityPitch(Camera), 40.0), EntityYaw(Camera), EntityRoll(Camera))
			} else {
				MoveEntity (Head, 0, 0, -HeadDropSpeed)
				RotateEntity(Head, CurveAngle(90.0, EntityPitch(Head), 20.0), EntityYaw(Head), EntityRoll(Head))
				RotateEntity(Camera, CurveAngle(EntityPitch(Head) + 40.0, EntityPitch(Camera), 40.0), EntityYaw(Camera), EntityRoll(Camera))
			}
			
			HeadDropSpeed = HeadDropSpeed - 0.002 * FPSfactor
		}
		
		if (InvertMouse) {
			TurnEntity (Camera, -MouseYSpeed() * 0.05 * FPSfactor, -MouseXSpeed() * 0.15 * FPSfactor, 0)
		} else {
			TurnEntity (Camera, MouseYSpeed() * 0.05 * FPSfactor, -MouseXSpeed() * 0.15 * FPSfactor, 0)
		}
		
	}
	
	//plyhiukkasia
	if (ParticleAmount=2) {
		if (Rand(35) = 1) {
			let pvt: int = CreatePivot()
			PositionEntity(pvt, EntityX(Camera, true), EntityY(Camera, true), EntityZ(Camera, true))
			RotateEntity(pvt, 0, Rnd(360), 0)
			if (Rand(2) = 1) {
				MoveEntity(pvt, 0, Rnd(-0.5, 0.5), Rnd(0.5, 1.0))
			} else {
				MoveEntity(pvt, 0, Rnd(-0.5, 0.5), Rnd(0.5, 1.0))
			}
			
			let p: Particles = CreateParticle(EntityX(pvt), EntityY(pvt), EntityZ(pvt), 2, 0.002, 0, 300)
			p.speed = 0.001
			RotateEntity(p.pvt, Rnd(-20, 20), Rnd(360), 0)
			
			p.SizeChange = -0.00001
			
			FreeEntity (pvt)
		}
	}
	
	// -- Limit the mouse//s movement. Using this method produces smoother mouselook movement than centering the mouse Each loop.
	if ((MouseX() > mouse_right_limit) || (MouseX() < mouse_left_limit) || (MouseY() > mouse_bottom_limit) || (MouseY() < mouse_top_limit)) {
		MoveMouse (viewport_center_x, viewport_center_y)
	}
	
	if (WearingGasMask || WearingHazmat || Wearing1499) {
		if (!Wearing714) {
			if (WearingGasMask == 2 || Wearing1499 == 2 || WearingHazmat == 2) {
				Stamina = Min(100, Stamina + (100.0-Stamina)*0.01*FPSfactor)
			}
		}
		if (WearingHazmat = 1) {
			Stamina = Min(60, Stamina)
		}
		
		ShowEntity(GasMaskOverlay)
	} else {
		HideEntity(GasMaskOverlay)
	}
	
	if (WearingNightVision != 0) { //Not WearingNightVision=0
		ShowEntity(NVOverlay)
		if (WearingNightVision=2) {
			EntityColor(NVOverlay, 0,100,255)
			AmbientLightRooms(15)
		} else if (WearingNightVision=3) {
			EntityColor(NVOverlay, 255,0,0)
			AmbientLightRooms(15)
		} else {
			EntityColor(NVOverlay, 0,255,0)
			AmbientLightRooms(15)
		}
		EntityTexture(Fog, FogNVTexture)
	} else {
		AmbientLightRooms(0)
		HideEntity(NVOverlay)
		EntityTexture(Fog, FogTexture)
	}
	
	for (i of range(6)) {
		if (SCP1025state[i]>0) {
			switch (i) {
				case 0: //common cold:
					if (FPSfactor>0) { 
						if (Rand(1000) == 1) {
							if (CoughCHN == 0) {
								CoughCHN = PlaySound_Strict(CoughSFX(Rand(0, 2)))
							} else {
								if (!ChannelPlaying(CoughCHN)) {CoughCHN = PlaySound_Strict(CoughSFX(Rand(0, 2)))}
							}
						}
					}
					Stamina = Stamina - FPSfactor * 0.3
				case 1: //chicken pox:
					if (Rand(9000) == 1 && Msg == "") {
						Msg="Your skin is feeling itchy."
						MsgTimer =70*4
					}
				case 2: //cancer of the lungs:
					if (FPSfactor>0) {
						if (Rand(800)=1) {
							if (CoughCHN = 0) {
								CoughCHN = PlaySound_Strict(CoughSFX(Rand(0, 2)))
							} else {
								if (!ChannelPlaying(CoughCHN)) {CoughCHN = PlaySound_Strict(CoughSFX(Rand(0, 2)))}
							}
						}
					}
					Stamina = Stamina - FPSfactor * 0.1
				case 3: //appendicitis:
					//0.035/sec = 2.1/min
					if (!I_427.Using && I_427.Timer < 70*360) {
						SCP1025state[i]=SCP1025state[i]+FPSfactor*0.0005
					}
					if (SCP1025state[i]>20.0) {
						if (SCP1025state[i]-FPSfactor<=20.0) {Msg="The pain in your stomach is becoming unbearable."}
						Stamina = Stamina - FPSfactor * 0.3
					} else if (SCP1025state[i]>10.0) {
						if (SCP1025state[i]-FPSfactor<=10.0) {Msg="Your stomach is aching."}
					}
				case 4: //asthma:
					if (Stamina < 35) {
						if (Rand(Int(140+Stamina*8))=1) {
							if (CoughCHN == 0) {
								CoughCHN = PlaySound_Strict(CoughSFX(Rand(0, 2)))
							} else {
								if (!ChannelPlaying(CoughCHN)) {CoughCHN = PlaySound_Strict(CoughSFX(Rand(0, 2)))}
							}
						}
						CurrSpeed = CurveValue(0, CurrSpeed, 10+Stamina*15)
					}
				case 5://cardiac arrest:
					if (!I_427.Using && I_427.Timer < 70*360) {
						SCP1025state[i]=SCP1025state[i]+FPSfactor*0.35
					}
					//35/sec
					if (SCP1025state[i]>110) {
						HeartBeatRate=0
						BlurTimer = Max(BlurTimer, 500)
						if (SCP1025state[i]>140) {
							DeathMSG = Chr(34)+"He died of a cardiac arrest after reading SCP-1025, that's for sure. Is there such a thing as psychosomatic cardiac arrest, or does SCP-1025 have some "
							DeathMSG = DeathMSG + "anomalous properties we are not yet aware of?"+Chr(34)
							Kill()
						}
					} else {
						HeartBeatRate=Max(HeartBeatRate, 70+SCP1025state[i])
						HeartBeatVolume = 1.0
					}
			}
		}
	}
	
	
}

//--------------------------------------- GUI, menu etc ------------------------------------------------

function DrawGUI() {
	CatchErrors("Uncaught (DrawGUI)")
	
	let temp: int
	let x: int
	let y: int
	let z: int
	let i: int
	let yawvalue: float
	let pitchvalue: float
	let x2: float
	let y2: float
	let z2: float
	let n: int
	let xtemp
	let ytemp
	let strtemp: string
	
	let e: Events
	let it: Items
	
	if (MenuOpen || ConsoleOpen || SelectedDoor != Null || InvOpen || OtherOpen != Null || EndingTimer < 0) {
		ShowPointer()
	} else {
		HidePointer()
	}
	
	if (PlayerRoom.RoomTemplate.Name == "pocketdimension") {
		for (e of Events.each) {
			if (e.room == PlayerRoom) {
				if (Float(e.EventStr)<1000.0) {
					if (e.EventState > 600) {
						if (BlinkTimer < -3 && BlinkTimer > -10) {
							if (e.img = 0) {
								if (BlinkTimer > -5 && Rand(30) == 1) {
									PlaySound_Strict (DripSFX(0))
									if (e.img == 0) {
										e.img = LoadImage_Strict("GFX/npcs/106face.jpg")
									}
								}
							} else {
								DrawImage(e.img, GraphicWidth/2-Rand(390,310), GraphicHeight/2-Rand(290,310))
							}
						} else {
							if (e.img != 0) {
								FreeImage (e.img)
								e.img = 0
							}
						}
							
						break
					}
				} else {
					if (BlinkTimer < -3 && BlinkTimer > -10) {
						if (e.img == 0) {
							if (BlinkTimer > -5) {
								if (e.img == 0) {
									e.img = LoadImage_Strict("GFX/kneelmortal.pd")
									if (ChannelPlaying(e.SoundCHN)) {
										StopChannel(e.SoundCHN)
									}
									e.SoundCHN = PlaySound_Strict(e.Sound)
								}
							}
						} else {
							DrawImage(e.img, GraphicWidth/2-Rand(390,310), GraphicHeight/2-Rand(290,310))
						}
					} else {
						if (e.img != 0) {
							FreeImage(e.img)
							e.img = 0
						}
						if (BlinkTimer < -3) {
							if (!ChannelPlaying(e.SoundCHN)) {
								e.SoundCHN = PlaySound_Strict(e.Sound)
							}
						} else {
							if (ChannelPlaying(e.SoundCHN)) {
								StopChannel(e.SoundCHN)
							}
						}
					}
					
					break
				}
			}
		}
	}
	
	if (ClosestButton != 0 && SelectedDoor == Null && InvOpen == false && MenuOpen == false && OtherOpen == Null) {
		temp = CreatePivot()
		PositionEntity(temp, EntityX(Camera), EntityY(Camera), EntityZ(Camera))
		PointEntity(temp, ClosestButton)
		yawvalue = WrapAngle(EntityYaw(Camera) - EntityYaw(temp))
		if (yawvalue > 90 && yawvalue <= 180) {yawvalue = 90}
		if (yawvalue > 180 && yawvalue < 270) {yawvalue = 270}
		pitchvalue = WrapAngle(EntityPitch(Camera) - EntityPitch(temp))
		if (pitchvalue > 90 && pitchvalue <= 180) {pitchvalue = 90}
		if (pitchvalue > 180 && pitchvalue < 270) {pitchvalue = 270}
		
		FreeEntity (temp)
		
		DrawImage(HandIcon, GraphicWidth / 2 + Sin(yawvalue) * (GraphicWidth / 3) - 32, GraphicHeight / 2 - Sin(pitchvalue) * (GraphicHeight / 3) - 32)
		
		if (MouseUp1) {
			MouseUp1 = false
			if (ClosestDoor != Null) { 
				if (ClosestDoor.Code != "") {
					SelectedDoor = ClosestDoor
				} else if (Playable) {
					PlaySound2(ButtonSFX, Camera, ClosestButton)
					UseDoor(ClosestDoor,true)				
				}
			}
		}
	}
	
	if (ClosestItem != Null) {
		yawvalue = -DeltaYaw(Camera, ClosestItem.collider)
		if (yawvalue > 90 && yawvalue <= 180) {yawvalue = 90}
		if (yawvalue > 180 && yawvalue < 270) {yawvalue = 270}
		pitchvalue = -DeltaPitch(Camera, ClosestItem.collider)
		if (pitchvalue > 90 && pitchvalue <= 180) {pitchvalue = 90}
		if (pitchvalue > 180 && pitchvalue < 270) {pitchvalue = 270}
		
		DrawImage(HandIcon2, GraphicWidth / 2 + Sin(yawvalue) * (GraphicWidth / 3) - 32, GraphicHeight / 2 - Sin(pitchvalue) * (GraphicHeight / 3) - 32)
	}
	
	if (DrawHandIcon) {DrawImage(HandIcon, GraphicWidth / 2 - 32, GraphicHeight / 2 - 32)}
	for (i of range(4)) {
		if (DrawArrowIcon(i)) {
			x = GraphicWidth / 2 - 32
			y = GraphicHeight / 2 - 32		
			switch (i) {
				case 0:
					y = y - 64 - 5
				case 1:
					x = x + 64 + 5
				case 2:
					y = y + 64 + 5
				case 3:
					x = x - 5 - 64
			}
			DrawImage(HandIcon, x, y)
			Color (0, 0, 0)
			Rect(x + 4, y + 4, 64 - 8, 64 - 8)
			DrawImage(ArrowIMG(i), x + 21, y + 21)
			DrawArrowIcon(i) = false
		}
	}
	
	if (Using294) {Use294()}
	
	if (HUDenabled) {
		
		let width: int = 204, height: int = 20
		x = 80
		y = GraphicHeight - 95
		
		Color (255, 255, 255)
		Rect (x, y, width, height, false)
		for (i of range(1, Int(((width - 2) * (BlinkTimer / (BLINKFREQ))) / 10) + 1)) {
			DrawImage(BlinkMeterIMG, x + 3 + 10 * (i - 1), y + 3)
		}	
		Color (0, 0, 0)
		Rect(x - 50, y, 30, 30)
		
		if (EyeIrritation > 0) {
			Color (200, 0, 0)
			Rect(x - 50 - 3, y - 3, 30 + 6, 30 + 6)
		}
		
		Color (255, 255, 255)
		Rect(x - 50 - 1, y - 1, 30 + 2, 30 + 2, false)
		
		DrawImage (BlinkIcon, x - 50, y)
		
		y = GraphicHeight - 55
		Color (255, 255, 255)
		Rect (x, y, width, height, false)
		for (i of range(1, Int(((width - 2) * (Stamina / 100.0)) / 10) + 1)) {
			DrawImage(StaminaMeterIMG, x + 3 + 10 * (i - 1), y + 3)
		}
		
		Color (0, 0, 0)
		Rect(x - 50, y, 30, 30)
		
		Color (255, 255, 255)
		Rect(x - 50 - 1, y - 1, 30 + 2, 30 + 2, false)
		if (Crouch) {
			DrawImage(CrouchIcon, x - 50, y)
		} else {
			DrawImage(SprintIcon, x - 50, y)
		}
		
		if (DebugHUD) {
			Color (255, 255, 255)
			AASetFont (ConsoleFont)
			
			AAText(x - 50, 50, "Player Position: (" + f2s(EntityX(Collider), 3) + ", " + f2s(EntityY(Collider), 3) + ", " + f2s(EntityZ(Collider), 3) + ")")
			AAText(x - 50, 70, "Camera Position: (" + f2s(EntityX(Camera), 3)+ ", " + f2s(EntityY(Camera), 3) +", " + f2s(EntityZ(Camera), 3) + ")")
			AAText(x - 50, 100, "Player Rotation: (" + f2s(EntityPitch(Collider), 3) + ", " + f2s(EntityYaw(Collider), 3) + ", " + f2s(EntityRoll(Collider), 3) + ")")
			AAText(x - 50, 120, "Camera Rotation: (" + f2s(EntityPitch(Camera), 3)+ ", " + f2s(EntityYaw(Camera), 3) +", " + f2s(EntityRoll(Camera), 3) + ")")
			AAText(x - 50, 150, "Room: " + PlayerRoom.RoomTemplate.Name)
			for (ev of Events.each) {
				if (ev.room = PlayerRoom) {
					AAText(x - 50, 170, "Room event: " + ev.EventName   )
					AAText(x - 50, 190, "state: " + ev.EventState)
					AAText(x - 50, 210, "state2: " + ev.EventState2   )
					AAText(x - 50, 230, "state3: " + ev.EventState3)
					AAText(x - 50, 250, "str: "+ ev.EventStr)
					break
				}
			}
			AAText(x - 50, 280, "Room coordinates: (" + Floor(EntityX(PlayerRoom.obj) / 8.0 + 0.5) + ", " + Floor(EntityZ(PlayerRoom.obj) / 8.0 + 0.5) + ", angle: "+PlayerRoom.angle + ")")
			AAText(x - 50, 300, "Stamina: " + f2s(Stamina, 3))
			AAText(x - 50, 320, "Death timer: " + f2s(KillTimer, 3)               )
			AAText(x - 50, 340, "Blink timer: " + f2s(BlinkTimer, 3))
			AAText(x - 50, 360, "Injuries: " + Injuries)
			AAText(x - 50, 380, "Bloodloss: " + Bloodloss)
			if (Curr173 != Null) {
				AAText(x - 50, 410, "SCP - 173 Position (collider): (" + f2s(EntityX(Curr173.Collider), 3) + ", " + f2s(EntityY(Curr173.Collider), 3) + ", " + f2s(EntityZ(Curr173.Collider), 3) + ")")
				AAText(x - 50, 430, "SCP - 173 Position (obj): (" + f2s(EntityX(Curr173.obj), 3) + ", " + f2s(EntityY(Curr173.obj), 3) + ", " + f2s(EntityZ(Curr173.obj), 3) + ")")
				AAText(x - 50, 450, "SCP - 173 State: " + Curr173.State)
			}
			if (Curr106 != Null) {
				AAText(x - 50, 470, "SCP - 106 Position: (" + f2s(EntityX(Curr106.obj), 3) + ", " + f2s(EntityY(Curr106.obj), 3) + ", " + f2s(EntityZ(Curr106.obj), 3) + ")")
				AAText(x - 50, 490, "SCP - 106 Idle: " + Curr106.Idle)
				AAText(x - 50, 510, "SCP - 106 State: " + Curr106.State)
			}
			offset = 0
			for (npc of NPCs.each) {
				if (npc.NPCtype = NPCtype096) {
					AAText(x - 50, 530, "SCP - 096 Position: (" + f2s(EntityX(npc.obj), 3) + ", " + f2s(EntityY(npc.obj), 3) + ", " + f2s(EntityZ(npc.obj), 3) + ")")
					AAText(x - 50, 550, "SCP - 096 Idle: " + npc.Idle)
					AAText(x - 50, 570, "SCP - 096 State: " + npc.State)
					AAText(x - 50, 590, "SCP - 096 Speed: " + f2s(npc.currspeed, 5))
				}
				if (npc.NPCtype = NPCtypeMTF) {
					AAText(x - 50, 620 + 60 * offset, "MTF " + offset + " Position: (" + f2s(EntityX(npc.obj), 3) + ", " + f2s(EntityY(npc.obj), 3) + ", " + f2s(EntityZ(npc.obj), 3) + ")")
					AAText(x - 50, 640 + 60 * offset, "MTF " + offset + " State: " + npc.State)
					AAText(x - 50, 660 + 60 * offset, "MTF " + offset + " LastSeen: " + npc.lastseen					)
					offset = offset + 1
				}
			}
			if (PlayerRoom.RoomTemplate.Name$ = "dimension1499") {
				AAText (x + 350, 50, "Current Chunk X/Z: ("+(Int((EntityX(Collider)+20)/40))+", "+(Int((EntityZ(Collider)+20)/40))+")")
				let CH_Amount: int = 0
				for (ch of Chunk.each) {
					CH_Amount = CH_Amount + 1
				}
				AAText(x + 350, 70, "Current Chunk Amount: "+CH_Amount)
			} else {
				AAText(x + 350, 50, "Current Room Position: ("+PlayerRoom.x+", "+PlayerRoom.y+", "+PlayerRoom.z+")")
			}
			GlobalMemoryStatus(m.MEMORYSTATUS)
			AAText(x + 350, 90, (m.dwAvailPhys/1024/1024)+" MB/"+(m.dwTotalPhys%/1024/1024)+" MB ("+(m.dwAvailPhys/1024)+" KB/"+(m.dwTotalPhys/1024)+" KB)")
			AAText(x + 350, 110, "Triangles rendered: "+CurrTrisAmount)
			AAText(x + 350, 130, "Active textures: "+ActiveTextures())
			AAText(x + 350, 150, "SCP-427 state (secs): "+Int(I_427.Timer/70.0))
			AAText(x + 350, 170, "SCP-008 infection: "+Infect)
			for (i of range(6)) {
				AAText(x + 350, 190+(20*i), "SCP-1025 State "+i+": "+SCP1025state[i])
			}
			if (SelectedMonitor != Null) {
				AAText(x + 350, 310, "Current monitor: "+SelectedMonitor.ScrObj)
			} else {
				AAText(x + 350, 310, "Current monitor: NULL")
			}
			
			AASetFont (Font1)
		}
		
	}
	
	if (SelectedScreen != Null) {
		DrawImage (SelectedScreen.img, GraphicWidth/2-ImageWidth(SelectedScreen.img)/2,GraphicHeight/2-ImageHeight(SelectedScreen.img)/2)
		
		if (MouseUp1 || MouseHit2) {
			FreeImage (SelectedScreen.img)
			SelectedScreen.img = 0
			SelectedScreen = Null
			MouseUp1 = false
		}
	}
	
	let PrevInvOpen: int = InvOpen
	let MouseSlot: int = 66
	
	let shouldDrawHUD: boolean = true
	if (SelectedDoor != Null) {
		SelectedItem = Null
		
		if (shouldDrawHUD) {
			pvt = CreatePivot()
			PositionEntity (pvt, EntityX(ClosestButton,true),EntityY(ClosestButton,true),EntityZ(ClosestButton,true))
			RotateEntity (pvt, 0, EntityYaw(ClosestButton,true)-180,0)
			MoveEntity (pvt, 0,0,0.22)
			PositionEntity (Camera, EntityX(pvt),EntityY(pvt),EntityZ(pvt))
			PointEntity (Camera, ClosestButton)
			FreeEntity (pvt)	
			
			CameraProject(Camera, EntityX(ClosestButton,true),EntityY(ClosestButton,true)+MeshHeight(ButtonOBJ)*0.015,EntityZ(ClosestButton,true))
			projY = ProjectedY()
			CameraProject(Camera, EntityX(ClosestButton,true),EntityY(ClosestButton,true)-MeshHeight(ButtonOBJ)*0.015,EntityZ(ClosestButton,true))
			scale = (ProjectedY()-projy)/462.0
			
			x = GraphicWidth/2-ImageWidth(KeypadHUD)*scale/2
			y = GraphicHeight/2-ImageHeight(KeypadHUD)*scale/2		
			
			AASetFont (Font3)
			if (KeypadMSG != "") {
				KeypadTimer = KeypadTimer-FPSfactor2
				
				if ((KeypadTimer % 70) < 35) {AAText (GraphicWidth/2, y+124*scale, KeypadMSG, true,true)}
				if (KeypadTimer <= 0) {
					KeypadMSG = ""
					SelectedDoor = Null
					MouseXSpeed()
					MouseYSpeed()
					MouseZSpeed()
					mouse_x_speed_1 =0.0
					mouse_y_speed_1 =0.0
				}
			} else {
				AAText (GraphicWidth/2, y+70*scale, "ACCESS CODE: ",true,true	)
				AASetFont (Font4)
				AAText (GraphicWidth/2, y+124*scale, KeypadInput,true,true	)
			}
			
			x = x+44*scale
			y = y+249*scale
			
			for (n of range(4)) {
				for (i of range(3)) {
					xtemp = x+Int(58.5*scale*n)
					ytemp = y+(67*scale)*i
					
					temp = false
					if (MouseOn(xtemp,ytemp, 54*scale,65*scale) && KeypadMSG == "") {
						if (MouseUp1) {
							PlaySound_Strict (ButtonSFX)
							
							switch ((n+1)+(i*4)) {
								case 1,2,3:
									KeypadInput=KeypadInput + ((n+1)+(i*4))
								case 4:
									KeypadInput=KeypadInput + "0"
								case 5,6,7:
									KeypadInput=KeypadInput + ((n+1)+(i*4)-1)
								case 8: //enter:
									if (KeypadInput = SelectedDoor.Code) {
										PlaySound_Strict (ScannerSFX1)
										
										if (SelectedDoor.Code = Str(AccessCode)) {
											GiveAchievement(AchvMaynard)
										} else if (SelectedDoor.Code = "7816") {
											GiveAchievement(AchvHarp)
										}
										
										SelectedDoor.locked = 0
										UseDoor(SelectedDoor,true)
										SelectedDoor = Null
										MouseXSpeed()
										MouseYSpeed()
										MouseZSpeed()
										mouse_x_speed_1 = 0.0
										mouse_y_speed_1 = 0.0
									} else {
										PlaySound_Strict(ScannerSFX2)
										KeypadMSG = "ACCESS DENIED"
										KeypadTimer = 210
										KeypadInput = ""	
									}
								case 9,10,11:
									KeypadInput=KeypadInput + ((n+1)+(i*4)-2)
								case 12:
									KeypadInput = ""
							}
							
							if (Len(KeypadInput)> 4) {KeypadInput = Left(KeypadInput,4)}
						}
						
					} else {
						temp = false
					}
					
				}
			}
			
			if (Fullscreen) {DrawImage(CursorIMG, ScaledMouseX(),ScaledMouseY())}
			
			if (MouseHit2) {
				SelectedDoor = Null
				MouseXSpeed()
				MouseYSpeed()
				MouseZSpeed()
				mouse_x_speed_1 = 0.0
				mouse_y_speed_1 = 0.0
			}
		} else {
			SelectedDoor = Null
		}
	} else {
		KeypadInput = ""
		KeypadTimer = 0
		KeypadMSG = ""
	}
	
	if (KeyHit(1) && EndingTimer == 0 && (!Using294)) {
		if (MenuOpen || InvOpen) {
			ResumeSounds()
			if (OptionsMenu != 0) {SaveOptionsINI()}
			MouseXSpeed()
			MouseYSpeed()
			MouseZSpeed()
			mouse_x_speed_1 = 0.0
			mouse_y_speed_1 = 0.0
		} else {
			PauseSounds()
		}
		MenuOpen = !MenuOpen
		
		AchievementsMenu = 0
		OptionsMenu = 0
		QuitMSG = 0
		
		SelectedDoor = Null
		SelectedScreen = Null
		SelectedMonitor = Null
		if (SelectedItem != Null) {
			if (Instr(SelectedItem.itemtemplate.tempname,"vest") || Instr(SelectedItem.itemtemplate.tempname,"hazmatsuit")) {
				if (!WearingVest && !WearingHazmat) {
					DropItem(SelectedItem)
				}
				SelectedItem = Null
			}
		}
	}
	
	let spacing: int
	let PrevOtherOpen: Items
	
	let OtherSize: int,OtherAmount: int
	
	let isEmpty: int
	
	let isMouseOn: int
	
	let closedInv: int
	
	if (OtherOpen != Null) {
		//[Block]
		if (PlayerRoom.RoomTemplate.Name = "gatea") {
			HideEntity (Fog)
			CameraFogRange(Camera, 5,30)
			CameraFogColor (Camera,200,200,200)
			CameraClsColor (Camera,200,200,200)					
			CameraRange(Camera, 0.05, 30)
		} else if ((PlayerRoom.RoomTemplate.Name = "exit1") && (EntityY(Collider)>1040.0*RoomScale)) {
			HideEntity (Fog)
			CameraFogRange(Camera, 5,45)
			CameraFogColor (Camera,200,200,200)
			CameraClsColor (Camera,200,200,200)					
			CameraRange(Camera, 0.05, 60)
		}
		
		PrevOtherOpen = OtherOpen
		OtherSize=OtherOpen.invSlots
		
		for (i of range(OtherSize)) {
			if (OtherOpen.SecondInv[i] != Null) {
				OtherAmount = OtherAmount+1
			}
		}
		
		InvOpen = false
		SelectedDoor = Null
		let tempX: int = 0
		
		width = 70
		height = 70
		spacing = 35
		
		x = GraphicWidth / 2 - (width * MaxItemAmount /2 + spacing * (MaxItemAmount / 2 - 1)) / 2
		y = GraphicHeight / 2 - (height * OtherSize /5 + spacing * (OtherSize / 5 - 1)) / 2//height
		
		ItemAmount = 0
		for (n of range(OtherSize)) {
			isMouseOn = false
			if (ScaledMouseX() > x && ScaledMouseX() < x + width) {
				if (ScaledMouseY() > y && ScaledMouseY() < y + height) {
					isMouseOn = true
				}
			}
			
			if (isMouseOn) {
				MouseSlot = n
				Color (255, 0, 0)
				Rect(x - 1, y - 1, width + 2, height + 2)
			}
			
			DrawFrame(x, y, width, height, (x % 64), (x % 64))
			
			if (OtherOpen = Null) {break}
			
			if (OtherOpen.SecondInv[n] != Null) {
				if (SelectedItem != OtherOpen.SecondInv[n] || isMouseOn) {
					DrawImage(OtherOpen.SecondInv[n].invimg, x + width / 2 - 32, y + height / 2 - 32)
				}
			}
			DebugLog ("otheropen: "+(OtherOpen!=Null))
			if (OtherOpen.SecondInv[n] != Null && SelectedItem != OtherOpen.SecondInv[n]) {
			
				if (isMouseOn) {
					Color (255, 255, 255)
					AAText(x + width / 2, y + height + spacing - 15, OtherOpen.SecondInv[n].itemtemplate.name, true)				
					if (SelectedItem = Null) {
						if (MouseHit1) {
							SelectedItem = OtherOpen.SecondInv[n]
							MouseHit1 = false
							
							if (DoubleClick) {
								if (OtherOpen.SecondInv[n].itemtemplate.sound != 66) {
									PlaySound_Strict(PickSFX(OtherOpen.SecondInv[n].itemtemplate.sound))
								}
								OtherOpen = Null
								closedInv=true
								InvOpen = false
								DoubleClick = false
							}
							
						}
					}
				}
				
				ItemAmount=ItemAmount+1
			} else {
				if (isMouseOn && MouseHit1) {
					for (z of range(OtherSize)) {
						if (OtherOpen.SecondInv[z] = SelectedItem) {
							OtherOpen.SecondInv[z] = Null
						}
					}
					OtherOpen.SecondInv[n] = SelectedItem
				}
				
			}				
			
			x=x+width + spacing
			tempX=tempX + 1
			if (tempX = 5) { 
				tempX=0
				y = y + height*2 
				x = GraphicWidth / 2 - (width * MaxItemAmount /2 + spacing * (MaxItemAmount / 2 - 1)) / 2
			}
		}
		
		if (SelectedItem != Null) {
			if (MouseDown1) {
				if (MouseSlot = 66) {
					DrawImage(SelectedItem.invimg, ScaledMouseX() - ImageWidth(SelectedItem.itemtemplate.invimg) / 2, ScaledMouseY() - ImageHeight(SelectedItem.itemtemplate.invimg) / 2)
				} else if (SelectedItem != PrevOtherOpen.SecondInv[MouseSlot]) {
					DrawImage(SelectedItem.invimg, ScaledMouseX() - ImageWidth(SelectedItem.itemtemplate.invimg) / 2, ScaledMouseY() - ImageHeight(SelectedItem.itemtemplate.invimg) / 2)
				}
			} else {
				if (MouseSlot = 66) {
					if (SelectedItem.itemtemplate.sound != 66) {PlaySound_Strict(PickSFX(SelectedItem.itemtemplate.sound))}
					
					ShowEntity(SelectedItem.collider)
					PositionEntity(SelectedItem.collider, EntityX(Camera), EntityY(Camera), EntityZ(Camera))
					RotateEntity(SelectedItem.collider, EntityPitch(Camera), EntityYaw(Camera), 0)
					MoveEntity(SelectedItem.collider, 0, -0.1, 0.1)
					RotateEntity(SelectedItem.collider, 0, Rand(360), 0)
					ResetEntity (SelectedItem.collider)
					//move the item so that it doesn't overlap with other items
					
					SelectedItem.DropSpeed = 0.0
					
					SelectedItem.Picked = false
					for (z of range(OtherSize)) {
						if (OtherOpen.SecondInv[z] = SelectedItem) {OtherOpen.SecondInv[z] = Null}
					}
					
					isEmpty=true
					if (OtherOpen.itemtemplate.tempname = "wallet") {
						if (!isEmpty) {
							for (z of range(OtherSize)) {
								if (OtherOpen.SecondInv[z]!=Null) {
									let name: string = OtherOpen.SecondInv[z].itemtemplate.tempname
									if (name$!="25ct" && name$!="coin" && name$!="key" && name$!="scp860" && name$!="scp714") {
										isEmpty=false
										break
									}
								}
							}
						}
					} else {
						for (z of range(OtherSize)) {
							if (OtherOpen.SecondInv[z]!=Null) {
								isEmpty = false
								break
							}
						}
					}
					
					if (isEmpty) {
						switch (OtherOpen.itemtemplate.tempname) {
							case "clipboard":
								OtherOpen.invimg = OtherOpen.itemtemplate.invimg2
								SetAnimTime (OtherOpen.model,17.0)
							case "wallet":
								SetAnimTime (OtherOpen.model,0.0)
						}
					}
					
					SelectedItem = Null
					OtherOpen = Null
					closedInv=true
					
					MoveMouse (viewport_center_x, viewport_center_y)
				} else {
					
					if (PrevOtherOpen.SecondInv[MouseSlot] = Null) {
						for (z of range(OtherSize)) {
							if (PrevOtherOpen.SecondInv[z] == SelectedItem) {PrevOtherOpen.SecondInv[z] = Null}
						}
						PrevOtherOpen.SecondInv[MouseSlot] = SelectedItem
						SelectedItem = Null
					 } else if (PrevOtherOpen.SecondInv[MouseSlot] != SelectedItem) {
						switch (SelectedItem.itemtemplate.tempname) {
							default:
								Msg = "You cannot combine these two items."
								MsgTimer = 70 * 5
						}				
					}
					
				}
				SelectedItem = Null
			}
		}
		
		if (Fullscreen) {DrawImage(CursorIMG,ScaledMouseX(),ScaledMouseY())}
		if ((closedInv) && (!InvOpen)) {
			ResumeSounds() 
			OtherOpen=Null
			MouseXSpeed()
			MouseYSpeed()
			MouseZSpeed()
			mouse_x_speed_1 = 0.0
			mouse_y_speed_1 = 0.0
		}
		
		
	} else if (InvOpen) {
		
		if (PlayerRoom.RoomTemplate.Name = "gatea") {
			HideEntity (Fog)
			CameraFogRange (Camera, 5,30)
			CameraFogColor (Camera,200,200,200)
			CameraClsColor (Camera,200,200,200)					
			CameraRange(Camera, 0.05, 30)
		} else if ((PlayerRoom.RoomTemplate.Name = "exit1") && (EntityY(Collider)>1040.0*RoomScale)) {
			HideEntity (Fog)
			CameraFogRange (Camera, 5,45)
			CameraFogColor (Camera,200,200,200)
			CameraClsColor (Camera,200,200,200)					
			CameraRange(Camera, 0.05, 60)
		}
		
		SelectedDoor = Null
		
		width = 70
		height = 70
		spacing = 35
		
		x = GraphicWidth / 2 - (width * MaxItemAmount /2 + spacing * (MaxItemAmount / 2 - 1)) / 2
		y = GraphicHeight / 2 - height
		
		ItemAmount = 0
		for (n of range(MaxItemAmount)) {
			isMouseOn = false
			if (ScaledMouseX() > x && ScaledMouseX() < x + width) {
				if (ScaledMouseY() > y && ScaledMouseY() < y + height) {
					isMouseOn = true
				}
			}
			
			if (Inventory(n) != Null) {
				Color (200, 200, 200)
				switch (Inventory(n).itemtemplate.tempname ) {
					case "gasmask":
						if (WearingGasMask=1) {Rect(x - 3, y - 3, width + 6, height + 6)}
					case "supergasmask":
						if (WearingGasMask=2) {Rect(x - 3, y - 3, width + 6, height + 6)}
					case "gasmask3":
						if (WearingGasMask=3) {Rect(x - 3, y - 3, width + 6, height + 6)}
					case "hazmatsuit":
						if (WearingHazmat=1) {Rect(x - 3, y - 3, width + 6, height + 6)}
					case "hazmatsuit2":
						if (WearingHazmat=2) {Rect(x - 3, y - 3, width + 6, height + 6)}
					case "hazmatsuit3":
						if (WearingHazmat=3) {Rect(x - 3, y - 3, width + 6, height + 6)	}
					case "vest":
						if (WearingVest=1) {Rect(x - 3, y - 3, width + 6, height + 6)}
					case "finevest":
						if (WearingVest=2) {Rect(x - 3, y - 3, width + 6, height + 6)}
					case "scp714":
						if (Wearing714=1) {Rect(x - 3, y - 3, width + 6, height + 6)}
						//BoH items
					case "nvgoggles":
						if (WearingNightVision=1) {Rect(x - 3, y - 3, width + 6, height + 6)}
					case "supernv":
						if (WearingNightVision=2) {Rect(x - 3, y - 3, width + 6, height + 6)}
					case "scp1499":
						if (Wearing1499=1) {Rect(x - 3, y - 3, width + 6, height + 6)}
					case "super1499":
						if (Wearing1499=2) {Rect(x - 3, y - 3, width + 6, height + 6)}
					case "finenvgoggles":
						if (WearingNightVision=3) {Rect(x - 3, y - 3, width + 6, height + 6)}
					case "scp427":
						if (I_427.Using=1) {Rect(x - 3, y - 3, width + 6, height + 6)}
				}
			}
			
			if (isMouseOn) {
				MouseSlot = n
				Color (255, 0, 0)
				Rect(x - 1, y - 1, width + 2, height + 2)
			}
			
			Color (255, 255, 255)
			DrawFrame(x, y, width, height, (x % 64), (x % 64))
			
			if (Inventory(n) != Null) {
				if (SelectedItem != Inventory(n) || isMouseOn) { 
					DrawImage(Inventory(n).invimg, x + width / 2 - 32, y + height / 2 - 32)
				}
			}
			
			if (Inventory(n) != Null && SelectedItem != Inventory(n)) {
				if (isMouseOn) {
					if (SelectedItem = Null) {
						if (MouseHit1) {
							SelectedItem = Inventory(n)
							MouseHit1 = false
							
							if (DoubleClick) {
								if (WearingHazmat > 0 && Instr(SelectedItem.itemtemplate.tempname,"hazmatsuit") == 0) {
									Msg = "You cannot use any items while wearing a hazmat suit."
									MsgTimer = 70*5
									SelectedItem = Null
									return
								}
								if (Inventory(n).itemtemplate.sound != 66) {
									PlaySound_Strict(PickSFX(Inventory(n).itemtemplate.sound))
								}
								InvOpen = false
								DoubleClick = false
							}
							
						}
						
						AASetFont(Font1)
						Color(0,0,0)
						AAText(x + width / 2 + 1, y + height + spacing - 15 + 1, Inventory(n).name, true)							
						Color(255, 255, 255	)
						AAText(x + width / 2, y + height + spacing - 15, Inventory(n).name, true)	
						
					}
				}
				
				ItemAmount=ItemAmount+1
			} else {
				if (isMouseOn && MouseHit1) {
					for (z of range(MaxItemAmount)) {
						if (Inventory(z) = SelectedItem) {Inventory(z) = Null}
					}
					Inventory(n) = SelectedItem
				}	
			}					
			
			x=x+width + spacing
			if (n = 4) { 
				y = y + height*2 
				x = GraphicWidth / 2 - (width * MaxItemAmount /2 + spacing * (MaxItemAmount / 2 - 1)) / 2
			}
		}
		
		if (SelectedItem != Null) {
			if (MouseDown1) {
				if (MouseSlot = 66) {
					DrawImage(SelectedItem.invimg, ScaledMouseX() - ImageWidth(SelectedItem.itemtemplate.invimg) / 2, ScaledMouseY() - ImageHeight(SelectedItem.itemtemplate.invimg) / 2)
				} else if (SelectedItem != Inventory(MouseSlot)) {
					DrawImage(SelectedItem.invimg, ScaledMouseX() - ImageWidth(SelectedItem.itemtemplate.invimg) / 2, ScaledMouseY() - ImageHeight(SelectedItem.itemtemplate.invimg) / 2)
				}
			} else {
				if (MouseSlot = 66) {
					switch (SelectedItem.itemtemplate.tempname) {
						case "vest","finevest","hazmatsuit","hazmatsuit2","hazmatsuit3":
							Msg = "Double click on this item to take it off."
							MsgTimer = 70*5
						case "scp1499","super1499":
							if (Wearing1499>0) {
								Msg = "Double click on this item to take it off."
								MsgTimer = 70*5
							} else {
								DropItem(SelectedItem)
								SelectedItem = Null
								InvOpen = false
							}
						default:
							DropItem(SelectedItem)
							SelectedItem = Null
							InvOpen = false
					}
					
					MoveMouse(viewport_center_x, viewport_center_y)
				} else {
					if (Inventory(MouseSlot) = Null) {
						for (z of range(MaxItemAmount)) {
							if (Inventory(z) = SelectedItem) {Inventory(z) = Null}
						}
						Inventory(MouseSlot) = SelectedItem
						SelectedItem = Null
					} else if (Inventory(MouseSlot) != SelectedItem) {
						switch (SelectedItem.itemtemplate.tempname) {
							case "paper","key1","key2","key3","key4","key5","key6","misc","oldpaper","badge","ticket","25ct","coin","key","scp860":
								//[Block]
								if (Inventory(MouseSlot).itemtemplate.tempname = "clipboard") {
									//Add an item to clipboard
									let added: Items = Null
									let b: string = SelectedItem.itemtemplate.tempname
									let b2: string = SelectedItem.itemtemplate.name
									if ((b!="misc" && b!="25ct" && b!="coin" && b!="key" && b!="scp860" && b!="scp714") || (b2="Playing Card" || b2 == "Mastercard")) {
										for (c of range(Inventory(MouseSlot).invSlots)) {
											if (Inventory(MouseSlot).SecondInv[c] = Null) {
												if (SelectedItem != Null) {
													Inventory(MouseSlot).SecondInv[c] = SelectedItem
													Inventory(MouseSlot).state = 1.0
													SetAnimTime (Inventory(MouseSlot).model,0.0)
													Inventory(MouseSlot).invimg = Inventory(MouseSlot).itemtemplate.invimg
													
													for (ri of range(MaxItemAmount)) {
														if (Inventory(ri) = SelectedItem) {
															Inventory(ri) = Null
															PlaySound_Strict(PickSFX(SelectedItem.itemtemplate.sound))
														}
													}
													added = SelectedItem
													SelectedItem = Null
													break
												}
											}
										}
										if (SelectedItem != Null) {
											Msg = "The paperclip is not strong enough to hold any more items."
										} else {
											if (added.itemtemplate.tempname = "paper" || added.itemtemplate.tempname == "oldpaper") {
												Msg = "This document was added to the clipboard."
											} else if (added.itemtemplate.tempname == "badge") {
												Msg = added.itemtemplate.name + " was added to the clipboard."
											} else {
												Msg = "The " + added.itemtemplate.name + " was added to the clipboard."
											}
											
										}
										MsgTimer = 70 * 5
									} else {
										Msg = "You cannot combine these two items."
										MsgTimer = 70 * 5
									}
								} else if (Inventory(MouseSlot).itemtemplate.tempname = "wallet") {
									//Add an item to clipboard
									added.Items = Null
									b$ = SelectedItem.itemtemplate.tempname
									b2$ = SelectedItem.itemtemplate.name
									if ((b!="misc" && b!="paper" && b!="oldpaper") || (b2 == "Playing Card" || b2 == "Mastercard")) {
										for (c of range(Inventory(MouseSlot).invSlots)) {
											if (Inventory(MouseSlot).SecondInv[c] = Null) {
												if (SelectedItem != Null) {
													Inventory(MouseSlot).SecondInv[c] = SelectedItem
													Inventory(MouseSlot).state = 1.0
													if (b!="25ct" && b!="coin" && b!="key" && b!="scp860") {
														SetAnimTime (Inventory(MouseSlot).model,3.0)
													}
													Inventory(MouseSlot).invimg = Inventory(MouseSlot).itemtemplate.invimg
													
													for (ri of range(MaxItemAmount)) {
														if (Inventory(ri) = SelectedItem) {
															Inventory(ri) = Null
															PlaySound_Strict(PickSFX(SelectedItem.itemtemplate.sound))
														}
													}
													added = SelectedItem
													SelectedItem = Null
													break
												}
											}
										}
										if (SelectedItem != Null) {
											Msg = "The wallet is full."
										} else {
											Msg = "You put "+added.itemtemplate.name+" into the wallet."
										}
										
										MsgTimer = 70 * 5
									} else {
										Msg = "You cannot combine these two items."
										MsgTimer = 70 * 5
									}
								} else {
									Msg = "You cannot combine these two items."
									MsgTimer = 70 * 5
								}
								SelectedItem = Null
								
							case "battery", "bat":
								//[Block]
								switch (Inventory(MouseSlot).itemtemplate.name) {
									case "S-NAV Navigator", "S-NAV 300 Navigator", "S-NAV 310 Navigator":
										if (SelectedItem.itemtemplate.sound != 66) {PlaySound_Strict(PickSFX(SelectedItem.itemtemplate.sound))}
										RemoveItem (SelectedItem)
										SelectedItem = Null
										Inventory(MouseSlot).state = 100.0
										Msg = "You replaced the navigator's battery."
										MsgTimer = 70 * 5
									case "S-NAV Navigator Ultimate":
										Msg = "There seems to be no place for batteries in this navigator."
										MsgTimer = 70 * 5
									case "Radio Transceiver":
										switch (Inventory(MouseSlot).itemtemplate.tempname) {
											case "fineradio", "veryfineradio":
												Msg = "There seems to be no place for batteries in this radio."
												MsgTimer = 70 * 5
											case "18vradio":
												Msg = "The battery does not fit inside this radio."
												MsgTimer = 70 * 5
											case "radio":
												if (SelectedItem.itemtemplate.sound != 66) {
													PlaySound_Strict(PickSFX(SelectedItem.itemtemplate.sound))	
												}
												RemoveItem (SelectedItem)
												SelectedItem = Null
												Inventory(MouseSlot).state = 100.0
												Msg = "You replaced the radio's battery."
												MsgTimer = 70 * 5
										}
									case "Night Vision Goggles":
										let nvname: string = Inventory(MouseSlot).itemtemplate.tempname
										if (nvname$ == "nvgoggles" || nvname$ == "supernv") {
											if (SelectedItem.itemtemplate.sound != 66) {PlaySound_Strict(PickSFX(SelectedItem.itemtemplate.sound))}
											RemoveItem (SelectedItem)
											SelectedItem = Null
											Inventory(MouseSlot).state = 1000.0
											Msg = "You replaced the goggles' battery."
											MsgTimer = 70 * 5
										} else {
											Msg = "There seems to be no place for batteries in these night vision goggles."
											MsgTimer = 70 * 5
										}
									default:
										Msg = "You cannot combine these two items."
										MsgTimer = 70 * 5	
								}
								
							case "18vbat":
								//[Block]
								switch (Inventory(MouseSlot).itemtemplate.name) {
									case "S-NAV Navigator", "S-NAV 300 Navigator", "S-NAV 310 Navigator":
										Msg = "The battery does not fit inside this navigator."
										MsgTimer = 70 * 5
									case "S-NAV Navigator Ultimate":
										Msg = "There seems to be no place for batteries in this navigator."
										MsgTimer = 70 * 5
									case "Radio Transceiver":
										switch (Inventory(MouseSlot).itemtemplate.tempname) {
											case "fineradio", "veryfineradio":
												Msg = "There seems to be no place for batteries in this radio."
												MsgTimer = 70 * 5		
											case "18vradio":
												if (SelectedItem.itemtemplate.sound != 66) {PlaySound_Strict(PickSFX(SelectedItem.itemtemplate.sound))}
												RemoveItem (SelectedItem)
												SelectedItem = Null
												Inventory(MouseSlot).state = 100.0
												Msg = "You replaced the radio's battery."
												MsgTimer = 70 * 5
										} 
									default:
										Msg = "You cannot combine these two items."
										MsgTimer = 70 * 5	
								}
								
							default:
								//[Block]
								Msg = "You cannot combine these two items."
								MsgTimer = 70 * 5
								
						}				
					}
					
				}
				SelectedItem = Null
			}
		}
		
		if (Fullscreen) {DrawImage(CursorIMG, ScaledMouseX(),ScaledMouseY())}
		
		if (InvOpen = false) {
			ResumeSounds() 
			MouseXSpeed()
			MouseYSpeed()
			MouseZSpeed()
			mouse_x_speed_1 = 0.0
			mouse_y_speed_1 = 0.0
		}
	} else { //invopen = false
		
		if (SelectedItem != Null) {
			switch (SelectedItem.itemtemplate.tempname) {
				case "nvgoggles":
					//[Block]
					if (Wearing1499 == 0 && WearingHazmat == 0) {
						if (WearingNightVision == 1) {
							Msg = "You removed the goggles."
							CameraFogFar = StoredCameraFogFar
						} else {
							Msg = "You put on the goggles."
							WearingGasMask = 0
							WearingNightVision = 0
							StoredCameraFogFar = CameraFogFar
							CameraFogFar = 30
						}
						
						WearingNightVision = (!WearingNightVision)
					} else if (Wearing1499 > 0) {
						Msg = "You need to take off SCP-1499 in order to put on the goggles."
					} else {
						Msg = "You need to take off the hazmat suit in order to put on the goggles."
					}
					SelectedItem = Null
					MsgTimer = 70 * 5
					
				case "supernv":
					//[Block]
					if (Wearing1499 == 0 && WearingHazmat == 0) {
						if (WearingNightVision = 2) {
							Msg = "You removed the goggles."
							CameraFogFar = StoredCameraFogFar
						} else {
							Msg = "You put on the goggles."
							WearingGasMask = 0
							WearingNightVision = 0
							StoredCameraFogFar = CameraFogFar
							CameraFogFar = 30
						}
						
						WearingNightVision = (!WearingNightVision) * 2
					} else if (Wearing1499 > 0) {
						Msg = "You need to take off SCP-1499 in order to put on the goggles."
					} else {
						Msg = "You need to take off the hazmat suit in order to put on the goggles."
					}
					SelectedItem = Null
					MsgTimer = 70 * 5
					
				case "finenvgoggles":
					//[Block]
					if (Wearing1499 == 0 && WearingHazmat == 0) {
						if (WearingNightVision == 3) {
							Msg = "You removed the goggles."
							CameraFogFar = StoredCameraFogFar
						} else {
							Msg = "You put on the goggles."
							WearingGasMask = 0
							WearingNightVision = 0
							StoredCameraFogFar = CameraFogFar
							CameraFogFar = 30
						}
						
						WearingNightVision = (!WearingNightVision) * 3
					} else if (Wearing1499 > 0) {
						Msg = "You need to take off SCP-1499 in order to put on the goggles."
					} else {
						Msg = "You need to take off the hazmat suit in order to put on the goggles."
					}
					SelectedItem = Null
					MsgTimer = 70 * 5
					
				case "ring":
					//[Block]
					if (Wearing714=2) {
						Msg = "You removed the ring."
						Wearing714 = false
					} else {
						//Achievements(Achv714)=true
						Msg = "You put on the ring."
						Wearing714 = 2
					}
					MsgTimer = 70 * 5
					SelectedItem = Null
					
				case "1123":
					//[Block]
					if (!(Wearing714 = 1)) {
						if (PlayerRoom.RoomTemplate.Name != "room1123") {
							ShowEntity (Light)
							LightFlash = 7
							PlaySound_Strict(LoadTempSound("SFX/SCP/1123/Touch.ogg"))		
							DeathMSG = "Subject D-9341 was shot dead after attempting to attack a member of Nine-Tailed Fox. Surveillance tapes show that the subject had been "
							DeathMSG = DeathMSG + "wandering around the site approximately 9 minutes prior, shouting the phrase " + Chr(34) + "get rid of the four pests" + Chr(34)
							DeathMSG = DeathMSG + " in chinese. SCP-1123 was found in [REDACTED] nearby, suggesting the subject had come into physical contact with it. How "
							DeathMSG = DeathMSG + "exactly SCP-1123 was removed from its containment chamber is still unknown."
							Kill()
							return
						}
						for (e of Events.each) {
							if (e.EventName = "room1123") {
								if (e.EventState = 0) {
									ShowEntity (Light)
									LightFlash = 3
									PlaySound_Strict(LoadTempSound("SFX/SCP/1123/Touch.ogg"))		
								}
								e.EventState = Max(1, e.EventState)
								break
							}
						}
					}
					
				case "battery":
					//[Block]
					//InvOpen = true
					{}
					
				case "key1", "key2", "key3", "key4", "key5", "key6", "keyomni", "scp860", "hand", "hand2", "25ct":
					//[Block]
					DrawImage(SelectedItem.itemtemplate.invimg, GraphicWidth / 2 - ImageWidth(SelectedItem.itemtemplate.invimg) / 2, GraphicHeight / 2 - ImageHeight(SelectedItem.itemtemplate.invimg) / 2)
					//se

				case "scp513":
					//[Block]
					PlaySound_Strict (LoadTempSound("SFX/SCP/513/Bell1.ogg"))
					
					if (Curr5131 = Null) {
						Curr5131 = CreateNPC(NPCtype5131, 0,0,0)
					}	
					SelectedItem = Null
					
				case "scp500":
					//[Block]
					if (CanUseItem(false, false, true)) {
						GiveAchievement(Achv500)
						
						if (Infect > 0) {
							Msg = "You swallowed the pill. Your nausea is fading."
						} else {
							Msg = "You swallowed the pill."
						}
						MsgTimer = 70*7
						
						DeathTimer = 0
						Infect = 0
						Stamina = 100
						for (i of range(6)) {
							SCP1025state[i]=0
						}
						if (StaminaEffect > 1.0) {
							StaminaEffect = 1.0
							StaminaEffectTimer = 0.0
						}
						
						RemoveItem(SelectedItem)
						SelectedItem = Null
					}	
					
				case "veryfinefirstaid":
					//[Block]
					if (CanUseItem(false, false, true)) {
						switch (Rand(5)) {
							case 1:
								Injuries = 3.5
								Msg = "You started bleeding heavily."
								MsgTimer = 70*7
							case 2:
								Injuries = 0
								Bloodloss = 0
								Msg = "Your wounds are healing up rapidly."
								MsgTimer = 70*7
							case 3:
								Injuries = Max(0, Injuries - Rnd(0.5,3.5))
								Bloodloss = Max(0, Bloodloss - Rnd(10,100))
								Msg = "You feel much better."
								MsgTimer = 70*7
							case 4:
								BlurTimer = 10000
								Bloodloss = 0
								Msg = "You feel nauseated."
								MsgTimer = 70*7
							case 5:
								BlinkTimer = -10
								let roomname: string = PlayerRoom.RoomTemplate.Name
								if (roomname == "dimension1499" || roomname == "gatea" || (roomname="exit1" && EntityY(Collider)>1040.0*RoomScale)) {
									Injuries = 2.5
									Msg = "You started bleeding heavily."
									MsgTimer = 70*7
								} else {
									for (r of Rooms.each) {
										if (r.RoomTemplate.Name = "pocketdimension") {
											PositionEntity(Collider, EntityX(r.obj),0.8,EntityZ(r.obj))		
											ResetEntity (Collider)									
											UpdateDoors()
											UpdateRooms()
											PlaySound_Strict(Use914SFX)
											DropSpeed = 0
											Curr106.State = -2500
											break
										}
									}
									Msg = "For some inexplicable reason, you find yourself inside the pocket dimension."
									MsgTimer = 70*8
								}
						}
						
						RemoveItem(SelectedItem)
					}
					
				case "firstaid", "finefirstaid", "firstaid2":
					//[Block]
					if (Bloodloss == 0 && Injuries == 0) {
						Msg = "You do not need to use a first aid kit right now."
						MsgTimer = 70*5
						SelectedItem = Null
					} else {
						if (CanUseItem(false, true, true)) {
							CurrSpeed = CurveValue(0, CurrSpeed, 5.0)
							Crouch = true
							
							DrawImage(SelectedItem.itemtemplate.invimg, GraphicWidth / 2 - ImageWidth(SelectedItem.itemtemplate.invimg) / 2, GraphicHeight / 2 - ImageHeight(SelectedItem.itemtemplate.invimg) / 2)
							
							width = 300
							height = 20
							x = GraphicWidth / 2 - width / 2
							y = GraphicHeight / 2 + 80
							Rect(x, y, width+4, height, false)
							for (i of range(1, Int((width - 2) * (SelectedItem.state / 100.0) / 10) + 1)) {
								DrawImage(BlinkMeterIMG, x + 3 + 10 * (i - 1), y + 3)
							}
							
							SelectedItem.state = Min(SelectedItem.state+(FPSfactor/5.0),100)			
							
							if (SelectedItem.state = 100) {
								if (SelectedItem.itemtemplate.tempname = "finefirstaid") {
									Bloodloss = 0
									Injuries = Max(0, Injuries - 2.0)
									if (Injuries = 0) {
										Msg = "You bandaged the wounds and took a painkiller. You feel fine."
									} else if (Injuries > 1.0) {
										Msg = "You bandaged the wounds and took a painkiller, but you were not able to stop the bleeding."
									} else {
										Msg = "You bandaged the wounds and took a painkiller, but you still feel sore."
									}
									MsgTimer = 70*5
									RemoveItem(SelectedItem)
								} else {
									Bloodloss = Max(0, Bloodloss - Rand(10,20))
									if (Injuries => 2.5) {
										Msg = "The wounds were way too severe to staunch the bleeding completely."
										Injuries = Max(2.5, Injuries-Rnd(0.3,0.7))
									} else if (Injuries > 1.0) {
										Injuries = Max(0.5, Injuries-Rnd(0.5,1.0))
										if (Injuries > 1.0) {
											Msg = "You bandaged the wounds but were unable to staunch the bleeding completely."
										} else {
											Msg = "You managed to stop the bleeding."
										}
									} else {
										if (Injuries > 0.5) {
											Injuries = 0.5
											Msg = "You took a painkiller, easing the pain slightly."
										} else {
											Injuries = 0.5
											Msg = "You took a painkiller, but it still hurts to walk."
										}
									}
									
									if (SelectedItem.itemtemplate.tempname = "firstaid2") {
										switch (Rand(6)) {
											case 1:
												SuperMan = true
												Msg = "You have becomed overwhelmedwithadrenalineholyshitWOOOOOO~!"
											case 2:
												InvertMouse = !InvertMouse
												Msg = "You suddenly find it very difficult to turn your head."
											case 3:
												BlurTimer = 5000
												Msg = "You feel nauseated."
											case 4:
												BlinkEffect = 0.6
												BlinkEffectTimer = Rand(20,30)
											case 5:
												Bloodloss = 0
												Injuries = 0
												Msg = "You bandaged the wounds. The bleeding stopped completely and you feel fine."
											case 6:
												Msg = "You bandaged the wounds and blood started pouring heavily through the bandages."
												Injuries = 3.5
										}
									}
									
									MsgTimer = 70*5
									RemoveItem(SelectedItem)
								}							
							}
						}
					}
					
				case "eyedrops":
					//[Block]
					if (CanUseItem(false,false,false)) {
						if (!(Wearing714=1)) { //wtf is this
							BlinkEffect = 0.6
							BlinkEffectTimer = Rand(20,30)
							BlurTimer = 200
						}
						RemoveItem(SelectedItem)
					}
					
				case "fineeyedrops":
					//[Block]
					if (CanUseItem(false,false,false)) {
						if (!(Wearing714=1)) {
							BlinkEffect = 0.4
							BlinkEffectTimer = Rand(30,40)
							Bloodloss = Max(Bloodloss-1.0, 0)
							BlurTimer = 200
						}
						RemoveItem(SelectedItem)
					}
					
				case "supereyedrops":
					//[Block]
					if (CanUseItem(false,false,false)) {
						if (!(Wearing714 = 1)) {
							BlinkEffect = 0.0
							BlinkEffectTimer = 60
							EyeStuck = 10000
						}
						BlurTimer = 1000
						RemoveItem(SelectedItem)
					}
					
				case "paper", "ticket":
					//[Block]
					if (SelectedItem.itemtemplate.img = 0) {
						switch (SelectedItem.itemtemplate.name) {
							case "Burnt Note" :
								SelectedItem.itemtemplate.img = LoadImage_Strict("GFX/items/bn.it")
								SetBuffer(ImageBuffer(SelectedItem.itemtemplate.img))
								Color(0,0,0)
								AAText(277, 469, AccessCode, true, true)
								Color(255,255,255)
								SetBuffer(BackBuffer())
							case "Document SCP-372":
								SelectedItem.itemtemplate.img = LoadImage_Strict(SelectedItem.itemtemplate.imgpath)	
								SelectedItem.itemtemplate.img = ResizeImage2(SelectedItem.itemtemplate.img, ImageWidth(SelectedItem.itemtemplate.img) * MenuScale, ImageHeight(SelectedItem.itemtemplate.img) * MenuScale)
								
								SetBuffer(ImageBuffer(SelectedItem.itemtemplate.img))
								Color(37,45,137)
								AASetFont(Font5)
								temp = ((Int(AccessCode)*3) % 10000)
								if (temp < 1000) {temp = temp+1000}
								AAText(383*MenuScale, 734*MenuScale, temp, true, true)
								Color(255,255,255)
								SetBuffer(BackBuffer())
							case "Movie Ticket":
								//don't resize because it messes up the masking
								SelectedItem.itemtemplate.img=LoadImage_Strict(SelectedItem.itemtemplate.imgpath)	
								
								if (SelectedItem.state = 0) {
									Msg = Chr(34)+"Hey, I remember this movie!"+Chr(34)
									MsgTimer = 70*10
									PlaySound_Strict (LoadTempSound("SFX/SCP/1162/NostalgiaCancer"+Rand(1,5)+".ogg"))
									SelectedItem.state = 1
								}
							default:
								SelectedItem.itemtemplate.img=LoadImage_Strict(SelectedItem.itemtemplate.imgpath)	
								SelectedItem.itemtemplate.img = ResizeImage2(SelectedItem.itemtemplate.img, ImageWidth(SelectedItem.itemtemplate.img) * MenuScale, ImageHeight(SelectedItem.itemtemplate.img) * MenuScale)
						}
						
						MaskImage(SelectedItem.itemtemplate.img, 255, 0, 255)
					}
					
					DrawImage(SelectedItem.itemtemplate.img, GraphicWidth / 2 - ImageWidth(SelectedItem.itemtemplate.img) / 2, GraphicHeight / 2 - ImageHeight(SelectedItem.itemtemplate.img) / 2)
					
				case "scp1025":
					//[Block]
					GiveAchievement(Achv1025) 
					if (SelectedItem.itemtemplate.img=0) {
						SelectedItem.state = Rand(0,5)
						SelectedItem.itemtemplate.img=LoadImage_Strict("GFX/items/1025/1025_"+Int(SelectedItem.state)+".jpg")	
						SelectedItem.itemtemplate.img = ResizeImage2(SelectedItem.itemtemplate.img, ImageWidth(SelectedItem.itemtemplate.img) * MenuScale, ImageHeight(SelectedItem.itemtemplate.img) * MenuScale)
						
						MaskImage(SelectedItem.itemtemplate.img, 255, 0, 255)
					}
					
					if (!Wearing714) {
						SCP1025state[SelectedItem.state]=Max(1,SCP1025state[SelectedItem.state])
					}
					
					DrawImage(SelectedItem.itemtemplate.img, GraphicWidth / 2 - ImageWidth(SelectedItem.itemtemplate.img) / 2, GraphicHeight / 2 - ImageHeight(SelectedItem.itemtemplate.img) / 2)
					
				case "cup":
					//[Block]
					if (CanUseItem(false,false,true)) {
						SelectedItem.name = Trim(Lower(SelectedItem.name))
						if (Left(SelectedItem.name, Min(6,Len(SelectedItem.name))) = "cup of") {
							SelectedItem.name = Right(SelectedItem.name, Len(SelectedItem.name)-7)
						} else if (Left(SelectedItem.name, Min(8,Len(SelectedItem.name))) = "a cup of") {
							SelectedItem.name = Right(SelectedItem.name, Len(SelectedItem.name)-9)
						}
						
						//the state of refined items is more than 1.0 (fine setting increases it by 1, very fine doubles it)
						x2 = (SelectedItem.state+1.0)
						
						let iniStr: string = "DATA/SCP-294.ini"
						
						let loc: int = GetINISectionLocation(iniStr, SelectedItem.name)
						
						//Stop
						
						strtemp = GetINIString2(iniStr, loc, "message")
						if (strtemp != "") {
							Msg = strtemp
							MsgTimer = 70*6
						}
						
						if (GetINIInt2(iniStr, loc, "lethal") || GetINIInt2(iniStr, loc, "deathtimer")) {
							DeathMSG = GetINIString2(iniStr, loc, "deathmessage")
							if (GetINIInt2(iniStr, loc, "lethal")) {Kill()}
						}
						BlurTimer = GetINIInt2(iniStr, loc, "blur")*70//*temp
						if (VomitTimer = 0) {VomitTimer = GetINIInt2(iniStr, loc, "vomit")}
						CameraShakeTimer = GetINIString2(iniStr, loc, "camerashake")
						Injuries = Max(Injuries + GetINIInt2(iniStr, loc, "damage"),0)//*temp
						Bloodloss = Max(Bloodloss + GetINIInt2(iniStr, loc, "blood loss"),0)//*temp
						strtemp =  GetINIString2(iniStr, loc, "sound")
						if (strtemp!="") {
							PlaySound_Strict (LoadTempSound(strtemp))
						}
						if (GetINIInt2(iniStr, loc, "stomachache")) {SCP1025state[3]=1}
						
						DeathTimer=GetINIInt2(iniStr, loc, "deathtimer")*70
						
						BlinkEffect = Float(GetINIString2(iniStr, loc, "blink effect", 1.0))*x2
						BlinkEffectTimer = Float(GetINIString2(iniStr, loc, "blink effect timer", 1.0))*x2
						
						StaminaEffect = Float(GetINIString2(iniStr, loc, "stamina effect", 1.0))*x2
						StaminaEffectTimer = Float(GetINIString2(iniStr, loc, "stamina effect timer", 1.0))*x2
						
						strtemp = GetINIString2(iniStr, loc, "refusemessage")
						if (strtemp != "") {
							Msg = strtemp 
							MsgTimer = 70*6		
						} else {
							it.Items = CreateItem("Empty Cup", "emptycup", 0,0,0)
							it.Picked = true
							for (i of range(MaxItemAmount)) {
								if (Inventory(i)=SelectedItem) {
									Inventory(i) = it
									break
								}
							}					
							EntityType (it.collider, HIT_ITEM)
							
							RemoveItem(SelectedItem)						
						}
						
						SelectedItem = Null
					}
					
				case "syringe":
					//[Block]
					if (CanUseItem(false,true,true)) {
						HealTimer = 30
						StaminaEffect = 0.5
						StaminaEffectTimer = 20
						
						Msg = "You injected yourself with the syringe and feel a slight adrenaline rush."
						MsgTimer = 70 * 8
						
						RemoveItem(SelectedItem)
					}
					
				case "finesyringe":
					//[Block]
					if (CanUseItem(false,true,true)) {
						HealTimer = Rnd(20, 40)
						StaminaEffect = Rnd(0.5, 0.8)
						StaminaEffectTimer = Rnd(20, 30)
						
						Msg = "You injected yourself with the syringe and feel an adrenaline rush."
						MsgTimer = 70 * 8
						
						RemoveItem(SelectedItem)
					}
					
				case "veryfinesyringe":
					//[Block]
					if (CanUseItem(false,true,true)) {
						switch (Rand(3)) {
							case 1:
								HealTimer = Rnd(40, 60)
								StaminaEffect = 0.1
								StaminaEffectTimer = 30
								Msg = "You injected yourself with the syringe and feel a huge adrenaline rush."
							case 2:
								SuperMan = true
								Msg = "You injected yourself with the syringe and feel a humongous adrenaline rush."
							case 3:
								VomitTimer = 30
								Msg = "You injected yourself with the syringe and feel a pain in your stomach."
						}
						
						MsgTimer = 70 * 8
						RemoveItem(SelectedItem)
					}
					
				case "radio","18vradio","fineradio","veryfineradio":
					//[Block]
					if (SelectedItem.state <= 100) {
						SelectedItem.state = Max(0, SelectedItem.state - FPSfactor * 0.004)
					}
					
					if (SelectedItem.itemtemplate.img=0) {
						SelectedItem.itemtemplate.img=LoadImage_Strict(SelectedItem.itemtemplate.imgpath)	
						MaskImage(SelectedItem.itemtemplate.img, 255, 0, 255)
					}
					
					//radiostate(5) = has the "use the number keys" -message been shown yet (true/false)
					//radiostate(6) = a timer for the "code channel"
					//RadioState(7) = another timer for the "code channel"
					
					if (RadioState(5) = 0) {
						Msg = "Use the numbered keys 1 through 5 to cycle between various channels."
						MsgTimer = 70 * 5
						RadioState(5) = 1
						RadioState(0) = -1
					}
					
					strtemp$ = ""
					
					x = GraphicWidth - ImageWidth(SelectedItem.itemtemplate.img) //+ 120
					y = GraphicHeight - ImageHeight(SelectedItem.itemtemplate.img) //- 30
					
					DrawImage(SelectedItem.itemtemplate.img, x, y)
					
					if (SelectedItem.state > 0) {
						if (PlayerRoom.RoomTemplate.Name = "pocketdimension" || CoffinDistance < 4.0) {
							ResumeChannel(RadioCHN(5))
							if (ChannelPlaying(RadioCHN(5)) = false) {RadioCHN(5) = PlaySound_Strict(RadioStatic)}
						} else {
							switch (Int(SelectedItem.state2)) {
								case 0: //randomkanava:
									ResumeChannel(RadioCHN(0))
									strtemp = "        USER TRACK PLAYER - "
									if (!EnableUserTracks) {
										if (ChannelPlaying(RadioCHN(0)) = false) {
											RadioCHN(0) = PlaySound_Strict(RadioStatic)
										}
										strtemp = strtemp + "NOT ENABLED     "
									} else if (UserTrackMusicAmount<1) {
										if (ChannelPlaying(RadioCHN(0)) = false) {
											RadioCHN(0) = PlaySound_Strict(RadioStatic)
										}
										strtemp = strtemp + "NO TRACKS FOUND     "
									} else {
										if (!ChannelPlaying(RadioCHN(0))) {
											if (!UserTrackFlag) {
												if (UserTrackMode) {
													if (RadioState(0)<(UserTrackMusicAmount-1)) {
														RadioState(0) = RadioState(0) + 1
													} else {
														RadioState(0) = 0
													}
													UserTrackFlag = true
												} else {
													RadioState(0) = Rand(0,UserTrackMusicAmount-1)
												}
											}
											if (CurrUserTrack!=0) {
												FreeSound_Strict(CurrUserTrack)
												CurrUserTrack = 0
											}
											CurrUserTrack = LoadSound_Strict("SFX/Radio/UserTracks/"+UserTrackName$(RadioState(0)))
											RadioCHN(0) = PlaySound_Strict(CurrUserTrack)
											DebugLog("CurrTrack: "+RadioState(0))
											DebugLog(UserTrackName$(RadioState(0)))
										} else {
											strtemp = strtemp + Upper(UserTrackName$(RadioState(0))) + "          "
											UserTrackFlag = false
										}
										
										if (KeyHit(2)) {
											PlaySound_Strict (RadioSquelch)
											if (!UserTrackFlag) {
												if (UserTrackMode) {
													if (RadioState(0)<(UserTrackMusicAmount-1)) {
														RadioState(0) = RadioState(0) + 1
													} else {
														RadioState(0) = 0
													}
													UserTrackFlag = true
												} else {
													RadioState(0) = Rand(0,UserTrackMusicAmount-1)
												}
											}
											if (CurrUserTrack != 0) {
												FreeSound_Strict(CurrUserTrack)
												CurrUserTrack = 0
											}
											CurrUserTrack = LoadSound_Strict("SFX/Radio/UserTracks/"+UserTrackName(RadioState(0)))
											RadioCHN(0) = PlaySound_Strict(CurrUserTrack)
											DebugLog("CurrTrack: "+RadioState(0))
											DebugLog(UserTrackName$(RadioState(0)))
										}
									}
								case 1: //hlytyskanava:
									DebugLog(RadioState(1) )
									
									ResumeChannel(RadioCHN(1))
									strtemp = "        WARNING - CONTAINMENT BREACH          "
									if (ChannelPlaying(RadioCHN(1)) = false) {
										
										if (RadioState(1) >= 5) {
											RadioCHN(1) = PlaySound_Strict(RadioSFX(1,1))	
											RadioState(1) = 0
										} else {
											RadioState(1)=RadioState(1)+1	
											RadioCHN(1) = PlaySound_Strict(RadioSFX(1,0))	
										}
										
									}
									
								case 2: //scp-radio:
									ResumeChannel(RadioCHN(2))
									strtemp = "        SCP Foundation On-Site Radio          "
									if (ChannelPlaying(RadioCHN(2)) = false) {
										RadioState(2)=RadioState(2)+1
										if (RadioState(2) = 17) {RadioState(2) = 1}
										if (Floor(RadioState(2)/2)=Ceil(RadioState(2)/2)) { //parillinen, soitetaan normiviesti
											RadioCHN(2) = PlaySound_Strict(RadioSFX(2,Int(RadioState(2)/2)))	
										} else { //pariton, soitetaan musiikkia
											RadioCHN(2) = PlaySound_Strict(RadioSFX(2,0))
										}
									} 
								case 3:
									ResumeChannel(RadioCHN(3))
									strtemp = "             EMERGENCY CHANNEL - RESERVED FOR COMMUNICATION IN THE EVENT OF A CONTAINMENT BREACH         "
									if (ChannelPlaying(RadioCHN(3)) = false) {RadioCHN(3) = PlaySound_Strict(RadioStatic)}
									
									if (MTFtimer > 0) { 
										RadioState(3)=RadioState(3)+Max(Rand(-10,1),0)
										switch (RadioState(3)) {
											case 40:
												if (!RadioState3(0)) {
													RadioCHN(3) = PlaySound_Strict(LoadTempSound("SFX/Character/MTF/Random1.ogg"))
													RadioState(3) = RadioState(3)+1	
													RadioState3(0) = true	
												}											
											case 400:
												if (!RadioState3(1)) {
													RadioCHN(3) = PlaySound_Strict(LoadTempSound("SFX/Character/MTF/Random2.ogg"))
													RadioState(3) = RadioState(3)+1	
													RadioState3(1) = true	
												}	
											case 800:
												if (!RadioState3(2)) {
													RadioCHN(3) = PlaySound_Strict(LoadTempSound("SFX/Character/MTF/Random3.ogg"))
													RadioState(3) = RadioState(3)+1	
													RadioState3(2) = true
												}													
											case 1200:
												if (!RadioState3(3)) {
													RadioCHN(3) = PlaySound_Strict(LoadTempSound("SFX/Character/MTF/Random4.ogg"))	
													RadioState(3) = RadioState(3)+1	
													RadioState3(3) = true
												}
											case 1600:
												if (!RadioState3(4)) {
													RadioCHN(3) = PlaySound_Strict(LoadTempSound("SFX/Character/MTF/Random5.ogg"))	
													RadioState(3) = RadioState(3)+1
													RadioState3(4) = true
												}
											case 2000:
												if (!RadioState3(5)) {
													RadioCHN(3) = PlaySound_Strict(LoadTempSound("SFX/Character/MTF/Random6.ogg"))	
													RadioState(3) = RadioState(3)+1
													RadioState3(5) = true
												}
											case 2400:
												if (!RadioState3(6)) {
													RadioCHN(3) = PlaySound_Strict(LoadTempSound("SFX/Character/MTF/Random7.ogg"))	
													RadioState(3) = RadioState(3)+1
													RadioState3(6) = true
												}
										}
									}
								case 4:
									ResumeChannel(RadioCHN(6)) //taustalle kohinaa
									if (ChannelPlaying(RadioCHN(6)) = false) {RadioCHN(6) = PlaySound_Strict(RadioStatic)}
									
									ResumeChannel(RadioCHN(4))
									if (ChannelPlaying(RadioCHN(4)) = false) {
										if (RemoteDoorOn = false && RadioState(8) == false) {
											RadioCHN(4) = PlaySound_Strict(LoadTempSound("SFX/radio/Chatter3.ogg"))	
											RadioState(8) = true
										} else {
											RadioState(4)=RadioState(4)+Max(Rand(-10,1),0)
											
											switch (RadioState(4)) {
												case 10:
													if (!Contained106) {
														if (!RadioState4(0)) {
															RadioCHN(4) = PlaySound_Strict(LoadTempSound("SFX/radio/OhGod.ogg"))
															RadioState(4) = RadioState(4)+1
															RadioState4(0) = true
														}
													}
												case 100:
													if (!RadioState4(1)) {
														RadioCHN(4) = PlaySound_Strict(LoadTempSound("SFX/radio/Chatter2.ogg"))
														RadioState(4) = RadioState(4)+1
														RadioState4(1) = true
													}		
												case 158:
													if (MTFtimer = 0 && (!RadioState4(2))) {
														RadioCHN(4) = PlaySound_Strict(LoadTempSound("SFX/radio/franklin1.ogg"))
														RadioState(4) = RadioState(4)+1
														RadioState(2) = true
													}
												case 200:
													if (!RadioState4(3)) {
														RadioCHN(4) = PlaySound_Strict(LoadTempSound("SFX/radio/Chatter4.ogg"))
														RadioState(4) = RadioState(4)+1
														RadioState4(3) = true
													}		
												case 260:
													if (!RadioState4(4)) {
														RadioCHN(4) = PlaySound_Strict(LoadTempSound("SFX/SCP/035/RadioHelp1.ogg"))
														RadioState(4) = RadioState(4)+1
														RadioState4(4) = true
													}		
												case 300:
													if (!RadioState4(5)) {
														RadioCHN(4) = PlaySound_Strict(LoadTempSound("SFX/radio/Chatter1.ogg"))	
														RadioState(4) = RadioState(4)+1	
														RadioState4(5) = true
													}		
												case 350:
													if (!RadioState4(6)) {
														RadioCHN(4) = PlaySound_Strict(LoadTempSound("SFX/radio/franklin2.ogg"))
														RadioState(4) = RadioState(4)+1
														RadioState4(6) = true
													}		
												case 400:
													if (!RadioState4(7)) {
														RadioCHN(4) = PlaySound_Strict(LoadTempSound("SFX/SCP/035/RadioHelp2.ogg"))
														RadioState(4) = RadioState(4)+1
														RadioState4(7) = true
													}		
												case 450:
													if (!RadioState4(8)) {
														RadioCHN(4) = PlaySound_Strict(LoadTempSound("SFX/radio/franklin3.ogg"))	
														RadioState(4) = RadioState(4)+1		
														RadioState4(8) = true
													}		
												case 600:
													if (!RadioState4(9)) {
														RadioCHN(4) = PlaySound_Strict(LoadTempSound("SFX/radio/franklin4.ogg"))	
														RadioState(4) = RadioState(4)+1	
														RadioState4(9) = true
													}		
											}
										}
									}
									
									
								case 5:
									ResumeChannel(RadioCHN(5))
									if (ChannelPlaying(RadioCHN(5)) = false) {
										RadioCHN(5) = PlaySound_Strict(RadioStatic)
									}
							}
							
							x=x+66
							y=y+419
							
							Color (30,30,30)
							
							if (SelectedItem.state <= 100) {
								for (i of range(5)) {
									Rect(x, y+8*i, 43 - i * 6, 4, Ceil(SelectedItem.state / 20.0) > 4 - i )
								}
							}	
							
							AASetFont (Font3)
							AAText(x+60, y, "CHN")						
							
							if (SelectedItem.itemtemplate.tempname = "veryfineradio") { //"KOODIKANAVA"
								ResumeChannel(RadioCHN(0))
								if (ChannelPlaying(RadioCHN(0)) = false) {
									RadioCHN(0) = PlaySound_Strict(RadioStatic)
								}
								
								//radiostate(7)=kuinka mones piippaus menossa
								//radiostate(8)=kuinka mones access coden numero menossa
								RadioState(6)=RadioState(6) + FPSfactor
								temp = Mid(Str(AccessCode),RadioState(8)+1,1)
								if (RadioState(6)-FPSfactor <= RadioState(7)*50 && RadioState(6)>RadioState(7)*50) {
									PlaySound_Strict(RadioBuzz)
									RadioState(7)=RadioState(7)+1
									if (RadioState(7) >= temp) {
										RadioState(7)=0
										RadioState(6)=-100
										RadioState(8)=RadioState(8)+1
										if (RadioState(8)=4) {
											RadioState(8)=0
											RadioState(6)=-200
										}
									}
								}
								
								strtemp = ""
								for (i of range(Rand(5, 30) + 1)) {
									strtemp = strtemp + Chr(Rand(1,100))
								}
								
								AASetFont (Font4)
								AAText(x+97, y+16, Rand(0,9),true,true)
								
							} else {
								for (i of range(2, 7)) {
									if (KeyHit(i)) {
										if (SelectedItem.state2 != i-2) { //pausetetaan nykyinen radiokanava
											PlaySound_Strict (RadioSquelch)
											if (RadioCHN(Int(SelectedItem.state2)) != 0) {
												PauseChannel(RadioCHN(Int(SelectedItem.state2)))
											}
										}
										SelectedItem.state2 = i-2
										//jos nykyist kanavaa ollaan soitettu, laitetaan jatketaan toistoa samasta kohdasta
										if (RadioCHN(SelectedItem.state2)!=0) {
											ResumeChannel(RadioCHN(SelectedItem.state2))
										}
									}
								}
								
								AASetFont (Font4)
								AAText(x+97, y+16, Int(SelectedItem.state2+1),true,true)
							}
							
							AASetFont (Font3)
							if (strtemp != "") {
								strtemp = Right(Left(strtemp, (Int(MilliSecs2()/300) % Len(strtemp))),10)
								AAText(x+32, y+33, strtemp)
							}
							
							AASetFont (Font1)
							
						}
						
					}
					
				case "cigarette":
					//[Block]
					if (CanUseItem(false,false,true)) {
						if (SelectedItem.state = 0) {
							switch (Rand(6)) {
								case 1:
									Msg = Chr(34)+"I don't have anything to light it with. Umm, what about that... Nevermind."+Chr(34)
								case 2:
									Msg = "You are unable to get lit."
								case 3:
									Msg = Chr(34)+"I quit that a long time ago."+Chr(34)
									RemoveItem(SelectedItem)
								case 4:
									Msg = Chr(34)+"Even if I wanted one, I have nothing to light it with."+Chr(34)
								case 5:
									Msg = Chr(34)+"Could really go for one now... Wish I had a lighter."+Chr(34)
								case 6:
									Msg = Chr(34)+"Don't plan on starting, even at a time like this."+Chr(34)
									RemoveItem(SelectedItem)
							}
							SelectedItem.state = 1 
						} else {
							Msg = "You are unable to get lit."
						}
						
						MsgTimer = 70 * 5
					}
					
				case "420":
					//[Block]
					if (CanUseItem(false,false,true)) {
						if (Wearing714=1) {
							Msg = Chr(34) + "DUDE WTF THIS SHIT DOESN'T EVEN WORK" + Chr(34)
						} else {
							Msg = Chr(34) + "MAN DATS SUM GOOD ASS SHIT" + Chr(34)
							Injuries = Max(Injuries-0.5, 0)
							BlurTimer = 500
							GiveAchievement(Achv420)
							PlaySound_Strict (LoadTempSound("SFX/Music/420J.ogg"))
						}
						MsgTimer = 70 * 5
						RemoveItem(SelectedItem)
					}
					
				case "420s":
					//[Block]
					if (CanUseItem(false,false,true)) {
						if (Wearing714=1) {
							Msg = Chr(34) + "DUDE WTF THIS SHIT DOESN'T EVEN WORK" + Chr(34)
						} else {
							DeathMSG = "Subject D-9341 found in a comatose state in [DATA REDACTED]. The subject was holding what appears to be a cigarette while smiling widely. "
							DeathMSG = DeathMSG+"Chemical analysis of the cigarette has been inconclusive, although it seems to contain a high concentration of an unidentified chemical "
							DeathMSG = DeathMSG+"whose molecular structure is remarkably similar to that of tetrahydrocannabinol."
							Msg = Chr(34) + "UH WHERE... WHAT WAS I DOING AGAIN... MAN I NEED TO TAKE A NAP..." + Chr(34)
							KillTimer = -1						
						}
						MsgTimer = 70 * 6
						RemoveItem(SelectedItem)
					}
					
				case "scp714":
					//[Block]
					if (Wearing714=1) {
						Msg = "You removed the ring."
						Wearing714 = false
					} else {
						GiveAchievement(Achv714)
						Msg = "You put on the ring."
						Wearing714 = true
					}
					MsgTimer = 70 * 5
					SelectedItem = Null	
					
				case "hazmatsuit", "hazmatsuit2", "hazmatsuit3":
					//[Block]
					if (WearingVest = 0) {
						CurrSpeed = CurveValue(0, CurrSpeed, 5.0)
						
						DrawImage(SelectedItem.itemtemplate.invimg, GraphicWidth / 2 - ImageWidth(SelectedItem.itemtemplate.invimg) / 2, GraphicHeight / 2 - ImageHeight(SelectedItem.itemtemplate.invimg) / 2)
						
						width = 300
						height = 20
						x = GraphicWidth / 2 - width / 2
						y = GraphicHeight / 2 + 80
						Rect(x, y, width+4, height, false)
						for (i of range(1, Int((width - 2) * (SelectedItem.state / 100.0) / 10) + 1)) {
							DrawImage(BlinkMeterIMG, x + 3 + 10 * (i - 1), y + 3)
						}
						
						SelectedItem.state = Min(SelectedItem.state+(FPSfactor/4.0),100)
						
						if (SelectedItem.state=100) {
							if (WearingHazmat>0) {
								Msg = "You removed the hazmat suit."
								WearingHazmat = false
								DropItem(SelectedItem)
							} else {
								if (SelectedItem.itemtemplate.tempname="hazmatsuit") {
									//Msg = "Hazmat1."
									WearingHazmat = 1
								} else if (SelectedItem.itemtemplate.tempname="hazmatsuit2") {
									//Msg = "Hazmat2."
									WearingHazmat = 2
								} else {
									//Msg = "Hazmat3."
									WearingHazmat = 3
								}
								if (SelectedItem.itemtemplate.sound != 66) {
									PlaySound_Strict(PickSFX(SelectedItem.itemtemplate.sound))
								}
								Msg = "You put on the hazmat suit."
								if (WearingNightVision) {
									CameraFogFar = StoredCameraFogFar
								}
								WearingGasMask = 0
								WearingNightVision = 0
							}
							SelectedItem.state=0
							MsgTimer = 70 * 5
							SelectedItem = Null
						}
					}
					
				case "vest","finevest":
					//[Block]
					CurrSpeed = CurveValue(0, CurrSpeed, 5.0)
					
					DrawImage(SelectedItem.itemtemplate.invimg, GraphicWidth / 2 - ImageWidth(SelectedItem.itemtemplate.invimg) / 2, GraphicHeight / 2 - ImageHeight(SelectedItem.itemtemplate.invimg) / 2)
					
					width = 300
					height = 20
					x = GraphicWidth / 2 - width / 2
					y = GraphicHeight / 2 + 80
					Rect(x, y, width+4, height, false)
					for (i of range(1, Int((width - 2) * (SelectedItem.state / 100.0) / 10) + 1)) {
						DrawImage(BlinkMeterIMG, x + 3 + 10 * (i - 1), y + 3)
					}
					
					SelectedItem.state = Min(SelectedItem.state+(FPSfactor/(2.0+(0.5*(SelectedItem.itemtemplate.tempname="finevest")))),100)
					
					if (SelectedItem.state=100) {
						if (WearingVest>0) {
							Msg = "You removed the vest."
							WearingVest = false
							DropItem(SelectedItem)
						} else {
							if (SelectedItem.itemtemplate.tempname="vest") {
								Msg = "You put on the vest and feel slightly encumbered."
								WearingVest = 1
							} else {
								Msg = "You put on the vest and feel heavily encumbered."
								WearingVest = 2
							}
							if (SelectedItem.itemtemplate.sound != 66) {
								PlaySound_Strict(PickSFX(SelectedItem.itemtemplate.sound))
							}
						}
						SelectedItem.state=0
						MsgTimer = 70 * 5
						SelectedItem = Null
					}
					
				case "gasmask", "supergasmask", "gasmask3":
					//[Block]
					if (Wearing1499 == 0 && WearingHazmat == 0) {
						if (WearingGasMask) {
							Msg = "You removed the gas mask."
						} else {
							if (SelectedItem.itemtemplate.tempname = "supergasmask") {
								Msg = "You put on the gas mask and you can breathe easier."
							} else {
								Msg = "You put on the gas mask."
							}
							if (WearingNightVision) {
								CameraFogFar = StoredCameraFogFar
							}
							WearingNightVision = 0
							WearingGasMask = 0
						}
						if (SelectedItem.itemtemplate.tempname="gasmask3") {
							if (WearingGasMask == 0) {WearingGasMask = 3} else {WearingGasMask=0}
						} else if (SelectedItem.itemtemplate.tempname="supergasmask") {
							if (WearingGasMask == 0) {WearingGasMask = 2} else {WearingGasMask=0}
						} else {
							WearingGasMask = (!WearingGasMask)
						}
					} else if (Wearing1499 > 0) {
						Msg = "You need to take off SCP-1499 in order to put on the gas mask."
					} else {
						Msg = "You need to take off the hazmat suit in order to put on the gas mask."
					}
					SelectedItem = Null
					MsgTimer = 70 * 5
					
				case "navigator", "nav":
					//[Block]
					
					if (SelectedItem.itemtemplate.img=0) {
						SelectedItem.itemtemplate.img=LoadImage_Strict(SelectedItem.itemtemplate.imgpath)	
						MaskImage(SelectedItem.itemtemplate.img, 255, 0, 255)
					}
					
					if (SelectedItem.state <= 100) {
						SelectedItem.state = Max(0, SelectedItem.state - FPSfactor * 0.005)
					}
					
					x = GraphicWidth - ImageWidth(SelectedItem.itemtemplate.img)*0.5+20
					y = GraphicHeight - ImageHeight(SelectedItem.itemtemplate.img)*0.4-85
					width = 287
					height = 256
					
					let PlayerX,PlayerZ
					
					DrawImage(SelectedItem.itemtemplate.img, x - ImageWidth(SelectedItem.itemtemplate.img) / 2, y - ImageHeight(SelectedItem.itemtemplate.img) / 2 + 85)
					
					AASetFont (Font3)
					
					let NavWorks: boolean = true
					if (PlayerRoom.RoomTemplate.Name == "pocketdimension" || PlayerRoom.RoomTemplate.Name == "dimension1499") {
						NavWorks = false
					} else if (PlayerRoom.RoomTemplate.Name$ = "room860") {
						for (e of Events.each) {
							if (e.EventName = "room860") {
								if (e.EventState = 1.0) {
									NavWorks = false
								}
								break
							}
						}
					}
					
					if (!NavWorks) {
						if ((MilliSecs2() % 1000) > 300) {
							Color(200, 0, 0)
							AAText(x, y + height / 2 - 80, "ERROR 06", true)
							AAText(x, y + height / 2 - 60, "LOCATION UNKNOWN", true)						
						}
					} else {
						
						if (SelectedItem.state > 0 && (Rnd(CoffinDistance + 15.0) > 1.0 || PlayerRoom.RoomTemplate.Name != "coffin")) {
							
							PlayerX = Floor((EntityX(PlayerRoom.obj)+8) / 8.0 + 0.5)
							PlayerZ = Floor((EntityZ(PlayerRoom.obj)+8) / 8.0 + 0.5)
							
							SetBuffer (ImageBuffer(NavBG))
							let xx = x-ImageWidth(SelectedItem.itemtemplate.img)/2
							let yy = y-ImageHeight(SelectedItem.itemtemplate.img)/2+85
							DrawImage(SelectedItem.itemtemplate.img, xx, yy)
							
							x = x - 12 + (((EntityX(Collider)-4.0)+8.0) % 8.0) * 3
							y = y + 12 - (((EntityZ(Collider)-4.0)+8.0) % 8.0) * 3
							for (x2 of range(Max(0, PlayerX - 6), Min(MapWidth, PlayerX + 6) + 1)) {
								for (z2 of range(Max(0, PlayerZ - 6), Min(MapHeight, PlayerZ + 6) + 1)) {
									
									if (CoffinDistance > 16.0 || Rnd(16.0)<CoffinDistance) { 
										if (MapTemp(x2, z2)>0 && (MapFound(x2, z2) > 0 || SelectedItem.itemtemplate.name == "S-NAV 310 Navigator" || SelectedItem.itemtemplate.name == "S-NAV Navigator Ultimate")) {
											let drawx: int = x + (PlayerX - 1 - x2) * 24 , drawy: int = y - (PlayerZ - 1 - z2) * 24
											
											if (x2+1<=MapWidth) {
												if (MapTemp(x2+1,z2)=false) {
													DrawImage(NavImages(3),drawx-12,drawy-12)
												}
											} else {
												DrawImage(NavImages(3),drawx-12,drawy-12)
											}
											if (x2-1>=0) {
												if (MapTemp(x2-1,z2)=false) {
													DrawImage(NavImages(1),drawx-12,drawy-12)
												}
											} else {
												DrawImage(NavImages(1),drawx-12,drawy-12)
											}
											if (z2-1>=0) {
												if (MapTemp(x2,z2-1)=false) {
													DrawImage(NavImages(0),drawx-12,drawy-12)
												}
											} else {
												DrawImage(NavImages(0),drawx-12,drawy-12)
											}
											if (z2+1<=MapHeight) {
												if (MapTemp(x2,z2+1)=false) {
													DrawImage(NavImages(2),drawx-12,drawy-12)
												}
											} else {
												DrawImage(NavImages(2),drawx-12,drawy-12)
											}
										}
									}
									
								}
							}
							
							SetBuffer (BackBuffer())
							DrawImageRect (NavBG,xx+80,yy+70,xx+80,yy+70,270,230)
							Color (30,30,30)
							if (SelectedItem.itemtemplate.name = "S-NAV Navigator") {
								Color(100, 0, 0)
							}
							Rect (xx+80,yy+70,270,230,false)
							
							x = GraphicWidth - ImageWidth(SelectedItem.itemtemplate.img)*0.5+20
							y = GraphicHeight - ImageHeight(SelectedItem.itemtemplate.img)*0.4-85
							
							if (SelectedItem.itemtemplate.name = "S-NAV Navigator") {
								Color(100, 0, 0)
							} else {
								Color (30,30,30)
							}
							if ((MilliSecs2() % 1000) > 300) {
								if (SelectedItem.itemtemplate.name != "S-NAV 310 Navigator" && SelectedItem.itemtemplate.name != "S-NAV Navigator Ultimate") {
									AAText(x - width/2 + 10, y - height/2 + 10, "MAP DATABASE OFFLINE")
								}
								
								yawvalue = EntityYaw(Collider)-90
								x1 = x+Cos(yawvalue)*6
								y1 = y-Sin(yawvalue)*6
								x2 = x+Cos(yawvalue-140)*5
								y2 = y-Sin(yawvalue-140)*5				
								x3 = x+Cos(yawvalue+140)*5
								y3 = y-Sin(yawvalue+140)*5
								
								Line(x1,y1,x2,y2)
								Line(x1,y1,x3,y3)
								Line(x2,y2,x3,y3)
							}
							
							let SCPs_found: int = 0
							if (SelectedItem.itemtemplate.name = "S-NAV Navigator Ultimate" && (MilliSecs2() % 600) < 400) {
								if (Curr173!=Null) {
									let dist = EntityDistance(Camera, Curr173.obj)
									dist = Ceil(dist / 8.0) * 8.0
									if (dist < 8.0 * 4) {
										Color (100, 0, 0)
										Oval(x - dist * 3, y - 7 - dist * 3, dist * 3 * 2, dist * 3 * 2, false)
										AAText(x - width / 2 + 10, y - height / 2 + 30, "SCP-173")
										SCPs_found = SCPs_found + 1
									}
								}
								if (Curr106!=Null) {
									dist = EntityDistance(Camera, Curr106.obj)
									if (dist < 8.0 * 4) {
										Color (100, 0, 0)
										Oval(x - dist * 1.5, y - 7 - dist * 1.5, dist * 3, dist * 3, false)
										AAText(x - width / 2 + 10, y - height / 2 + 30 + (20*SCPs_found), "SCP-106")
										SCPs_found = SCPs_found + 1
									}
								}
								if (Curr096!=Null) { 
									dist = EntityDistance(Camera, Curr096.obj)
									if (dist < 8.0 * 4) {
										Color (100, 0, 0)
										Oval(x - dist * 1.5, y - 7 - dist * 1.5, dist * 3, dist * 3, false)
										AAText(x - width / 2 + 10, y - height / 2 + 30 + (20*SCPs_found), "SCP-096")
										SCPs_found = SCPs_found + 1
									}
								}
								for (np of NPCs.each) {
									if (np.NPCtype = NPCtype049) {
										dist = EntityDistance(Camera, np.obj)
										if (dist < 8.0 * 4) {
											if (!np.HideFromNVG) {
												Color (100, 0, 0)
												Oval(x - dist * 1.5, y - 7 - dist * 1.5, dist * 3, dist * 3, false)
												AAText(x - width / 2 + 10, y - height / 2 + 30 + (20*SCPs_found), "SCP-049")
												SCPs_found = SCPs_found + 1
											}
										}
										break
									}
								}
								if (PlayerRoom.RoomTemplate.Name = "coffin") {
									if (CoffinDistance < 8.0) {
										dist = Rnd(4.0, 8.0)
										Color (100, 0, 0)
										Oval(x - dist * 1.5, y - 7 - dist * 1.5, dist * 3, dist * 3, false)
										AAText(x - width / 2 + 10, y - height / 2 + 30 + (20*SCPs_found), "SCP-895")
									}
								}
							}
							
							Color (30,30,30)
							if (SelectedItem.itemtemplate.name = "S-NAV Navigator") {
								Color(100, 0, 0)
							}
							if (SelectedItem.state <= 100) {
								xtemp = x - width/2 + 196
								ytemp = y - height/2 + 10
								Rect (xtemp,ytemp,80,20,false)
								
								for (i of range(1, Ceil(SelectedItem.state / 10.0) + 1)) {
									DrawImage (NavImages(4),xtemp+i*8-6,ytemp+4)
								}
								
								AASetFont (Font3)
							}
						}
						
					}
					
				//new Items in SCP:CB 1.3
				case "scp1499","super1499":
					//[Block]
					if (WearingHazmat>0) {
						Msg = "You are not able to wear SCP-1499 and a hazmat suit at the same time."
						MsgTimer = 70 * 5
						SelectedItem=Null
						return
					}
					
					CurrSpeed = CurveValue(0, CurrSpeed, 5.0)
					
					DrawImage(SelectedItem.itemtemplate.invimg, GraphicWidth / 2 - ImageWidth(SelectedItem.itemtemplate.invimg) / 2, GraphicHeight / 2 - ImageHeight(SelectedItem.itemtemplate.invimg) / 2)
					
					width = 300
					height = 20
					x = GraphicWidth / 2 - width / 2
					y = GraphicHeight / 2 + 80
					Rect(x, y, width+4, height, false)
					for (i of range(1, Int((width - 2) * (SelectedItem.state / 100.0) / 10) + 1)) {
						DrawImage(BlinkMeterIMG, x + 3 + 10 * (i - 1), y + 3)
					}
					
					SelectedItem.state = Min(SelectedItem.state+(FPSfactor),100)
					
					if (SelectedItem.state=100) {
						if (Wearing1499>0) {
							//Msg = "1499remove."
							Wearing1499 = false
							//DropItem(SelectedItem)
							if (SelectedItem.itemtemplate.sound != 66) {
								PlaySound_Strict(PickSFX(SelectedItem.itemtemplate.sound))
							}
						} else {
							if (SelectedItem.itemtemplate.tempname="scp1499") {
								//Msg = "scp1499."
								Wearing1499 = 1
							} else {
								//Msg = "super1499."
								Wearing1499 = 2
							}
							if (SelectedItem.itemtemplate.sound != 66) {
								PlaySound_Strict(PickSFX(SelectedItem.itemtemplate.sound))
							}
							GiveAchievement(Achv1499)
							if (WearingNightVision) {
								CameraFogFar = StoredCameraFogFar
							}
							WearingGasMask = 0
							WearingNightVision = 0
							for (r of Rooms.each) {
								if (r.RoomTemplate.Name = "dimension1499") {
									BlinkTimer = -1
									NTF_1499PrevRoom = PlayerRoom
									NTF_1499PrevX = EntityX(Collider)
									NTF_1499PrevY = EntityY(Collider)
									NTF_1499PrevZ = EntityZ(Collider)
									
									if (NTF_1499X == 0.0 && NTF_1499Y == 0.0 && NTF_1499Z == 0.0) {
										PositionEntity (Collider, r.x+6086.0*RoomScale, r.y+304.0*RoomScale, r.z+2292.5*RoomScale)
										RotateEntity (Collider,0,90,0,true)
									} else {
										PositionEntity (Collider, NTF_1499X, NTF_1499Y+0.05, NTF_1499Z)
									}
									ResetEntity(Collider)
									UpdateDoors()
									UpdateRooms()
									for (it of Items.each) {
										it.disttimer = 0
									}
									PlayerRoom = r
									PlaySound_Strict (LoadTempSound("SFX/SCP/1499/Enter.ogg"))
									NTF_1499X = 0.0
									NTF_1499Y = 0.0
									NTF_1499Z = 0.0
									if (Curr096!=Null) {
										if (Curr096.SoundChn!=0) {
											SetStreamVolume_Strict(Curr096.SoundChn,0.0)
										}
									}
									for (e of Events.each) {
										if (e.EventName = "dimension1499") {
											if (EntityDistance(e.room.obj,Collider)>8300.0*RoomScale) {
												if (e.EventState2 < 5) {
													e.EventState2 = e.EventState2 + 1
												}
											}
											break
										}
									}
									break
								}
							}
						}
						SelectedItem.state=0
						//MsgTimer = 70 * 5
						SelectedItem = Null
					}
					
				case "badge":
					//[Block]
					if (SelectedItem.itemtemplate.img=0) {
						SelectedItem.itemtemplate.img=LoadImage_Strict(SelectedItem.itemtemplate.imgpath)	
						
						MaskImage(SelectedItem.itemtemplate.img, 255, 0, 255)
					}
					
					DrawImage(SelectedItem.itemtemplate.img, GraphicWidth / 2 - ImageWidth(SelectedItem.itemtemplate.img) / 2, GraphicHeight / 2 - ImageHeight(SelectedItem.itemtemplate.img) / 2)
					
					if (SelectedItem.state = 0) {
						PlaySound_Strict (LoadTempSound("SFX/SCP/1162/NostalgiaCancer"+Rand(6,10)+".ogg"))
						switch (SelectedItem.itemtemplate.name) {
							case "Old Badge":
								Msg = Chr(34)+"Huh? This guy looks just like me!"+Chr(34)
								MsgTimer = 70*10
						}
						
						SelectedItem.state = 1
					}
					
				case "key":
					//[Block]
					if (SelectedItem.state = 0) {
						PlaySound_Strict (LoadTempSound("SFX/SCP/1162/NostalgiaCancer"+Rand(6,10)+".ogg"))
						
						Msg = Chr(34)+"Isn't this the key to that old shack? The one where I... No, it can't be."+Chr(34)
						MsgTimer = 70*10						
					}
					
					SelectedItem.state = 1
					SelectedItem = Null
					
				case "oldpaper":
					//[Block]
					if (SelectedItem.itemtemplate.img = 0) {
						SelectedItem.itemtemplate.img = LoadImage_Strict(SelectedItem.itemtemplate.imgpath)	
						SelectedItem.itemtemplate.img = ResizeImage2(SelectedItem.itemtemplate.img, ImageWidth(SelectedItem.itemtemplate.img) * MenuScale, ImageHeight(SelectedItem.itemtemplate.img) * MenuScale)
						
						MaskImage(SelectedItem.itemtemplate.img, 255, 0, 255)
					}
					
					DrawImage(SelectedItem.itemtemplate.img, GraphicWidth / 2 - ImageWidth(SelectedItem.itemtemplate.img) / 2, GraphicHeight / 2 - ImageHeight(SelectedItem.itemtemplate.img) / 2)
					
					if (SelectedItem.state = 0) {
						switch (SelectedItem.itemtemplate.name) {
							case "Disciplinary Hearing DH-S-4137-17092":
								BlurTimer = 1000
								
								Msg = Chr(34)+"Why does this seem so familiar?"+Chr(34)
								MsgTimer = 70*10
								PlaySound_Strict(LoadTempSound("SFX/SCP/1162/NostalgiaCancer"+Rand(6,10)+".ogg"))
								SelectedItem.state = 1
						}
					}
					
				case "coin":
					//[Block]
					if (SelectedItem.state = 0) {
						PlaySound_Strict(LoadTempSound("SFX/SCP/1162/NostalgiaCancer"+Rand(1,5)+".ogg"))
					}
					
					Msg = ""
					
					SelectedItem.state = 1
					DrawImage(SelectedItem.itemtemplate.invimg, GraphicWidth / 2 - ImageWidth(SelectedItem.itemtemplate.invimg) / 2, GraphicHeight / 2 - ImageHeight(SelectedItem.itemtemplate.invimg) / 2)
					
				case "scp427":
					//[Block]
					if (I_427.Using=1) {
						Msg = "You closed the locket."
						I_427.Using = false
					} else {
						GiveAchievement(Achv427)
						Msg = "You opened the locket."
						I_427.Using = true
					}
					MsgTimer = 70 * 5
					SelectedItem = Null
					
				case "pill":
					//[Block]
					if (CanUseItem(false, false, true)) {
						Msg = "You swallowed the pill."
						MsgTimer = 70*7
						
						RemoveItem(SelectedItem)
						SelectedItem = Null
					}	
					
				case "scp500death":
					//[Block]
					if (CanUseItem(false, false, true)) {
						Msg = "You swallowed the pill."
						MsgTimer = 70*7
						
						if (I_427.Timer < 70*360) {
							I_427.Timer = 70*360
						}
						
						RemoveItem(SelectedItem)
						SelectedItem = Null
					}
					
				default:
					//[Block]
					//check if the item is an inventory-type object
					if (SelectedItem.invSlots>0) {
						DoubleClick = 0
						MouseHit1 = 0
						MouseDown1 = 0
						LastMouseHit1 = 0
						OtherOpen = SelectedItem
						SelectedItem = Null
					}
					
					
			}
			
			if (SelectedItem != Null) {
				if (SelectedItem.itemtemplate.img != 0) {
					let IN: string = SelectedItem.itemtemplate.tempname
					if (IN == "paper" || IN == "badge" || IN == "oldpaper" || IN == "ticket") {
						for (a_it of Items.each) {
							if (a_it != SelectedItem) {
								let IN2: string = a_it.itemtemplate.tempname
								if (IN2 == "paper" || IN2 == "badge" || IN2 == "oldpaper" || IN2 == "ticket") {
									if (a_it.itemtemplate.img!=0) {
										if (a_it.itemtemplate.img != SelectedItem.itemtemplate.img) {
											FreeImage(a_it.itemtemplate.img)
											a_it.itemtemplate.img = 0
										}
									}
								}
							}
						}
					}
				}			
			}
			
			if (MouseHit2) {
				EntityAlpha (Dark, 0.0)
				
				IN = SelectedItem.itemtemplate.tempname
				if (IN == "scp1025") {
					if (SelectedItem.itemtemplate.img!=0) {
						FreeImage(SelectedItem.itemtemplate.img)
					}
					SelectedItem.itemtemplate.img=0
				} else if (IN == "firstaid" || IN == "finefirstaid" || IN == "firstaid2") {
					SelectedItem.state = 0
				} else if (IN == "vest" || IN == "finevest") {
					SelectedItem.state = 0
					if (!WearingVest) {
						DropItem(SelectedItem,false)
					}
				} else if (IN == "hazmatsuit" || IN == "hazmatsuit2" || IN == "hazmatsuit3") {
					SelectedItem.state = 0
					if (!WearingHazmat) {
						DropItem(SelectedItem,false)
					}
				} else if (IN == "scp1499" || IN == "super1499") {
					SelectedItem.state = 0
				}
				
				if (SelectedItem.itemtemplate.sound != 66) {
					PlaySound_Strict(PickSFX(SelectedItem.itemtemplate.sound))
				}
				SelectedItem = Null
			}
		}		
	}
	
	if (SelectedItem = Null) {
		for (i of range(7)) {
			if (RadioCHN(i) != 0) {
				if (ChannelPlaying(RadioCHN(i))) {
					PauseChannel(RadioCHN(i))
				}
			}
		}
	}
	
	for (it of Items.each) {
		if (it!=SelectedItem) {
			switch (it.itemtemplate.tempname) {
				case "firstaid","finefirstaid","firstaid2","vest","finevest","hazmatsuit","hazmatsuit2","hazmatsuit3","scp1499","super1499":
					it.state = 0
			}
		}
	}
	
	if (PrevInvOpen && (!InvOpen)) {
		MoveMouse(viewport_center_x, viewport_center_y)
	}
	
	CatchErrors("DrawGUI")
}

function DrawMenu() {
	CatchErrors("Uncaught (DrawMenu)")
	
	let x: int
	let y: int
	let width: int
	let height: int

	if (api_GetFocus() = 0) { //Game is out of focus -> pause the game
		if (!Using294) {
			MenuOpen = true
			PauseSounds()
		}
        Delay (1000) //Reduce the CPU take while game is not in focus
    }
	if (MenuOpen) {
				
		if (PlayerRoom.RoomTemplate.Name$ != "exit1" && PlayerRoom.RoomTemplate.Name$ != "gatea") {
			if (StopHidingTimer = 0) {
				if (EntityDistance(Curr173.Collider, Collider)<4.0 || EntityDistance(Curr106.Collider, Collider)<4.0) {
					StopHidingTimer = 1
				}	
			} else if (StopHidingTimer < 40) {
				if (KillTimer >= 0) {
					StopHidingTimer = StopHidingTimer+FPSfactor
					
					if (StopHidingTimer => 40) {
						PlaySound_Strict(HorrorSFX(15))
						Msg = "STOP HIDING"
						MsgTimer = 6*70
						MenuOpen = false
						return
					}
				}
			}
		}
		
		InvOpen = false
		
		width = ImageWidth(PauseMenuIMG)
		height = ImageHeight(PauseMenuIMG)
		x = GraphicWidth / 2 - width / 2
		y = GraphicHeight / 2 - height / 2
		
		DrawImage (PauseMenuIMG, x, y)
		
		Color(255, 255, 255)
		
		x = x+132*MenuScale
		y = y+122*MenuScale	
		
		if (!MouseDown1) {
			OnSliderID = 0
		}
		
		if (AchievementsMenu > 0) {
			AASetFont(Font2)
			AAText(x, y-(122-45)*MenuScale, "ACHIEVEMENTS",false,true)
			AASetFont(Font1)
		} else if (OptionsMenu > 0) {
			AASetFont(Font2)
			AAText(x, y-(122-45)*MenuScale, "OPTIONS",false,true)
			AASetFont(Font1)
		} else if (QuitMSG > 0) {
			AASetFont(Font2)
			AAText(x, y-(122-45)*MenuScale, "QUIT?",false,true)
			AASetFont(Font1)
		} else if (KillTimer >= 0) {
			AASetFont(Font2)
			AAText(x, y-(122-45)*MenuScale, "PAUSED",false,true)
			AASetFont(Font1)
		} else {
			AASetFont(Font2)
			AAText(x, y-(122-45)*MenuScale, "YOU DIED",false,true)
			AASetFont(Font1)
		}	
		
		let AchvXIMG: int = (x + (22*MenuScale))
		let scale: float = GraphicHeight/768.0
		let SeparationConst: int = 76*scale
		let imgsize: int = 64
		
		if (AchievementsMenu <= 0 && OptionsMenu <= 0 && QuitMSG <= 0) {
			AASetFont (Font1)
			AAText(x, y, "Difficulty: "+SelectedDifficulty.name)
			AAText(x, y+20*MenuScale, "Save: "+CurrSave)
			AAText(x, y+40*MenuScale, "Map seed: "+RandomSeed)
		} else if (AchievementsMenu <= 0 && OptionsMenu > 0 && QuitMSG <= 0 && KillTimer >= 0) {
			if (DrawButton(x + 101 * MenuScale, y + 390 * MenuScale, 230 * MenuScale, 60 * MenuScale, "Back")) {
				AchievementsMenu = 0
				OptionsMenu = 0
				QuitMSG = 0
				MouseHit1 = false
				SaveOptionsINI()
				
				AntiAlias (Opt_AntiAlias)
				TextureLodBias (TextureFloat)
			}
			
			Color (0,255,0)
			if (OptionsMenu = 1) {
				Rect(x-10*MenuScale,y-5*MenuScale,110*MenuScale,40*MenuScale,true)
			} else if (OptionsMenu = 2) {
				Rect(x+100*MenuScale,y-5*MenuScale,110*MenuScale,40*MenuScale,true)
			} else if (OptionsMenu = 3) {
				Rect(x+210*MenuScale,y-5*MenuScale,110*MenuScale,40*MenuScale,true)
			} else if (OptionsMenu = 4) {
				Rect(x+320*MenuScale,y-5*MenuScale,110*MenuScale,40*MenuScale,true)
			}
			
			if (DrawButton(x-5*MenuScale,y,100*MenuScale,30*MenuScale,"GRAPHICS",false)) {OptionsMenu = 1}
			if (DrawButton(x+105*MenuScale,y,100*MenuScale,30*MenuScale,"AUDIO",false)) {OptionsMenu = 2}
			if (DrawButton(x+215*MenuScale,y,100*MenuScale,30*MenuScale,"CONTROLS",false)) {OptionsMenu = 3}
			if (DrawButton(x+325*MenuScale,y,100*MenuScale,30*MenuScale,"ADVANCED",false)) {OptionsMenu = 4}
			
			let tx: float = (GraphicWidth/2)+(width/2)
			let ty: float = y
			let tw: float = 400*MenuScale
			let th: float = 150*MenuScale
			
			Color (255,255,255)
			switch (OptionsMenu) {
				case 1: //Graphics
					AASetFont (Font1)
					//[Block]
					y=y+50*MenuScale
					
					Color (100,100,100)
					AAText(x, y, "Enable bump mapping:")	
					BumpEnabled = DrawTick(x + 270 * MenuScale, y + MenuScale, BumpEnabled, true)
					if (MouseOn(x + 270 * MenuScale, y + MenuScale, 20*MenuScale,20*MenuScale) && OnSliderID == 0) {
						DrawOptionsTooltip(tx,ty,tw,th,"bump")
					}
					
					y=y+30*MenuScale
					
					Color (255,255,255)
					AAText(x, y, "VSync:")
					Vsync = DrawTick(x + 270 * MenuScale, y + MenuScale, Vsync)
					if (MouseOn(x+270*MenuScale,y+MenuScale,20*MenuScale,20*MenuScale) && OnSliderID == 0) {
						DrawOptionsTooltip(tx,ty,tw,th,"vsync")
					}
					
					y=y+30*MenuScale
					
					Color (255,255,255)
					AAText(x, y, "Anti-aliasing:")
					Opt_AntiAlias = DrawTick(x + 270 * MenuScale, y + MenuScale, Opt_AntiAlias)
					if (MouseOn(x+270*MenuScale,y+MenuScale,20*MenuScale,20*MenuScale) && OnSliderID == 0) {
						DrawOptionsTooltip(tx,ty,tw,th,"antialias")
					}
					
					y=y+30*MenuScale
					
					Color (255,255,255)
					AAText(x, y, "Enable room lights:")
					EnableRoomLights = DrawTick(x + 270 * MenuScale, y + MenuScale, EnableRoomLights)
					if (MouseOn(x+270*MenuScale,y+MenuScale,20*MenuScale,20*MenuScale) && OnSliderID == 0) {
						DrawOptionsTooltip(tx,ty,tw,th,"roomlights")
					}
					
					y=y+30*MenuScale
					
					ScreenGamma = (SlideBar(x + 270*MenuScale, y+6*MenuScale, 100*MenuScale, ScreenGamma*50.0)/50.0)
					Color (255,255,255)
					AAText(x, y, "Screen gamma")
					if (MouseOn(x+270*MenuScale,y+6*MenuScale,100*MenuScale+14,20) && OnSliderID == 0) {
						DrawOptionsTooltip(tx,ty,tw,th,"gamma",ScreenGamma)
					}
					
					//y = y + 50*MenuScale
					
					y=y+50*MenuScale
					
					Color(255,255,255)
					AAText(x, y, "Particle amount:")
					ParticleAmount = Slider3(x+270*MenuScale,y+6*MenuScale,100*MenuScale,ParticleAmount,2,"MINIMAL","REDUCED","FULL")
					if ((MouseOn(x + 270 * MenuScale, y-6*MenuScale, 100*MenuScale+14, 20) && OnSliderID == 0) || OnSliderID == 2) {
						DrawOptionsTooltip(tx,ty,tw,th,"particleamount",ParticleAmount)
					}
					
					y=y+50*MenuScale
					
					Color(255,255,255)
					AAText(x, y, "Texture LOD Bias:")
					TextureDetails = Slider5(x+270*MenuScale,y+6*MenuScale,100*MenuScale,TextureDetails,3,"0.8","0.4","0.0","-0.4","-0.8")
					switch (TextureDetails) {
						case 0:
							TextureFloat = 0.8
						case 1:
							TextureFloat = 0.4
						case 2:
							TextureFloat = 0.0
						case 3:
							TextureFloat = -0.4
						case 4:
							TextureFloat = -0.8
					}
					TextureLodBias (TextureFloat)
					if ((MouseOn(x+270*MenuScale,y-6*MenuScale,100*MenuScale+14,20) && OnSliderID == 0) || OnSliderID == 3) {
						DrawOptionsTooltip(tx,ty,tw,th+100*MenuScale,"texquality")
					}
					
					y=y+50*MenuScale
					Color(100,100,100)
					AAText(x, y, "Save textures in the VRAM:")	
					EnableVRam = DrawTick(x + 270 * MenuScale, y + MenuScale, EnableVRam, true)
					if (MouseOn(x + 270 * MenuScale, y + MenuScale, 20*MenuScale,20*MenuScale) && OnSliderID == 0) {
						DrawOptionsTooltip(tx,ty,tw,th,"vram")
					}
					
					
				case 2: //Audio
					AASetFont (Font1)
					//[Block]
					y = y + 50*MenuScale
					
					MusicVolume = (SlideBar(x + 250*MenuScale, y-4*MenuScale, 100*MenuScale, MusicVolume*100.0)/100.0)
					Color (255,255,255)
					AAText(x, y, "Music volume:")
					if (MouseOn(x+250*MenuScale,y-4*MenuScale,100*MenuScale+14,20)) {
						DrawOptionsTooltip(tx,ty,tw,th,"musicvol",MusicVolume)
					}
					
					y = y + 30*MenuScale
					
					PrevSFXVolume = (SlideBar(x + 250*MenuScale, y-4*MenuScale, 100*MenuScale, SFXVolume*100.0)/100.0)
					if (!DeafPlayer) {
						SFXVolume = PrevSFXVolume
					}
					Color(255,255,255)
					AAText(x, y, "Sound volume:")
					if (MouseOn(x+250*MenuScale,y-4*MenuScale,100*MenuScale+14,20)) {
						DrawOptionsTooltip(tx,ty,tw,th,"soundvol",PrevSFXVolume)
					}
					
					y = y + 30*MenuScale
					
					Color (100,100,100)
					AAText (x, y, "Sound auto-release:")
					EnableSFXRelease = DrawTick(x + 270 * MenuScale, y + MenuScale, EnableSFXRelease,true)
					if (MouseOn(x+270*MenuScale,y+MenuScale,20*MenuScale,20*MenuScale)) {
						DrawOptionsTooltip(tx,ty,tw,th+220*MenuScale,"sfxautorelease")
					}
					
					y = y + 30*MenuScale
					
					Color (100,100,100)
					AAText (x, y, "Enable user tracks:")
					EnableUserTracks = DrawTick(x + 270 * MenuScale, y + MenuScale, EnableUserTracks,true)
					if (MouseOn(x+270*MenuScale,y+MenuScale,20*MenuScale,20*MenuScale)) {
						DrawOptionsTooltip(tx,ty,tw,th,"usertrack")
					}
					
					if (EnableUserTracks) {
						y = y + 30 * MenuScale
						Color (255,255,255)
						AAText (x, y, "User track mode:")
						UserTrackMode = DrawTick(x + 270 * MenuScale, y + MenuScale, UserTrackMode)
						if (UserTrackMode) {
							AAText(x, y + 20 * MenuScale, "Repeat")
						} else {
							AAText(x, y + 20 * MenuScale, "Random")
						}
						if (MouseOn(x+270*MenuScale,y+MenuScale,20*MenuScale,20*MenuScale)) {
							DrawOptionsTooltip(tx,ty,tw,th,"usertrackmode")
						}
					}
					
				case 3: //Controls:
					AASetFont (Font1)
					//[Block]
					y = y + 50*MenuScale
					
					MouseSens = (SlideBar(x + 270*MenuScale, y-4*MenuScale, 100*MenuScale, (MouseSens+0.5)*100.0)/100.0)-0.5
					Color(255, 255, 255)
					AAText(x, y, "Mouse sensitivity:")
					if (MouseOn(x+270*MenuScale,y-4*MenuScale,100*MenuScale+14,20)) {
						DrawOptionsTooltip(tx,ty,tw,th,"mousesensitivity",MouseSens)
					}
					
					y = y + 30*MenuScale
					
					Color(255, 255, 255)
					AAText(x, y, "Invert mouse Y-axis:")
					InvertMouse = DrawTick(x + 270 * MenuScale, y + MenuScale, InvertMouse)
					if (MouseOn(x+270*MenuScale,y+MenuScale,20*MenuScale,20*MenuScale)) {
						DrawOptionsTooltip(tx,ty,tw,th,"mouseinvert")
					}
					
					y = y + 40*MenuScale
					
					MouseSmooth = (SlideBar(x + 270*MenuScale, y-4*MenuScale, 100*MenuScale, (MouseSmooth)*50.0)/50.0)
					Color(255, 255, 255)
					AAText(x, y, "Mouse smoothing:")
					if (MouseOn(x+270*MenuScale,y-4*MenuScale,100*MenuScale+14,20)) {
						DrawOptionsTooltip(tx,ty,tw,th,"mousesmoothing",MouseSmooth)
					}
					
					Color(255, 255, 255)
					
					y = y + 30*MenuScale
					AAText(x, y, "Control configuration:")
					y = y + 10*MenuScale
					
					AAText(x, y + 20 * MenuScale, "Move Forward")
					InputBox(x + 200 * MenuScale, y + 20 * MenuScale,100*MenuScale,20*MenuScale,KeyName(Min(KEY_UP,210)),5)		
					AAText(x, y + 40 * MenuScale, "Strafe Left")
					InputBox(x + 200 * MenuScale, y + 40 * MenuScale,100*MenuScale,20*MenuScale,KeyName(Min(KEY_LEFT,210)),3)	
					AAText(x, y + 60 * MenuScale, "Move Backward")
					InputBox(x + 200 * MenuScale, y + 60 * MenuScale,100*MenuScale,20*MenuScale,KeyName(Min(KEY_DOWN,210)),6)				
					AAText(x, y + 80 * MenuScale, "Strafe Right")
					InputBox(x + 200 * MenuScale, y + 80 * MenuScale,100*MenuScale,20*MenuScale,KeyName(Min(KEY_RIGHT,210)),4)
					
					AAText(x, y + 100 * MenuScale, "Manual Blink")
					InputBox(x + 200 * MenuScale, y + 100 * MenuScale,100*MenuScale,20*MenuScale,KeyName(Min(KEY_BLINK,210)),7)				
					AAText(x, y + 120 * MenuScale, "Sprint")
					InputBox(x + 200 * MenuScale, y + 120 * MenuScale,100*MenuScale,20*MenuScale,KeyName(Min(KEY_SPRINT,210)),8)
					AAText(x, y + 140 * MenuScale, "Open/Close Inventory")
					InputBox(x + 200 * MenuScale, y + 140 * MenuScale,100*MenuScale,20*MenuScale,KeyName(Min(KEY_INV,210)),9)
					AAText(x, y + 160 * MenuScale, "Crouch")
					InputBox(x + 200 * MenuScale, y + 160 * MenuScale,100*MenuScale,20*MenuScale,KeyName(Min(KEY_CROUCH,210)),10)
					AAText(x, y + 180 * MenuScale, "Quick Save")
					InputBox(x + 200 * MenuScale, y + 180 * MenuScale,100*MenuScale,20*MenuScale,KeyName(Min(KEY_SAVE,210)),11)	
					AAText(x, y + 200 * MenuScale, "Open/Close Console")
					InputBox(x + 200 * MenuScale, y + 200 * MenuScale,100*MenuScale,20*MenuScale,KeyName(Min(KEY_CONSOLE,210)),12)
					
					if (MouseOn(x,y,300*MenuScale,220*MenuScale)) {
						DrawOptionsTooltip(tx,ty,tw,th,"controls")
					}
					
					for (i of range(228)) {
						if (KeyHit(i)) {
							key = i
							break
						}
					}
					if (key != 0) {
						switch (SelectedInputBox) {
							case 3:
								KEY_LEFT = key
							case 4:
								KEY_RIGHT = key
							case 5:
								KEY_UP = key
							case 6:
								KEY_DOWN = key
							case 7:
								KEY_BLINK = key
							case 8:
								KEY_SPRINT = key
							case 9:
								KEY_INV = key
							case 10:
								KEY_CROUCH = key
							case 11:
								KEY_SAVE = key
							case 12:
								KEY_CONSOLE = key
						}
						SelectedInputBox = 0
					}
					
				case 4: //Advanced:
					AASetFont (Font1)
					//[Block]
					y = y + 50*MenuScale
					
					Color (255,255,255)
					AAText(x, y, "Show HUD:")	
					HUDenabled = DrawTick(x + 270 * MenuScale, y + MenuScale, HUDenabled)
					if (MouseOn(x+270*MenuScale,y+MenuScale,20*MenuScale,20*MenuScale)) {
						DrawOptionsTooltip(tx,ty,tw,th,"hud")
					}
					
					y = y + 30*MenuScale
					
					Color (255,255,255)
					AAText(x, y, "Enable console:")
					CanOpenConsole = DrawTick(x +270 * MenuScale, y + MenuScale, CanOpenConsole)
					if (MouseOn(x+270*MenuScale,y+MenuScale,20*MenuScale,20*MenuScale)) {
						DrawOptionsTooltip(tx,ty,tw,th,"consoleenable")
					}
					
					y = y + 30*MenuScale
					
					Color(255,255,255)
					AAText(x, y, "Open console on error:")
					ConsoleOpening = DrawTick(x + 270 * MenuScale, y + MenuScale, ConsoleOpening)
					if (MouseOn(x+270*MenuScale,y+MenuScale,20*MenuScale,20*MenuScale)) {
						DrawOptionsTooltip(tx,ty,tw,th,"consoleerror")
					}
					
					y = y + 50*MenuScale
					
					Color(255,255,255)
					AAText(x, y, "Achievement popups:")
					AchvMSGenabled = DrawTick(x + 270 * MenuScale, y, AchvMSGenabled)
					if (MouseOn(x+270*MenuScale,y+MenuScale,20*MenuScale,20*MenuScale)) {
						DrawOptionsTooltip(tx,ty,tw,th,"achpopup")
					}
					
					y = y + 50*MenuScale
					
					Color(255,255,255)
					AAText(x, y, "Show FPS:")
					ShowFPS = DrawTick(x + 270 * MenuScale, y, ShowFPS)
					if (MouseOn(x+270*MenuScale,y+MenuScale,20*MenuScale,20*MenuScale)) {
						DrawOptionsTooltip(tx,ty,tw,th,"showfps")
					}
					
					y = y + 30*MenuScale
					
					Color(255,255,255)
					AAText(x, y, "Framelimit:")
					
					Color(255,255,255)
					if (DrawTick(x + 270 * MenuScale, y, CurrFrameLimit > 0.0)) {
						CurrFrameLimit = (SlideBar(x + 150*MenuScale, y+30*MenuScale, 100*MenuScale, CurrFrameLimit*99.0)/99.0)
						CurrFrameLimit = Max(CurrFrameLimit, 0.01)
						Framelimit = 19+(CurrFrameLimit*100.0)
						Color (255,255,0)
						AAText(x + 5 * MenuScale, y + 25 * MenuScale, Framelimit%+" FPS")
					} else {
						CurrFrameLimit = 0.0
						Framelimit = 0
					}
					if (MouseOn(x+270*MenuScale,y+MenuScale,20*MenuScale,20*MenuScale)) {
						DrawOptionsTooltip(tx,ty,tw,th,"framelimit",Framelimit)
					}
					if (MouseOn(x+150*MenuScale,y+30*MenuScale,100*MenuScale+14,20)) {
						DrawOptionsTooltip(tx,ty,tw,th,"framelimit",Framelimit)
					}
					
					y = y + 80*MenuScale
					
					Color (255,255,255)
					AAText(x, y, "Antialiased text:")
					AATextEnable = DrawTick(x + 270 * MenuScale, y + MenuScale, AATextEnable)
					if (AATextEnable_Prev != AATextEnable) {
						for (font of AAFont.each) {
							FreeFont (font.lowResFont)
							if (!AATextEnable) {
								FreeTexture (font.texture)
								FreeImage (font.backup)
							}
							Delete (font)
						}
						if (!AATextEnable) {
							FreeEntity (AATextCam)
						}
						InitAAFont()
						Font1 = AALoadFont("GFX/font/cour/Courier New.ttf", Int(18 * (GraphicHeight / 1024.0)), 0,0,0)
						Font2 = AALoadFont("GFX/font/courbd/Courier New.ttf", Int(58 * (GraphicHeight / 1024.0)), 0,0,0)
						Font3 = AALoadFont("GFX/font/DS-DIGI/DS-Digital.ttf", Int(22 * (GraphicHeight / 1024.0)), 0,0,0)
						Font4 = AALoadFont("GFX/font/DS-DIGI/DS-Digital.ttf", Int(60 * (GraphicHeight / 1024.0)), 0,0,0)
						Font5 = AALoadFont("GFX/font/Journal/Journal.ttf", Int(58 * (GraphicHeight / 1024.0)), 0,0,0)
						ConsoleFont = AALoadFont("Blitz", Int(22 * (GraphicHeight / 1024.0)), 0,0,0,1)
						AATextEnable_Prev = AATextEnable
					}
					if (MouseOn(x+270*MenuScale,y+MenuScale,20*MenuScale,20*MenuScale)) {
						DrawOptionsTooltip(tx,ty,tw,th,"antialiastext")
					}
					
			}
		} else if (AchievementsMenu <= 0 && OptionsMenu <= 0 && QuitMSG > 0 && KillTimer >= 0) {
			let QuitButton: int = 60 
			if (SelectedDifficulty.saveType == SAVEONQUIT || SelectedDifficulty.saveType == SAVEANYWHERE) {
				let RN: string = PlayerRoom.RoomTemplate.Name$
				let AbleToSave: boolean = true
				if (RN == "173" || RN == "exit1" || RN == "gatea") {AbleToSave = false}
				if (!CanSave) {AbleToSave = false}
				if (AbleToSave) {
					QuitButton = 140
					if (DrawButton(x, y + 60*MenuScale, 390*MenuScale, 60*MenuScale, "Save & Quit")) {
						DropSpeed = 0
						SaveGame(SavePath + CurrSave + "/")
						NullGame()
						MenuOpen = false
						MainMenuOpen = true
						MainMenuTab = 0
						CurrSave = ""
						FlushKeys()
					}
				}
			}
			
			if (DrawButton(x, y + QuitButton*MenuScale, 390*MenuScale, 60*MenuScale, "Quit")) {
				NullGame()
				MenuOpen = false
				MainMenuOpen = true
				MainMenuTab = 0
				CurrSave = ""
				FlushKeys()
			}
			
			if (DrawButton(x+101*MenuScale, y + 344*MenuScale, 230*MenuScale, 60*MenuScale, "Back")) {
				AchievementsMenu = 0
				OptionsMenu = 0
				QuitMSG = 0
				MouseHit1 = false
			}
		} else {
			if (DrawButton(x+101*MenuScale, y + 344*MenuScale, 230*MenuScale, 60*MenuScale, "Back")) {
				AchievementsMenu = 0
				OptionsMenu = 0
				QuitMSG = 0
				MouseHit1 = false
			}
			
			if (AchievementsMenu>0) {
				if (AchievementsMenu <= Floor(Float(MAXACHIEVEMENTS-1)/12.0)) { 
					if (DrawButton(x+341*MenuScale, y + 344*MenuScale, 50*MenuScale, 60*MenuScale, ">")) {
						AchievementsMenu = AchievementsMenu+1
					}
				}
				if (AchievementsMenu > 1) {
					if (DrawButton(x+41*MenuScale, y + 344*MenuScale, 50*MenuScale, 60*MenuScale, "<")) {
						AchievementsMenu = AchievementsMenu-1
					}
				}
				
				for (i of range(12)) {
					if (i+((AchievementsMenu-1)*12)<MAXACHIEVEMENTS) {
						DrawAchvIMG(AchvXIMG,y+((i/4)*120*MenuScale),i+((AchievementsMenu-1)*12))
					} else {
						break
					}
				}
				
				for (i of range(12)) {
					if (i+((AchievementsMenu-1)*12)<MAXACHIEVEMENTS) {
						if (MouseOn(AchvXIMG+((i % 4)*SeparationConst),y+((i/4)*120*MenuScale),64*scale,64*scale)) {
							AchievementTooltip(i+((AchievementsMenu-1)*12))
							break
						}
					} else {
						break
					}
				}
				
			}
		}
		
		y = y+10
		
		if (AchievementsMenu<=0 && OptionsMenu<=0 && QuitMSG<=0) {
			if (KillTimer >= 0) {	
				
				y = y+ 72*MenuScale
				
				if (DrawButton(x, y, 390*MenuScale, 60*MenuScale, "Resume", true, true)) {
					MenuOpen = false
					ResumeSounds()
					MouseXSpeed()
					MouseYSpeed()
					MouseZSpeed()
					mouse_x_speed_1=0.0
					mouse_y_speed_1=0.0
				}
				
				y = y + 75*MenuScale
				if (!SelectedDifficulty.permaDeath) {
					if (GameSaved) {
						if (DrawButton(x, y, 390*MenuScale, 60*MenuScale, "Load Game")) {
							DrawLoading(0)
							
							MenuOpen = false
							LoadGameQuick(SavePath + CurrSave + "/")
							
							MoveMouse (viewport_center_x,viewport_center_y)
							AASetFont (Font1)
							HidePointer ()
							
							FlushKeys()
							FlushMouse()
							Playable=true
							
							UpdateRooms()
							
							for (r of Rooms.each) {
								x = Abs(EntityX(Collider) - EntityX(r.obj))
								z = Abs(EntityZ(Collider) - EntityZ(r.obj))
								
								if (x < 12.0 && z < 12.0) {
									MapFound(Floor(EntityX(r.obj) / 8.0), Floor(EntityZ(r.obj) / 8.0)) = Max(MapFound(Floor(EntityX(r.obj) / 8.0), Floor(EntityZ(r.obj) / 8.0)), 1)
									if (x < 4.0 && z < 4.0) {
										if (Abs(EntityY(Collider) - EntityY(r.obj)) < 1.5) {PlayerRoom = r}
										MapFound(Floor(EntityX(r.obj) / 8.0), Floor(EntityZ(r.obj) / 8.0)) = 1
									}
								}
							}
							
							DrawLoading(100)
							
							DropSpeed=0
							
							UpdateWorld (0.0)
							
							PrevTime = MilliSecs()
							FPSfactor = 0
							
							ResetInput()
						}
					} else {
						DrawFrame(x,y,390*MenuScale, 60*MenuScale)
						Color (100, 100, 100)
						AASetFont (Font2)
						AAText(x + (390*MenuScale) / 2, y + (60*MenuScale) / 2, "Load Game", true, true)
					}
					y = y + 75*MenuScale
				}
				
				if (DrawButton(x, y, 390*MenuScale, 60*MenuScale, "Achievements")) {AchievementsMenu = 1}
				y = y + 75*MenuScale
				if (DrawButton(x, y, 390*MenuScale, 60*MenuScale, "Options")) {OptionsMenu = 1}
				y = y + 75*MenuScale
			} else {
				y = y+104*MenuScale
				if (GameSaved && (!SelectedDifficulty.permaDeath)) {
					if (DrawButton(x, y, 390*MenuScale, 60*MenuScale, "Load Game")) {
						DrawLoading(0)
						
						MenuOpen = false
						LoadGameQuick(SavePath + CurrSave + "/")
						
						MoveMouse (viewport_center_x,viewport_center_y)
						AASetFont (Font1)
						HidePointer ()
						
						FlushKeys()
						FlushMouse()
						Playable=true
						
						UpdateRooms()
						
						for (r of Rooms.each) {
							x = Abs(EntityX(Collider) - EntityX(r.obj))
							z = Abs(EntityZ(Collider) - EntityZ(r.obj))
							
							if (x < 12.0 && z < 12.0) {
								MapFound(Floor(EntityX(r.obj) / 8.0), Floor(EntityZ(r.obj) / 8.0)) = Max(MapFound(Floor(EntityX(r.obj) / 8.0), Floor(EntityZ(r.obj) / 8.0)), 1)
								if (x < 4.0 && z < 4.0) {
									if (Abs(EntityY(Collider) - EntityY(r.obj)) < 1.5) {PlayerRoom = r}
									MapFound(Floor(EntityX(r.obj) / 8.0), Floor(EntityZ(r.obj) / 8.0)) = 1
								}
							}
						}
						
						DrawLoading(100)
						
						DropSpeed=0
						
						UpdateWorld (0.0)
						
						PrevTime = MilliSecs()
						FPSfactor = 0
						
						ResetInput()
					}
				} else {
					DrawButton(x, y, 390*MenuScale, 60*MenuScale, "")
					Color (50,50,50)
					AAText(x + 185*MenuScale, y + 30*MenuScale, "Load Game", true, true)
				}
				if (DrawButton(x, y + 80*MenuScale, 390*MenuScale, 60*MenuScale, "Quit to Menu")) {
					NullGame()
					MenuOpen = false
					MainMenuOpen = true
					MainMenuTab = 0
					CurrSave = ""
					FlushKeys()
				}
				y= y + 80*MenuScale
			}
			
			if (KillTimer >= 0 && (!MainMenuOpen)) {
				if (DrawButton(x, y, 390*MenuScale, 60*MenuScale, "Quit")) {
					QuitMSG = 1
				}
			}
			
			AASetFont (Font1)
			if (KillTimer < 0) {RowText(DeathMSG$, x, y + 80*MenuScale, 390*MenuScale, 600*MenuScale)}
		}
		
		if (Fullscreen) {DrawImage (CursorIMG, ScaledMouseX(),ScaledMouseY())}
		
	}
	
	AASetFont (Font1)
	
	CatchErrors("DrawMenu")
}

function MouseOn(x: int, y: int, width: int, height: int): int {
	if (ScaledMouseX() > x & ScaledMouseX() < x + width) {
		if (ScaledMouseY() > y & ScaledMouseY() < y + height) {
			return true
		}
	}
	return false
}

//----------------------------------------------------------------------------------------------

enum Containment {
	LIGHT,
	HEAVY,
	ENTRANCE,
	GENERAL,
	PRE_BREACH,
	FOREST
}

export function LoadAllSounds() {
	for (let i of range(3)) {
		OpenDoorSFX[0][i] = LoadSound_Strict("SFX/Door/DoorOpen" + (i + 1) + ".ogg")
		CloseDoorSFX[0][i] = LoadSound_Strict("SFX/Door/DoorClose" + (i + 1) + ".ogg")
		OpenDoorSFX[2][i] = LoadSound_Strict("SFX/Door/Door2Open" + (i + 1) + ".ogg")
		CloseDoorSFX[2][i] = LoadSound_Strict("SFX/Door/Door2Close" + (i + 1) + ".ogg")
		OpenDoorSFX[3][i] = LoadSound_Strict("SFX/Door/ElevatorOpen" + (i + 1) + ".ogg")
		CloseDoorSFX[3][i] = LoadSound_Strict("SFX/Door/ElevatorClose" + (i + 1) + ".ogg")
	}
	for (let i of range(2)) {
		OpenDoorSFX[1][i] = LoadSound_Strict("SFX/Door/BigDoorOpen" + (i + 1) + ".ogg")
		CloseDoorSFX[1][i] = LoadSound_Strict("SFX/Door/BigDoorClose" + (i + 1) + ".ogg")
	}

	KeyCardSFX1 = LoadSound_Strict("SFX/Interact/KeyCardUse1.ogg")
	KeyCardSFX2 = LoadSound_Strict("SFX/Interact/KeyCardUse2.ogg")
	ButtonSFX2 = LoadSound_Strict("SFX/Interact/Button2.ogg")
	ScannerSFX1 = LoadSound_Strict("SFX/Interact/ScannerUse1.ogg")
	ScannerSFX2 = LoadSound_Strict("SFX/Interact/ScannerUse2.ogg")

	OpenDoorFastSFX=LoadSound_Strict("SFX/Door/DoorOpenFast.ogg")
	CautionSFX = LoadSound_Strict("SFX/Room/LockroomSiren.ogg")

	CameraSFX = LoadSound_Strict("SFX/General/Camera.ogg") 

	StoneDragSFX = LoadSound_Strict("SFX/SCP/173/StoneDrag.ogg")

	GunshotSFX = LoadSound_Strict("SFX/General/Gunshot.ogg")
	Gunshot2SFX = LoadSound_Strict("SFX/General/Gunshot2.ogg")
	Gunshot3SFX = LoadSound_Strict("SFX/General/BulletMiss.ogg")
	BullethitSFX = LoadSound_Strict("SFX/General/BulletHit.ogg")

	TeslaIdleSFX = LoadSound_Strict("SFX/Room/Tesla/Idle.ogg")
	TeslaActivateSFX = LoadSound_Strict("SFX/Room/Tesla/WindUp.ogg")
	TeslaPowerUpSFX = LoadSound_Strict("SFX/Room/Tesla/PowerUp.ogg")

	MagnetUpSFX = LoadSound_Strict("SFX/Room/106Chamber/MagnetUp.ogg") 
	MagnetDownSFX = LoadSound_Strict("SFX/Room/106Chamber/MagnetDown.ogg")
	for (let i of range(4)) {
		DecaySFX(i) = LoadSound_Strict("SFX/SCP/106/Decay" + i + ".ogg")
	}

	BurstSFX = LoadSound_Strict("SFX/Room/TunnelBurst.ogg")

	
	For i = 0 To 2
		RustleSFX(i) = LoadSound_Strict("SFX/SCP/372/Rustle" + i + ".ogg")
	Next

	Death914SFX = LoadSound_Strict("SFX/SCP/914/PlayerDeath.ogg") 
	Use914SFX = LoadSound_Strict("SFX/SCP/914/PlayerUse.ogg")

	For i = 0 To 3
		DripSFX(i) = LoadSound_Strict("SFX/Character/D9341/BloodDrip" + i + ".ogg")
	Next

	LeverSFX = LoadSound_Strict("SFX/Interact/LeverFlip.ogg") 
	LightSFX = LoadSound_Strict("SFX/General/LightSwitch.ogg")

	ButtGhostSFX = LoadSound_Strict("SFX/SCP/Joke/789J.ogg")

	RadioSFX(1,0) = LoadSound_Strict("SFX/Radio/RadioAlarm.ogg")
	RadioSFX(1,1) = LoadSound_Strict("SFX/Radio/RadioAlarm2.ogg")
	for (let i of range(9)) {
		RadioSFX(2,i) = LoadSound_Strict("SFX/Radio/scpradio"+i+".ogg")
	}
	RadioSquelch = LoadSound_Strict("SFX/Radio/squelch.ogg")
	RadioStatic = LoadSound_Strict("SFX/Radio/static.ogg")
	RadioBuzz = LoadSound_Strict("SFX/Radio/buzz.ogg")

	ElevatorBeepSFX = LoadSound_Strict("SFX/General/Elevator/Beep.ogg") 
	ElevatorMoveSFX = LoadSound_Strict("SFX/General/Elevator/Moving.ogg") 

	//Dim PickSFX%(10)
	For i = 0 To 3
		PickSFX(i) = LoadSound_Strict("SFX/Interact/PickItem" + i + ".ogg")
	Next

	AmbientSFXAmount[Containment.LIGHT] = 11
	AmbientSFXAmount[Containment.HEAVY] = 11
	AmbientSFXAmount[Containment.ENTRANCE] = 12
	AmbientSFXAmount[Containment.GENERAL] = 15
	AmbientSFXAmount[Containment.PRE_BREACH] = 5
	AmbientSFXAmount[Containment.FOREST] = 10

	For i = 0 To 2
		OldManSFX(i) = LoadSound_Strict("SFX/SCP/106/Corrosion" + (i + 1) + ".ogg")
	Next
	OldManSFX(3) = LoadSound_Strict("SFX/SCP/106/Laugh.ogg")
	OldManSFX(4) = LoadSound_Strict("SFX/SCP/106/Breathing.ogg")
	OldManSFX(5) = LoadSound_Strict("SFX/Room/PocketDimension/Enter.ogg")
	For i = 0 To 2
		OldManSFX(6+i) = LoadSound_Strict("SFX/SCP/106/WallDecay"+(i+1)+".ogg")
	Next


	For i = 0 To 2
		Scp173SFX(i) = LoadSound_Strict("SFX/SCP/173/Rattle" + (i + 1) + ".ogg")
	Next

	//Dim HorrorSFX%(20)
	For i = 0 To 11
		HorrorSFX(i) = LoadSound_Strict("SFX/Horror/Horror" + i + ".ogg")
	Next
	For i = 14 To 15
		HorrorSFX(i) = LoadSound_Strict("SFX/Horror/Horror" + i + ".ogg")
	Next

	//DrawLoading(25, True)

	//Dim IntroSFX%(20)

	For i = 7 To 9
		IntroSFX(i) = LoadSound_Strict("SFX/Room/Intro/Bang" + (i - 6) + ".ogg")
	Next
	For i = 10 To 12
		IntroSFX(i) = LoadSound_Strict("SFX/Room/Intro/Light" + (i - 9) + ".ogg")
	Next

	IntroSFX(15) = LoadSound_Strict("SFX/Room/Intro/173Vent.ogg")

	//Dim AlarmSFX%(5)
	AlarmSFX(0) = LoadSound_Strict("SFX/Alarm/Alarm.ogg")
	AlarmSFX(2) = LoadSound_Strict("SFX/Alarm/Alarm3.ogg")

	//room_gw alarms
	AlarmSFX(3) = LoadSound_Strict("SFX/Alarm/Alarm4.ogg")
	AlarmSFX(4) = LoadSound_Strict("SFX/Alarm/Alarm5.ogg")

	HeartBeatSFX = LoadSound_Strict("SFX/Character/D9341/Heartbeat.ogg")

	For i = 0 To 4
		BreathSFX(0,i)=LoadSound_Strict("SFX/Character/D9341/breath"+i+".ogg")
		BreathSFX(1,i)=LoadSound_Strict("SFX/Character/D9341/breath"+i+"gas.ogg")
	Next


	//Dim NeckSnapSFX(3)
	For i = 0 To 2
		NeckSnapSFX(i) =  LoadSound_Strict("SFX/SCP/173/NeckSnap"+(i+1)+".ogg")
	Next

	//Dim DamageSFX%(9)
	For i = 0 To 8
		DamageSFX(i) = LoadSound_Strict("SFX/Character/D9341/Damage"+(i+1)+".ogg")
	Next

	For i = 0 To 2
		CoughSFX(i) = LoadSound_Strict("SFX/Character/D9341/Cough" + (i + 1) + ".ogg")
	Next

	MachineSFX = LoadSound_Strict("SFX/SCP/914/Refining.ogg")

	ApacheSFX = LoadSound_Strict("SFX/Character/Apache/Propeller.ogg")

	for (let i of range(8)) {
		StepSFX[0][0][i] = LoadSound_Strict("SFX/Step/Step" + (i + 1) + ".ogg")
		StepSFX[1][0][i] = LoadSound_Strict("SFX/Step/StepMetal" + (i + 1) + ".ogg")
		StepSFX[0][1][i]= LoadSound_Strict("SFX/Step/Run" + (i + 1) + ".ogg")
		StepSFX[1][1][i] = LoadSound_Strict("SFX/Step/RunMetal" + (i + 1) + ".ogg")
		if (i < 3) {
			StepSFX[2][0][i] = LoadSound_Strict("SFX/Character/MTF/Step" + (i + 1) + ".ogg")
			StepSFX[3][0][i] = LoadSound_Strict("SFX/SCP/049/Step"+ (i + 1) + ".ogg")
		}
		if (i < 4) {
			StepSFX[4][0][i] = LoadSound_Strict("SFX/Step/SCP/StepSCP" + (i + 1) + ".ogg")//new one 1.3.9
		}
	}

	//Dim Step2SFX(6)
	for (let i of range(3)) {
		Step2SFX[i] = LoadSound_Strict("SFX/Step/StepPD" + (i + 1) + ".ogg")
		Step2SFX[i + 3] = LoadSound_Strict("SFX/Step/StepForest" + (i + 1) + ".ogg")
	}
}

export { LoadSound_Strict }


function LoadEntities() {
	CatchErrors("Uncaught (LoadEntities)")
	DrawLoading(0)
	
	let i: int
	
	for (i of range(10)) {
		TempSounds[i]=0
	}
	
	PauseMenuIMG = LoadImage_Strict("GFX/menu/pausemenu.jpg")
	MaskImage (PauseMenuIMG, 255,255,0)
	ScaleImage (PauseMenuIMG,MenuScale,MenuScale)
	
	SprintIcon = LoadImage_Strict("GFX/sprinticon.png")
	BlinkIcon = LoadImage_Strict("GFX/blinkicon.png")
	CrouchIcon = LoadImage_Strict("GFX/sneakicon.png")
	HandIcon = LoadImage_Strict("GFX/handsymbol.png")
	HandIcon2 = LoadImage_Strict("GFX/handsymbol2.png")

	StaminaMeterIMG = LoadImage_Strict("GFX/staminameter.jpg")

	KeypadHUD =  LoadImage_Strict("GFX/keypadhud.jpg")
	MaskImage(KeypadHUD, 255,0,255)

	Panel294 = LoadImage_Strict("GFX/294panel.jpg")
	MaskImage(Panel294, 255,0,255)
	
	
	Brightness = GetINIFloat("options.ini", "options", "brightness")
	CameraFogNear = GetINIFloat("options.ini", "options", "camera fog near")
	CameraFogFar = GetINIFloat("options.ini", "options", "camera fog far")
	StoredCameraFogFar = CameraFogFar
		
	AmbientLightRoomTex = CreateTexture(2,2,257)
	TextureBlend (AmbientLightRoomTex,5)
	SetBuffer(TextureBuffer(AmbientLightRoomTex))
	ClsColor (0,0,0)
	Cls()
	SetBuffer (BackBuffer())
	AmbientLightRoomVal = 0
	
	SoundEmitter = CreatePivot()
	
	Camera = CreateCamera()
	CameraViewport (Camera,0,0,GraphicWidth,GraphicHeight)
	CameraRange(Camera, 0.05, CameraFogFar)
	CameraFogMode (Camera, 1)
	CameraFogRange (Camera, CameraFogNear, CameraFogFar)
	CameraFogColor (Camera, GetINIInt("options.ini", "options", "fog r"), GetINIInt("options.ini", "options", "fog g"), GetINIInt("options.ini", "options", "fog b"))
	AmbientLight (Brightness, Brightness, Brightness)
	
	ScreenTexs[0] = CreateTexture(512, 512, 1+256)
	ScreenTexs[1] = CreateTexture(512, 512, 1+256)
	
	CreateBlurImage()
	CameraProjMode (ark_blur_cam,0)
	
	FogTexture = LoadTexture_Strict("GFX/fog.jpg", 1)
	
	Fog = CreateSprite(ark_blur_cam)
	ScaleSprite(Fog, Max(GraphicWidth / 1240.0, 1.0), Max(GraphicHeight / 960.0 * 0.8, 0.8))
	EntityTexture(Fog, FogTexture)
	EntityBlend (Fog, 2)
	EntityOrder (Fog, -1000)
	MoveEntity(Fog, 0, 0, 1.0)
	
	GasMaskTexture = LoadTexture_Strict("GFX/GasmaskOverlay.jpg", 1)
	GasMaskOverlay = CreateSprite(ark_blur_cam)
	ScaleSprite(GasMaskOverlay, Max(GraphicWidth / 1024.0, 1.0), Max(GraphicHeight / 1024.0 * 0.8, 0.8))
	EntityTexture(GasMaskOverlay, GasMaskTexture)
	EntityBlend (GasMaskOverlay, 2)
	EntityFX(GasMaskOverlay, 1)
	EntityOrder (GasMaskOverlay, -1003)
	MoveEntity(GasMaskOverlay, 0, 0, 1.0)
	HideEntity(GasMaskOverlay)
	
	InfectTexture = LoadTexture_Strict("GFX/InfectOverlay.jpg", 1)
	InfectOverlay = CreateSprite(ark_blur_cam)
	ScaleSprite(InfectOverlay, Max(GraphicWidth / 1024.0, 1.0), Max(GraphicHeight / 1024.0 * 0.8, 0.8))
	EntityTexture(InfectOverlay, InfectTexture)
	EntityBlend (InfectOverlay, 3)
	EntityFX(InfectOverlay, 1)
	EntityOrder (InfectOverlay, -1003)
	MoveEntity(InfectOverlay, 0, 0, 1.0)
	HideEntity(InfectOverlay)
	
	NVTexture = LoadTexture_Strict("GFX/NightVisionOverlay.jpg", 1)
	NVOverlay = CreateSprite(ark_blur_cam)
	ScaleSprite(NVOverlay, Max(GraphicWidth / 1024.0, 1.0), Max(GraphicHeight / 1024.0 * 0.8, 0.8))
	EntityTexture(NVOverlay, NVTexture)
	EntityBlend (NVOverlay, 2)
	EntityFX(NVOverlay, 1)
	EntityOrder (NVOverlay, -1003)
	MoveEntity(NVOverlay, 0, 0, 1.0)
	HideEntity(NVOverlay)
	NVBlink = CreateSprite(ark_blur_cam)
	ScaleSprite(NVBlink, Max(GraphicWidth / 1024.0, 1.0), Max(GraphicHeight / 1024.0 * 0.8, 0.8))
	EntityColor(NVBlink,0,0,0)
	EntityFX(NVBlink, 1)
	EntityOrder (NVBlink, -1005)
	MoveEntity(NVBlink, 0, 0, 1.0)
	HideEntity(NVBlink)
	
	FogNVTexture = LoadTexture_Strict("GFX/fogNV.jpg", 1)
	
	DrawLoading(5)
	
	DarkTexture = CreateTexture(1024, 1024, 1 + 2)
	SetBuffer (TextureBuffer(DarkTexture))
	Cls
	SetBuffer (BackBuffer())
	
	Dark = CreateSprite(Camera)
	ScaleSprite(Dark, Max(GraphicWidth / 1240.0, 1.0), Max(GraphicHeight / 960.0 * 0.8, 0.8))
	EntityTexture(Dark, DarkTexture)
	EntityBlend (Dark, 1)
	EntityOrder (Dark, -1002)
	MoveEntity(Dark, 0, 0, 1.0)
	EntityAlpha (Dark, 0.0)
	
	LightTexture = CreateTexture(1024, 1024, 1 + 2+256)
	SetBuffer (TextureBuffer(LightTexture))
	ClsColor (255, 255, 255)
	Cls
	ClsColor (0, 0, 0)
	SetBuffer (BackBuffer())
	
	TeslaTexture = LoadTexture_Strict("GFX/map/tesla.jpg", 1+2)
	
	Light = CreateSprite(Camera)
	ScaleSprite(Light, Max(GraphicWidth / 1240.0, 1.0), Max(GraphicHeight / 960.0 * 0.8, 0.8))
	EntityTexture(Light, LightTexture)
	EntityBlend (Light, 1)
	EntityOrder (Light, -1002)
	MoveEntity(Light, 0, 0, 1.0)
	HideEntity (Light)
	
	Collider = CreatePivot()
	EntityRadius (Collider, 0.15, 0.30)
	EntityPickMode(Collider, 1)
	EntityType (Collider, HIT_PLAYER)
	
	Head = CreatePivot()
	EntityRadius (Head, 0.15)
	EntityType (Head, HIT_PLAYER)
	
	
	LiquidObj = LoadMesh_Strict("GFX/items/cupliquid.x") //optimized the cups dispensed by 294
	HideEntity (LiquidObj)
	
	MTFObj = LoadAnimMesh_Strict("GFX/npcs/MTF2.b3d") //optimized MTFs
	GuardObj = LoadAnimMesh_Strict("GFX/npcs/guard.b3d") //optimized Guards
		
	ClassDObj = LoadAnimMesh_Strict("GFX/npcs/classd.b3d") //optimized Class-D's and scientists/researchers
	ApacheObj = LoadAnimMesh_Strict("GFX/apache.b3d") //optimized Apaches (helicopters)
	ApacheRotorObj = LoadAnimMesh_Strict("GFX/apacherotor.b3d") //optimized the Apaches even more
	
	HideEntity(MTFObj)
	HideEntity(GuardObj)
	HideEntity(ClassDObj)
	HideEntity(ApacheObj)
	HideEntity(ApacheRotorObj)
	
	//Other NPCs pre-loaded
	NPC049OBJ = LoadAnimMesh_Strict("GFX/npcs/scp-049.b3d")
	HideEntity(NPC049OBJ)
	NPC0492OBJ = LoadAnimMesh_Strict("GFX/npcs/zombie1.b3d")
	HideEntity(NPC0492OBJ)
	ClerkOBJ = LoadAnimMesh_Strict("GFX/npcs/clerk.b3d")
	HideEntity(ClerkOBJ	)
	
	LightSpriteTex(0) = LoadTexture_Strict("GFX/light1.jpg", 1)
	LightSpriteTex(1) = LoadTexture_Strict("GFX/light2.jpg", 1)
	LightSpriteTex(2) = LoadTexture_Strict("GFX/lightsprite.jpg",1)
	
	DrawLoading(10)
	
	DoorOBJ = LoadMesh_Strict("GFX/map/door01.x")
	HideEntity(DoorOBJ)
	DoorFrameOBJ = LoadMesh_Strict("GFX/map/doorframe.x")
	HideEntity(DoorFrameOBJ)
	
	HeavyDoorObj(0) = LoadMesh_Strict("GFX/map/heavydoor1.x")
	HideEntity(HeavyDoorObj(0))
	HeavyDoorObj(1) = LoadMesh_Strict("GFX/map/heavydoor2.x")
	HideEntity(HeavyDoorObj(1))
	
	DoorColl = LoadMesh_Strict("GFX/map/doorcoll.x")
	HideEntity(DoorColl)
	
	ButtonOBJ = LoadMesh_Strict("GFX/map/Button.x")
	HideEntity(ButtonOBJ)
	ButtonKeyOBJ = LoadMesh_Strict("GFX/map/ButtonKeycard.x")
	HideEntity(ButtonKeyOBJ)
	ButtonCodeOBJ = LoadMesh_Strict("GFX/map/ButtonCode.x")
	HideEntity(ButtonCodeOBJ	)
	ButtonScannerOBJ = LoadMesh_Strict("GFX/map/ButtonScanner.x")
	HideEntity(ButtonScannerOBJ	)
	
	BigDoorOBJ(0) = LoadMesh_Strict("GFX/map/ContDoorLeft.x")
	HideEntity(BigDoorOBJ(0))
	BigDoorOBJ(1) = LoadMesh_Strict("GFX/map/ContDoorRight.x")
	HideEntity(BigDoorOBJ(1))
	
	LeverBaseOBJ = LoadMesh_Strict("GFX/map/leverbase.x")
	HideEntity (LeverBaseOBJ)
	LeverOBJ = LoadMesh_Strict("GFX/map/leverhandle.x")
	HideEntity (LeverOBJ)
		
	DrawLoading(15)
	
	for (i of range(6)) {
		GorePics(i) = LoadTexture_Strict("GFX/895pics/pic" + (i + 1) + ".jpg")
	}
	
	OldAiPics(0) = LoadTexture_Strict("GFX/AIface.jpg")
	OldAiPics(1) = LoadTexture_Strict("GFX/AIface2.jpg")	
	
	DrawLoading(20)
	
	for (i of range(0, 6 + 1)) {
		DecalTextures(i) = LoadTexture_Strict("GFX/decal" + (i + 1) + ".png", 1 + 2)
	}
	DecalTextures(7) = LoadTexture_Strict("GFX/items/INVpaperstrips.jpg", 1 + 2)
	for (i of range(8, 12 + 1)) {
		DecalTextures(i) = LoadTexture_Strict("GFX/decalpd"+(i-7)+".jpg", 1 + 2)	
	}
	for (i of range(13, 14 + 1)) {
		DecalTextures(i) = LoadTexture_Strict("GFX/bullethole"+(i-12)+".jpg", 1 + 2)	
	}
	for (i of range(15, 16 + 1)) {
		DecalTextures(i) = LoadTexture_Strict("GFX/blooddrop"+(i-14)+".png", 1 + 2)	
	}
	DecalTextures(17) = LoadTexture_Strict("GFX/decal8.png", 1 + 2)	
	DecalTextures(18) = LoadTexture_Strict("GFX/decalpd6.dc", 1 + 2)	
	DecalTextures(19) = LoadTexture_Strict("GFX/decal19.png", 1 + 2)
	DecalTextures(20) = LoadTexture_Strict("GFX/decal427.png", 1 + 2)
	
	DrawLoading(25)
	
	Monitor = LoadMesh_Strict("GFX/map/monitor.b3d")
	HideEntity (Monitor)
	MonitorTexture = LoadTexture_Strict("GFX/monitortexture.jpg")
	
	CamBaseOBJ = LoadMesh_Strict("GFX/map/cambase.x")
	HideEntity(CamBaseOBJ)
	CamOBJ = LoadMesh_Strict("GFX/map/CamHead.b3d")
	HideEntity(CamOBJ)
	
	Monitor2 = LoadMesh_Strict("GFX/map/monitor_checkpoint.b3d")
	HideEntity (Monitor2)
	Monitor3 = LoadMesh_Strict("GFX/map/monitor_checkpoint.b3d")
	HideEntity (Monitor3)
	MonitorTexture2 = LoadTexture_Strict("GFX/map/LockdownScreen2.jpg")
	MonitorTexture3 = LoadTexture_Strict("GFX/map/LockdownScreen.jpg")
	MonitorTexture4 = LoadTexture_Strict("GFX/map/LockdownScreen3.jpg")
	MonitorTextureOff = CreateTexture(1,1)
	SetBuffer (TextureBuffer(MonitorTextureOff))
	ClsColor (0,0,0)
	Cls
	SetBuffer (BackBuffer())
	LightConeModel = LoadMesh_Strict("GFX/lightcone.b3d")
	HideEntity (LightConeModel)
	
	for (i of range(2, CountSurfaces(Monitor2) + 1)) {
		sf = GetSurface(Monitor2,i)
		b = GetSurfaceBrush(sf)
		if (b!=0) {
			t1 = GetBrushTexture(b,0)
			if (t1!=0) {
				name$ = StripPath(TextureName(t1))
				if (Lower(name) != "monitortexture.jpg") {
					BrushTexture (b, MonitorTextureOff, 0, 0)
					PaintSurface (sf,b)
				}
				if (name!="") {
					FreeTexture (t1)
				}
			}
			FreeBrush (b)
		}
	}
	for (i of range(2, CountSurfaces(Monitor3) + 1)) {
		sf = GetSurface(Monitor3,i)
		b = GetSurfaceBrush(sf)
		if (b!=0) {
			t1 = GetBrushTexture(b,0)
			if (t1!=0) {
				name$ = StripPath(TextureName(t1))
				if (Lower(name) != "monitortexture.jpg") {
					BrushTexture (b, MonitorTextureOff, 0, 0)
					PaintSurface (sf,b)
				}
				if (name!="") {FreeTexture (t1)}
			}
			FreeBrush (b)
		}
	}
	
	UserTrackMusicAmount = 0
	if (EnableUserTracks) {
		let dirPath: string = "SFX/Radio/UserTracks/"
		if (FileType(dirPath)!=2) {
			CreateDir(dirPath)
		}
		
		let Dir: int = ReadDir("SFX/Radio/UserTracks/")
		while (true) {
			file$=NextFile(Dir)
			if (file="") {
				break
			}
			if (FileType("SFX/Radio/UserTracks/"+file$) = 1) {
				test = LoadSound("SFX/Radio/UserTracks/"+file$)
				if (test!=0) {
					UserTrackName(UserTrackMusicAmount) = file$
					UserTrackMusicAmount = UserTrackMusicAmount + 1
				}
				FreeSound (test)
			}
		}
		CloseDir (Dir)
	}
	if (EnableUserTracks) {
		DebugLog ("User Tracks found: "+UserTrackMusicAmount)
	}
	
	InitItemTemplates()
	
	ParticleTextures(0) = LoadTexture_Strict("GFX/smoke.png", 1 + 2)
	ParticleTextures(1) = LoadTexture_Strict("GFX/flash.jpg", 1 + 2)
	ParticleTextures(2) = LoadTexture_Strict("GFX/dust.jpg", 1 + 2)
	ParticleTextures(3) = LoadTexture_Strict("GFX/npcs/hg.pt", 1 + 2)
	ParticleTextures(4) = LoadTexture_Strict("GFX/map/sun.jpg", 1 + 2)
	ParticleTextures(5) = LoadTexture_Strict("GFX/bloodsprite.png", 1 + 2)
	ParticleTextures(6) = LoadTexture_Strict("GFX/smoke2.png", 1 + 2)
	ParticleTextures(7) = LoadTexture_Strict("GFX/spark.jpg", 1 + 2)
	ParticleTextures(8) = LoadTexture_Strict("GFX/particle.png", 1 + 2)
	
	SetChunkDataValues()
	
	//NPCtypeD - different models with different textures (loaded using "CopyEntity") - ENDSHN
	//[Block]
	for (i of range(1, MaxDTextures + 1)) {
		DTextures[i] = CopyEntity(ClassDObj)
		HideEntity (DTextures[i])
	}
	//Gonzales
	tex = LoadTexture_Strict("GFX/npcs/gonzales.jpg")
	EntityTexture (DTextures[1],tex)
	FreeTexture (tex)
	//SCP-970 corpse
	tex = LoadTexture_Strict("GFX/npcs/corpse.jpg")
	EntityTexture (DTextures[2],tex)
	FreeTexture (tex)
	//scientist 1
	tex = LoadTexture_Strict("GFX/npcs/scientist.jpg")
	EntityTexture(DTextures[3],tex)
	FreeTexture(tex)
	//scientist 2
	tex = LoadTexture_Strict("GFX/npcs/scientist2.jpg")
	EntityTexture(DTextures[4],tex)
	FreeTexture(tex)
	//janitor
	tex = LoadTexture_Strict("GFX/npcs/janitor.jpg")
	EntityTexture(DTextures[5],tex)
	FreeTexture(tex)
	//106 Victim
	tex = LoadTexture_Strict("GFX/npcs/106victim.jpg")
	EntityTexture(DTextures[6],tex)
	FreeTexture(tex)
	//2nd ClassD
	tex = LoadTexture_Strict("GFX/npcs/classd2.jpg")
	EntityTexture(DTextures[7],tex)
	FreeTexture(tex)
	//035 victim
	tex = LoadTexture_Strict("GFX/npcs/035victim.jpg")
	EntityTexture(DTextures[8],tex)
	FreeTexture(tex)
	
	
	
	LoadMaterials("DATA/materials.ini")
	
	OBJTunnel[0]=LoadRMesh("GFX/map/mt1.rmesh",Null)	
	HideEntity(OBJTunnel[0])
	OBJTunnel[1]=LoadRMesh("GFX/map/mt2.rmesh",Null)	
	HideEntity(OBJTunnel[1])
	OBJTunnel[2]=LoadRMesh("GFX/map/mt2c.rmesh",Null)	
	HideEntity(OBJTunnel[2])
	OBJTunnel[3]=LoadRMesh("GFX/map/mt3.rmesh",Null)	
	HideEntity(OBJTunnel[3]	)
	OBJTunnel[4]=LoadRMesh("GFX/map/mt4.rmesh",Null)	
	HideEntity(OBJTunnel[4])
	OBJTunnel[5]=LoadRMesh("GFX/map/mt_elevator.rmesh",Null)
	HideEntity(OBJTunnel[5])
	OBJTunnel[6]=LoadRMesh("GFX/map/mt_generator.rmesh",Null)
	HideEntity(OBJTunnel[6])
	
	//TextureLodBias TextureBias
	TextureLodBias (TextureFloat)
	//Devil Particle System
	//ParticleEffect[] numbers:
	//	0 - electric spark
	//	1 - smoke effect
	
	let t0
	
	InitParticles(Camera)
	
	//Spark Effect (short)
	ParticleEffect[0] = CreateTemplate()
	SetTemplateEmitterBlend(ParticleEffect[0], 3)
	SetTemplateInterval(ParticleEffect[0], 1)
	SetTemplateParticlesPerInterval(ParticleEffect[0], 6)
	SetTemplateEmitterLifeTime(ParticleEffect[0], 6)
	SetTemplateParticleLifeTime(ParticleEffect[0], 20, 30)
	SetTemplateTexture(ParticleEffect[0], "GFX/Spark.png", 2, 3)
	SetTemplateOffset(ParticleEffect[0], -0.1, 0.1, -0.1, 0.1, -0.1, 0.1)
	SetTemplateVelocity(ParticleEffect[0], -0.0375, 0.0375, -0.0375, 0.0375, -0.0375, 0.0375)
	SetTemplateAlignToFall(ParticleEffect[0], true, 45)
	SetTemplateGravity(ParticleEffect[0], 0.001)
	SetTemplateAlphaVel(ParticleEffect[0], true)
	//SetTemplateSize(ParticleEffect[0], 0.0625, 0.125, 0.7, 1)
	SetTemplateSize(ParticleEffect[0], 0.03125, 0.0625, 0.7, 1)
	SetTemplateColors(ParticleEffect[0], $0000FF, $6565FF)
	SetTemplateFloor(ParticleEffect[0], 0.0, 0.5)
	
	//Smoke effect (for some vents)
	ParticleEffect[1] = CreateTemplate()
	SetTemplateEmitterBlend(ParticleEffect[1], 1)
	SetTemplateInterval(ParticleEffect[1], 1)
	SetTemplateEmitterLifeTime(ParticleEffect[1], 3)
	SetTemplateParticleLifeTime(ParticleEffect[1], 30, 45)
	SetTemplateTexture(ParticleEffect[1], "GFX/smoke2.png", 2, 1)
	//SetTemplateOffset(ParticleEffect[1], -.3, .3, -.3, .3, -.3, .3)
	SetTemplateOffset(ParticleEffect[1], 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)
	//SetTemplateVelocity(ParticleEffect[1], -.04, .04, .1, .2, -.04, .04)
	SetTemplateVelocity(ParticleEffect[1], 0.0, 0.0, 0.02, 0.025, 0.0, 0.0)
	SetTemplateAlphaVel(ParticleEffect[1], true)
	//SetTemplateSize(ParticleEffect[1], 3, 3, .5, 1.5)
	SetTemplateSize(ParticleEffect[1], 0.4, 0.4, 0.5, 1.5)
	SetTemplateSizeVel(ParticleEffect[1], .01, 1.01)
	
	//Smoke effect (for decontamination gas)
	ParticleEffect[2] = CreateTemplate()
	SetTemplateEmitterBlend(ParticleEffect[2], 1)
	SetTemplateInterval(ParticleEffect[2], 1)
	SetTemplateEmitterLifeTime(ParticleEffect[2], 3)
	SetTemplateParticleLifeTime(ParticleEffect[2], 30, 45)
	SetTemplateTexture(ParticleEffect[2], "GFX/smoke.png", 2, 1)
	SetTemplateOffset(ParticleEffect[2], -0.1, 0.1, -0.1, 0.1, -0.1, 0.1)
	SetTemplateVelocity(ParticleEffect[2], -0.005, 0.005, 0.0, -0.03, -0.005, 0.005)
	SetTemplateAlphaVel(ParticleEffect[2], true)
	SetTemplateSize(ParticleEffect[2], 0.4, 0.4, 0.5, 1.5)
	SetTemplateSizeVel(ParticleEffect[2], .01, 1.01)
	SetTemplateGravity(ParticleEffect[2], 0.005)
	t0 = CreateTemplate()
	SetTemplateEmitterBlend(t0, 1)
	SetTemplateInterval(t0, 1)
	SetTemplateEmitterLifeTime(t0, 3)
	SetTemplateParticleLifeTime(t0, 30, 45)
	SetTemplateTexture(t0, "GFX/smoke2.png", 2, 1)
	SetTemplateOffset(t0, -0.1, 0.1, -0.1, 0.1, -0.1, 0.1)
	SetTemplateVelocity(t0, -0.005, 0.005, 0.0, -0.03, -0.005, 0.005)
	SetTemplateAlphaVel(t0, true)
	SetTemplateSize(t0, 0.4, 0.4, 0.5, 1.5)
	SetTemplateSizeVel(t0, .01, 1.01)
	SetTemplateGravity(ParticleEffect[2], 0.005)
	SetTemplateSubTemplate(ParticleEffect[2], t0)
	
	Room2slCam = CreateCamera()
	CameraViewport(Room2slCam, 0, 0, 128, 128)
	CameraRange (Room2slCam, 0.05, 6.0)
	CameraZoom(Room2slCam, 0.8)
	HideEntity(Room2slCam)
	
	DrawLoading(30)
		
	CatchErrors("LoadEntities")
}

function InitNewGame() {
	CatchErrors("Uncaught (InitNewGame)")
	let i: int
	let de: Decals
	let d: Doors
	let it: Items
	let r: Rooms
	let sc: SecurityCams
	let e: Events
	
	DrawLoading(45)
	
	HideDistance = 15.0
	
	HeartBeatRate = 70
	
	AccessCode = 0
	for (i of range(4)) {
		AccessCode = AccessCode + Rand(1,9)*(10^i)
	}	
	
	if (SelectedMap = "") {
		CreateMap()
	} else {
		LoadMap("Map Creator/Maps/"+SelectedMap)
	}
	InitWayPoints()
	
	DrawLoading(79)
	
	Curr173 = CreateNPC(NPCtype173, 0, -30.0, 0)
	Curr106 = CreateNPC(NPCtypeOldMan, 0, -30.0, 0)
	Curr106.State = 70 * 60 * Rand(12,17)
	
	for (d of Doors.each) {
		EntityParent(d.obj, 0)
		if (d.obj2 != 0) {EntityParent(d.obj2, 0)}
		if (d.frameobj != 0) {EntityParent(d.frameobj, 0)}
		if (d.buttons[0] != 0) {EntityParent(d.buttons[0], 0)}
		if (d.buttons[1] != 0) {EntityParent(d.buttons[1], 0)}
		
		if (d.obj2 != 0 && d.dir == 0) {
			MoveEntity(d.obj, 0, 0, 8.0 * RoomScale)
			MoveEntity(d.obj2, 0, 0, 8.0 * RoomScale)
		}	
	}
	
	for (it of Items.each) {
		EntityType (it.collider, HIT_ITEM)
		EntityParent(it.collider, 0)
	}
	
	DrawLoading(80)
	for (sc of SecurityCams.each) {
		sc.angle = EntityYaw(sc.obj) + sc.angle
		EntityParent(sc.obj, 0)
	}	
	
	for (r of Rooms.each) {
		for (i of range(MaxRoomLights + 1)) {
			if (r.Lights[i]!=0) {
				EntityParent(r.Lights[i],0)
			}
		}
		
		if (!r.RoomTemplate.DisableDecals) {
			if (Rand(4) = 1) {
				de.Decals = CreateDecal(Rand(2, 3), EntityX(r.obj)+Rnd(- 2,2), 0.003, EntityZ(r.obj)+Rnd(-2,2), 90, Rand(360), 0)
				de.Size = Rnd(0.1, 0.4)
				ScaleSprite(de.obj, de.Size, de.Size)
				EntityAlpha(de.obj, Rnd(0.85, 0.95))
			}
			
			if (Rand(4) = 1) {
				de.Decals = CreateDecal(0, EntityX(r.obj)+Rnd(- 2,2), 0.003, EntityZ(r.obj)+Rnd(-2,2), 90, Rand(360), 0)
				de.Size = Rnd(0.5, 0.7)
				EntityAlpha(de.obj, 0.7)
				de.ID = 1
				ScaleSprite(de.obj, de.Size, de.Size)
				EntityAlpha(de.obj, Rnd(0.7, 0.85))
			}
		}
		
		if (r.RoomTemplate.Name == "start" && IntroEnabled == false) {
			PositionEntity (Collider, EntityX(r.obj)+3584*RoomScale, 704*RoomScale, EntityZ(r.obj)+1024*RoomScale)
			PlayerRoom = r
			it = CreateItem("Class D Orientation Leaflet", "paper", 1, 1, 1)
			it.Picked = true
			it.Dropped = -1
			it.itemtemplate.found=true
			Inventory(0) = it
			HideEntity(it.collider)
			EntityType (it.collider, HIT_ITEM)
			EntityParent(it.collider, 0)
			ItemAmount = ItemAmount + 1
			it = CreateItem("Document SCP-173", "paper", 1, 1, 1)
			it.Picked = true
			it.Dropped = -1
			it.itemtemplate.found=true
			Inventory(1) = it
			HideEntity(it.collider)
			EntityType (it.collider, HIT_ITEM)
			EntityParent(it.collider, 0)
			ItemAmount = ItemAmount + 1
		} else if (r.RoomTemplate.Name == "173" && IntroEnabled) {
			PositionEntity (Collider, EntityX(r.obj), 1.0, EntityZ(r.obj))
			PlayerRoom = r
		}
		
	}
	
	let rt: RoomTemplates
	for (rt of RoomTemplates.each) {
		FreeEntity (rt.obj)
	}
	
	let tw: TempWayPoints
	for (tw of TempWayPoints.each) {
		Delete (tw)
	}
	
	TurnEntity(Collider, 0, Rand(160, 200), 0)
	
	ResetEntity (Collider)
	
	if (SelectedMap = "") {InitEvents()}
	
	for (e of Events.each) {
		if (e.EventName = "room2nuke") {
			e.EventState = 1
			DebugLog("room2nuke")
		}
		if (e.EventName = "room106") {
			e.EventState2 = 1
			DebugLog("room106")
		}
		if (e.EventName = "room2sl") {
			e.EventState3 = 1
			DebugLog("room2sl")
		}
	}
	
	MoveMouse (viewport_center_x,viewport_center_y)//320, 240
	
	AASetFont (Font1)
	
	HidePointer()
	
	BlinkTimer = -10
	BlurTimer = 100
	Stamina = 100
	
	for (i of range(71)) {
		FPSfactor = 1.0
		FlushKeys()
		MovePlayer()
		UpdateDoors()
		UpdateNPCs()
		UpdateWorld()
		if (Int(Float(i)*0.27)!=Int(Float(i-1)*0.27)) {
			DrawLoading(80+Int(Float(i)*0.27))
		}
	}
	
	FreeTextureCache
	DrawLoading(100)
	
	FlushKeys()
	FlushMouse()
	
	DropSpeed = 0
	
	PrevTime = MilliSecs()
	CatchErrors("InitNewGame")
}

function InitLoadGame() {
	CatchErrors("Uncaught (InitLoadGame)")
	let d: Doors, sc: SecurityCams, rt: RoomTemplates, e: Events
	
	DrawLoading(80)
	
	for (d of Doors.each) {
		EntityParent(d.obj, 0)
		if (d.obj2 != 0) {EntityParent(d.obj2, 0)}
		if (d.frameobj != 0) {EntityParent(d.frameobj, 0)}
		if (d.buttons[0] != 0) {EntityParent(d.buttons[0], 0)}
		if (d.buttons[1] != 0) {EntityParent(d.buttons[1], 0)}
		
	}
	
	for (sc of SecurityCams.each) {
		sc.angle = EntityYaw(sc.obj) + sc.angle
		EntityParent(sc.obj, 0)
	}
	
	ResetEntity (Collider)
	
	//InitEvents()
	
	DrawLoading(90)
	
	MoveMouse (viewport_center_x,viewport_center_y)
	
	AASetFont (Font1)
	
	HidePointer ()
	
	BlinkTimer = BLINKFREQ
	Stamina = 100
	
	for (rt of RoomTemplates.each) {
		if (rt.obj != 0) {
			FreeEntity(rt.obj)
			rt.obj = 0
		}
	}
	
	DropSpeed = 0.0
	
	for (e of Events.each) {
		//Loading the necessary stuff for dimension1499, but this will only be done if the player is in this dimension already
		if (e.EventName = "dimension1499") {
			if (e.EventState == 2) {
				//[Block]
				DrawLoading(91)
				e.room.Objects[0] = CreatePlane()
				let planetex: int = LoadTexture_Strict("GFX/map/dimension1499/grit3.jpg")
				EntityTexture (e.room.Objects[0],planetex)
				FreeTexture(planetex)
				PositionEntity (e.room.Objects[0],0,EntityY(e.room.obj),0)
				EntityType (e.room.Objects[0],HIT_MAP)
				DrawLoading(92)
				NTF_1499Sky = sky_CreateSky("GFX/map/sky/1499sky")
				DrawLoading(93)
				for (i of range(1, 16)) {
					e.room.Objects[i] = LoadMesh_Strict("GFX/map/dimension1499/1499object"+i+".b3d")
					HideEntity (e.room.Objects[i])
				}
				DrawLoading(96)
				CreateChunkParts(e.room)
				DrawLoading(97)
				x = EntityX(e.room.obj)
				z = EntityZ(e.room.obj)
				let ch: Chunk
				for (i of range(-2, 3, 2)) {
					ch = CreateChunk(-1,x*(i*2.5),EntityY(e.room.obj),z)
				}
				DrawLoading(98)
				UpdateChunks(e.room,15,false)
				
				DebugLog ("Loaded dimension1499 successful")
				
				break
				
			}
		}
	}
	
	FreeTextureCache
	
	CatchErrors("InitLoadGame")
	DrawLoading(100)
	
	PrevTime = MilliSecs()
	FPSfactor = 0
	ResetInput()
	
}

function NullGame(playbuttonsfx: boolean = true) {
	CatchErrors("Uncaught (NullGame)")
	let i: int, x: int, y: int, lvl
	let itt: ItemTemplates, s: Screens, lt: LightTemplates, d: Doors, m: Materials
	let wp: WayPoints, twp: TempWayPoints, r: Rooms, it: Items
	
	KillSounds()
	if (playbuttonsfx) {PlaySound_Strict (ButtonSFX)}
	
	FreeParticles()
	
	ClearTextureCache
	
	DebugHUD = false
	
	UnableToMove = false
	
	QuickLoadPercent = -1
	QuickLoadPercent_DisplayTimer = 0
	QuickLoad_CurrEvent = Null
	
	DeathMSG$=""
	
	SelectedMap = ""
	
	UsedConsole = false
	
	DoorTempID = 0
	RoomTempID = 0
	
	GameSaved = 0
	
	HideDistance = 15.0
	
	for (lvl of range(0, 1)) {
		for (x of range(MapWidth+2)) {
			for (y of range(MapHeight+2)) {
				MapTemp(x, y) = 0
				MapFound(x, y) = 0
			}
		}
	}
	
	for (itt of  ItemTemplates.each) {
		itt.found = false
	}
	
	DropSpeed = 0
	Shake = 0
	CurrSpeed = 0
	
	DeathTimer=0
	
	HeartBeatVolume = 0
	
	StaminaEffect = 1.0
	StaminaEffectTimer = 0
	BlinkEffect = 1.0
	BlinkEffectTimer = 0
	
	Bloodloss = 0
	Injuries = 0
	Infect = 0
	
	for (i of range(6)) {
		SCP1025state[i] = 0
	}
	
	SelectedEnding = ""
	EndingTimer = 0
	ExplosionTimer = 0
	
	CameraShake = 0
	Shake = 0
	LightFlash = 0
	
	GodMode = 0
	NoClip = 0
	WireframeState = 0
	WireFrame (0)
	WearingGasMask = 0
	WearingHazmat = 0
	WearingVest = 0
	Wearing714 = 0
	if (WearingNightVision) {
		CameraFogFar = StoredCameraFogFar
		WearingNightVision = 0
	}
	I_427.Using = 0
	I_427.Timer = 0.0
	
	ForceMove = 0.0
	ForceAngle = 0.0	
	Playable = true
	
	CoffinDistance = 100
	
	Contained106 = false
	if (Curr173 != Null) {Curr173.Idle = false}
	
	MTFtimer = 0
	for (i of range(10)) {
		MTFrooms[i]=Null
		MTFroomState[i]=0
	}
	
	for (s of Screens.each) {
		if (s.img != 0) {
			FreeImage (s.img)
			s.img = 0
		}
		Delete (s)
	}
	
	for (i of range(MAXACHIEVEMENTS)) {
		Achievements(i)=0
	}
	RefinedItems = 0
	
	ConsoleInput = ""
	ConsoleOpen = false
	
	EyeIrritation = 0
	EyeStuck = 0
	
	ShouldPlay = 0
	
	KillTimer = 0
	FallTimer = 0
	Stamina = 100
	BlurTimer = 0
	SuperMan = false
	SuperManTimer = 0
	Sanity = 0
	RestoreSanity = true
	Crouch = false
	CrouchState = 0.0
	LightVolume = 0.0
	Vomit = false
	VomitTimer = 0.0
	SecondaryLightOn = true
	PrevSecondaryLightOn = true
	RemoteDoorOn = true
	SoundTransmission = false
	
	InfiniteStamina = false
	
	Msg = ""
	MsgTimer = 0
	
	SelectedItem = Null
	
	for (i of range(MaxItemAmount)) {
		Inventory(i) = Null
	}
	SelectedItem = Null
	
	ClosestButton = 0
	
	for (d of Doors.each) {
		Delete (d)
	}
	
	//ClearWorld
	
	for (lt of LightTemplates.each) {
		Delete (lt)
	}
	
	for (m of Materials.each) {
		Delete (m)
	}
	
	for (wp of WayPoints.each) {
		Delete (wp)
	}
	
	for (twp of TempWayPoints.each) {
		Delete (twp)
	}
	
	for (r of Rooms.each) {
		Delete (r)
	}
	
	for (itt of ItemTemplates.each) {
		Delete (itt)
	}
	
	for (it of Items.each) {
		Delete (it)
	}
	
	for (pr of Props.each) {
		Delete (pr)
	}
	
	for (de of Decals.each) {
		Delete (de)
	}
	
	for (n of NPCs.each) {
		Delete (n)
	}
	Curr173 = Null
	Curr106 = Null
	Curr096 = Null
	for (i of range(7)) {
		MTFrooms[i]=Null
	}
	ForestNPC = 0
	ForestNPCTex = 0
	
	let e: Events
	for (e of Events.each) {
		if (e.Sound != 0) {FreeSound_Strict (e.Sound)}
		if (e.Sound2 != 0) {FreeSound_Strict (e.Sound2)}
		Delete (e)
	}
	
	for (sc of SecurityCams.each) {
		Delete (sc)
	}
	
	for (em of Emitters.each) {
		Delete (em)
	}
	
	for (p of Particles.each) {
		Delete (p)
	}
	
	for (rt of RoomTemplates.each) {
		rt.obj = 0
	}
	
	for (i of range(6)) {
		if (ChannelPlaying(RadioCHN(i))) {StopChannel(RadioCHN(i))}
	}
	
	NTF_1499PrevX = 0.0
	NTF_1499PrevY = 0.0
	NTF_1499PrevZ = 0.0
	NTF_1499PrevRoom = Null
	NTF_1499X = 0.0
	NTF_1499Y = 0.0
	NTF_1499Z = 0.0
	Wearing1499 = false
	DeleteChunks()
	
	DeleteElevatorObjects()
	
	DeleteDevilEmitters()
	
	NoTarget = false
	
	OptionsMenu = -1
	QuitMSG = -1
	AchievementsMenu = -1
	
	MusicVolume = PrevMusicVolume
	SFXVolume = PrevSFXVolume
	DeafPlayer = false
	DeafTimer = 0.0
	
	IsZombie = false
	
	Delete(AchievementMsg.each)
	CurrAchvMSGID = 0
	
	//DeInitExt
	
	ClearWorld
	ReloadAAFont()
	Camera = 0
	ark_blur_cam = 0
	Collider = 0
	Sky = 0
	InitFastResize()
	
	CatchErrors("NullGame")
}


function SaveGame(file: string) {
	CatchErrors("Uncaught (SaveGame)")
	
	If Not Playable Then Return //don't save if the player can't move at all
	
	If DropSpeed#>0.02*FPSfactor Or DropSpeed#<-0.02*FPSfactor Then Return
	
	If KillTimer < 0 Then Return
	
	GameSaved = True
	
	let x: int, y: int, i: int, temp: int
	let n: NPCs, r: Rooms, door: Doors
	
	CreateDir(file)
	
	let f: int = WriteFile(file + "save.txt")
	
	WriteString (f, CurrentTime())
	WriteString (f, CurrentDate())
	
	WriteInt (f, PlayTime)
	WriteFloat (f, EntityX(Collider))
	WriteFloat (f, EntityY(Collider))
	WriteFloat (f, EntityZ(Collider))
	
	WriteFloat (f, EntityX(Head))
	WriteFloat (f, EntityY(Head))
	WriteFloat (f, EntityZ(Head))
	
	WriteString (f, Str(AccessCode))
	
	WriteFloat (f, EntityPitch(Collider))
	WriteFloat (f, EntityYaw(Collider))
	
	//WriteString (f, VersionNumber)
	WriteString (f, CompatibleNumber)
	
	WriteFloat (f, BlinkTimer)
	WriteFloat (f, BlinkEffect)
	WriteFloat (f, BlinkEffectTimer)
	
	WriteInt (f, DeathTimer)
	WriteInt (f, BlurTimer)
	WriteFloat (f, HealTimer)
	
	WriteByte (f, Crouch)
	
	WriteFloat (f, Stamina)
	WriteFloat (f, StaminaEffect)
	WriteFloat (f, StaminaEffectTimer)
	
	WriteFloat (f, EyeStuck	)
	WriteFloat (f, EyeIrritation)
	
	WriteFloat (f, Injuries)
	WriteFloat (f, Bloodloss)
	
	WriteFloat (f,PrevInjuries)
	WriteFloat (f,PrevBloodloss)
	
	WriteString (f, DeathMSG)
	
	for (i of range(6)) {
		WriteFloat (f, SCP1025state[i])
	}
	
	WriteFloat (f, VomitTimer)
	WriteByte (f, Vomit)
	WriteFloat (f, CameraShakeTimer)
	WriteFloat (f, Infect)
	
	for (i of range(CUSTOM + 1)) {
		if (SelectedDifficulty = difficulties(i)) {
			WriteByte (f, i)
			
			if (i = CUSTOM) {
				WriteByte (f,SelectedDifficulty.aggressiveNPCs)
				WriteByte (f,SelectedDifficulty.permaDeath)
				WriteByte (f,SelectedDifficulty.saveType)
				WriteByte (f,SelectedDifficulty.otherFactors)
			}
		}
	}
	
	WriteFloat (f, MonitorTimer)
	
	WriteFloat (f, Sanity)
	
	WriteByte (f, WearingGasMask)
	WriteByte (f, WearingVest)
	WriteByte (f, WearingHazmat)
	
	WriteByte (f, WearingNightVision)
	WriteByte (f, Wearing1499)
	WriteFloat (f,NTF_1499PrevX)
	WriteFloat (f,NTF_1499PrevY)
	WriteFloat (f,NTF_1499PrevZ)
	WriteFloat (f,NTF_1499X)
	WriteFloat (f,NTF_1499Y)
	WriteFloat (f,NTF_1499Z)
	if (NTF_1499PrevRoom != Null) {
		WriteFloat(f,NTF_1499PrevRoom.x)
		WriteFloat(f,NTF_1499PrevRoom.z)
	} else {
		WriteFloat(f,0.0)
		WriteFloat (f,0.0)
	}
	
	WriteByte (f, SuperMan)
	WriteFloat (f, SuperManTimer)
	WriteByte (f, LightsOn)
	
	WriteString (f, RandomSeed)
	
	WriteFloat (f, SecondaryLightOn)
	WriteFloat (f, PrevSecondaryLightOn)
	WriteByte (f, RemoteDoorOn)
	WriteByte (f, SoundTransmission)
	WriteByte (f, Contained106)
	
	for (i of range(MAXACHIEVEMENTS)) {
		WriteByte (f, Achievements(i))
	}
	WriteInt (f, RefinedItems)
	
	WriteInt (f, MapWidth)
	WriteInt (f, MapHeight)
	for (lvl of range(1)) {
		for (x of range(MapWidth + 1)) {
			for (y of range(MapHeight + 1)) {
				WriteInt (f, MapTemp(x, y))
				WriteByte (f, MapFound(x, y))
			}
		}
	}
	
	WriteInt f, 113
	
	temp = 0
	For  n.NPCs = Each NPCs
		temp = temp +1
	Next	
	
	WriteInt f, temp
	for (n of NPCs.each) {
		DebugLog("Saving NPC " +n.NVName+ " (ID "+n.ID+")")
		
		WriteByte (f, n.NPCtype)
		WriteFloat (f, EntityX(n.Collider,True))
		WriteFloat (f, EntityY(n.Collider,True))
		WriteFloat (f, EntityZ(n.Collider,True))
		
		WriteFloat (f, EntityPitch(n.Collider))
		WriteFloat (f, EntityYaw(n.Collider))
		WriteFloat (f, EntityRoll(n.Collider))
		
		WriteFloat (f, n.State)
		WriteFloat (f, n.State2)
		WriteFloat (f, n.State3)
		WriteInt (f, n.PrevState)
		
		WriteByte (f, n.Idle)
		WriteFloat (f, n.LastDist)
		WriteInt (f, n.LastSeen)
		
		WriteInt (f, n.CurrSpeed)
		
		WriteFloat (f, n.Angle)
		
		WriteFloat (f, n.Reload)
		
		WriteInt (f, n.ID)
		if (n.Target != Null) {
			WriteInt (f, n.Target.ID)
		} else {
			WriteInt (f, 0)
		}
		
		WriteFloat (f, n.EnemyX)
		WriteFloat (f, n.EnemyY)
		WriteFloat (f, n.EnemyZ)
		
		WriteString (f, n.texture)
		
		WriteFloat (f, AnimTime(n.obj))
		
		WriteInt (f, n.IsDead)
		WriteFloat (f, n.PathX)
		WriteFloat (f, n.PathZ)
		WriteInt (f, n.HP)
		WriteString (f, n.Model)
		WriteFloat (f, n.ModelScaleX)
		WriteFloat (f, n.ModelScaleY)
		WriteFloat (f, n.ModelScaleZ)
		WriteInt (f, n.TextureID)
	}
	
	WriteFloat f, MTFtimer
	For i = 0 To 6
		If MTFrooms[0]<>Null Then 
			WriteString f, MTFrooms[0]\RoomTemplate\Name 
		Else 
			WriteString f,	"a"
		EndIf
		WriteInt f, MTFroomState[i]
	Next
	
	WriteInt f, 632
	
	WriteInt f, room2gw_brokendoor
	WriteFloat (f,room2gw_x)
	WriteFloat (f,room2gw_z)
	
	WriteByte (f, I_Zone.Transition[0])
	WriteByte (f, I_Zone.Transition[1])
	WriteByte (f, I_Zone.HasCustomForest)
	WriteByte (f, I_Zone.HasCustomMT)
	
	temp = 0
	For r.Rooms = Each Rooms
		temp=temp+1
	Next	
	WriteInt f, temp	
	For r.Rooms = Each Rooms
		WriteInt (f, r.RoomTemplate.id)
		WriteInt (f, r.angle)
		WriteFloat (f, r.x)
		WriteFloat (f, r.y)
		WriteFloat (f, r.z)
		
		WriteByte (f, r.found)
		
		WriteInt (f, r.zone)
		
		If PlayerRoom = r Then 
			WriteByte (f, 1)
		Else 
			WriteByte (f, 0)
		EndIf
		
		For i = 0 To 11
			If r\NPC[i]=Null Then
				WriteInt f, 0
			Else
				WriteInt f, r\NPC[i]\ID
			EndIf
		Next
		
		for (i of range(11)) {
			if (r.Levers[i] != 0) {
				if (EntityPitch(r.Levers[i],True) > 0) {
					WriteByte(f,1)
				} else {
					WriteByte(f,0)
				}
			}
		}
		WriteByte(f,2)
		
		
		If r\grid=Null Then //this room doesn't have a grid
			WriteByte(f,0)
		Else //this room has a grid
			WriteByte(f,1)
			for (y of range(gridsz)) {
				for (x of range(gridsz)) {
					WriteByte(f,r.grid.grid[x+(y*gridsz)])
					WriteByte(f,r.grid.angles[x+(y*gridsz)])
				}
			}
		EndIf
		
		If r\fr=Null Then //this room doesn't have a forest
			WriteByte(f,0)
		Else //this room has a forest
			If (Not I_Zone\HasCustomForest) Then
				WriteByte(f,1)
			Else
				WriteByte(f,2)
			EndIf
			For y=0 To gridsize-1
				For x=0 To gridsize-1
					WriteByte(f,r\fr\grid[x+(y*gridsize)])
				Next
			Next
			WriteFloat (f,EntityX(r.fr.Forest_Pivot,True))
			WriteFloat (f,EntityY(r.fr.Forest_Pivot,True))
			WriteFloat (f,EntityZ(r.fr.Forest_Pivot,True))
		EndIf
	Next
	
	WriteInt f, 954
	
	temp = 0
	For door.Doors = Each Doors
		temp = temp+1	
	Next	
	WriteInt f, temp	
	For door.Doors = Each Doors
		WriteFloat (f, EntityX(door.frameobj,True))
		WriteFloat (f, EntityY(door.frameobj,True))
		WriteFloat (f, EntityZ(door.frameobj,True))
		WriteByte (f, door.open)
		WriteFloat (f, door.openstate)
		WriteByte (f, door.locked)
		WriteByte (f, door.AutoClose)
		
		WriteFloat (f, EntityX(door.obj, True))
		WriteFloat (f, EntityZ(door.obj, True))
		
		if (door.obj2 <> 0) {
			WriteFloat (f, EntityX(door.obj2, True))
			WriteFloat (f, EntityZ(door.obj2, True))
		} else {
			WriteFloat (f, 0.0)
			WriteFloat (f, 0.0)
		}
		
		WriteFloat (f, door.timer)
		WriteFloat (f, door.timerstate)
		
		WriteByte (f, door.IsElevatorDoor)
		WriteByte (f, door.MTFClose)
	Next
	
	WriteInt f, 1845
	DebugLog 1845
	
	Local d.Decals
	temp = 0
	For d.Decals = Each Decals
		temp = temp+1
	Next	
	WriteInt f, temp
	for (d of Decals.each) {
		WriteInt (f, d.ID)
		
		WriteFloat (f, EntityX(d.obj,True))
		WriteFloat (f, EntityY(d.obj,True))
		WriteFloat (f, EntityZ(d.obj,True))
		
		WriteFloat (f, EntityPitch(d.obj,True))
		WriteFloat (f, EntityYaw(d.obj,True))
		WriteFloat (f, EntityRoll(d.obj,True))
		
		WriteByte (f, d.blendmode)
		WriteInt (f, d.fx)
		
		WriteFloat (f, d.Size)
		WriteFloat (f, d.Alpha)
		WriteFloat (f, d.AlphaChange)
		WriteFloat (f, d.Timer)
		WriteFloat (f, d.lifetime)
	}
	
	let e: Events
	temp = 0
	For e.Events = Each Events
		temp=temp+1
	Next	
	WriteInt f, temp
	For e.Events = Each Events
		WriteString f, e.EventName
		WriteFloat (f, e.EventState)
		WriteFloat (f, e.EventState2)
		WriteFloat (f, e.EventState3)
		WriteFloat (f, EntityX(e.room.obj))
		WriteFloat (f, EntityZ(e.room.obj))
		WriteString f, e.EventStr
	Next
	
	temp = 0
	For it.items = Each Items	
		temp=temp+1
	Next
	WriteInt f, temp
	For it.items = Each Items
		WriteString (f, it.itemtemplate.name)
		WriteString (f, it.itemtemplate.tempName)
		
		WriteString (f, it.name)
		
		WriteFloat (f, EntityX(it.collider, True))
		WriteFloat (f, EntityY(it.collider, True))
		WriteFloat (f, EntityZ(it.collider, True))
		
		WriteByte (f, it.r)
		WriteByte (f, it.g)
		WriteByte (f, it.b)
		WriteFloat (f, it.a)
		
		WriteFloat (f, EntityPitch(it.collider))
		WriteFloat (f, EntityYaw(it.collider))
		
		WriteFloat (f, it.state)
		WriteByte (f, it.Picked)
		
		if (SelectedItem = it) {
			WriteByte (f, 1)
		} else {
			WriteByte (f, 0)
		}
		let ItemFound: boolean = False
		for (i of range(MaxItemAmount)) {
			if (Inventory(i) = it) {
				ItemFound = True
				Exit
			}
		}
		If ItemFound Then WriteByte f, i Else WriteByte f, 66
		
		If it.itemtemplate.isAnim<>0 Then
			WriteFloat f, AnimTime(it.model)
		EndIf
		WriteByte f,it.invSlots
		WriteInt f,it.ID
		If it.itemtemplate.invimg=it.invimg Then WriteByte f,0 Else WriteByte f,1
	Next
	
	temp=0
	For it.items = Each Items
		If it.invSlots>0 Then temp=temp+1
	Next
	
	WriteInt f,temp
	
	For it.items = Each Items
		//OtherInv
		If it\invSlots>0 Then
			WriteInt f,it\ID
			For i=0 To it\invSlots-1
				If it\SecondInv[i] <> Null Then
					WriteInt f, it\SecondInv[i]\ID
				Else
					WriteInt f, -1
				EndIf
			Next
		EndIf
		//OtherInv End
	Next
	
	For itt.itemtemplates = Each ItemTemplates
		WriteByte f, itt\found
	Next
	
	If UsedConsole
		WriteInt f, 100
		DebugLog "Used Console"
	Else
		WriteInt f, 994
	EndIf
	WriteFloat f, CameraFogFar
	WriteFloat f, StoredCameraFogFar
	WriteByte f, I_427\Using
	WriteFloat f, I_427\Timer
	
	WriteByte f, Wearing714
	CloseFile f
	
	If Not MenuOpen Then
		If SelectedDifficulty\saveType = SAVEONSCREENS Then
			PlaySound_Strict(LoadTempSound("SFX/General/Save2.ogg"))
		Else
			PlaySound_Strict(LoadTempSound("SFX/General/Save1.ogg"))
		EndIf
		
		Msg = "Game progress saved."
		MsgTimer = 70 * 4
	EndIf
	
	CatchErrors("SaveGame")
}

function LoadGame(file: string) {
	let version: string = ""
	
	CatchErrors("Uncaught (LoadGame)")
	DebugLog ("---------------------------------------------------------------------------")
	
	DropSpeed=0.0
	
	DebugHUD = False
	
	GameSaved = True
	
	let x: float
	let y: float
	let z: float
	let i: int
	let temp: int
	let strtemp: string
	let r: Rooms
	let id: int
	let n: NPCs
	let door: Doors
	let f: int = ReadFile(file + "save.txt")
	
	strtemp = ReadString(f)
	strtemp = ReadString(f)
	
	PlayTime = ReadInt(f)
	
	x = ReadFloat(f)
	y = ReadFloat(f)
	z = ReadFloat(f)	
	PositionEntity(Collider, x, y+0.05, z)
	ResetEntity(Collider)
	
	x = ReadFloat(f)
	y = ReadFloat(f)
	z = ReadFloat(f)	
	PositionEntity(Head, x, y+0.05, z)
	ResetEntity(Head)
	
	AccessCode = Int(ReadString(f))
	
	x = ReadFloat(f)
	y = ReadFloat(f)
	RotateEntity(Collider, x, y, 0, 0)
	
	strtemp = ReadString(f)
	version = strtemp
	
	BlinkTimer = ReadFloat(f)
	BlinkEffect = ReadFloat(f)	
	BlinkEffectTimer = ReadFloat(f)
	
	DeathTimer = ReadInt(f)	
	BlurTimer = ReadInt(f)	
	HealTimer = ReadFloat(f)
	
	Crouch = ReadByte(f)
	
	Stamina = ReadFloat(f)
	StaminaEffect = ReadFloat(f)	
	StaminaEffectTimer = ReadFloat(f)	
	
	EyeStuck = ReadFloat(f)
	EyeIrritation = ReadFloat(f)
	
	Injuries = ReadFloat(f)
	Bloodloss = ReadFloat(f)
	
	PrevInjuries = ReadFloat(f)
	PrevBloodloss = ReadFloat(f)
	
	DeathMSG = ReadString(f)
	
	For i = 0 To 5
		SCP1025state[i]=ReadFloat(f)
	Next
	
	VomitTimer = ReadFloat(f)
	Vomit = ReadByte(f)
	CameraShakeTimer = ReadFloat(f)
	Infect = ReadFloat(f)
	
	let difficultyIndex = ReadByte(f)
	SelectedDifficulty = difficulties(difficultyIndex)
	if (difficultyIndex = CUSTOM) {
		SelectedDifficulty.aggressiveNPCs = ReadByte(f)
		SelectedDifficulty.permaDeath = ReadByte(f)
		SelectedDifficulty.saveType	= ReadByte(f)
		SelectedDifficulty.otherFactors = ReadByte(f)
	}
	
	MonitorTimer = ReadFloat(f)
	
	Sanity = ReadFloat(f)
	
	WearingGasMask = ReadByte(f)
	WearingVest = ReadByte(f)	
	WearingHazmat = ReadByte(f)
	
	WearingNightVision = ReadByte(f)
	Wearing1499 = ReadByte(f)
	NTF_1499PrevX = ReadFloat(f)
	NTF_1499PrevY = ReadFloat(f)
	NTF_1499PrevZ = ReadFloat(f)
	NTF_1499X = ReadFloat(f)
	NTF_1499Y = ReadFloat(f)
	NTF_1499Z = ReadFloat(f)
	let r1499_x: float = ReadFloat(f)
	let r1499_z: float = ReadFloat(f)
	
	SuperMan = ReadByte(f)
	SuperManTimer = ReadFloat(f)
	LightsOn = ReadByte(f)
	
	RandomSeed = ReadString(f)
	
	SecondaryLightOn = ReadFloat(f)
	PrevSecondaryLightOn = ReadFloat(f)
	RemoteDoorOn = ReadByte(f)
	SoundTransmission = ReadByte(f)	
	Contained106 = ReadByte(f)	
	
	For i = 0 To MAXACHIEVEMENTS-1
		Achievements(i)=ReadByte(f)
	Next
	RefinedItems = ReadInt(f)
	
	MapWidth = ReadInt(f)
	MapHeight = ReadInt(f)
	for (x of range(MapWidth + 1)) {
		for (y of range(MapHeight + 1)) {
			MapTemp( x, y) = ReadInt(f)
			MapFound(x, y) = ReadByte(f)
		}
	}
	
	If (ReadInt(f) <> 113) {
		RuntimeError("Couldn't load the game, save file corrupted (error 2.5)")
	}
	
	temp = ReadInt(f)
	For i = 1 To temp
		Local NPCtype% = ReadByte(f)
		x = ReadFloat(f)
		y = ReadFloat(f)
		z = ReadFloat(f)
		
		n.NPCs = CreateNPC(NPCtype, x, y, z)
		switch (NPCtype) {
			case NPCtype173:
				Curr173 = n
			case NPCtypeOldMan:
				Curr106 = n
			case NPCtype096:
				Curr096 = n
			case NPCtype5131:
				Curr5131 = n
		}
		
		x = ReadFloat(f)
		y = ReadFloat(f)
		z = ReadFloat(f)
		RotateEntity(n.Collider, x, y, z)
		
		n.State = ReadFloat(f)
		n.State2 = ReadFloat(f)	
		n.State3 = ReadFloat(f)			
		n.PrevState = ReadInt(f)
		
		n.Idle = ReadByte(f)
		n.LastDist = ReadFloat(f)
		n.LastSeen = ReadInt(f)
		
		n.CurrSpeed = ReadInt(f)
		n.Angle = ReadFloat(f)
		n.Reload = ReadFloat(f)
		
		ForceSetNPCID(n, ReadInt(f))
		n.TargetID = ReadInt(f)
		
		DebugLog("Loading NPC " +n.NVName+ " (ID "+n.ID+")")
		
		n.EnemyX = ReadFloat(f)
		n.EnemyY = ReadFloat(f)
		n.EnemyZ = ReadFloat(f)
		
		n.texture = ReadString(f)
		if (n.texture != "") {
			tex = LoadTexture_Strict (n.texture)
			EntityTexture (n.obj, tex)
		}
		
		let frame: float = ReadFloat(f)
		switch (NPCtype) {
			case NPCtypeOldMan, NPCtypeD, NPCtype096, NPCtypeMTF, NPCtypeGuard, NPCtype049, NPCtypeZombie, NPCtypeClerk:
				SetAnimTime(n.obj, frame)
		}
		
		n.Frame = frame
		
		n.IsDead = ReadInt(f)
		n.PathX = ReadFloat(f)
		n.PathZ = ReadFloat(f)
		n.HP = ReadInt(f)
		n.Model = ReadString(f)
		n.ModelScaleX = ReadFloat(f)
		n.ModelScaleY = ReadFloat(f)
		n.ModelScaleZ = ReadFloat(f)
		if (n.Model != "") {
			FreeEntity (n.obj)
			n.obj = LoadAnimMesh_Strict(n.Model)
			ScaleEntity (n.obj,n.ModelScaleX,n.ModelScaleY,n.ModelScaleZ)
			SetAnimTime (n.obj,frame)
		}
		n.TextureID = ReadInt(f)
		if (n.TextureID > 0) {
			ChangeNPCTextureID(n.NPCs,n.TextureID-1)
			SetAnimTime(n.obj,frame)
		}
	}
	
	for (n of NPCs.each) {
		if (n.TargetID != 0) {
			for (n2 of NPCs.each) {
				if (n2 != n) {
					if (n2.id = n.TargetID) {
						n.Target = n2
					}
				}
			}
		}
	}
	
	MTFtimer = ReadFloat(f)
	For i = 0 To 6
		strtemp =  ReadString(f)
		If strtemp <> "a" Then
			For r.Rooms = Each Rooms
				If r.RoomTemplate.Name = strtemp Then
					MTFrooms[i]=r
				EndIf
			Next
		EndIf
		MTFroomState[i]=ReadInt(f)
	Next
	
	If ReadInt(f) <> 632 Then RuntimeError("Couldn't load the game, save file corrupted (error 1)")
	
	room2gw_brokendoor = ReadInt(f)
	room2gw_x = ReadFloat(f)
	room2gw_z = ReadFloat(f)
	
	If version = CompatibleNumber Then
		I_Zone.Transition[0] = ReadByte(f)
		I_Zone.Transition[1] = ReadByte(f)
		I_Zone.HasCustomForest = ReadByte(f)
		I_Zone.HasCustomMT = ReadByte(f)
	EndIf
	
	temp = ReadInt(f)
	For i = 1 To temp
		Local roomtemplateID% = ReadInt(f)
		Local angle% = ReadInt(f)
		x = ReadFloat(f)
		y = ReadFloat(f)
		z = ReadFloat(f)
		
		found = ReadByte(f)
		
		level = ReadInt(f)
		
		temp2 = ReadByte(f)		
		
//		If angle >= 360
//            angle = angle-360
//        EndIf
		angle=WrapAngle(angle)
		
		For rt.roomtemplates = Each RoomTemplates
			If rt\id = roomtemplateID Then
				r.Rooms = CreateRoom(level, rt\shape, x, y, z, rt\name)
				TurnEntity(r\obj, 0, angle, 0)
				r\angle = angle
				r\found = found
				Exit
			End If
		Next
		
		If temp2 = 1 Then PlayerRoom = r.Rooms
		
		For x = 0 To 11
			id = ReadInt(f)
			If id > 0 Then
				For n.NPCs = Each NPCs
					If n\ID = id Then r\NPC[x]=n : Exit
				Next
			EndIf
		Next
		
		For x=0 To 11
			id = ReadByte(f)
			If id=2 Then
				Exit
			Else If id=1 Then
				RotateEntity(r\Levers[x], 78, EntityYaw(r\Levers[x]), 0)
			Else
				RotateEntity(r\Levers[x], -78, EntityYaw(r\Levers[x]), 0)
			EndIf
		Next
		
		If ReadByte(f)=1 Then //this room has a grid
			If r\grid<>Null Then //remove the old grid content
				For x=0 To gridsz-1
					For y=0 To gridsz-1
						If r\grid\Entities[x+(y*gridsz)]<>0 Then
							FreeEntity r\grid\Entities[x+(y*gridsz)]
							r\grid\Entities[x+(y*gridsz)]=0
						EndIf
						If r\grid\waypoints[x+(y*gridsz)]<>Null Then
							RemoveWaypoint(r\grid\waypoints[x+(y*gridsz)])
							r\grid\waypoints[x+(y*gridsz)]=Null
						EndIf
					Next
				Next
				For x=0 To 5
					If r\grid\Meshes[x]<>0 Then
						FreeEntity r\grid\Meshes[x]
						r\grid\Meshes[x]=0
					EndIf
				Next
				Delete r\grid
			EndIf
			r\grid=New Grids
			For y=0 To gridsz-1
				For x=0 To gridsz-1
					r\grid\grid[x+(y*gridsz)]=ReadByte(f)
					r\grid\angles[x+(y*gridsz)]=ReadByte(f)
					//get only the necessary data, make the event handle the meshes and waypoints separately
				Next
			Next
		EndIf
		
		Local hasForest = ReadByte(f)
		If hasForest>0 Then //this room has a forest
			If r\fr<>Null Then //remove the old forest
				DestroyForest(r\fr)
			Else
				r\fr=New Forest
			EndIf
			For y=0 To gridsize-1
				Local sssss$ = ""
				For x=0 To gridsize-1
					r\fr\grid[x+(y*gridsize)]=ReadByte(f)
					sssss=sssss+Str(r\fr\grid[x+(y*gridsize)])
				Next
				DebugLog sssss
			Next
			lx# = ReadFloat(f)
			ly# = ReadFloat(f)
			lz# = ReadFloat(f)
			If hasForest=1 Then
				PlaceForest(r\fr,lx,ly,lz,r)
			Else
				PlaceForest_MapCreator(r\fr,lx,ly,lz,r)
			EndIf
		ElseIf r\fr<>Null Then //remove the old forest
			DestroyForest(r\fr)
			Delete r\fr
		EndIf
		
	Next
	
	For r.Rooms = Each Rooms
		If r\x = r1499_x# And r\z = r1499_z#
			NTF_1499PrevRoom = r
			Exit
		EndIf
	Next
	
	If ReadInt(f) <> 954 Then RuntimeError("Couldn't load the game, save file may be corrupted (error 2)")
	
	Local spacing# = 8.0
	Local zone%,shouldSpawnDoor%
	For y = MapHeight To 0 Step -1
		
		If y<I_Zone\Transition[1]-(SelectedMap="") Then
			zone=3
		ElseIf y>=I_Zone\Transition[1]-(SelectedMap="") And y<I_Zone\Transition[0]-(SelectedMap="") Then
			zone=2
		Else
			zone=1
		EndIf
		
		For x = MapWidth To 0 Step -1
			If MapTemp(x,y) > 0 Then
				If zone = 2 Then temp=2 Else temp=0
                
                For r.Rooms = Each Rooms
					r\angle = WrapAngle(r\angle)
					If Int(r\x/8.0)=x And Int(r\z/8.0)=y Then
						shouldSpawnDoor = False
						Select r\RoomTemplate\Shape
							Case ROOM1
								If r\angle=90
									shouldSpawnDoor = True
								EndIf
							Case ROOM2
								If r\angle=90 Or r\angle=270
									shouldSpawnDoor = True
								EndIf
							Case ROOM2C
								If r\angle=0 Or r\angle=90
									shouldSpawnDoor = True
								EndIf
							Case ROOM3
								If r\angle=0 Or r\angle=180 Or r\angle=90
									shouldSpawnDoor = True
								EndIf
							Default
								shouldSpawnDoor = True
						End Select
						If shouldSpawnDoor
							If (x+1)<(MapWidth+1)
								If MapTemp(x + 1, y) > 0 Then
									door.Doors = CreateDoor(r\zone, Float(x) * spacing + spacing / 2.0, 0, Float(y) * spacing, 90, r, Max(Rand(-3, 1), 0), temp)
									r\AdjDoor[0] = door
								EndIf
							EndIf
						EndIf
						
						shouldSpawnDoor = False
						Select r\RoomTemplate\Shape
							Case ROOM1
								If r\angle=180
									shouldSpawnDoor = True
								EndIf
							Case ROOM2
								If r\angle=0 Or r\angle=180
									shouldSpawnDoor = True
								EndIf
							Case ROOM2C
								If r\angle=180 Or r\angle=90
									shouldSpawnDoor = True
								EndIf
							Case ROOM3
								If r\angle=180 Or r\angle=90 Or r\angle=270
									shouldSpawnDoor = True
								EndIf
							Default
								shouldSpawnDoor = True
						End Select
						If shouldSpawnDoor
							If (y+1)<(MapHeight+1)
								If MapTemp(x, y + 1) > 0 Then
									door.Doors = CreateDoor(r\zone, Float(x) * spacing, 0, Float(y) * spacing + spacing / 2.0, 0, r, Max(Rand(-3, 1), 0), temp)
									r\AdjDoor[3] = door
								EndIf
							EndIf
						EndIf
						
						Exit
					EndIf
                Next
                
			End If
			
		Next
	Next
	
	temp = ReadInt (f)
	
	For i = 1 To temp
		x = ReadFloat(f)
		y = ReadFloat(f)
		z = ReadFloat(f)
		
		Local open% = ReadByte(f)
		Local openstate# = ReadFloat(f)
		Local locked% = ReadByte(f)
		Local autoclose% = ReadByte(f)
		
		Local objX# = ReadFloat(f)
		Local objZ# = ReadFloat(f)
		
		Local obj2X# = ReadFloat(f)
		Local obj2Z# = ReadFloat(f)
		
		Local timer% = ReadFloat(f)
		Local timerstate# = ReadFloat(f)
		
		Local IsElevDoor = ReadByte(f)
		Local MTFClose = ReadByte(f)
		
		For door.Doors = Each Doors
			If EntityX(door\frameobj,True) = x And EntityY(door\frameobj,True) = y And EntityZ(door\frameobj,True) = z Then
				door\open = open
				door\openstate = openstate
				door\locked = locked
				door\AutoClose = autoclose
				door\timer = timer
				door\timerstate = timerstate
				door\IsElevatorDoor = IsElevDoor
				door\MTFClose = MTFClose
				
				PositionEntity(door\obj, objX, y, objZ, True)
				If door\obj2 <> 0 Then PositionEntity(door\obj2, obj2X, y, obj2Z, True)
				Exit
			End If
		Next		
	Next
	
	InitWayPoints()
	
	If ReadInt(f) <> 1845 Then RuntimeError("Couldn't load the game, save file corrupted (error 3)")
	
	Local d.Decals
	For d.Decals = Each Decals
		FreeEntity d\obj
		Delete d
	Next
	
	temp = ReadInt(f)
	For i = 1 To temp
		id% = ReadInt(f)
		x = ReadFloat(f)
		y = ReadFloat(f)
		z = ReadFloat(f)
		Local pitch# = ReadFloat(f)
		Local yaw# = ReadFloat(f)
		Local roll# = ReadFloat(f)
		d.Decals = CreateDecal(id, x, y, z, pitch, yaw, roll)
		d\blendmode = ReadByte (f)
		d\fx = ReadInt(f)
		
		d\Size = ReadFloat(f)
		d\Alpha = ReadFloat(f)
		d\AlphaChange = ReadFloat(f)
		d\Timer = ReadFloat(f)
		d\lifetime = ReadFloat(f)
		
		ScaleSprite(d\obj, d\Size, d\Size)
		EntityBlend d\obj, d\blendmode
		EntityFX d\obj, d\fx
		
		DebugLog "Created Decal @"+x+","+y+","+z
	Next
	UpdateDecals()
	
	temp = ReadInt(f)
	For i = 1 To temp
		Local e.Events = New Events
		e\EventName = ReadString(f)
		
		e\EventState =ReadFloat(f)
		e\EventState2 =ReadFloat(f)		
		e\EventState3 =ReadFloat(f)
		x = ReadFloat(f)
		z = ReadFloat(f)
		For  r.Rooms = Each Rooms
			If EntityX(r\obj) = x And EntityZ(r\obj) = z Then
				e\room = r
				Exit
			EndIf
		Next
		e\EventStr = ReadString(f)
	Next
	
	For e.Events = Each Events
		//Reset for the monitor loading and stuff for room2sl
		If e\EventName = "room2sl"
			e\EventState = 0.0
			e\EventStr = ""
			DebugLog "Reset Eventstate in "+e\EventName
		//Reset dimension1499
		ElseIf e\EventName = "dimension1499"
			If e\EventState > 0.0
				e\EventState = 0.0
				e\EventStr = ""
				HideChunks()
				DeleteChunks()
				For n.NPCs = Each NPCs
					If n\NPCtype = NPCtype1499
						If n\InFacility = 0
							RemoveNPC(n)
						EndIf
					EndIf
				Next
				DebugLog "Reset Eventstate in "+e\EventName
			EndIf
		//Reset the forest event to make it loading properly
		ElseIf e\EventName = "room860"
			e\EventStr = ""
		ElseIf e\EventName = "room205"
			e\EventStr = ""
		ElseIf e\EventName = "room106"
			If e\EventState2 = False Then
				PositionEntity (e\room\Objects[6],EntityX(e\room\Objects[6],True),-1280.0*RoomScale,EntityZ(e\room\Objects[6],True),True)
			EndIf
		EndIf
	Next
	
	Local it.Items
	For it.Items = Each Items
		RemoveItem(it)
	Next
	
	temp = ReadInt(f)
	For i = 1 To temp
		Local ittName$ = ReadString(f)
		Local tempName$ = ReadString(f)
		Local Name$ = ReadString(f)
		
		If tempName = "50ct" Then
			ittName = "Quarter"
			tempName = "25ct"
		EndIf
		
		x = ReadFloat(f)
		y = ReadFloat(f)
		z = ReadFloat(f)
		
		red = ReadByte(f)
		green = ReadByte(f)
		blue = ReadByte(f)		
		a = ReadFloat(f)
		
		it.Items = CreateItem(ittName, tempName, x, y, z, red,green,blue,a)
		it\name = Name
		
		EntityType it\collider, HIT_ITEM
		
		x = ReadFloat(f)
		y = ReadFloat(f)
		RotateEntity(it\collider, x, y, 0)
		
		it\state = ReadFloat(f)
		it\Picked = ReadByte(f)
		If it\Picked Then HideEntity(it\collider)
		
		nt = ReadByte(f)
		If nt = True Then SelectedItem = it
		
		nt = ReadByte(f)
		If nt < 66
			Inventory(nt) = it
			ItemAmount = ItemAmount + 1
		EndIf
		
		For itt.ItemTemplates = Each ItemTemplates
			If (itt\tempname = tempName) And (itt\name = ittName) Then
				If itt\isAnim<>0 Then SetAnimTime it\model,ReadFloat(f) : Exit
			EndIf
		Next
		it\invSlots = ReadByte(f)
		it\ID = ReadInt(f)
		
		If it\ID>LastItemID Then LastItemID=it\ID
		
		If ReadByte(f)=0 Then
			it\invimg=it\itemtemplate\invimg
		Else
			it\invimg=it\itemtemplate\invimg2
		EndIf
	Next	
	
	Local o_i%
	
	temp = ReadInt(f)
	For i=1 To temp
		//OtherInv
		o_i=ReadInt(f)
		
		For ij.Items = Each Items
			If ij\ID=o_i Then it.Items=ij : Exit
		Next
		For j%=0 To it\invSlots-1
			o_i=ReadInt(f)
			DebugLog "secondinv "+o_i
			If o_i<>-1 Then
				For ij.Items=Each Items
					If ij\ID=o_i Then
						it\SecondInv[j]=ij
						Exit
					EndIf
				Next
			EndIf
		Next
		//OtherInv End
	Next
	
	For itt.ItemTemplates = Each ItemTemplates
		itt\found = ReadByte(f)
	Next
	
	For door.Doors = Each Doors
		If door\room <> Null Then
			dist# = 20.0
			Local closestroom.Rooms
			For r.Rooms = Each Rooms
				dist2# = EntityDistance(r\obj, door\obj)
				If dist2 < dist Then
					dist = dist2
					closestroom = r.Rooms
				EndIf
			Next
			door\room = closestroom
		EndIf
	Next
	
	//If ReadInt(f) <> 994 Then RuntimeError("Couldn't load the game, save file corrupted (error 4)")
	
	If ReadInt(f)<>994
		UsedConsole = True
		DebugLog "Used Console"
	EndIf
	
	CameraFogFar = ReadFloat(f)
    StoredCameraFogFar = ReadFloat(f)
	If CameraFogFar = 0 Then
		CameraFogFar = 6
	EndIf
	I_427\Using = ReadByte(f)
	I_427\Timer = ReadFloat(f)
	
	If version = "1.3.10" Then
		I_Zone\Transition[0] = ReadByte(f)
		I_Zone\Transition[1] = ReadByte(f)
		I_Zone\HasCustomForest = ReadByte(f)
		I_Zone\HasCustomMT = ReadByte(f)
	EndIf
	
	Wearing714 = ReadByte(f)
	
	CloseFile f
	
	For r.Rooms = Each Rooms
		r\Adjacent[0]=Null
		r\Adjacent[1]=Null
		r\Adjacent[2]=Null
		r\Adjacent[3]=Null
		For r2.Rooms = Each Rooms
			If r<>r2 Then
				If r2\z=r\z Then
					If (r2\x)=(r\x+8.0) Then
						r\Adjacent[0]=r2
						If r\AdjDoor[0] = Null Then r\AdjDoor[0] = r2\AdjDoor[2]
					ElseIf (r2\x)=(r\x-8.0)
						r\Adjacent[2]=r2
						If r\AdjDoor[2] = Null Then r\AdjDoor[2] = r2\AdjDoor[0]
					EndIf
				ElseIf r2\x=r\x Then
					If (r2\z)=(r\z-8.0) Then
						r\Adjacent[1]=r2
						If r\AdjDoor[1] = Null Then r\AdjDoor[1] = r2\AdjDoor[3]
					ElseIf (r2\z)=(r\z+8.0)
						r\Adjacent[3]=r2
						If r\AdjDoor[3] = Null Then r\AdjDoor[3] = r2\AdjDoor[1]
					EndIf
				EndIf
			EndIf
			If (r\Adjacent[0]<>Null) And (r\Adjacent[1]<>Null) And (r\Adjacent[2]<>Null) And (r\Adjacent[3]<>Null) Then Exit
		Next
		
		For door.Doors = Each Doors
			If (door\KeyCard = 0) And (door\Code="") Then
				If EntityZ(door\frameobj,True)=r\z Then
					If EntityX(door\frameobj,True)=r\x+4.0 Then
						r\AdjDoor[0] = door
					ElseIf EntityX(door\frameobj,True)=r\x-4.0 Then
						r\AdjDoor[2] = door
					EndIf
				ElseIf EntityX(door\frameobj,True)=r\x Then
					If EntityZ(door\frameobj,True)=r\z+4.0 Then
						r\AdjDoor[3] = door
					ElseIf EntityZ(door\frameobj,True)=r\z-4.0 Then
						r\AdjDoor[1] = door
					EndIf
				EndIf
			EndIf
		Next
	Next
	
	If PlayerRoom\RoomTemplate\Name = "dimension1499"
		BlinkTimer = -1
		ShouldEntitiesFall = False
		PlayerRoom = NTF_1499PrevRoom
		UpdateDoors()
		UpdateRooms()
		For it.Items = Each Items
			it\disttimer = 0
		Next
	EndIf
	
	If Collider <> 0 Then
		If PlayerRoom<>Null Then
			ShowEntity PlayerRoom\obj
		EndIf
		ShowEntity Collider
		TeleportEntity(Collider,EntityX(Collider),EntityY(Collider)+0.5,EntityZ(Collider),0.3,True)
		If PlayerRoom<>Null Then
			HideEntity PlayerRoom\obj
		EndIf
	EndIf
	
	UpdateDoorsTimer = 0
	
	CatchErrors("LoadGame")
}

function LoadGameQuick(file$) {
	Local version$ = ""
	
	CatchErrors("Uncaught (LoadGameQuick)")
	DebugLog "---------------------------------------------------------------------------"
	
	DebugHUD = False
	GameSaved = True
	NoTarget = False
	InfiniteStamina = False
	IsZombie% = False
	DeafPlayer% = False
	DeafTimer# = 0.0
	UnableToMove% = False
	Msg = ""
	SelectedEnding = ""
	
	PositionEntity Collider,0,1000.0,0,True
	ResetEntity Collider
	
	Local x#, y#, z#, i%, temp%, strtemp$, id%
	Local player_x#,player_y#,player_z#, r.Rooms, n.NPCs, door.Doors
	Local f% = ReadFile(file + "save.txt")
	
	strtemp = ReadString(f)
	strtemp = ReadString(f)
	
	DropSpeed = -0.1
	HeadDropSpeed = 0.0
	Shake = 0
	CurrSpeed = 0
	
	HeartBeatVolume = 0
	
	CameraShake = 0
	Shake = 0
	LightFlash = 0
	BlurTimer = 0
	
	KillTimer = 0
	FallTimer = 0
	MenuOpen = False
	
	GodMode = 0
	NoClip = 0
	
	PlayTime = ReadInt(f)
	
	//HideEntity Head
	HideEntity Collider
	
	x = ReadFloat(f)
	y = ReadFloat(f)
	z = ReadFloat(f)	
	PositionEntity(Collider, x, y+0.05, z)
	//ResetEntity(Collider)
	
	ShowEntity Collider
	
	x = ReadFloat(f)
	y = ReadFloat(f)
	z = ReadFloat(f)	
	PositionEntity(Head, x, y+0.05, z)
	ResetEntity(Head)
	
	AccessCode = Int(ReadString(f))
	
	x = ReadFloat(f)
	y = ReadFloat(f)
	RotateEntity(Collider, x, y, 0, 0)
	
	strtemp = ReadString(f)
	version = strtemp
	
	BlinkTimer = ReadFloat(f)
	BlinkEffect = ReadFloat(f)	
	BlinkEffectTimer = ReadFloat(f)	
	
	DeathTimer = ReadInt(f)	
	BlurTimer = ReadInt(f)	
	HealTimer = ReadFloat(f)
	
	Crouch = ReadByte(f)
	
	Stamina = ReadFloat(f)
	StaminaEffect = ReadFloat(f)	
	StaminaEffectTimer = ReadFloat(f)	
	
	EyeStuck	= ReadFloat(f)
	EyeIrritation= ReadFloat(f)
	
	Injuries = ReadFloat(f)
	Bloodloss = ReadFloat(f)
	
	PrevInjuries = ReadFloat(f)
	PrevBloodloss = ReadFloat(f)
	
	DeathMSG = ReadString(f)
	
	For i = 0 To 5
		SCP1025state[i]=ReadFloat(f)
	Next
	
	VomitTimer = ReadFloat(f)
	Vomit = ReadByte(f)
	CameraShakeTimer = ReadFloat(f)
	Infect = ReadFloat(f)
	
	Local difficultyIndex = ReadByte(f)
	SelectedDifficulty = difficulties(difficultyIndex)
	If (difficultyIndex = CUSTOM) Then
		SelectedDifficulty\aggressiveNPCs = ReadByte(f)
		SelectedDifficulty\permaDeath = ReadByte(f)
		SelectedDifficulty\saveType	= ReadByte(f)
		SelectedDifficulty\otherFactors = ReadByte(f)
	EndIf
	
	MonitorTimer = ReadFloat(f)
	
	Sanity = ReadFloat(f)
	
	WearingGasMask = ReadByte(f)
	WearingVest = ReadByte(f)	
	WearingHazmat = ReadByte(f)
	
	WearingNightVision = ReadByte(f)
	Wearing1499 = ReadByte(f)
	NTF_1499PrevX# = ReadFloat(f)
	NTF_1499PrevY# = ReadFloat(f)
	NTF_1499PrevZ# = ReadFloat(f)
	NTF_1499X# = ReadFloat(f)
	NTF_1499Y# = ReadFloat(f)
	NTF_1499Z# = ReadFloat(f)
	Local r1499_x# = ReadFloat(f)
	Local r1499_z# = ReadFloat(f)
	
	SuperMan = ReadByte(f)
	SuperManTimer = ReadFloat(f)
	LightsOn = ReadByte(f)
	
	RandomSeed = ReadString(f)
	
	SecondaryLightOn = ReadFloat(f)
	PrevSecondaryLightOn = ReadFloat(f)
	RemoteDoorOn = ReadByte(f)
	SoundTransmission = ReadByte(f)	
	Contained106 = ReadByte(f)	
	
	For i = 0 To MAXACHIEVEMENTS-1
		Achievements(i)=ReadByte(f)
	Next
	RefinedItems = ReadInt(f)
	
	MapWidth = ReadInt(f)
	MapHeight = ReadInt(f)
	DebugLog MapWidth
	DebugLog MapHeight
	For x = 0 To MapWidth
		For y = 0 To MapHeight
			MapTemp(x, y) = ReadInt(f)
			MapFound(x, y) = ReadByte(f)
		Next
	Next
	
	If ReadInt(f) <> 113 Then RuntimeError("Couldn't load the game, save file corrupted (error 2.5)")
	
	For n.NPCs = Each NPCs
		RemoveNPC(n)
	Next
	
	temp = ReadInt(f)
	For i = 1 To temp
		Local NPCtype% = ReadByte(f)
		x = ReadFloat(f)
		y = ReadFloat(f)
		z = ReadFloat(f)
		
		n.NPCs = CreateNPC(NPCtype, x, y, z)
		Select NPCtype
			Case NPCtype173
				Curr173 = n
			Case NPCtypeOldMan
				Curr106 = n
			Case NPCtype096
				Curr096 = n
			Case NPCtype5131
				Curr5131 = n
		End Select
		
		x = ReadFloat(f)
		y = ReadFloat(f)
		z = ReadFloat(f)
		RotateEntity(n\Collider, x, y, z)
		
		n\State = ReadFloat(f)
		n\State2 = ReadFloat(f)	
		n\State3 = ReadFloat(f)			
		n\PrevState = ReadInt(f)
		
		n\Idle = ReadByte(f)
		n\LastDist = ReadFloat(f)
		n\LastSeen = ReadInt(f)
		
		n\CurrSpeed = ReadInt(f)
		n\Angle = ReadFloat(f)
		n\Reload = ReadFloat(f)
		
		ForceSetNPCID(n, ReadInt(f))
		n\TargetID = ReadInt(f)
		
		n\EnemyX = ReadFloat(f)
		n\EnemyY = ReadFloat(f)
		n\EnemyZ = ReadFloat(f)
		
		n\texture = ReadString(f)
		If n\texture <> "" Then
			tex = LoadTexture_Strict (n\texture)
			EntityTexture n\obj, tex
		EndIf
		
		Local frame# = ReadFloat(f)
		Select NPCtype
			Case NPCtypeOldMan, NPCtypeD, NPCtype096, NPCtypeMTF, NPCtypeGuard, NPCtype049, NPCtypeZombie, NPCtypeClerk
				SetAnimTime(n\obj, frame)
		End Select		
		
		n\Frame = frame
		
		n\IsDead = ReadInt(f)
		n\PathX = ReadFloat(f)
		n\PathZ = ReadFloat(f)
		n\HP = ReadInt(f)
		n\Model = ReadString(f)
		n\ModelScaleX# = ReadFloat(f)
		n\ModelScaleY# = ReadFloat(f)
		n\ModelScaleZ# = ReadFloat(f)
		If n\Model <> ""
			FreeEntity n\obj
			n\obj = LoadAnimMesh_Strict(n\Model)
			ScaleEntity n\obj,n\ModelScaleX,n\ModelScaleY,n\ModelScaleZ
			SetAnimTime n\obj,frame
		EndIf
		n\TextureID = ReadInt(f)
		If n\TextureID > 0
			ChangeNPCTextureID(n.NPCs,n\TextureID-1)
			SetAnimTime(n\obj,frame)
		EndIf
	Next
	
	For n.NPCs = Each NPCs
		If n\TargetID <> 0 Then
			For n2.npcs = Each NPCs
				If n2<>n Then
					If n2\id = n\TargetID Then n\Target = n2
				EndIf
			Next
		EndIf
	Next
	
	MTFtimer = ReadFloat(f)
	For i = 0 To 6
		strtemp =  ReadString(f)
		If strtemp <> "a" Then
			For r.Rooms = Each Rooms
				If r\RoomTemplate\Name = strtemp Then
					MTFrooms[i]=r
				EndIf
			Next
		EndIf
		MTFroomState[i]=ReadInt(f)
	Next
	
	If ReadInt(f) <> 632 Then RuntimeError("Couldn't load the game, save file corrupted (error 1)")
	
	room2gw_brokendoor = ReadInt(f)
	room2gw_x = ReadFloat(f)
	room2gw_z = ReadFloat(f)
	
	If version = CompatibleNumber Then
		I_Zone\Transition[0] = ReadByte(f)
		I_Zone\Transition[1] = ReadByte(f)
		I_Zone\HasCustomForest = ReadByte(f)
		I_Zone\HasCustomMT = ReadByte(f)
	EndIf
	
	temp = ReadInt(f)
	For i = 1 To temp
		Local roomtemplateID% = ReadInt(f)
		Local angle% = ReadInt(f)
		x = ReadFloat(f)
		y = ReadFloat(f)
		z = ReadFloat(f)
		
		found = ReadByte(f)
		
		level = ReadInt(f)
		
		temp2 = ReadByte(f)	
		
		If angle >= 360
            angle = angle-360
        EndIf
		
		For r.Rooms = Each Rooms
			If r\x = x And r\z = z Then
				Exit
			EndIf
		Next
		
		For x = 0 To 11
			id = ReadInt(f)
			If id > 0 Then
				For n.NPCs = Each NPCs
					If n\ID = id Then r\NPC[x]=n : Exit
				Next
			EndIf
		Next
		
		For x=0 To 11
			id = ReadByte(f)
			If id=2 Then
				Exit
			Else If id=1 Then
				RotateEntity(r\Levers[x], 78, EntityYaw(r\Levers[x]), 0)
			Else
				RotateEntity(r\Levers[x], -78, EntityYaw(r\Levers[x]), 0)
			EndIf
		Next
		
		If ReadByte(f)=1 Then //this room has a grid
			For y=0 To gridsz-1
				For x=0 To gridsz-1
					ReadByte(f) : ReadByte(f)
				Next
			Next
		Else //this grid doesn't exist in the save
			If r\grid<>Null Then
				For x=0 To gridsz-1
					For y=0 To gridsz-1
						If r\grid\Entities[x+(y*gridsz)]<>0 Then
							FreeEntity r\grid\Entities[x+(y*gridsz)]
							r\grid\Entities[x+(y*gridsz)]=0
						EndIf
						If r\grid\waypoints[x+(y*gridsz)]<>Null Then
							RemoveWaypoint(r\grid\waypoints[x+(y*gridsz)])
							r\grid\waypoints[x+(y*gridsz)]=Null
						EndIf
					Next
				Next
				For x=0 To 5
					If r\grid\Meshes[x]<>0 Then
						FreeEntity r\grid\Meshes[x]
						r\grid\Meshes[x]=0
					EndIf
				Next
				Delete r\grid
				r\grid=Null
			EndIf
		EndIf
		
		If ReadByte(f)>0 Then //this room has a forest
			For y=0 To gridsize-1
				For x=0 To gridsize-1
					ReadByte(f)
				Next
			Next
			lx# = ReadFloat(f)
			ly# = ReadFloat(f)
			lz# = ReadFloat(f)
		ElseIf r\fr<>Null Then //remove the old forest
			DestroyForest(r\fr)
			Delete r\fr
		EndIf
		
		If temp2 = 1 Then PlayerRoom = r.Rooms
	Next
	
	For r.Rooms = Each Rooms
		If r\x = r1499_x# And r\z = r1499_z#
			NTF_1499PrevRoom = r
			Exit
		EndIf
	Next
	
	//InitWayPoints()
	
	If ReadInt(f) <> 954 Then RuntimeError("Couldn't load the game, save file may be corrupted (error 2)")
	
	temp = ReadInt (f)
	
	For i = 1 To temp
		x = ReadFloat(f)
		y = ReadFloat(f)
		z = ReadFloat(f)
		
		Local open% = ReadByte(f)
		Local openstate# = ReadFloat(f)
		Local locked% = ReadByte(f)
		Local autoclose% = ReadByte(f)
		
		Local objX# = ReadFloat(f)
		Local objZ# = ReadFloat(f)
		
		Local obj2X# = ReadFloat(f)
		Local obj2Z# = ReadFloat(f)
		
		Local timer% = ReadFloat(f)
		Local timerstate# = ReadFloat(f)
		
		Local IsElevDoor = ReadByte(f)
		Local MTFClose = ReadByte(f)
		
		For door.Doors = Each Doors
			If EntityX(door\frameobj,True) = x Then 
				If EntityZ(door\frameobj,True) = z Then	
					If EntityY(door\frameobj,True) = y 
						door\open = open
						door\openstate = openstate
						door\locked = locked
						door\AutoClose = autoclose
						door\timer = timer
						door\timerstate = timerstate
						door\IsElevatorDoor = IsElevDoor
						door\MTFClose = MTFClose
						
						PositionEntity(door\obj, objX, EntityY(door\obj), objZ, True)
						If door\obj2 <> 0 Then PositionEntity(door\obj2, obj2X, EntityY(door\obj2), obj2Z, True)
						
						Exit
					EndIf
				EndIf
			End If
		Next		
	Next
	
	If ReadInt(f) <> 1845 Then RuntimeError("Couldn't load the game, save file corrupted (error 3)")
	
	Local d.Decals
	For d.Decals = Each Decals
		FreeEntity d\obj
		Delete d
	Next
	
	temp = ReadInt(f)
	For i = 1 To temp
		id% = ReadInt(f)
		x = ReadFloat(f)
		y = ReadFloat(f)
		z = ReadFloat(f)
		Local pitch# = ReadFloat(f)
		Local yaw# = ReadFloat(f)
		Local roll# = ReadFloat(f)
		d.Decals = CreateDecal(id, x, y, z, pitch, yaw, roll)
		d\blendmode = ReadByte (f)
		d\fx = ReadInt(f)
		
		d\Size = ReadFloat(f)
		d\Alpha = ReadFloat(f)
		d\AlphaChange = ReadFloat(f)
		d\Timer = ReadFloat(f)
		d\lifetime = ReadFloat(f)
		
		ScaleSprite(d\obj, d\Size, d\Size)
		EntityBlend d\obj, d\blendmode
		EntityFX d\obj, d\fx
		
		DebugLog "Created Decal @"+x+","+y+","+z
	Next
	UpdateDecals()
	
	Local e.Events
	For e.Events = Each Events
		If e\Sound <> 0 Then FreeSound_Strict e\Sound
		Delete e
	Next
	
	temp = ReadInt(f)
	For i = 1 To temp
		e.Events = New Events
		e\EventName = ReadString(f)
		
		e\EventState = ReadFloat(f)
		e\EventState2 = ReadFloat(f)
		e\EventState3 = ReadFloat(f)		
		x = ReadFloat(f)
		z = ReadFloat(f)
		For r.Rooms = Each Rooms
			If EntityX(r\obj) = x And EntityZ(r\obj) = z Then
				//If e\EventName = "room2servers" Then Stop
				e\room = r
				Exit
			EndIf
		Next	
		e\EventStr = ReadString(f)
		If e\EventName = "alarm"
			//A hacky fix for the case that the intro objects aren't loaded when they should
			//Altough I'm too lazy to add those objects there because at the time where you can save, those objects are already in the ground anyway - ENDSHN
			If e\room\Objects[0]=0
				e\room\Objects[0]=CreatePivot()
				e\room\Objects[1]=CreatePivot()
			EndIf
		ElseIf e\EventName = "room860" Then
			If e\EventState = 1.0 Then
				ShowEntity e\room\fr\Forest_Pivot
			EndIf
		EndIf
	Next
	
	Local it.Items
	For it.Items = Each Items
		RemoveItem(it)
	Next
	
	temp = ReadInt(f)
	For i = 1 To temp
		Local ittName$ = ReadString(f)
		Local tempName$ = ReadString(f)
		Local Name$ = ReadString(f)
		
		If tempName = "50ct" Then
			ittName = "Quarter"
			tempName = "25ct"
		EndIf
		
		x = ReadFloat(f)
		y = ReadFloat(f)
		z = ReadFloat(f)
		
		red = ReadByte(f)
		green = ReadByte(f)
		blue = ReadByte(f)		
		a = ReadFloat(f)
		
		it.Items = CreateItem(ittName, tempName, x, y, z, red,green,blue,a)
		it\name = Name
		
		EntityType it\collider, HIT_ITEM
		
		x = ReadFloat(f)
		y = ReadFloat(f)
		RotateEntity(it\collider, x, y, 0)
		
		it\state = ReadFloat(f)
		it\Picked = ReadByte(f)
		If it\Picked Then HideEntity(it\collider)
		
		nt = ReadByte(f)
		If nt = True Then SelectedItem = it
		
		nt = ReadByte(f)
		If nt < 66
			Inventory(nt) = it
			ItemAmount = ItemAmount + 1
		EndIf
		
		For itt.ItemTemplates = Each ItemTemplates
			If itt\tempname = tempName Then
				If itt\isAnim<>0 Then SetAnimTime it\model,ReadFloat(f) : Exit
			EndIf
		Next
		it\invSlots = ReadByte(f)
		it\ID = ReadInt(f)
		
		If it\ID>LastItemID Then LastItemID=it\ID
		
		If ReadByte(f)=0 Then
			it\invimg=it\itemtemplate\invimg
		Else
			it\invimg=it\itemtemplate\invimg2
		EndIf
	Next	
	
	Local o_i%
	
	temp = ReadInt(f)
	For i=1 To temp
		//OtherInv
		o_i=ReadInt(f)
		
		For ij.Items = Each Items
			If ij\ID=o_i Then it.Items=ij : Exit
		Next
		For j%=0 To it\invSlots-1
			o_i=ReadInt(f)
			If o_i<>-1 Then
				For ij.Items=Each Items
					If ij\ID=o_i Then
						it\SecondInv[j]=ij
						Exit
					EndIf
				Next
			EndIf
		Next
		//OtherInv End
	Next
	For itt.ItemTemplates = Each ItemTemplates
		itt\found = ReadByte(f)
	Next
	
	For door.Doors = Each Doors
		If door\room <> Null Then
			dist# = 20.0
			Local closestroom.Rooms
			For r.Rooms = Each Rooms
				dist2# = EntityDistance(r\obj, door\obj)
				If dist2 < dist Then
					dist = dist2
					closestroom = r.Rooms
				EndIf
			Next
			door\room = closestroom
		EndIf
	Next
	
	//If ReadInt(f) <> 994 Then RuntimeError("Couldn't load the game, save file corrupted (error 4)")
	
	If ReadInt(f)<>994
		UsedConsole = True
		DebugLog "Used Console"
	EndIf
	
	If 0 Then 
		closestroom = Null
		dist = 30
		For r.Rooms = Each Rooms
			dist2# = EntityDistance(r\obj, Collider)
			If dist2 < dist Then
				dist = dist2
				closestroom = r
			EndIf
		Next
		
		If closestroom<>Null Then PlayerRoom = closestroom
	EndIf
	
	//This will hopefully fix the 895 crash bug after the player died by it's sanity effect and then quickloaded the game - ENDSHN
	For sc.SecurityCams = Each SecurityCams
		sc\PlayerState = 0
	Next
	EntityTexture NVOverlay,NVTexture
	RestoreSanity = True
	
	CameraFogFar = ReadFloat(f)
    StoredCameraFogFar = ReadFloat(f)
	If CameraFogFar = 0 Then
		CameraFogFar = 6
	EndIf
	I_427\Using = ReadByte(f)
	I_427\Timer = ReadFloat(f)
	
	If version = "1.3.10" Then
		I_Zone\Transition[0] = ReadByte(f)
		I_Zone\Transition[1] = ReadByte(f)
		I_Zone\HasCustomForest = ReadByte(f)
		I_Zone\HasCustomMT = ReadByte(f)
	EndIf
	
	Wearing714 = ReadByte(f)
	CloseFile f
	
	If Collider <> 0 Then
		If PlayerRoom<>Null Then
			ShowEntity PlayerRoom\obj
		EndIf
		ShowEntity Collider
		TeleportEntity(Collider,EntityX(Collider),EntityY(Collider)+0.5,EntityZ(Collider),0.3,True)
		If PlayerRoom<>Null Then
			HideEntity PlayerRoom\obj
		EndIf
	EndIf
	
	UpdateDoorsTimer = 0
	
	//Free some entities that could potentially cause memory leaks (for the endings)
	//This is only required for the LoadGameQuick function, as the other one is from the menu where everything is already deleted anyways
	Local xtemp#,ztemp#
	If Sky <> 0 Then
		FreeEntity Sky
		Sky = 0
	EndIf
	For r.Rooms = Each Rooms
		If r\RoomTemplate\Name = "gatea" Then
			If r\Objects[0]<>0 Then
				FreeEntity r\Objects[0] : r\Objects[0] = 0
				xtemp#=EntityX(r\Objects[9],True)
				ztemp#=EntityZ(r\Objects[9],True)
				FreeEntity r\Objects[9] : r\Objects[9] = 0
				r\Objects[10] = 0 //r\Objects[10] is already deleted because it is a parent object to r\Objects[9] which is already deleted a line before
				//Readding this object, as it is originally inside the "FillRoom" function but gets deleted when it loads GateA
				r\Objects[9]=CreatePivot()
				PositionEntity(r\Objects[9], xtemp#, r\y+992.0*RoomScale, ztemp#, True)
				EntityParent r\Objects[9], r\obj
				//The GateA wall pieces
				xtemp# = EntityX(r\Objects[13],True)
				ztemp# = EntityZ(r\Objects[13],True)
				FreeEntity r\Objects[13]
				r\Objects[13]=LoadMesh_Strict("GFX\map\gateawall1.b3d",r\obj)
				PositionEntity(r\Objects[13], xtemp#, r\y-1045.0*RoomScale, ztemp#, True)
				EntityColor r\Objects[13], 25,25,25
				EntityType r\Objects[13],HIT_MAP
				xtemp# = EntityX(r\Objects[14],True)
				ztemp# = EntityZ(r\Objects[14],True)
				FreeEntity r\Objects[14]
				r\Objects[14]=LoadMesh_Strict("GFX\map\gateawall2.b3d",r\obj)
				PositionEntity(r\Objects[14], xtemp#, r\y-1045.0*RoomScale, ztemp#, True)	
				EntityColor r\Objects[14], 25,25,25
				EntityType r\Objects[14],HIT_MAP
			EndIf
			If r\Objects[12]<>0 Then
				FreeEntity r\Objects[12] : r\Objects[12] = 0
				FreeEntity r\Objects[17] : r\Objects[17] = 0
			EndIf
		ElseIf r\RoomTemplate\Name = "exit1" Then
			If r\Objects[0]<>0 Then
				xtemp# = EntityX(r\Objects[0],True)
				ztemp# = EntityZ(r\Objects[0],True)
				FreeEntity r\Objects[0] : r\Objects[0] = 0
				r\Objects[0] = CreatePivot(r\obj)
				PositionEntity(r\Objects[0], xtemp#, 9767.0*RoomScale, ztemp#, True)
			EndIf
		EndIf
	Next
	//Resetting some stuff (those get changed when going to the endings)
	CameraFogMode(Camera, 1)
	HideDistance# = 15.0
	
	CatchErrors("LoadGameQuick")
}

function LoadSaveGames() {
	CatchErrors("Uncaught (LoadSaveGames)")
	SaveGameAmount = 0
	If FileType(SavePath)=1 Then RuntimeError "Can't create dir "+Chr(34)+SavePath+Chr(34)
	If FileType(SavePath)=0 Then CreateDir(SavePath)
	myDir=ReadDir(SavePath) 
	Repeat 
		file$=NextFile$(myDir) 
		If file$="" Then Exit 
		If FileType(SavePath+"\"+file$) = 2 Then 
			If file <> "." And file <> ".." Then 
				If (FileType(SavePath + file + "\save.txt")>0) Then
					SaveGameAmount=SaveGameAmount+1
				EndIf
			EndIf
		End If 
	Forever 
	CloseDir myDir 
	
	Dim SaveGames$(SaveGameAmount+1) 
	
	myDir=ReadDir(SavePath) 
	i = 0
	Repeat 
		file$=NextFile$(myDir) 
		If file$="" Then Exit 
		If FileType(SavePath+"\"+file$) = 2 Then 
			If file <> "." And file <> ".." Then 
				If (FileType(SavePath + file + "\save.txt")>0) Then
					SaveGames(i) = file
					i=i+1
				EndIf
			EndIf
		End If 
	Forever 
	CloseDir myDir 
	
	Dim SaveGameTime$(SaveGameAmount + 1)
	Dim SaveGameDate$(SaveGameAmount + 1)
	Dim SaveGameVersion$(SaveGameAmount + 1)
	For i = 1 To SaveGameAmount
		DebugLog (SavePath + SaveGames(i - 1) + "\save.txt")
		Local f% = ReadFile(SavePath + SaveGames(i - 1) + "\save.txt")
		SaveGameTime(i - 1) = ReadString(f)
		SaveGameDate(i - 1) = ReadString(f)
		//Skip all data until the CompatibleVersion number
		ReadInt(f)
		For j = 0 To 5
			ReadFloat(f)
		Next
		ReadString(f)
		ReadFloat(f)
		ReadFloat(f)
		//End Skip
		SaveGameVersion(i - 1) = ReadString(f)
		
		CloseFile f
	Next
	
	CatchErrors("LoadSaveGames")
}


function LoadSavedMaps() {
	CatchErrors("Uncaught (LoadSavedMaps)")
	Local i%, Dir, file$
	
	For i = 0 To SavedMapsAmount
		SavedMaps(i)=""
		SavedMapsAuthor(i)=""
	Next
	SavedMapsAmount = 0
	
	Dir=ReadDir("Map Creator\Maps")
	Repeat
		file$=NextFile$(Dir)
		
		DebugLog file
		
		If file$="" Then Exit
		DebugLog (CurrentDir()+"Map Creator\Maps\"+file$)
		If FileType(CurrentDir()+"Map Creator\Maps\"+file$) = 1 Then 
			If file <> "." And file <> ".." Then
				If Right(file,6)="cbmap2" Or Right(file,5)="cbmap" Then
					SavedMapsAmount = SavedMapsAmount + 1
				EndIf
			EndIf
		EndIf 
	Forever 
	CloseDir Dir
	
	Dim SavedMaps(SavedMapsAmount+1)
	Dim SavedMapsAuthor$(SavedMapsAmount+1)
	
	i = 0
	Dir=ReadDir("Map Creator\Maps") 
	Repeat
		file$=NextFile$(Dir)
		
		DebugLog file
		
		If file$="" Then Exit
		DebugLog (CurrentDir()+"Map Creator\Maps\"+file$)
		If FileType(CurrentDir()+"Map Creator\Maps\"+file$) = 1 Then 
			If file <> "." And file <> ".." Then
				If Right(file,6)="cbmap2" Or Right(file,5)="cbmap" Then
					SavedMaps(i) = file
					If Right(file,6)="cbmap2" Then
						Local f = ReadFile("Map Creator\Maps\"+file)
						SavedMapsAuthor$(i) = ReadLine(f)
						CloseFile f
					Else
						SavedMapsAuthor$(i) = "[Unknown]"
					EndIf
					i=i+1
				EndIf
			EndIf
		EndIf 
	Forever 
	CloseDir Dir 
	CatchErrors("LoadSavedMaps")
}

function LoadMap(file$) {
	CatchErrors("Uncaught (LoadMap)")
	Local f%, x%, y%, name$, angle%, prob#
	Local r.Rooms, rt.RoomTemplates, e.Events
	Local roomamount%,forestpieceamount%,mtpieceamount%,i%
	
	f% = ReadFile(file)
	DebugLog file
	
	Dim MapTemp%(MapWidth+1, MapHeight+1)
	Dim MapFound%(MapWidth+1, MapHeight+1)
	CoffinDistance = 100
	
	For x = 0 To MapWidth+1
		For y = 0 To MapHeight+1
			MapTemp(x,y)=False
			MapFound(x,y)=False
		Next
	Next
	
	If Right(file,6)="cbmap2" Then
		ReadLine(f)
		ReadLine(f)
		I_Zone\Transition[0] = ReadByte(f)
		I_Zone\Transition[1] = ReadByte(f)
		roomamount = ReadInt(f)
		forestpieceamount = ReadInt(f)
		mtpieceamount = ReadInt(f)
		
		If forestpieceamount > 0 Then
			I_Zone\HasCustomForest = True
		EndIf
		If mtpieceamount > 0 Then
			I_Zone\HasCustomMT = True
		EndIf
		
		//Facility rooms
		For i = 0 To roomamount-1
			x = ReadByte(f)
			y = ReadByte(f)
			name$ = Lower(ReadString(f))
			
			angle = ReadByte(f)*90.0
			
			DebugLog x+", "+y+": "+name
			DebugLog "angle: "+angle
			
			For rt.RoomTemplates=Each RoomTemplates
				If Lower(rt\Name) = name Then
					
					r.Rooms = CreateRoom(0, rt\Shape, (MapWidth-x) * 8.0, 0, y * 8.0, name)
					DebugLog "createroom"
					
					r\angle = angle
					If r\angle<>90 And r\angle<>270
						r\angle = r\angle + 180
					EndIf
					r\angle = WrapAngle(r\angle)
					
					TurnEntity(r\obj, 0, r\angle, 0)
					
					MapTemp(MapWidth-x,y)=True
					
					Exit
				EndIf
			Next
			
			name = ReadString(f)
			prob# = ReadFloat(f)
			
			If r<>Null Then
				If prob>0.0 Then
					If Rnd(0.0,1.0)<=prob Then
						e.Events = New Events
						e\EventName = name
						e\room = r   
					EndIf
				ElseIf prob = 0.0 And name <> "" Then
					e.Events = New Events
					e\EventName = name
					e\room = r  
				EndIf
			EndIf
		Next
		
		Local ForestRoom.Rooms
		For r.Rooms = Each Rooms
			If r\RoomTemplate\Name = "room860" Then
				ForestRoom = r
				Exit
			EndIf
		Next
		
		If ForestRoom<>Null Then
			Local fr.Forest = New Forest
		EndIf
		
		//Forest rooms
		For i = 0 To forestpieceamount-1
			x = ReadByte(f)
			y = ReadByte(f)
			name$ = Lower(ReadString(f))
			
			angle = ReadByte(f)
			
			DebugLog x+", "+y+": "+name
			DebugLog "angle: "+angle
			
			If angle <> 0 And angle <> 2 Then
				angle = angle + 2
			EndIf
			angle = angle + 1
			If angle > 3 Then
				angle = (angle Mod 4)
			EndIf
			
			x = (gridsize-1)-x
			
			If fr<>Null Then
				Select name
					//1,2,3,4 = ROOM1
					//5,6,7,8 = ROOM2
					//9,10,11,12 = ROOM2C
					//13,14,15,16 = ROOM3
					//17,18,19,20 = ROOM4
					//21,22,23,24 = DOORROOM
					Case "scp-860-1 endroom"
						fr\grid[(y*gridsize)+x] = 1+angle
					Case "scp-860-1 path"
						fr\grid[(y*gridsize)+x] = 5+angle
					Case "scp-860-1 corner"
						fr\grid[(y*gridsize)+x] = 9+angle
					Case "scp-860-1 t-shaped path"
						fr\grid[(y*gridsize)+x] = 13+angle
					Case "scp-860-1 4-way path"
						fr\grid[(y*gridsize)+x] = 17+angle
					Case "scp-860-1 door"
						fr\grid[(y*gridsize)+x] = 21+angle
				End Select
				DebugLog "created forest piece "+Chr(34)+name+Chr(34)+" successfully"
			EndIf
		Next
		
		If fr<>Null Then
			ForestRoom\fr=fr
			PlaceForest_MapCreator(ForestRoom\fr,ForestRoom\x,ForestRoom\y+30.0,ForestRoom\z,ForestRoom)
		EndIf
		
		Local MTRoom.Rooms
		For r.Rooms = Each Rooms
			If r\RoomTemplate\Name = "room2tunnel" Then
				MTRoom = r
				Exit
			EndIf
		Next
		
		If MTRoom<>Null Then
			MTRoom\grid = New Grids
		EndIf
		
		//Maintenance tunnels rooms
		For i = 0 To mtpieceamount-1
			x = ReadByte(f)
			y = ReadByte(f)
			name$ = Lower(ReadString(f))
			
			angle = ReadByte(f)
			
			DebugLog x+", "+y+": "+name
			DebugLog "angle: "+angle
			
			If angle<>1 And angle<>3 Then
				angle = angle + 2
			EndIf
			If name = "maintenance tunnel corner" Or name = "maintenance tunnel t-shaped room" Then
				angle = angle + 3
			EndIf
			If angle > 3 Then
				angle = (angle Mod 4)
			EndIf
			
			x = (gridsz-1)-x
			
			If MTRoom<>Null Then
				Select name
					Case "maintenance tunnel endroom"
						MTRoom\grid\grid[x+(y*gridsz)]=ROOM1
					Case "maintenance tunnel corridor"
						MTRoom\grid\grid[x+(y*gridsz)]=ROOM2
					Case "maintenance tunnel corner"
						MTRoom\grid\grid[x+(y*gridsz)]=ROOM2C
					Case "maintenance tunnel t-shaped room"
						MTRoom\grid\grid[x+(y*gridsz)]=ROOM3
					Case "maintenance tunnel 4-way room"
						MTRoom\grid\grid[x+(y*gridsz)]=ROOM4
					Case "maintenance tunnel elevator"
						MTRoom\grid\grid[x+(y*gridsz)]=ROOM4+1
					Case "maintenance tunnel generator room"
						MTRoom\grid\grid[x+(y*gridsz)]=ROOM4+2
				End Select
				MTRoom\grid\angles[x+(y*gridsz)]=angle
				DebugLog "created mtunnel piece "+Chr(34)+name+Chr(34)+" successfully"
			EndIf
		Next
		
		//If MTRoom<>Null Then
		//	PlaceGrid_MapCreator(MTRoom)
		//EndIf
	Else
		I_Zone\Transition[0] = 13
		I_Zone\Transition[1] = 7
		I_Zone\HasCustomForest = False
		I_Zone\HasCustomMT = False
		While Not Eof(f)
			x = ReadByte(f)
			y = ReadByte(f)
			name$ = Lower(ReadString(f))
			
			angle = ReadByte(f)*90.0
			
			DebugLog x+", "+y+": "+name
			DebugLog "angle: "+angle
			
			For rt.RoomTemplates=Each RoomTemplates
				If Lower(rt\Name) = name Then
					
					r.Rooms = CreateRoom(0, rt\Shape, (MapWidth-x) * 8.0, 0, y * 8.0, name)
					DebugLog "createroom"
					
					r\angle = angle
					If r\angle<>90 And r\angle<>270
						r\angle = r\angle + 180
					EndIf
					r\angle = WrapAngle(r\angle)
					
					TurnEntity(r\obj, 0, r\angle, 0)
					
					MapTemp(MapWidth-x,y)=True
					
					Exit
				EndIf
			Next
			
			name = ReadString(f)
			prob# = ReadFloat(f)
			
			If r<>Null Then
				If prob>0.0 Then
					If Rnd(0.0,1.0)<=prob Then
						e.Events = New Events
						e\EventName = name
						e\room = r   
					EndIf
				ElseIf prob = 0.0 And name <> "" Then
					e.Events = New Events
					e\EventName = name
					e\room = r
				EndIf
			EndIf
			
		Wend
	EndIf
	
	CloseFile f
	
	Local temp = 0, zone
	Local spacing# = 8.0
	Local shouldSpawnDoor% = False
	Local d.Doors
	For y = MapHeight To 0 Step -1
		
		If y<I_Zone\Transition[1] Then
			zone=3
		ElseIf y>=I_Zone\Transition[1] And y<I_Zone\Transition[0] Then
			zone=2
		Else
			zone=1
		EndIf
		
		For x = MapWidth To 0 Step -1
			If MapTemp(x,y) > 0 Then
				If zone = 2 Then temp=2 Else temp=0
                
                For r.Rooms = Each Rooms
					r\angle = WrapAngle(r\angle)
					If Int(r\x/8.0)=x And Int(r\z/8.0)=y Then
						shouldSpawnDoor = False
						Select r\RoomTemplate\Shape
							Case ROOM1
								If r\angle=90
									shouldSpawnDoor = True
								EndIf
							Case ROOM2
								If r\angle=90 Or r\angle=270
									shouldSpawnDoor = True
								EndIf
							Case ROOM2C
								If r\angle=0 Or r\angle=90
									shouldSpawnDoor = True
								EndIf
							Case ROOM3
								If r\angle=0 Or r\angle=180 Or r\angle=90
									shouldSpawnDoor = True
								EndIf
							Default
								shouldSpawnDoor = True
						End Select
						If shouldSpawnDoor
							If (x+1)<(MapWidth+1)
								If MapTemp(x + 1, y) > 0 Then
									d.Doors = CreateDoor(r\zone, Float(x) * spacing + spacing / 2.0, 0, Float(y) * spacing, 90, r, Max(Rand(-3, 1), 0), temp)
									r\AdjDoor[0] = d
								EndIf
							EndIf
						EndIf
						
						shouldSpawnDoor = False
						Select r\RoomTemplate\Shape
							Case ROOM1
								If r\angle=180
									shouldSpawnDoor = True
								EndIf
							Case ROOM2
								If r\angle=0 Or r\angle=180
									shouldSpawnDoor = True
								EndIf
							Case ROOM2C
								If r\angle=180 Or r\angle=90
									shouldSpawnDoor = True
								EndIf
							Case ROOM3
								If r\angle=180 Or r\angle=90 Or r\angle=270
									shouldSpawnDoor = True
								EndIf
							Default
								shouldSpawnDoor = True
						End Select
						If shouldSpawnDoor
							If (y+1)<(MapHeight+1)
								If MapTemp(x, y + 1) > 0 Then
									d.Doors = CreateDoor(r\zone, Float(x) * spacing, 0, Float(y) * spacing + spacing / 2.0, 0, r, Max(Rand(-3, 1), 0), temp)
									r\AdjDoor[3] = d
								EndIf
							EndIf
						EndIf
						
						Exit
					EndIf
                Next
                
			End If
			
		Next
	Next
	
	//r = CreateRoom(0, ROOM1, 8, 0, (MapHeight-1) * 8, "173")
	//r = CreateRoom(0, ROOM1, (MapWidth-1) * 8, 0, (MapHeight-1) * 8, "pocketdimension")
	//r = CreateRoom(0, ROOM1, 0, 0, 8, "gatea")
	If IntroEnabled Then r = CreateRoom(0, ROOM1, 8, 0, (MapHeight+2) * 8, "173")
	r = CreateRoom(0, ROOM1, (MapWidth+2) * 8, 0, (MapHeight+2) * 8, "pocketdimension")
	r = CreateRoom(0, ROOM1, 0, 500, -16, "gatea")
	r = CreateRoom(0, ROOM1, -16, 800, 0, "dimension1499")
	
	CreateEvent("173", "173", 0)
	CreateEvent("pocketdimension", "pocketdimension", 0)   
	CreateEvent("gatea", "gatea", 0)
	CreateEvent("dimension1499", "dimension1499", 0)
	
	For r.Rooms = Each Rooms
		r\Adjacent[0]=Null
		r\Adjacent[1]=Null
		r\Adjacent[2]=Null
		r\Adjacent[3]=Null
		For r2.Rooms = Each Rooms
			If r<>r2 Then
				If r2\z=r\z Then
					If (r2\x)=(r\x+8.0) Then
						r\Adjacent[0]=r2
						If r\AdjDoor[0] = Null Then r\AdjDoor[0] = r2\AdjDoor[2]
					ElseIf (r2\x)=(r\x-8.0)
						r\Adjacent[2]=r2
						If r\AdjDoor[2] = Null Then r\AdjDoor[2] = r2\AdjDoor[0]
					EndIf
				ElseIf r2\x=r\x Then
					If (r2\z)=(r\z-8.0) Then
						r\Adjacent[1]=r2
						If r\AdjDoor[1] = Null Then r\AdjDoor[1] = r2\AdjDoor[3]
					ElseIf (r2\z)=(r\z+8.0)
						r\Adjacent[3]=r2
						If r\AdjDoor[3] = Null Then r\AdjDoor[3] = r2\AdjDoor[1]
					EndIf
				EndIf
			EndIf
			If (r\Adjacent[0]<>Null) And (r\Adjacent[1]<>Null) And (r\Adjacent[2]<>Null) And (r\Adjacent[3]<>Null) Then Exit
		Next
	Next
	
	For x = 0 To MapWidth+1
		For y = 0 To MapHeight+1
			If MapTemp(x,y)>0 Then
				DebugLog "MapTemp("+x+","+y+") = True"
			Else
				DebugLog "MapTemp("+x+","+y+") = False"
			EndIf
		Next
	Next
	
	CatchErrors("LoadMap")
}








//~IDEal Editor Parameters:
//~C#Blitz3D
//--------------------------------------- music & sounds ----------------------------------------------

function PlaySound2(SoundHandle: int, cam: int, entity: int, range: float = 10, volume: float = 1.0): int {
	range = Max(range, 1.0)
	let soundchn: int = 0
	
	if (volume > 0) {
		let dist: float = EntityDistance(cam, entity) / range
		if (1 - dist > 0 && 1 - dist < 1) {
			let panvalue: float = Sin(-DeltaYaw(cam,entity))
			soundchn = PlaySound_Strict (SoundHandle)
			
			ChannelVolume(soundchn, volume * (1 - dist)*SFXVolume)
			ChannelPan(soundchn, panvalue)			
		}
	}
	
	return soundchn
}

function LoopSound2(SoundHandle: int, Chn: int, cam: int, entity: int, range: float = 10, volume: float = 1.0): int {
	range = Max(range,1.0)
	
	if (volume>0) {
		
		let dist: float = EntityDistance(cam, entity) / range
			
		let panvalue: float = Sin(-DeltaYaw(cam,entity))
		
		if (Chn = 0) {
			Chn = PlaySound_Strict (SoundHandle)
		} else {
			if (!ChannelPlaying(Chn)) {Chn = PlaySound_Strict (SoundHandle)}
		}
		
		ChannelVolume(Chn, volume * (1 - dist)*SFXVolume)
		ChannelPan(Chn, panvalue)
	} else {
		if (Chn != 0) {
			ChannelVolume (Chn, 0)
		} 
	}
	
	return Chn
}

function LoadTempSound(file: string) {
	if (TempSounds[TempSoundIndex] != 0) {
		FreeSound_Strict(TempSounds[TempSoundIndex])
	}
	TempSound = LoadSound_Strict(file)
	TempSounds[TempSoundIndex] = TempSound
	
	TempSoundIndex=(TempSoundIndex+1) % 10
	
	return TempSound
}

function LoadEventSound(e: Events,file: string,num: int = 0) {
	
	if (num=0) {
		if (e.Sound != 0) {
			FreeSound_Strict (e.Sound)
			e.Sound=0
		}
		e.Sound=LoadSound_Strict(file)
		return e.Sound
	} else if (num=1) {
		if (e.Sound2 != 0) {
			FreeSound_Strict (e.Sound2)
			e.Sound2=0
		}
		e.Sound2=LoadSound_Strict(file)
		return e.Sound2
	}
}

function UpdateMusic() {
	
	if (ConsoleFlush) {
		if (!ChannelPlaying(ConsoleMusPlay)) {ConsoleMusPlay = PlaySound(ConsoleMusFlush)}
	} else if (!PlayCustomMusic) {
		if (NowPlaying != ShouldPlay) { // playing the wrong clip, fade out
			CurrMusicVolume = Max(CurrMusicVolume - (FPSfactor / 250.0), 0)
			if (CurrMusicVolume = 0) {
				if (NowPlaying<66) {
					StopStream_Strict(MusicCHN)
				}
				NowPlaying = ShouldPlay
				MusicCHN = 0
				CurrMusic=0
			}
		} else { // playing the right clip
			CurrMusicVolume = CurrMusicVolume + (MusicVolume - CurrMusicVolume) * (0.1*FPSfactor)
		}
		
		if (NowPlaying < 66) {
			if (CurrMusic = 0) {
				MusicCHN = StreamSound_Strict("SFX/Music/"+Music(NowPlaying)+".ogg",0.0,Mode)
				CurrMusic = 1
			}
			SetStreamVolume_Strict(MusicCHN,CurrMusicVolume)
		}
	} else {
		if (FPSfactor > 0 || OptionsMenu == 2) {
			if (!ChannelPlaying(MusicCHN)) {MusicCHN = PlaySound_Strict(CustomMusic)}
			ChannelVolume (MusicCHN,1.0*MusicVolume)
		}
	}
	
} 

function PauseSounds() {
	for (e of Events.each) {
		if (e.soundchn != 0) {
			if (!e.soundchn_isstream) {
				if (ChannelPlaying(e.soundchn)) {PauseChannel(e.soundchn)}
			} else {
				SetStreamPaused_Strict(e.soundchn,true)
			}
		}
		if (e.soundchn2 != 0) {
			if (!e.soundchn2_isstream) {
				if (ChannelPlaying(e.soundchn2)) {PauseChannel(e.soundchn2)}
			} else {
				SetStreamPaused_Strict(e.soundchn2,true)
			}
		}		
	}
	
	for (n of NPCs.each) {
		if (n.soundchn != 0) {
			if (!n.soundchn_isstream) {
				if (ChannelPlaying(n.soundchn)) {PauseChannel(n.soundchn)}
			} else {
				if (n.soundchn_isstream=true) {
					SetStreamPaused_Strict(n.soundchn,true)
				}
			}
		}
		if (n.soundchn2 != 0) {
			if (!n.soundchn2_isstream) {
				if (ChannelPlaying(n.soundchn2)) {PauseChannel(n.soundchn2)}
			} else {
				if (n.soundchn2_isstream=true) {
					SetStreamPaused_Strict(n.soundchn2,true)
				}
			}
		}
	}	
	
	for (d of Doors.each) {
		if (d.soundchn != 0) {
			if (ChannelPlaying(d.soundchn)) {PauseChannel(d.soundchn)}
		}
	}
	
	for (dem of DevilEmitters.each) {
		if (dem.soundchn != 0) {
			if (ChannelPlaying(dem.soundchn)) {PauseChannel(dem.soundchn)}
		}
	}
	
	if (AmbientSFXCHN != 0) {
		if (ChannelPlaying(AmbientSFXCHN)) {PauseChannel(AmbientSFXCHN)}
	}
	
	if (BreathCHN != 0) {
		if (ChannelPlaying(BreathCHN)) {PauseChannel(BreathCHN)}
	}
	
	if (IntercomStreamCHN != 0) {
		SetStreamPaused_Strict(IntercomStreamCHN,true)
	}
}

function ResumeSounds() {
	for (e of Events.each) {
		if (e.soundchn != 0) {
			if (!e.soundchn_isstream) {
				if (ChannelPlaying(e.soundchn)) {ResumeChannel(e.soundchn)}
			} else {
				SetStreamPaused_Strict(e.soundchn,false)
			}
		}
		if (e.soundchn2 != 0) {
			if (!e.soundchn2_isstream) {
				if (ChannelPlaying(e.soundchn2)) {ResumeChannel(e.soundchn2)}
			} else {
				SetStreamPaused_Strict(e.soundchn2,false)
			}
		}	
	}
	
	for (n of NPCs.each) {
		if (n.soundchn != 0) {
			if (!n.soundchn_isstream) {
				if (ChannelPlaying(n.soundchn)) {ResumeChannel(n.soundchn)}
			} else {
				if (n.soundchn_isstream=true) {
					SetStreamPaused_Strict(n.soundchn,false)
				}
			}
		}
		if (n.soundchn2 != 0) {
			if (!n.soundchn2_isstream) {
				if (ChannelPlaying(n.soundchn2)) {ResumeChannel(n.soundchn2)}
			} else {
				if (n.soundchn2_isstream=true) {
					SetStreamPaused_Strict(n.soundchn2,false)
				}
			}
		}
	}	
	
	for (d of Doors.each) {
		if (d.soundchn != 0) {
			if (ChannelPlaying(d.soundchn)) {ResumeChannel(d.soundchn)}
		}
	}
	
	for (dem of DevilEmitters.each) {
		if (dem.soundchn != 0) {
			if (ChannelPlaying(dem.soundchn)) {ResumeChannel(dem.soundchn)}
		}
	}
	
	if (AmbientSFXCHN != 0) {
		if (ChannelPlaying(AmbientSFXCHN)) {ResumeChannel(AmbientSFXCHN)}
	}	
	
	if (BreathCHN != 0) {
		if (ChannelPlaying(BreathCHN)) {ResumeChannel(BreathCHN)}
	}
	
	if (IntercomStreamCHN != 0) {
		SetStreamPaused_Strict(IntercomStreamCHN,false)
	}
}

function KillSounds() {
	let i: int,e: Events,n: NPCs,d: Doors,dem: DevilEmitters,snd: Sound
	
	for (i of range(10)) {
		if (TempSounds[i]!=0) {
			FreeSound_Strict (TempSounds[i])
			TempSounds[i]=0
		}
	}
	for (e of Events.each) {
		if (e.SoundCHN != 0) {
			if (!e.SoundCHN_isStream) {
				if (ChannelPlaying(e.SoundCHN)) {StopChannel(e.SoundCHN)}
			} else {
				StopStream_Strict(e.SoundCHN)
			}
		}
		if (e.SoundCHN2 != 0) {
			if (!e.SoundCHN2_isStream){
				if (ChannelPlaying(e.SoundCHN2)) {StopChannel(e.SoundCHN2)}
			} else {
				StopStream_Strict(e.SoundCHN2)
			}
		}		
	}
	for (n of NPCs.each) {
		if (n.SoundChn != 0) {
			if (!n.SoundChn_IsStream) {
				if (ChannelPlaying(n.SoundChn)) {StopChannel(n.SoundChn)}
			} else {
				StopStream_Strict(n.SoundChn)
			}
		}
		if (n.SoundChn2 != 0) {
			if (!n.SoundChn2_IsStream) {
				if (ChannelPlaying(n.SoundChn2)) {StopChannel(n.SoundChn2)}
			} else {
				StopStream_Strict(n.SoundChn2)
			}
		}
	}	
	for (d of Doors.each) {
		if (d.SoundCHN != 0) {
			if (ChannelPlaying(d.SoundCHN)) {StopChannel(d.SoundCHN)}
		}
	}
	for (dem of DevilEmitters.each) {
		if (dem.SoundCHN != 0) {
			if (ChannelPlaying(dem.SoundCHN)) {StopChannel(dem.SoundCHN)}
		}
	}
	if (AmbientSFXCHN != 0) {
		if (ChannelPlaying(AmbientSFXCHN)) {StopChannel(AmbientSFXCHN)}
	}
	if (BreathCHN != 0) {
		if (ChannelPlaying(BreathCHN)) {StopChannel(BreathCHN)}
	}
	if (IntercomStreamCHN != 0) {
		StopStream_Strict(IntercomStreamCHN)
		IntercomStreamCHN = 0
	}
	if (EnableSFXRelease) {
		for (snd of Sound.each) {
			if (snd.internalHandle != 0) {
				FreeSound (snd.internalHandle)
				snd.internalHandle = 0
				snd.releaseTime = 0
			}
		}
	}
	
	for (snd of Sound.each) {
		for (i of range(32)) {
			if (snd.channels[i]!=0) {
				StopChannel (snd.channels[i])
			}
		}
	}
	
	DebugLog ("Terminated all sounds")
	
}

function GetStepSound(entity: int) {
    let picker: int,brush: int,texture: int,name$
    let mat: Materials
    
    picker = LinePick(EntityX(entity),EntityY(entity),EntityZ(entity),0,-1,0)
    if (picker != 0) {
        if (GetEntityType(picker) != HIT_MAP) {return 0}
        brush = GetSurfaceBrush(GetSurface(picker,CountSurfaces(picker)))
        if (brush != 0) {
            texture = GetBrushTexture(brush,3)
            if (texture != 0) {
                name = StripPath(TextureName(texture))
                if ((name != "")) {FreeTexture(texture)}
				for (mat of Materials.each) {
					if (mat.name = name) {
						if (mat.StepSound > 0) {
							FreeBrush(brush)
							return mat.StepSound-1
						}
						break
					}
				}                
			}
			texture = GetBrushTexture(brush,2)
			if (texture != 0) {
				name = StripPath(TextureName(texture))
				if ((name != "")) {FreeTexture(texture)}
				for (mat of Materials.each) {
					if (mat.name = name) {
						if (mat.StepSound > 0) {
							FreeBrush(brush)
							return mat.StepSound-1
						}
						break
					}
				}                
			}
			texture = GetBrushTexture(brush,1)
			if (texture != 0) {
				name = StripPath(TextureName(texture))
				if ((name != "")) {FreeTexture(texture)}
				FreeBrush(brush)
				for (mat of Materials.each) {
					if (mat.name = name) {
						if (mat.StepSound > 0) {
							return mat.StepSound-1
						}
						break
					}
				}                
			}
		}
	}
    
    return 0
}

function UpdateSoundOrigin2(Chn: int, cam: int, entity: int, range: float = 10, volume: float = 1.0) {
	range = Max(range,1.0)
	
	if (volume>0) {
		
		let dist: float = EntityDistance(cam, entity) / range
		if (1 - dist > 0 && 1 - dist < 1) {
			
			let panvalue: float = Sin(-DeltaYaw(cam,entity))
			
			ChannelVolume(Chn, volume * (1 - dist))
			ChannelPan(Chn, panvalue)
		}
	} else {
		if (Chn != 0) {
			ChannelVolume (Chn, 0)
		} 
	}
}

function UpdateSoundOrigin(Chn: int, cam: int, entity: int, range: float = 10, volume: float = 1.0) {
	range = Max(range,1.0)
	
	if (volume>0) {
		
		let dist: float = EntityDistance(cam, entity) / range
		if (1 - dist > 0 && 1 - dist < 1) {
			
			let panvalue: float = Sin(-DeltaYaw(cam,entity))
			
			ChannelVolume(Chn, volume * (1 - dist)*SFXVolume)
			ChannelPan(Chn, panvalue)
		}
	} else {
		if (Chn != 0) {
			ChannelVolume (Chn, 0)
		} 
	}
}
//--------------------------------------- random -------------------------------------------------------

function f2s(n: float, count: int): string {
	return Left(n, Len(Int(n))+count+1)
}

function AnimateNPC(n: NPCs, start: float, quit: float, speed: float, loop=true) {
	let newTime: float
	
	if (speed > 0.0) {
		newTime = Max(Min(n.Frame + speed * FPSfactor,quit),start)
		
		if (loop && newTime >= quit) {
			newTime = start
		}
	} else {
		if (start < quit) {
			temp = start
			start = quit
			quit = temp
		}
		
		if (loop) {
			newTime = n.Frame + speed * FPSfactor
			
			if (newTime < quit) { 
				newTime = start
			} else if (newTime > start) {
				newTime = quit
			}
		} else {
			newTime = Max(Min(n.Frame + speed * FPSfactor,start),quit)
		}
	}
	SetNPCFrame(n, newTime)
	
}

function SetNPCFrame(n: NPCs, frame: float) {
	if (Abs(n.Frame-frame)<0.001) {return}
	
	SetAnimTime (n.obj, frame)
	
	n.Frame = frame
}

function Animate2(entity: int, curr: float, start: int, quit: int, speed: float, loop=true): float {
	
	let newTime: float
	
	if (speed > 0.0) {
		newTime = Max(Min(curr + speed * FPSfactor,quit),start)
		
		if (loop) {
			if (newTime >= quit) { 
				newTime = start
			}
		}
	} else {
		if (start < quit) {
			temp = start
			start = quit
			quit = temp
		}
		
		if (loop) {
			newTime = curr + speed * FPSfactor
			
			if (newTime < quit) {newTime = start}
			if (newTime > start) {newTime = quit}
			
		} else {
			newTime = Max(Min(curr + speed * FPSfactor,start),quit)
		}
	}
	
	SetAnimTime (entity, newTime)
	return newTime
	
} 


function Use914(item: Items, setting: string, x: float, y: float, z: float) {
	
	RefinedItems = RefinedItems+1
	
	let it2: Items
	switch (item.itemtemplate.name) {
		case "Gas Mask", "Heavy Gas Mask":
			switch (setting) {
				case "rough", "coarse":
					d.Decals = CreateDecal(0, x, 8 * RoomScale + 0.005, z, 90, Rand(360), 0)
					d.Size = 0.12
					ScaleSprite(d.obj, d.Size, d.Size)
					RemoveItem(item)
				case "1:1":
					PositionEntity(item.collider, x, y, z)
					ResetEntity(item.collider)
				case "fine", "very fine":
					it2 = CreateItem("Gas Mask", "supergasmask", x, y, z)
					RemoveItem(item)
			}
		case "SCP-1499":
			switch (setting) {
				case "rough", "coarse":
					d.Decals = CreateDecal(0, x, 8 * RoomScale + 0.005, z, 90, Rand(360), 0)
					d.Size = 0.12
					ScaleSprite(d.obj, d.Size, d.Size)
					RemoveItem(item)
				case "1:1":
					it2 = CreateItem("Gas Mask", "gasmask", x, y, z)
					RemoveItem(item)
				case "fine":
					it2 = CreateItem("SCP-1499", "super1499", x, y, z)
					RemoveItem(item)
				case "very fine":
					n.NPCs = CreateNPC(NPCtype1499,x,y,z)
					n.State = 1
					n.Sound = LoadSound_Strict("SFX/SCP/1499/Triggered.ogg")
					n.SoundChn = PlaySound2(n.Sound, Camera, n.Collider,20.0)
					n.State3 = 1
					RemoveItem(item)
			}
		case "Ballistic Vest":
			switch (setting) {
				case "rough", "coarse":
					d.Decals = CreateDecal(0, x, 8 * RoomScale + 0.005, z, 90, Rand(360), 0)
					d.Size = 0.12
					ScaleSprite(d.obj, d.Size, d.Size)
					RemoveItem(item)
				case "1:1":
					PositionEntity(item.collider, x, y, z)
					ResetEntity(item.collider)
				case "fine":
					it2 = CreateItem("Heavy Ballistic Vest", "finevest", x, y, z)
					RemoveItem(item)
				case "very fine":
					it2 = CreateItem("Bulky Ballistic Vest", "veryfinevest", x, y, z)
					RemoveItem(item)
			}
		case "Clipboard":
			switch (setting) {
				case "rough", "coarse":
					d.Decals = CreateDecal(7, x, 8 * RoomScale + 0.005, z, 90, Rand(360), 0)
					d.Size = 0.12
					ScaleSprite(d.obj, d.Size, d.Size)
					for (i of range(20)) {
						if (item.SecondInv[i]!=Null) {
							RemoveItem(item.SecondInv[i])
						}
						item.SecondInv[i]=Null
					}
					RemoveItem(item)
				case "1:1":
					PositionEntity(item.collider, x, y, z)
					ResetEntity(item.collider)
				case "fine":
					item.invSlots = Max(item.state2,15)
					PositionEntity(item.collider, x, y, z)
					ResetEntity(item.collider)
				case "very fine":
					item.invSlots = Max(item.state2,20)
					PositionEntity(item.collider, x, y, z)
					ResetEntity(item.collider)
			}
		case "Cowbell":
			switch (setting) {
				case "rough","coarse":
					d.Decals = CreateDecal(0, x, 8*RoomScale+0.010, z, 90, Rand(360), 0)
					d.Size = 0.2
					EntityAlpha(d.obj, 0.8)
					ScaleSprite(d.obj, d.Size, d.Size)
					RemoveItem(item)
				case "1:1","fine","very fine":
					PositionEntity(item.collider, x, y, z)
					ResetEntity(item.collider)
			}
		case "Night Vision Goggles":
			switch (setting) {
				case "rough", "coarse":
					d.Decals = CreateDecal(0, x, 8 * RoomScale + 0.005, z, 90, Rand(360), 0)
					d.Size = 0.12
					ScaleSprite(d.obj, d.Size, d.Size)
					RemoveItem(item)
				case "1:1":
					PositionEntity(item.collider, x, y, z)
					ResetEntity(item.collider)
				case "fine":
					it2 = CreateItem("Night Vision Goggles", "finenvgoggles", x, y, z)
					RemoveItem(item)
				case "very fine":
					it2 = CreateItem("Night Vision Goggles", "supernv", x, y, z)
					it2.state = 1000
					RemoveItem(item)
			}
		case "Metal Panel", "SCP-148 Ingot":
			switch (setting) {
				case "rough", "coarse":
					it2 = CreateItem("SCP-148 Ingot", "scp148ingot", x, y, z)
					RemoveItem(item)
				case "1:1", "fine", "very fine":
					it2 = Null
					for (it of Items.each) {
						if (it!=item && it.collider != 0 && it.Picked == false) {
							if (Distance(EntityX(it.collider,true), EntityZ(it.collider,true), EntityX(item.collider, true), EntityZ(item.collider, true)) < (180.0 * RoomScale)) {
								it2 = it
								break
							} else if (Distance(EntityX(it.collider,true), EntityZ(it.collider,true), x,z) < (180.0 * RoomScale)) {
								it2 = it
								break
							}
						}
					}
					
					if (it2!=Null) {
						switch (it2.itemtemplate.tempname) {
							case "gasmask", "supergasmask":
								RemoveItem (it2)
								RemoveItem (item)
								
								it2 = CreateItem("Heavy Gas Mask", "gasmask3", x, y, z)
							case "vest":
								RemoveItem (it2)
								RemoveItem(item)
								it2 = CreateItem("Heavy Ballistic Vest", "finevest", x, y, z)
							case "hazmatsuit","hazmatsuit2":
								RemoveItem (it2)
								RemoveItem(item)
								it2 = CreateItem("Heavy Hazmat Suit", "hazmatsuit3", x, y, z)
						}
					} else { 
						if (item.itemtemplate.name="SCP-148 Ingot") {
							it2 = CreateItem("Metal Panel", "scp148", x, y, z)
							RemoveItem(item)
						} else {
							PositionEntity(item.collider, x, y, z)
							ResetEntity(item.collider)							
						}
					}					
			}
		case "Severed Hand", "Black Severed Hand":
			switch (setting) {
				case "rough", "coarse":
					d.Decals = CreateDecal(3, x, 8 * RoomScale + 0.005, z, 90, Rand(360), 0)
					d.Size = 0.12
					ScaleSprite(d.obj, d.Size, d.Size)
				case "1:1", "fine", "very fine":
					if (item.itemtemplate.name = "Severed Hand") {
						it2 = CreateItem("Black Severed Hand", "hand2", x, y, z)
					} else {
						it2 = CreateItem("Severed Hand", "hand", x, y, z)
					}
			}
			RemoveItem(item)
		case "First Aid Kit", "Blue First Aid Kit":
			switch (setting) {
				case "rough", "coarse":
					d.Decals = CreateDecal(0, x, 8 * RoomScale + 0.005, z, 90, Rand(360), 0)
					d.Size = 0.12
					ScaleSprite(d.obj, d.Size, d.Size)
				case "1:1":
					if (Rand(2)=1) {
						it2 = CreateItem("Blue First Aid Kit", "firstaid2", x, y, z)
					} else {
						it2 = CreateItem("First Aid Kit", "firstaid", x, y, z)
					}
				case "fine":
					it2 = CreateItem("Small First Aid Kit", "finefirstaid", x, y, z)
				case "very fine":
					it2 = CreateItem("Strange Bottle", "veryfinefirstaid", x, y, z)
			}
			RemoveItem(item)
		case "Level 1 Key Card", "Level 2 Key Card", "Level 3 Key Card", "Level 4 Key Card", "Level 5 Key Card", "Key Card":
			switch (setting) {
				case "rough", "coarse":
					d.Decals = CreateDecal(0, x, 8 * RoomScale + 0.005, z, 90, Rand(360), 0)
					d.Size = 0.07
					ScaleSprite(d.obj, d.Size, d.Size)
				case "1:1":
					it2 = CreateItem("Playing Card", "misc", x, y, z)
				case "fine":
					switch (item.itemtemplate.name) {
						case "Level 1 Key Card":
							switch (SelectedDifficulty.otherFactors) {
								case EASY:
									it2 = CreateItem("Level 2 Key Card", "key2", x, y, z)
								case NORMAL:
									if (Rand(5)=1) {
										it2 = CreateItem("Mastercard", "misc", x, y, z)
									} else {
										it2 = CreateItem("Level 2 Key Card", "key2", x, y, z)
									}
								case HARD:
									if (Rand(4)=1) {
										it2 = CreateItem("Mastercard", "misc", x, y, z)
									} else {
										it2 = CreateItem("Level 2 Key Card", "key2", x, y, z)
									}
							}
						case "Level 2 Key Card":
							switch (SelectedDifficulty.otherFactors) {
								case EASY:
									it2 = CreateItem("Level 3 Key Card", "key3", x, y, z)
								case NORMAL:
									if (Rand(4)=1) {
										it2 = CreateItem("Mastercard", "misc", x, y, z)
									} else {
										it2 = CreateItem("Level 3 Key Card", "key3", x, y, z)
									}
								case HARD:
									if (Rand(3)=1) {
										it2 = CreateItem("Mastercard", "misc", x, y, z)
									} else {
										it2 = CreateItem("Level 3 Key Card", "key3", x, y, z)
									}
							}
						case "Level 3 Key Card":
							switch (SelectedDifficulty.otherFactors) {
								case EASY:
									if (Rand(10)=1) {
										it2 = CreateItem("Level 4 Key Card", "key4", x, y, z)
									} else {
										it2 = CreateItem("Playing Card", "misc", x, y, z)	
									}
								case NORMAL:
									if (Rand(15)=1) {
										it2 = CreateItem("Level 4 Key Card", "key4", x, y, z)
									} else {
										it2 = CreateItem("Playing Card", "misc", x, y, z)	
									}
								case HARD:
									if (Rand(20)=1) {
										it2 = CreateItem("Level 4 Key Card", "key4", x, y, z)
									} else {
										it2 = CreateItem("Playing Card", "misc", x, y, z)	
									}
							}
						case "Level 4 Key Card":
							switch (SelectedDifficulty.otherFactors) {
								case EASY:
									it2 = CreateItem("Level 5 Key Card", "key5", x, y, z)
								case NORMAL:
									if (Rand(4)=1) {
										it2 = CreateItem("Mastercard", "misc", x, y, z)
									} else {
										it2 = CreateItem("Level 5 Key Card", "key5", x, y, z)
									}
								case HARD:
									if (Rand(3)=1) {
										it2 = CreateItem("Mastercard", "misc", x, y, z)
									} else {
										it2 = CreateItem("Level 5 Key Card", "key5", x, y, z)
									}
							}
						case "Level 5 Key Card":
							let CurrAchvAmount: int = 0
							for (i of range(MAXACHIEVEMENTS)) {
								if (Achievements(i)=true) {
									CurrAchvAmount=CurrAchvAmount+1
								}
							}
							
							DebugLog (CurrAchvAmount)
							
							switch (SelectedDifficulty.otherFactors) {
								case EASY:
									if (Rand(0,((MAXACHIEVEMENTS-1)*3)-((CurrAchvAmount-1)*3))=0) {
										it2 = CreateItem("Key Card Omni", "key6", x, y, z)
									} else {
										it2 = CreateItem("Mastercard", "misc", x, y, z)
									}
								case NORMAL:
									if (Rand(0,((MAXACHIEVEMENTS-1)*4)-((CurrAchvAmount-1)*3))=0) {
										it2 = CreateItem("Key Card Omni", "key6", x, y, z)
									} else {
										it2 = CreateItem("Mastercard", "misc", x, y, z)
									}
								case HARD:
									if (Rand(0,((MAXACHIEVEMENTS-1)*5)-((CurrAchvAmount-1)*3))=0) {
										it2 = CreateItem("Key Card Omni", "key6", x, y, z)
									} else {
										it2 = CreateItem("Mastercard", "misc", x, y, z)
									}
							}		
					}
				case "very fine":
					CurrAchvAmount = 0
					for (i of range(MAXACHIEVEMENTS)) {
						if (Achievements(i)=true) {
							CurrAchvAmount=CurrAchvAmount+1
						}
					}
					
					DebugLog (CurrAchvAmount)
					
					switch (SelectedDifficulty.otherFactors) {
						case EASY:
							if (Rand(0,((MAXACHIEVEMENTS-1)*3)-((CurrAchvAmount-1)*3))=0) {
								it2 = CreateItem("Key Card Omni", "key6", x, y, z)
							} else {
								it2 = CreateItem("Mastercard", "misc", x, y, z)
							}
						case NORMAL:
							if (Rand(0,((MAXACHIEVEMENTS-1)*4)-((CurrAchvAmount-1)*3))=0) {
								it2 = CreateItem("Key Card Omni", "key6", x, y, z)
							} else {
								it2 = CreateItem("Mastercard", "misc", x, y, z)
							}
						case HARD:
							if (Rand(0,((MAXACHIEVEMENTS-1)*5)-((CurrAchvAmount-1)*3))=0) {
								it2 = CreateItem("Key Card Omni", "key6", x, y, z)
							} else {
								it2 = CreateItem("Mastercard", "misc", x, y, z)
							}
					}
			}
			
			RemoveItem(item)
		case "Key Card Omni":
			switch (setting) {
				case "rough", "coarse":
					d.Decals = CreateDecal(0, x, 8 * RoomScale + 0.005, z, 90, Rand(360), 0)
					d.Size = 0.07
					ScaleSprite(d.obj, d.Size, d.Size)
				case "1:1":
					if (Rand(2)=1) {
						it2 = CreateItem("Mastercard", "misc", x, y, z)
					} else {
						it2 = CreateItem("Playing Card", "misc", x, y, z)			
					}	
				case "fine", "very fine":
					it2 = CreateItem("Key Card Omni", "key6", x, y, z)
			}			
			
			RemoveItem(item)
		case "Playing Card", "Coin", "Quarter":
			switch (setting) {
				case "rough", "coarse":
					d.Decals = CreateDecal(0, x, 8 * RoomScale + 0.005, z, 90, Rand(360), 0)
					d.Size = 0.07
					ScaleSprite(d.obj, d.Size, d.Size)
				case "1:1":
					it2 = CreateItem("Level 1 Key Card", "key1", x, y, z)	
			    case "fine", "very fine":
					it2 = CreateItem("Level 2 Key Card", "key2", x, y, z)
			}
			RemoveItem(item)
		case "Mastercard":
			switch (setting) {
				case "rough":
					d.Decals = CreateDecal(0, x, 8 * RoomScale + 0.005, z, 90, Rand(360), 0)
					d.Size = 0.07
					ScaleSprite(d.obj, d.Size, d.Size)
				case "coarse":
					it2 = CreateItem("Quarter", "25ct", x, y, z)
					let it3: Items,it4: Items,it5: Items
					it3 = CreateItem("Quarter", "25ct", x, y, z)
					it4 = CreateItem("Quarter", "25ct", x, y, z)
					it5 = CreateItem("Quarter", "25ct", x, y, z)
					EntityType (it3.collider, HIT_ITEM)
					EntityType (it4.collider, HIT_ITEM)
					EntityType (it5.collider, HIT_ITEM)
				case "1:1":
					it2 = CreateItem("Level 1 Key Card", "key1", x, y, z)	
			    case "fine", "very fine":
					it2 = CreateItem("Level 2 Key Card", "key2", x, y, z)
			}
			RemoveItem(item)
		case "S-NAV 300 Navigator", "S-NAV 310 Navigator", "S-NAV Navigator", "S-NAV Navigator Ultimate":
			switch (setting) {
				case "rough", "coarse":
					it2 = CreateItem("Electronical components", "misc", x, y, z)
				case "1:1":
					it2 = CreateItem("S-NAV Navigator", "nav", x, y, z)
					it2.state = 100
				case "fine":
					it2 = CreateItem("S-NAV 310 Navigator", "nav", x, y, z)
					it2.state = 100
				case "very fine":
					it2 = CreateItem("S-NAV Navigator Ultimate", "nav", x, y, z)
					it2.state = 101
			}
			
			RemoveItem(item)
		case "Radio Transceiver":
			switch (setting) {
				case "rough", "coarse":
					it2 = CreateItem("Electronical components", "misc", x, y, z)
				case "1:1":
					it2 = CreateItem("Radio Transceiver", "18vradio", x, y, z)
					it2.state = 100
				case "fine":
					it2 = CreateItem("Radio Transceiver", "fineradio", x, y, z)
					it2.state = 101
				case "very fine":
					it2 = CreateItem("Radio Transceiver", "veryfineradio", x, y, z)
					it2.state = 101
			}
			
			RemoveItem(item)
		case "SCP-513":
			switch (setting) {
				case "rough", "coarse":
					PlaySound_Strict (LoadTempSound("SFX/SCP/513/914Refine.ogg"))
					for (n of NPCs.each) {
						if (n.npctype = NPCtype5131) {RemoveNPC(n)}
					}
					d.Decals = CreateDecal(0, x, 8*RoomScale+0.010, z, 90, Rand(360), 0)
					d.Size = 0.2
					EntityAlpha(d.obj, 0.8)
					ScaleSprite(d.obj, d.Size, d.Size)
				case "1:1", "fine", "very fine":
					it2 = CreateItem("SCP-513", "scp513", x, y, z)
					
			}
			
			RemoveItem(item)
		case "Some SCP-420-J", "Cigarette":
			switch (setting) {
				case "rough", "coarse":		
					d.Decals = CreateDecal(0, x, 8*RoomScale+0.010, z, 90, Rand(360), 0)
					d.Size = 0.2
					EntityAlpha(d.obj, 0.8)
					ScaleSprite(d.obj, d.Size, d.Size)
				case "1:1":
					it2 = CreateItem("Cigarette", "cigarette", x + 1.5, y + 0.5, z + 1.0)
				case "fine":
					it2 = CreateItem("Joint", "420s", x + 1.5, y + 0.5, z + 1.0)
				case "very fine":
					it2 = CreateItem("Smelly Joint", "420s", x + 1.5, y + 0.5, z + 1.0)
			}
			
			RemoveItem(item)
		case "9V Battery", "18V Battery", "Strange Battery":
			switch (setting) {
				case "rough", "coarse":
					d.Decals = CreateDecal(0, x, 8 * RoomScale + 0.010, z, 90, Rand(360), 0)
					d.Size = 0.2
					EntityAlpha(d.obj, 0.8)
					ScaleSprite(d.obj, d.Size, d.Size)
				case "1:1":
					it2 = CreateItem("18V Battery", "18vbat", x, y, z)
				case "fine":
					it2 = CreateItem("Strange Battery", "killbat", x, y, z)
				case "very fine":
					it2 = CreateItem("Strange Battery", "killbat", x, y, z)
			}
			
			RemoveItem(item)
		case "ReVision Eyedrops", "RedVision Eyedrops", "Eyedrops":
			switch (setting) {
				case "rough", "coarse":
					d.Decals = CreateDecal(0, x, 8 * RoomScale + 0.010, z, 90, Rand(360), 0)
					d.Size = 0.2
					EntityAlpha(d.obj, 0.8)
					ScaleSprite(d.obj, d.Size, d.Size)
				case "1:1":
					it2 = CreateItem("RedVision Eyedrops", "eyedrops", x,y,z)
				case "fine":
					it2 = CreateItem("Eyedrops", "fineeyedrops", x,y,z)
				case "very fine":
					it2 = CreateItem("Eyedrops", "supereyedrops", x,y,z)
			}
			
			RemoveItem(item)		
		case "Hazmat Suit":
			switch (setting) {
				case "rough", "coarse":
					d.Decals = CreateDecal(0, x, 8 * RoomScale + 0.010, z, 90, Rand(360), 0)
					d.Size = 0.2
					EntityAlpha(d.obj, 0.8)
					ScaleSprite(d.obj, d.Size, d.Size)
				case "1:1":
					it2 = CreateItem("Hazmat Suit", "hazmatsuit", x,y,z)
				case "fine":
					it2 = CreateItem("Hazmat Suit", "hazmatsuit2", x,y,z)
				case "very fine":
					it2 = CreateItem("Hazmat Suit", "hazmatsuit2", x,y,z)
			}
			
			RemoveItem(item)
			
		case "Syringe":
			switch (item.itemtemplate.tempname) {
				case "syringe":
					switch (setting) {
						case "rough", "coarse":
							d.Decals = CreateDecal(0, x, 8 * RoomScale + 0.005, z, 90, Rand(360), 0)
							d.Size = 0.07
							ScaleSprite(d.obj, d.Size, d.Size)
						case "1:1":
							it2 = CreateItem("Small First Aid Kit", "finefirstaid", x, y, z)	
						case "fine":
							it2 = CreateItem("Syringe", "finesyringe", x, y, z)
						case "very fine":
							it2 = CreateItem("Syringe", "veryfinesyringe", x, y, z)
					}
					
				case "finesyringe":
					switch (setting) {
						case "rough":
							d.Decals = CreateDecal(0, x, 8 * RoomScale + 0.005, z, 90, Rand(360), 0)
							d.Size = 0.07
							ScaleSprite(d.obj, d.Size, d.Size)
						case "coarse":
							it2 = CreateItem("First Aid Kit", "firstaid", x, y, z)
						case "1:1":
							it2 = CreateItem("Blue First Aid Kit", "firstaid2", x, y, z)	
						case "fine", "very fine":
							it2 = CreateItem("Syringe", "veryfinesyringe", x, y, z)
					}
					
				case "veryfinesyringe":
					switch (setting) {
						case "rough", "coarse", "1:1", "fine":
							it2 = CreateItem("Electronical components", "misc", x, y, z)	
						case "very fine":
							n.NPCs = CreateNPC(NPCtype008,x,y,z)
							n.State = 2
					}
			}
			
			RemoveItem(item)
			
		case "SCP-500-01", "Upgraded pill", "Pill":
			switch (setting) {
				case "rough", "coarse":
					d.Decals = CreateDecal(0, x, 8 * RoomScale + 0.010, z, 90, Rand(360), 0)
					d.Size = 0.2
					EntityAlpha(d.obj, 0.8)
					ScaleSprite(d.obj, d.Size, d.Size)
				case "1:1":
					it2 = CreateItem("Pill", "pill", x, y, z)
					RemoveItem(item)
				case "fine":
					let no427Spawn: boolean = false
					for (it3 of Items.each) {
						if (it3.itemtemplate.tempname = "scp427") {
							no427Spawn = true
							break
						}
					}
					if (!no427Spawn) {
						it2 = CreateItem("SCP-427", "scp427", x, y, z)
					} else {
						it2 = CreateItem("Upgraded pill", "scp500death", x, y, z)
					}
					RemoveItem(item)
				case "very fine":
					it2 = CreateItem("Upgraded pill", "scp500death", x, y, z)
					RemoveItem(item)
			}
			
		default:
			
			switch (item.itemtemplate.tempname) {
				case "cup":
					switch (setting) {
						case "rough", "coarse":
							d.Decals = CreateDecal(0, x, 8 * RoomScale + 0.010, z, 90, Rand(360), 0)
							d.Size = 0.2
							EntityAlpha(d.obj, 0.8)
							ScaleSprite(d.obj, d.Size, d.Size)
						case "1:1":
							it2 = CreateItem("cup", "cup", x,y,z)
							it2.name = item.name
							it2.r = 255-item.r
							it2.g = 255-item.g
							it2.b = 255-item.b
						case "fine":
							it2 = CreateItem("cup", "cup", x,y,z)
							it2.name = item.name
							it2.state = 1.0
							it2.r = Min(item.r*Rnd(0.9,1.1),255)
							it2.g = Min(item.g*Rnd(0.9,1.1),255)
							it2.b = Min(item.b*Rnd(0.9,1.1),255)
						case "very fine":
							it2 = CreateItem("cup", "cup", x,y,z)
							it2.name = item.name
							it2.state = Max(it2.state*2.0,2.0)	
							it2.r = Min(item.r*Rnd(0.5,1.5),255)
							it2.g = Min(item.g*Rnd(0.5,1.5),255)
							it2.b = Min(item.b*Rnd(0.5,1.5),255)
							if (Rand(5)=1) {
								ExplosionTimer = 135
							}
					}
					
					RemoveItem(item)
				case "paper":
					switch (setting) {
						case "rough", "coarse":
							d.Decals = CreateDecal(7, x, 8 * RoomScale + 0.005, z, 90, Rand(360), 0)
							d.Size = 0.12
							ScaleSprite(d.obj, d.Size, d.Size)
						case "1:1":
							switch (Rand(6)) {
								case 1:
									it2 = CreateItem("Document SCP-106", "paper", x, y, z)
								case 2:
									it2 = CreateItem("Document SCP-079", "paper", x, y, z)
								case 3:
									it2 = CreateItem("Document SCP-173", "paper", x, y, z)
								case 4:
									it2 = CreateItem("Document SCP-895", "paper", x, y, z)
								case 5:
									it2 = CreateItem("Document SCP-682", "paper", x, y, z)
								case 6:
									it2 = CreateItem("Document SCP-860", "paper", x, y, z)
							}
						case "fine", "very fine":
							it2 = CreateItem("Origami", "misc", x, y, z)
					}
					
					RemoveItem(item)
				default:
					PositionEntity(item.collider, x, y, z)
					ResetEntity(item.collider)	
			}
			
	}
	
	if (it2 != Null) {EntityType (it2.collider, HIT_ITEM)}
}

function Use294() {
	let x: float,y: float, xtemp: int,ytemp: int, strtemp: string, temp: int
	
	ShowPointer()
	
	x = GraphicWidth/2 - (ImageWidth(Panel294)/2)
	y = GraphicHeight/2 - (ImageHeight(Panel294)/2)
	DrawImage (Panel294, x, y)
	if (Fullscreen) {DrawImage (CursorIMG, ScaledMouseX(),ScaledMouseY())}
	
	temp = true
	if (PlayerRoom.SoundCHN!=0) {temp = false}
	
	AAText (x+907, y+185, Input294, true,true)
	
	if (temp) {
		if (MouseHit1) {
			xtemp = Floor((ScaledMouseX()-x-228) / 35.5)
			ytemp = Floor((ScaledMouseY()-y-342) / 36.5)
			
			if (ytemp => 0 && ytemp < 5) {
				if (xtemp => 0 && xtemp < 10) {PlaySound_Strict (ButtonSFX)}
			}
			
			strtemp = ""
			
			temp = false
			
			switch (ytemp) {
				case 0:
					strtemp = (xtemp + 1) % 10
				case 1:
					switch (xtemp) {
						case 0:
							strtemp = "Q"
						case 1:
							strtemp = "W"
						case 2:
							strtemp = "E"
						case 3:
							strtemp = "R"
						case 4:
							strtemp = "T"
						case 5:
							strtemp = "Y"
						case 6:
							strtemp = "U"
						case 7:
							strtemp = "I"
						case 8:
							strtemp = "O"
						case 9:
							strtemp = "P"
					}
				case 2:
					switch (xtemp) {
						case 0:
							strtemp = "A"
						case 1:
							strtemp = "S"
						case 2:
							strtemp = "D"
						case 3:
							strtemp = "F"
						case 4:
							strtemp = "G"
						case 5:
							strtemp = "H"
						case 6:
							strtemp = "J"
						case 7:
							strtemp = "K"
						case 8:
							strtemp = "L"
						case 9: //dispense
							temp = true
					}
				case 3:
					switch (xtemp) {
						case 0:
							strtemp = "Z"
						case 1:
							strtemp = "X"
						case 2:
							strtemp = "C"
						case 3:
							strtemp = "V"
						case 4:
							strtemp = "B"
						case 5:
							strtemp = "N"
						case 6:
							strtemp = "M"
						case 7:
							strtemp = "-"
						case 8:
							strtemp = " "
						case 9:
							Input294 = Left(Input294, Max(Len(Input294)-1,0))
					}
				case 4:
					strtemp = " "
			}
			
			Input294 = Input294 + strtemp
			
			Input294 = Left(Input294, Min(Len(Input294),15))
			
			if (temp && Input294!="") { //dispense
				Input294 = Trim(Lower(Input294))
				if (Left(Input294, Min(7,Len(Input294))) = "cup of ") {
					Input294 = Right(Input294, Len(Input294)-7)
				} else if (Left(Input294, Min(9,Len(Input294))) = "a cup of ") {
					Input294 = Right(Input294, Len(Input294)-9)
				}
				
				if (Input294!="") {
					let loc: int = GetINISectionLocation("DATA/SCP-294.ini",Input294)
				}
				
				if (loc > 0) {
					strtemp$ = GetINIString2("DATA/SCP-294.ini", loc, "dispensesound")
					if (strtemp="") {
						PlayerRoom.SoundCHN = PlaySound_Strict (LoadTempSound("SFX/SCP/294/dispense1.ogg"))
					} else {
						PlayerRoom.SoundCHN = PlaySound_Strict (LoadTempSound(strtemp))
					}
					
					if (GetINIInt2("DATA/SCP-294.ini", loc, "explosion")=true) {
						ExplosionTimer = 135
						DeathMSG = GetINIString2("DATA/SCP-294.ini", loc, "deathmessage")
					}
					
					strtemp$ = GetINIString2("DATA/SCP-294.ini", loc, "color")
					
					sep1 = Instr(strtemp, ",", 1)
					sep2 = Instr(strtemp, ",", sep1+1)
					r = Trim(Left(strtemp, sep1-1))
					g = Trim(Mid(strtemp, sep1+1, sep2-sep1-1))
					b = Trim(Right(strtemp, Len(strtemp)-sep2))
					
					alpha = Float(GetINIString2("DATA/SCP-294.ini", loc, "alpha",1.0))
					glow = GetINIInt2("DATA/SCP-294.ini", loc, "glow")
					//If alpha = 0 Then alpha = 1.0
					if (glow) {alpha = -alpha}
					
					it.items = CreateItem("Cup", "cup", EntityX(PlayerRoom.Objects[1],true),EntityY(PlayerRoom.Objects[1],true),EntityZ(PlayerRoom.Objects[1],true), r,g,b,alpha)
					it.name = "Cup of "+Input294
					EntityType (it.collider, HIT_ITEM)
					
				} else {
					//out of range
					Input294 = "OUT OF RANGE"
					PlayerRoom.SoundCHN = PlaySound_Strict (LoadTempSound("SFX/SCP/294/outofrange.ogg"))
				}
				
			}
			
		} //if mousehit1
		
		if (MouseHit2 || (!Using294)) {
			HidePointer()
			Using294 = false
			Input294 = ""
			MouseXSpeed()
			MouseYSpeed()
			MouseZSpeed()
			mouse_x_speed_1 = 0.0
			mouse_y_speed_1 = 0.0
		}
		
	} else { //playing a dispensing sound
		if (Input294 != "OUT OF RANGE") {Input294 = "DISPENSING..."}
		
		if (!ChannelPlaying(PlayerRoom.SoundCHN)) {
			if (Input294 != "OUT OF RANGE") {
				HidePointer()
				Using294 = false
				MouseXSpeed()
				MouseYSpeed()
				MouseZSpeed()
				mouse_x_speed_1 = 0.0
				mouse_y_speed_1 = 0.0
				let e: Events
				for (e of Events.each) {
					if (e.room = PlayerRoom) {
						e.EventState2 = 0
						break
					}
				}
			}
			Input294=""
			PlayerRoom.SoundCHN=0
		}
	}
	
}

function Use427() {
	let i: int,pvt: int,de: Decals,tempchn: int
	let prevI427Timer: float = I_427.Timer
	
	if (I_427.Timer < 70*360) {
		if (I_427.Using=true) {
			I_427.Timer = I_427.Timer + FPSfactor
			if (Injuries > 0.0) {
				Injuries = Max(Injuries - 0.0005 * FPSfactor,0.0)
			}
			if (Bloodloss > 0.0 && Injuries <= 1.0) {
				Bloodloss = Max(Bloodloss - 0.001 * FPSfactor,0.0)
			}
			if (Infect > 0.0) {
				Infect = Max(Infect - 0.001 * FPSfactor,0.0)
			}
			for (i of range(6)) {
				if (SCP1025state[i]>0.0) {
					SCP1025state[i] = Max(SCP1025state[i] - 0.001 * FPSfactor,0.0)
				}
			}
			if (I_427.Sound[0]=0) {
				I_427.Sound[0] = LoadSound_Strict("SFX/SCP/427/Effect.ogg")
			}
			if (!ChannelPlaying(I_427.SoundCHN[0])) {
				I_427.SoundCHN[0] = PlaySound_Strict(I_427.Sound[0])
			}
			if (I_427.Timer >= 70*180) {
				if (I_427.Sound[1]=0) {
					I_427.Sound[1] = LoadSound_Strict("SFX/SCP/427/Transform.ogg")
				}
				if (!ChannelPlaying(I_427.SoundCHN[1])) {
					I_427.SoundCHN[1] = PlaySound_Strict(I_427.Sound[1])
				}
			}
			if (prevI427Timer < 70*60 && I_427.Timer >= 70*60) {
				Msg = "You feel refreshed and energetic."
				MsgTimer = 70*5
			} else if (prevI427Timer < 70*180 && I_427.Timer >= 70*180) {
				Msg = "You feel gentle muscle spasms all over your body."
				MsgTimer = 70*5
			}
		} else {
			for (i of range(2)) {
				if (I_427.SoundCHN[i]!=0) {
					if (ChannelPlaying(I_427.SoundCHN[i])) {
						StopChannel(I_427.SoundCHN[i])
					}
				}
			}
		}
	} else {
		if (prevI427Timer-FPSfactor < 70*360 && I_427.Timer >= 70*360) {
			Msg = "Your muscles are swelling. You feel more powerful than ever."
			MsgTimer = 70*5
		} else if (prevI427Timer-FPSfactor < 70*390 && I_427.Timer >= 70*390) {
			Msg = "You can't feel your legs. But you don't need legs anymore."
			MsgTimer = 70*5
		}
		I_427.Timer = I_427.Timer + FPSfactor
		if (I_427.Sound[0]=0) {
			I_427.Sound[0] = LoadSound_Strict("SFX/SCP/427/Effect.ogg")
		}
		if (I_427.Sound[1]=0) {
			I_427.Sound[1] = LoadSound_Strict("SFX/SCP/427/Transform.ogg")
		}
		for (i of range(2)) {
			if (!ChannelPlaying(I_427.SoundCHN[i])) {
				I_427.SoundCHN[i] = PlaySound_Strict(I_427.Sound[i])
			}
		}
		if (Rnd(200)<2.0) {
			pvt = CreatePivot()
			PositionEntity (pvt, EntityX(Collider)+Rnd(-0.05,0.05),EntityY(Collider)-0.05,EntityZ(Collider)+Rnd(-0.05,0.05))
			TurnEntity (pvt, 90, 0, 0)
			EntityPick(pvt,0.3)
			de.Decals = CreateDecal(20, PickedX(), PickedY()+0.005, PickedZ(), 90, Rand(360), 0)
			de.Size = Rnd(0.03,0.08)*2.0
			EntityAlpha(de.obj, 1.0)
			ScaleSprite( de.obj, de.Size, de.Size)
			tempchn = PlaySound_Strict (DripSFX(Rand(0,2)))
			ChannelVolume (tempchn, Rnd(0.0,0.8)*SFXVolume)
			ChannelPitch (tempchn, Rand(20000,30000))
			FreeEntity (pvt)
			BlurTimer = 800
		}
		if (I_427.Timer >= 70*420) {
			Kill()
			DeathMSG = Chr(34)+"Requesting support from MTF Nu-7. We need more firepower to take this thing down."+Chr(34)
		} else if (I_427.Timer >= 70*390) {
			Crouch = true
		}
	}
	
}


function UpdateMTF(): int {
	if (PlayerRoom.RoomTemplate.Name = "gateaentrance") {return}
	
	let r: Rooms, n: NPCs
	let dist: float, i: int
	
	//mtf ei viel spawnannut, spawnataan jos pelaaja menee tarpeeksi lhelle gate b:t
	if (MTFtimer = 0) {
		if (Rand(30)=1 && PlayerRoom.RoomTemplate.Name$ != "dimension1499") {
			
			let entrance: Rooms = Null
			for (r of Rooms.each) {
				if (Lower(r.RoomTemplate.Name) = "gateaentrance") {
					entrance = r
					break
				}
			}
			
			if (entrance != Null) {
				if (Abs(EntityZ(entrance.obj)-EntityZ(Collider))<30.0) {
					if (PlayerInReachableRoom()) {
						PlayAnnouncement("SFX/Character/MTF/Announc.ogg")
					}
					
					MTFtimer = FPSfactor
					let leader: NPCs
					for (i of range(3)) {
						n.NPCs = CreateNPC(NPCtypeMTF, EntityX(entrance.obj)+0.3*(i-1), 1.0,EntityZ(entrance.obj)+8.0)
						
						if (i = 0) {
							leader = n
						} else {
							n.MTFLeader = leader
						}
						
						n.PrevX = i
					}
				}
			}
		}
	} else {
		if (MTFtimer <= 70*120) {
			MTFtimer = MTFtimer + FPSfactor
		} else if (MTFtimer > 70*120 && MTFtimer < 10000) {
			if (PlayerInReachableRoom()) {
				PlayAnnouncement("SFX/Character/MTF/AnnouncAfter1.ogg")
			}
			MTFtimer = 10000
			} else if (MTFtimer >= 10000 && MTFtimer <= 10000+(70*120)) {
			MTFtimer = MTFtimer + FPSfactor
			} else if (MTFtimer > 10000+(70*120) && MTFtimer < 20000) {
			if (PlayerInReachableRoom()) {
				PlayAnnouncement("SFX/Character/MTF/AnnouncAfter2.ogg")
			}
			MTFtimer = 20000
			} else if (MTFtimer >= 20000 && MTFtimer <= 20000+(70*60)) {
			MTFtimer = MTFtimer + FPSfactor
			} else if (MTFtimer > 20000+(70*60) && MTFtimer < 25000) {
			if (PlayerInReachableRoom()) {
				//If the player has an SCP in their inventory play special voice line.
				for (i of range(MaxItemAmount)) {
					if (Inventory(i) != Null) {
						if ((Left(Inventory(i).itemtemplate.name, 4) == "SCP-") && (Left(Inventory(i).itemtemplate.name, 7) != "SCP-035") && (Left(Inventory(i).itemtemplate.name, 7) != "SCP-093")) {
							PlayAnnouncement("SFX/Character/MTF/ThreatAnnouncPossession.ogg")
							MTFtimer = 25000
							return
							break
						}
					}
				}
				
				PlayAnnouncement("SFX/Character/MTF/ThreatAnnounc"+Rand(1,3)+".ogg")
			}
			MTFtimer = 25000
			
		} else if (MTFtimer >= 25000 && MTFtimer <= 25000+(70*60)) {
			MTFtimer = MTFtimer + FPSfactor
		} else if (MTFtimer > 25000+(70*60) && MTFtimer < 30000) {
			if (PlayerInReachableRoom()) {
				PlayAnnouncement("SFX/Character/MTF/ThreatAnnouncFinal.ogg")
			}
			MTFtimer = 30000
			
		}
	}
	
}


function UpdateInfect() {
	let temp: float, i: int, r: Rooms
	
	let teleportForInfect: int = true
	
	if (PlayerRoom.RoomTemplate.Name = "room860") {
		for (e of Events.each) {
			if (e.EventName = "room860") {
				if (e.EventState = 1.0) {
					teleportForInfect = false
				}
				Exit
			}
		}
	} else if (PlayerRoom.RoomTemplate.Name == "dimension1499" || PlayerRoom.RoomTemplate.Name == "pocketdimension" || PlayerRoom.RoomTemplate.Name == "gatea") {
		teleportForInfect = false
	} else if (PlayerRoom.RoomTemplate.Name = "exit1" && EntityY(Collider)>1040.0*RoomScale) {
		teleportForInfect = false
	}
	
	if (Infect>0) {
		ShowEntity (InfectOverlay)
		
		if (Infect < 93.0) {
			temp=Infect
			if (!I_427.Using && I_427.Timer < 70*360) {
				Infect = Min(Infect+FPSfactor*0.002,100)
			}
			
			BlurTimer = Max(Infect*3*(2.0-CrouchState),BlurTimer)
			
			HeartBeatRate = Max(HeartBeatRate, 100)
			HeartBeatVolume = Max(HeartBeatVolume, Infect/120.0)
			
			EntityAlpha (InfectOverlay, Min(((Infect*0.2)^2)/1000.0,0.5) * (Sin(MilliSecs2()/8.0)+2.0))
			
			for (i of range(7)) {
				if (Infect>i*15+10 && temp <= i*15+10) {
					PlaySound_Strict (LoadTempSound("SFX/SCP/008/Voices"+i+".ogg"))
				}
			}
			
			if (Infect > 20 && temp <= 20.0) {
				Msg = "You feel kinda feverish."
				MsgTimer = 70*6
			} else if (Infect > 40 && temp <= 40.0) {
				Msg = "You feel nauseated."
				MsgTimer = 70*6
			} else if (Infect > 60 && temp <= 60.0) {
				Msg = "The nausea's getting worse."
				MsgTimer = 70*6
			} else if (Infect > 80 && temp <= 80.0) {
				Msg = "You feel very faint."
				MsgTimer = 70*6
			} else if (Infect >= 91.5) {
				BlinkTimer = Max(Min(-10*(Infect-91.5),BlinkTimer),-10)
				IsZombie = true
				UnableToMove = true
				if (Infect >= 92.7 && temp < 92.7) {
					if (teleportForInfect) {
						for (r of Rooms.each) {
							if (r.RoomTemplate.Name="008") {
								PositionEntity (Collider, EntityX(r.Objects[7],true),EntityY(r.Objects[7],true),EntityZ(r.Objects[7],true),true)
								ResetEntity (Collider)
								r.NPC[0] = CreateNPC(NPCtypeD, EntityX(r.Objects[6],true),EntityY(r.Objects[6],true)+0.2,EntityZ(r.Objects[6],true))
								r.NPC[0].Sound = LoadSound_Strict("SFX/SCP/008/KillScientist1.ogg")
								r.NPC[0].SoundChn = PlaySound_Strict(r.NPC[0].Sound)
								tex = LoadTexture_Strict("GFX/npcs/scientist2.jpg")
								EntityTexture (r.NPC[0].obj, tex)
								FreeTexture (tex)
								r.NPC[0].State=6
								PlayerRoom = r
								UnableToMove = false
								break
							}
						}
					}
				}
			}
		} else {
			
			temp=Infect
			Infect = Min(Infect+FPSfactor*0.004,100)
			
			if (teleportForInfect) {
				if (Infect < 94.7) {
					EntityAlpha (InfectOverlay, 0.5 * (Sin(MilliSecs2()/8.0)+2.0))
					BlurTimer = 900
					
					if (Infect > 94.5) {
						BlinkTimer = Max(Min(-50*(Infect-94.5),BlinkTimer),-10)
					}
					PointEntity(Collider, PlayerRoom.NPC[0].Collider)
					PointEntity(PlayerRoom.NPC[0].Collider, Collider)
					PointEntity(Camera, PlayerRoom.NPC[0].Collider,EntityRoll(Camera))
					ForceMove = 0.75
					Injuries = 2.5
					Bloodloss = 0
					UnableToMove = false
					
					Animate2(PlayerRoom.NPC[0].obj, AnimTime(PlayerRoom.NPC[0].obj), 357, 381, 0.3)
				} else if (Infect < 98.5) {
					
					EntityAlpha (InfectOverlay, 0.5 * (Sin(MilliSecs2()/5.0)+2.0))
					BlurTimer = 950
					
					ForceMove = 0.0
					UnableToMove = true
					PointEntity (Camera, PlayerRoom.NPC[0].Collider)
					
					if (temp < 94.7) {
						PlayerRoom.NPC[0].Sound = LoadSound_Strict("SFX/SCP/008/KillScientist2.ogg")
						PlayerRoom.NPC[0].SoundChn = PlaySound_Strict(PlayerRoom.NPC[0].Sound)
						
						DeathMSG = "Subject D-9341 found ingesting Dr. [REDACTED] at Sector [REDACTED]. Subject was immediately terminated by Nine-Tailed Fox and sent for autopsy. "
						DeathMSG = DeathMSG + "SCP-008 infection was confirmed, after which the body was incinerated."
						
						Kill()
						de.Decals = CreateDecal(3, EntityX(PlayerRoom.NPC[0].Collider), 544*RoomScale + 0.01, EntityZ(PlayerRoom.NPC[0].Collider),90,Rnd(360),0)
						de.Size = 0.8
						ScaleSprite(de.obj, de.Size,de.Size)
					} else if (Infect > 96) {
						BlinkTimer = Max(Min(-10*(Infect-96),BlinkTimer),-10)
					} else {
						KillTimer = Max(-350, KillTimer)
					}
					
					if (PlayerRoom.NPC[0].State2=0) {
						Animate2(PlayerRoom.NPC[0].obj, AnimTime(PlayerRoom.NPC[0].obj), 13, 19, 0.3,false)
						if (AnimTime(PlayerRoom.NPC[0].obj) >= 19) {PlayerRoom.NPC[0].State2=1}
					} else {
						Animate2(PlayerRoom.NPC[0].obj, AnimTime(PlayerRoom.NPC[0].obj), 19, 13, -0.3)
						if (AnimTime(PlayerRoom.NPC[0].obj) <= 13) {PlayerRoom.NPC[0].State2=0}
					}
					
					if (ParticleAmount>0) {
						if (Rand(50)=1) {
							p.Particles = CreateParticle(EntityX(PlayerRoom.NPC[0].Collider),EntityY(PlayerRoom.NPC[0].Collider),EntityZ(PlayerRoom.NPC[0].Collider), 5, Rnd(0.05,0.1), 0.15, 200)
							p.speed = 0.01
							p.SizeChange = 0.01
							p.A = 0.5
							p.Achange = -0.01
							RotateEntity (p.pvt, Rnd(360),Rnd(360),0)
						}
					}
					
					PositionEntity(Head, EntityX(PlayerRoom.NPC[0].Collider,true), EntityY(PlayerRoom.NPC[0].Collider,true)+0.65,EntityZ(PlayerRoom.NPC[0].Collider,true),true)
					RotateEntity(Head, (1.0+Sin(MilliSecs2()/5.0))*15, PlayerRoom.angle-180, 0, true)
					MoveEntity(Head, 0,0,-0.4)
					TurnEntity(Head, 80+(Sin(MilliSecs2()/5.0))*30,(Sin(MilliSecs2()/5.0))*40,0)
				}
			} else {
				Kill()
				BlinkTimer = Max(Min(-10*(Infect-96),BlinkTimer),-10)
				if (PlayerRoom.RoomTemplate.Name = "dimension1499") {
					DeathMSG = "The whereabouts of SCP-1499 are still unknown, but a recon team has been dispatched to investigate reports of a violent attack to a church in the Russian town of [REDACTED]."
				} else if (PlayerRoom.RoomTemplate.Name == "gatea" || PlayerRoom.RoomTemplate.Name == "exit1") {
					DeathMSG = "Subject D-9341 found wandering around Gate "
					if (PlayerRoom.RoomTemplate.Name = "gatea") {
						DeathMSG = DeathMSG + "A"
					} else {
						DeathMSG = DeathMSG + "B"
					}
					DeathMSG = DeathMSG + ". Subject was immediately terminated by Nine-Tailed Fox and sent for autopsy. "
					DeathMSG = DeathMSG + "SCP-008 infection was confirmed, after which the body was incinerated."
				} else {
					DeathMSG = ""
				}
			}
		}
		
		
	} else {
		HideEntity (InfectOverlay)
	}
}

//--------------------------------------- math -------------------------------------------------------

function GenerateSeedNumber(seed: string) {
 	let temp: int = 0
 	let shift: int = 0
 	for (i of range(1, Len(seed) + 1)) {
 		temp = temp ^ (Asc(Mid(seed,i,1)) << shift)
 		shift=(shift+1) % 24
	}
 	return temp
}

function Distance(x1: float, y1: float, x2: float, y2: float): float {
	let x: float = x2 - x1, y: float = y2 - y1
	return Sqr(x*x + y*y)
}

function CurveValue(number: float, old: float, smooth: float): float {
	if (FPSfactor = 0) {return old}
	
	if (number < old) {
		return Max(old + (number - old) * (1.0 / smooth * FPSfactor), number)
	} else {
		return Min(old + (number - old) * (1.0 / smooth * FPSfactor), number)
	}
}

export function CurveAngle(val: float, old: float, smooth: float): float {
	if (FPSfactor = 0) {return old}
	
   let diff: float = WrapAngle(val) - WrapAngle(old)
   if (diff > 180) {diff = diff - 360}
   if (diff < - 180) {diff = diff + 360}
   return WrapAngle(old + diff * (1.0 / smooth * FPSfactor))
}

export function WrapAngle(angle: float): float {
	if (angle = INFINITY) {return 0.0}
	while (angle < 0) {
		angle = angle + 360
	}
	while (angle >= 360) {
		angle = angle - 360
	}
	return angle
}

export function GetAngle(x1: float, y1: float, x2: float, y2: float): float {
	return ATan2( y2 - y1, x2 - x1 )
}

export function CircleToLineSegIsect(cx: float, cy: float, r: float, l1x: float, l1y: float, l2x: float, l2y: float): int {
	if (Distance(cx, cy, l1x, l1y) <= r) {
		return true
	}
	
	if (Distance(cx, cy, l2x, l2y) <= r) {
		return true
	}	
	
	//Vektorit (janan vektori ja vektorit janan ptepisteist ympyrn keskipisteeseen)
	let SegVecX: float = l2x - l1x
	let SegVecY: float = l2y - l1y
	
	let PntVec1X: float = cx - l1x
	let PntVec1Y: float = cy - l1y
	
	let PntVec2X: float = cx - l2x
	let PntVec2Y: float = cy - l2y
	
	//Em. vektorien pistetulot
	let dp1: float = SegVecX * PntVec1X + SegVecY * PntVec1Y
	let dp2: float = -SegVecX * PntVec2X - SegVecY * PntVec2Y
	
	if (!(dp1 == 0 || dp2 == 0 || (dp1 > 0 && dp2 > 0) || (dp1 < 0 && dp2 < 0))) {
		return false
	}
	
	//Janan ptepisteiden kautta kulkevan suoran //yhtl// (ax + by + c = 0)
	let a: float = (l2y - l1y) / (l2x - l1x)
	let b: float = -1
	let c: float = -(l2y - l1y) / (l2x - l1x) * l1x + l1y
	
	//Ympyrn keskipisteen etisyys suorasta
	let d: float = Abs(a * cx + b * cy + c) / Sqr(a * a + b * b)
	
	//Ympyr on liian kaukana
	//-> ei leikkausta
	if (d > r) {return false}
	
	
	//Jos pstn tnne saakka, ympyr ja jana leikkaavat (tai ovat siskkin)
	return true
}

export function Min(a: float, b: float): float {
	if (a < b) {
		return a
	} else {
		return b
	}
}

export function Max(a: float, b: float): float {
	if (a > b) {
		return a
	} else {
		return b
	}
}

export function point_direction(x1: float,z1: float,x2: float,z2: float): float {
	let dx: float, dz: float
	dx = x1 - x2
	dz = z1 - z2
	return ATan2(dz,dx)
}

export function point_distance(x1: float,z1: float,x2: float,z2: float): float {
	let dx: float,dy: float
	dx = x1 - x2
	dy = z1 - z2
	return Sqr((dx*dx)+(dy*dy)) 
}

export function angleDist(a0: float,a1: float): float {
	let b: float = a0-a1
	let bb: float
	if (b<-180.0) {
		bb = b+360.0
	} else if (b>180.0) {
		bb = b-360.0
	} else {
		bb = b
	}
	return bb
}

export function Inverse(number: float): float {
	return Float(1.0-number)
}

export function Rnd_Array(numb1: float,numb2: float,Array1: float,Array2: float): float {
	let whatarray: int = Rand(1,2)
	
	if (whatarray = 1) {
		return Rnd(Array1,numb1)
	} else {
		return Rnd(numb2,Array2)
	}
}

//--------------------------------------- decals -------------------------------------------------------

export class Decals {
	obj: int
	SizeChange: float
	Size: float
	MaxSize: float
	AlphaChange: float
	Alpha: float
	blendmode: int
	fx: int
	ID: int
	Timer: float
	
	lifetime: float
	
	x: float
	y: float
	z: float
	pitch: float
	yaw: float
	roll: float
}

export function CreateDecal(id: int, x: float, y: float, z: float, pitch: float, yaw: float, roll: float): Decals {
	let d: Decals = new Decals()
	
	d.x = x
	d.y = y
	d.z = z
	d.pitch = pitch
	d.yaw = yaw
	d.roll = roll
	
	d.MaxSize = 1.0
	
	d.Alpha = 1.0
	d.Size = 1.0
	d.obj = CreateSprite()
	d.blendmode = 1
	
	EntityTexture(d.obj, DecalTextures(id))
	EntityFX(d.obj, 0)
	SpriteViewMode(d.obj, 2)
	PositionEntity(d.obj, x, y, z)
	RotateEntity(d.obj, pitch, yaw, roll)
	
	d.ID = id
	
	if (DecalTextures(id) == 0 || d.obj == 0) {return Null}
	
	return d
}

export function UpdateDecals() {
	let d: Decals
	for (d of Decals.each) {
		if (d.SizeChange != 0) {
			d.Size=d.Size + d.SizeChange * FPSfactor
			ScaleSprite(d.obj, d.Size, d.Size)
			
			switch (d.ID) {
				case 0:
					if (d.Timer <= 0) {
						let angle: float = Rand(360)
						let temp: float = Rnd(d.Size)
						let d2: Decals = CreateDecal(1, EntityX(d.obj) + Cos(angle) * temp, EntityY(d.obj) - 0.0005, EntityZ(d.obj) + Sin(angle) * temp, EntityPitch(d.obj), Rnd(360), EntityRoll(d.obj))
						d2.Size = Rnd(0.1, 0.5)
						ScaleSprite(d2.obj, d2.Size, d2.Size)
						PlaySound2(DecaySFX(Rand(1, 3)), Camera, d2.obj, 10.0, Rnd(0.1, 0.5))
						d.Timer = Rand(50, 100)
					} else {
						d.Timer= d.Timer-FPSfactor
					}
			}
			
			if (d.Size >= d.MaxSize) {
				d.SizeChange = 0
				d.Size = d.MaxSize
			}
		}
		
		if (d.AlphaChange != 0) {
			d.Alpha = Min(d.Alpha + FPSfactor * d.AlphaChange, 1.0)
			EntityAlpha(d.obj, d.Alpha)
		}
		
		if (d.lifetime > 0) {
			d.lifetime=Max(d.lifetime-FPSfactor,5)
		}
		
		if (d.Size <= 0 || d.Alpha <= 0 || d.lifetime == 5.0 ) {
			FreeEntity(d.obj)
			Delete (d)
		}
	}
}


//--------------------------------------- INI-functions -------------------------------------------------------

export class INIFile {
	name: string
	bank: int
	bankOffset: int = 0
	size: int
}

export function ReadINILine(file: INIFile) : string {
	let rdbyte: int
	let firstbyte: int = true
	let offset: int = file.bankOffset
	let bank: int = file.bank
	let retStr: string = ""
	rdbyte = PeekByte(bank,offset)
	while (((firstbyte) || ((rdbyte!=13) && (rdbyte!=10))) && (offset<file.size)) {
		rdbyte = PeekByte(bank,offset)
		if ((rdbyte!=13) && (rdbyte!=10)) {
			firstbyte = false
			retStr=retStr+Chr(rdbyte)
		}
		offset=offset+1
	}
	file.bankOffset = offset
	return retStr
}

export function UpdateINIFile(filename: string) : string {
	let file: INIFile = Null
	for (k of INIFile.each) {
		if (k.name = Lower(filename)) {
			file = k
		}
	}
	
	if (file=Null) {return}
	
	if (file.bank!=0) {FreeBank (file.bank)}
	let f: int = ReadFile(file.name)
	let fleSize: int = 1
	while (fleSize<FileSize(file.name)) {
		fleSize=fleSize*2
	}
	file.bank = CreateBank(fleSize)
	file.size = 0
	while (!Eof(f)) {
		PokeByte(file.bank,file.size,ReadByte(f))
		file.size=file.size+1
	}
	CloseFile(f)
}

export function GetINIString(file: string, section: string, parameter: string, defaultvalue: string=""): string {
	let TemporaryString: string = ""
	
	let lfile: INIFile
	for (k of INIFile.each) {
		if (k.name = Lower(file)) {
			lfile = k
		}
	}
	
	if (lfile == Null) {
		DebugLog ("CREATE BANK FOR "+file)
		lfile = new INIFile()
		lfile.name = Lower(file)
		lfile.bank = 0
		UpdateINIFile(lfile.name)
	}
	
	lfile.bankOffset = 0
	
	section = Lower(section)
	
	//While Not Eof(f)
	while (lfile.bankOffset<lfile.size) {
		let strtemp: string = ReadINILine(lfile)
		if (Left(strtemp,1) = "[") {
			strtemp$ = Lower(strtemp)
			if (Mid(strtemp, 2, Len(strtemp)-2)=section) {
				do {
					TemporaryString = ReadINILine(lfile)
					if (Lower(Trim(Left(TemporaryString, Max(Instr(TemporaryString, "=") - 1, 0)))) = Lower(parameter)) {
						//CloseFile f
						return Trim( Right(TemporaryString,Len(TemporaryString)-Instr(TemporaryString,"=")) )
					}
				} while (!((Left(TemporaryString, 1) = "[") || (lfile.bankOffset>=lfile.size)))
				
				//CloseFile f
				return defaultvalue
			}
		}
	}
	
	return defaultvalue
}

export function GetINIInt(file: string, section: string, parameter: string, defaultvalue: int = 0): int {
	let txt: string = GetINIString(file$, section$, parameter$, defaultvalue)
	if (Lower(txt) = "true") {
		return 1
	} else if (Lower(txt) = "false") {
		return 0
	} else {
		return Int(txt)
	}
}

export function GetINIFloat(file: string, section: string, parameter: string, defaultvalue: float = 0.0): float {
	return Float(GetINIString(file, section, parameter, defaultvalue))
}


export function GetINIString2(file: string, start: int, parameter: string, defaultvalue: string=""): string {
	let TemporaryString: string = ""
	let f: int = ReadFile(file)
	
	let n: int = 0
	while (!Eof(f)) {
		let strtemp: string = ReadLine(f)
		n=n+1
		if (n=start) {
			do {
				TemporaryString = ReadLine(f)
				if (Lower(Trim(Left(TemporaryString, Max(Instr(TemporaryString, "=") - 1, 0)))) = Lower(parameter)) {
					CloseFile (f)
					return Trim( Right(TemporaryString,Len(TemporaryString)-Instr(TemporaryString,"=")) )
				}
			} while (!(Left(TemporaryString, 1) = "[" || Eof(f)))
			CloseFile (f)
			return defaultvalue
		}
	}
	
	CloseFile (f)
	
	return defaultvalue
}

export function GetINIInt2(file: string, start: int, parameter: string, defaultvalue: string=""): int {
	let txt: string = GetINIString2(file, start, parameter, defaultvalue)
	if (Lower(txt) = "true") {
		return 1
	} else if (Lower(txt) = "false") {
		return 0
	} else {
		return Int(txt)
	}
}


export function GetINISectionLocation(file: string, section: string): int {
	let Temp: int
	let f: int = ReadFile(file)
	
	section = Lower(section)
	
	let n: int = 0
	while (!Eof(f)) {
		let strtemp: string = ReadLine(f)
		n=n+1
		if (Left(strtemp,1) = "[") {
			strtemp = Lower(strtemp)
			Temp = Instr(strtemp, section)
			if (Temp>0) {
				if (Mid(strtemp, Temp-1, 1) == "[" || Mid(strtemp, Temp-1, 1) == "|") {
					CloseFile (f)
					return n
				}
			}
		}
	}
	
	CloseFile (f)
}

export function PutINIValue(file: string, INI_sSection: string, INI_sKey: string, INI_sValue: string): int {
	
	// Returns: true (Success) Or false (Failed)
	
	INI_sSection = "[" + Trim$(INI_sSection) + "]"
	let INI_sUpperSection: string = Upper(INI_sSection)
	INI_sKey = Trim$(INI_sKey)
	INI_sValue = Trim$(INI_sValue)
	let INI_sFilename$ = file$
	
	// Retrieve the INI Data (If it exists)
	
	let INI_sContents$ = INI_FileToString(INI_sFilename)
	
		// (Re)Create the INI file updating/adding the SECTION, KEY && VALUE
	
	let INI_bWrittenKey: int = false
	let INI_bSectionFound: int = false
	let INI_sCurrentSection$ = ""
	
	let INI_lFileHandle: int = WriteFile(INI_sFilename)
	if (INI_lFileHandle = 0) {return false} // Create file failed!
	
	let INI_lOldPos: int = 1
	let INI_lPos: int = Instr(INI_sContents, Chr$(0))
	
	while (INI_lPos != 0) {
		
		let INI_sTemp: string = Mid(INI_sContents, INI_lOldPos, (INI_lPos - INI_lOldPos))
		
		if (INI_sTemp != "") {
			
			if (Left$(INI_sTemp, 1) == "[" && Right$(INI_sTemp, 1) == "]") {
				
					// Process SECTION
				
				if ((INI_sCurrentSection = INI_sUpperSection) && (INI_bWrittenKey = false)) {
					INI_bWrittenKey = INI_CreateKey(INI_lFileHandle, INI_sKey, INI_sValue)
				}
				INI_sCurrentSection = Upper$(INI_CreateSection(INI_lFileHandle, INI_sTemp))
				if (INI_sCurrentSection = INI_sUpperSection) {INI_bSectionFound = true}
				
			} else {
				if (Left(INI_sTemp, 1) = ":") {
					WriteLine (INI_lFileHandle, INI_sTemp)
				} else {
						// KEY=VALUE				
					let lEqualsPos: int = Instr(INI_sTemp, "=")
					if (lEqualsPos != 0) {
						if ((INI_sCurrentSection = INI_sUpperSection) && (Upper$(Trim$(Left$(INI_sTemp, (lEqualsPos - 1)))) = Upper$(INI_sKey))) {
							if (INI_sValue != "") {INI_CreateKey (INI_lFileHandle, INI_sKey, INI_sValue)}
							INI_bWrittenKey = true
						} else {
							WriteLine (INI_lFileHandle, INI_sTemp)
						}
					}
				}
				
			}
			
		}
		
			// Move through the INI file...
		
		INI_lOldPos = INI_lPos + 1
		INI_lPos = Instr(INI_sContents, Chr$(0), INI_lOldPos)
		
	}
	
		// KEY wasn//t found in the INI file - Append a New SECTION If required && create our KEY=VALUE Line
	
	if (INI_bWrittenKey = false) {
		if (INI_bSectionFound = false) {INI_CreateSection (INI_lFileHandle, INI_sSection)}
		INI_CreateKey (INI_lFileHandle, INI_sKey, INI_sValue)
	}
	
	CloseFile (INI_lFileHandle)
	
	return true // Success
	
}

export function INI_FileToString(INI_sFilename: string): string {
	
	let INI_sString: string = ""
	let INI_lFileHandle: int = ReadFile(INI_sFilename)
	if (INI_lFileHandle != 0) {
		while (Not(Eof(INI_lFileHandle))) {
			INI_sString = INI_sString + ReadLine$(INI_lFileHandle) + Chr$(0)
		}
		CloseFile (INI_lFileHandle)
	}
	return INI_sString
	
}

export function INI_CreateSection(INI_lFileHandle: int, INI_sNewSection: string): string {
	
	if (FilePos(INI_lFileHandle) != 0) {WriteLine (INI_lFileHandle, "")} // Blank Line between sections
	WriteLine (INI_lFileHandle, INI_sNewSection)
	return INI_sNewSection
	
}

export function INI_CreateKey(INI_lFileHandle: int, INI_sKey: string, INI_sValue: string): int {
	WriteLine (INI_lFileHandle, INI_sKey + " = " + INI_sValue)
	return true
}

//Save options to .ini.
export function SaveOptionsINI() {
	
	PutINIValue(OptionFile, "options", "mouse sensitivity", MouseSens)
	PutINIValue(OptionFile, "options", "invert mouse y", InvertMouse)
	PutINIValue(OptionFile, "options", "bump mapping enabled", BumpEnabled)			
	PutINIValue(OptionFile, "options", "HUD enabled", HUDenabled)
	PutINIValue(OptionFile, "options", "screengamma", ScreenGamma)
	PutINIValue(OptionFile, "options", "antialias", Opt_AntiAlias)
	PutINIValue(OptionFile, "options", "vsync", Vsync)
	PutINIValue(OptionFile, "options", "show FPS", ShowFPS)
	PutINIValue(OptionFile, "options", "framelimit", Framelimit)
	PutINIValue(OptionFile, "options", "achievement popup enabled", AchvMSGenabled)
	PutINIValue(OptionFile, "options", "room lights enabled", EnableRoomLights)
	PutINIValue(OptionFile, "options", "texture details", TextureDetails)
	PutINIValue(OptionFile, "console", "enabled", CanOpenConsole)
	PutINIValue(OptionFile, "console", "auto opening", ConsoleOpening)
	PutINIValue(OptionFile, "options", "antialiased text", AATextEnable)
	PutINIValue(OptionFile, "options", "particle amount", ParticleAmount)
	PutINIValue(OptionFile, "options", "enable vram", EnableVRam)
	PutINIValue(OptionFile, "options", "mouse smoothing", MouseSmooth)
	
	PutINIValue(OptionFile, "audio", "music volume", MusicVolume)
	PutINIValue(OptionFile, "audio", "sound volume", PrevSFXVolume)
	PutINIValue(OptionFile, "audio", "sfx release", EnableSFXRelease)
	PutINIValue(OptionFile, "audio", "enable user tracks", EnableUserTracks)
	PutINIValue(OptionFile, "audio", "user track setting", UserTrackMode)
	
	PutINIValue(OptionFile, "binds", "Right key", KEY_RIGHT)
	PutINIValue(OptionFile, "binds", "Left key", KEY_LEFT)
	PutINIValue(OptionFile, "binds", "Up key", KEY_UP)
	PutINIValue(OptionFile, "binds", "Down key", KEY_DOWN)
	PutINIValue(OptionFile, "binds", "Blink key", KEY_BLINK)
	PutINIValue(OptionFile, "binds", "Sprint key", KEY_SPRINT)
	PutINIValue(OptionFile, "binds", "Inventory key", KEY_INV)
	PutINIValue(OptionFile, "binds", "Crouch key", KEY_CROUCH)
	PutINIValue(OptionFile, "binds", "Save key", KEY_SAVE)
	PutINIValue(OptionFile, "binds", "Console key", KEY_CONSOLE)
	
}

//--------------------------------------- MakeCollBox -functions -------------------------------------------------------


// Create a collision box For a mesh entity taking into account entity scale
// (will not work in non-uniform scaled space)
export function MakeCollBox(mesh: int) {
	let sx: float = EntityScaleX(mesh, 1)
	let sy: float = Max(EntityScaleY(mesh, 1), 0.001)
	let sz: float = EntityScaleZ(mesh, 1)
	GetMeshExtents(mesh)
	EntityBox (mesh, Mesh_MinX * sx, Mesh_MinY * sy, Mesh_MinZ * sz, Mesh_MagX * sx, Mesh_MagY * sy, Mesh_MagZ * sz)
}

// Find mesh extents
export function GetMeshExtents(Mesh: int) {
	let s: int
	let surf: int
	let surfs: int
	let v: int
	let verts: int
	let x: float
	let y: float
	let z: float
	let minx: float = INFINITY
	let miny: float = INFINITY
	let minz: float = INFINITY
	let maxx: float = -INFINITY
	let maxy: float = -INFINITY
	let maxz: float = -INFINITY
	
	surfs = CountSurfaces(Mesh)
	
	for (s of range(1, surfs + 1)) {
		surf = GetSurface(Mesh, s)
		verts = CountVertices(surf)
		
		for (v of range(verts)) {
			x = VertexX(surf, v)
			y = VertexY(surf, v)
			z = VertexZ(surf, v)
			
			if (x < minx) {minx = x}
			if (x > maxx) {maxx = x}
			if (y < miny) {miny = y}
			if (y > maxy) {maxy = y}
			if (z < minz) {minz = z}
			if (z > maxz) {maxz = z}
		}
	}
	
	Mesh_MinX = minx
	Mesh_MinY = miny
	Mesh_MinZ = minz
	Mesh_MaxX = maxx
	Mesh_MaxY = maxy
	Mesh_MaxZ = maxz
	Mesh_MagX = maxx-minx
	Mesh_MagY = maxy-miny
	Mesh_MagZ = maxz-minz
	
}

export function EntityScaleX(entity: int, globl: int = false): float {
	if (globl) {TFormVector (1, 0, 0, entity, 0)} else {TFormVector (1, 0, 0, entity, GetParent(entity))}
	return Sqr(TFormedX() * TFormedX() + TFormedY() * TFormedY() + TFormedZ() * TFormedZ())
} 

export function EntityScaleY(entity: int, globl: int = false): float {
	if (globl) {TFormVector( 0, 1, 0, entity, 0)} else {TFormVector (0, 1, 0, entity, GetParent(entity))}
	return Sqr(TFormedX() * TFormedX() + TFormedY() * TFormedY() + TFormedZ() * TFormedZ())
} 

export function EntityScaleZ(entity: int, globl: int = false): float {
	if (globl) {TFormVector (0, 0, 1, entity, 0)} else {TFormVector (0, 0, 1, entity, GetParent(entity))}
	return Sqr(TFormedX() * TFormedX() + TFormedY() * TFormedY() + TFormedZ() * TFormedZ())
} 

export function Graphics3DExt(width: int, height: int, depth: int= 32,mode: int= 2): int {
	Graphics3D (width,height,depth,mode)
	InitFastResize()
	AntiAlias (GetINIInt(OptionFile,"options","antialias"))
}

export function ResizeImage2(image: int,width: int,height: int) {
    img = CreateImage(width,height)
	
	oldWidth = ImageWidth(image)
	oldHeight = ImageHeight(image)
	CopyRect (0,0,oldWidth,oldHeight,1024-oldWidth/2,1024-oldHeight/2,ImageBuffer(image),TextureBuffer(fresize_texture))
	SetBuffer( BackBuffer())
	ScaleRender(0,0,2048.0 / Float(RealGraphicWidth) * Float(width) / Float(oldWidth), 2048.0 / Float(RealGraphicWidth) * Float(height) / Float(oldHeight))
	//might want to replace Float(GraphicWidth) with Max(GraphicWidth,GraphicHeight) if portrait sizes cause issues
	//everyone uses landscape so it's probably a non-issue
	CopyRect (RealGraphicWidth/2-width/2,RealGraphicHeight/2-height/2,width,height,0,0,BackBuffer(),ImageBuffer(img))
	
    FreeImage (image)
    return img
}

export function RenderWorld2() {
	CameraProjMode(ark_blur_cam,0)
	CameraProjMode(Camera,1)
	
	if (WearingNightVision>0 && WearingNightVision<3) {
		AmbientLight(Min(Brightness*2,255), Min(Brightness*2,255), Min(Brightness*2,255))
	} else if (WearingNightVision=3) {
		AmbientLight(255,255,255)
	} else if (PlayerRoom!=Null) {
		if ((PlayerRoom.RoomTemplate.Name!="173") && (PlayerRoom.RoomTemplate.Name!="exit1") && (PlayerRoom.RoomTemplate.Name!="gatea")) {
			AmbientLight(Brightness, Brightness, Brightness)
		}
	}
	
	IsNVGBlinking = false
	HideEntity (NVBlink)
	
	CameraViewport (Camera,0,0,GraphicWidth,GraphicHeight)
	
	let hasBattery: int = 2
	let power: int = 0
	if ((WearingNightVision == 1) || (WearingNightVision == 2)) {
		for (i of range(MaxItemAmount)) {
			if (Inventory(i)!=Null) {
				if ((WearingNightVision == 1 && Inventory(i).itemtemplate.tempname == "nvgoggles") || (WearingNightVision == 2 && Inventory(i).itemtemplate.tempname == "supernv")) {
					Inventory(i).state = Inventory(i).state - (FPSfactor * (0.02 * WearingNightVision))
					power%=Int(Inventory(i).state)
					if (Inventory(i).state<=0.0) { //this nvg can't be used
						hasBattery = 0
						Msg = "The batteries in these night vision goggles died."
						BlinkTimer = -1.0
						MsgTimer = 350
						Exit
 					} else if (Inventory(i).state<=100.0) {
						hasBattery = 1
					}
				}
			}
		}
		
		if (hasBattery) {
			RenderWorld()
		}
	} else {
		RenderWorld()
	}
	
	CurrTrisAmount = TrisRendered()

	if (hasBattery == 0 && WearingNightVision! == 3) {
		IsNVGBlinking = true
		ShowEntity (NVBlink)
	}
	
	if (BlinkTimer < - 16 || BlinkTimer > - 6) {
		if (WearingNightVision=2 && hasBattery!=0) { //show a HUD
			NVTimer=NVTimer-FPSfactor
			
			if (NVTimer<=0.0) {
				for (np of NPCs.each) {
					np.NVX = EntityX(np.Collider,true)
					np.NVY = EntityY(np.Collider,true)
					np.NVZ = EntityZ(np.Collider,true)
				}
				IsNVGBlinking = true
				ShowEntity (NVBlink)
				if (NVTimer<=-10) {
					NVTimer = 600.0
				}
			}
			
			Color (255,255,255)
			
			AASetFont (Font3)
			
			let plusY: int = 0
			if (hasBattery=1) {plusY = 40}
			
			AAText (GraphicWidth/2,(20+plusY)*MenuScale,"REFRESHING DATA IN",true,false)
			
			AAText (GraphicWidth/2,(60+plusY)*MenuScale,Max(f2s(NVTimer/60.0,1),0.0),true,false)
			AAText (GraphicWidth/2,(100+plusY)*MenuScale,"SECONDS",true,false)
			
			temp = CreatePivot()
			temp2 = CreatePivot()
			PositionEntity (temp, EntityX(Collider), EntityY(Collider), EntityZ(Collider))
			
			Color (255,255,255)
			
			for (np of NPCs.each) {
				if (np.NVName!="" && (!np.HideFromNVG)) { //don't waste your time if the string is empty
					PositionEntity (temp2,np.NVX,np.NVY,np.NVZ)
					dist = EntityDistance(temp2,Collider)
					if (dist<23.5) { //don't draw text if the NPC is too far away
						PointEntity (temp, temp2)
						yawvalue = WrapAngle(EntityYaw(Camera) - EntityYaw(temp))
						xvalue = 0.0
						if (yawvalue > 90 && yawvalue <= 180) {
							xvalue = Sin(90)/90*yawvalue
						} else if (yawvalue > 180 && yawvalue < 270) {
							xvalue = Sin(270)/yawvalue*270
						} else {
							xvalue = Sin(yawvalue)
						}
						pitchvalue = WrapAngle(EntityPitch(Camera) - EntityPitch(temp))
						yvalue = 0.0
						if (pitchvalue > 90 && pitchvalue <= 180) {
							yvalue = Sin(90)/90*pitchvalue
						} else if (pitchvalue > 180 && pitchvalue < 270) {
							yvalue = Sin(270)/pitchvalue*270
						} else {
							yvalue = Sin(pitchvalue)
						}
						
						if (!IsNVGBlinking) {
							AAText(GraphicWidth / 2 + xvalue * (GraphicWidth / 2),GraphicHeight / 2 - yvalue * (GraphicHeight / 2),np.NVName,true,true)
							AAText(GraphicWidth / 2 + xvalue * (GraphicWidth / 2),GraphicHeight / 2 - yvalue * (GraphicHeight / 2) + 30.0 * MenuScale,f2s(dist,1)+" m",true,true)
						}
					}
				}
			}
			
			FreeEntity (temp)
			FreeEntity (temp2)
			
			Color(0,0,55)
			for (k of range(11)) {
				Rect (45,GraphicHeight*0.5-(k*20),54,10,true)
			}
			Color(0,0,255)
			for (l of range(Floor((power%+50)*0.01) + 1)) {
				Rect (45,GraphicHeight*0.5-(l*20),54,10,true)
			}
			DrawImage (NVGImages,40,GraphicHeight*0.5+30,1)
			
			Color(255,255,255)
		} else if (WearingNightVision=1 && hasBattery!=0) {
			Color(0,55,0)
			for (k of range(11)) {
				Rect(45,GraphicHeight*0.5-(k*20),54,10,true)
			}
			Color(0,255,0)
			for (l of range(Floor((power%+50)*0.01) + 1)) {
				Rect(45,GraphicHeight*0.5-(l*20),54,10,true)
			}
			DrawImage (NVGImages,40,GraphicHeight*0.5+30,0)
		}
	}
	
	//render sprites
	CameraProjMode(ark_blur_cam,2)
	CameraProjMode(Camera,0)
	RenderWorld()
	CameraProjMode(ark_blur_cam,0)
	
	if (BlinkTimer < -16 || BlinkTimer > -6) {
		if ((WearingNightVision == 1 || WearingNightVision == 2) && (hasBattery == 1) && ((MilliSecs2() % 800) < 400)) {
			Color (255,0,0)
			AASetFont (Font3)
			
			AAText (GraphicWidth/2,20*MenuScale,"WARNING: LOW BATTERY",true,false)
			Color (255,255,255)
		}
	}
}


export function ScaleRender(x: float,y: float,hscale: float=1.0,vscale: float=1.0) {
	if (Camera!=0) {HideEntity (Camera)}
	WireFrame (0)
	ShowEntity (fresize_image)
	ScaleEntity (fresize_image,hscale,vscale,1.0)
	PositionEntity (fresize_image, x, y, 1.0001)
	ShowEntity (fresize_cam)
	RenderWorld()
	HideEntity (fresize_cam)
	HideEntity (fresize_image)
	WireFrame (WireframeState)
	if (Camera!=0) {ShowEntity (Camera)}
}

export function InitFastResize() {
    //Create Camera
	let cam: int = CreateCamera()
	CameraProjMode (cam, 2)
	CameraZoom (cam, 0.1)
	CameraClsMode (cam, 0, 0)
	CameraRange (cam, 0.1, 1.5)
	MoveEntity (cam, 0, 0, -10000)
	
	fresize_cam = cam
	
    //ark_sw = GraphicsWidth()
    //ark_sh = GraphicsHeight()
	
    //Create sprite
	let spr: int = CreateMesh(cam)
	let sf: int = CreateSurface(spr)
	AddVertex (sf, -1, 1, 0, 0, 0)
	AddVertex (sf, 1, 1, 0, 1, 0)
	AddVertex (sf, -1, -1, 0, 0, 1)
	AddVertex (sf, 1, -1, 0, 1, 1)
	AddTriangle (sf, 0, 1, 2)
	AddTriangle (sf, 3, 2, 1)
	EntityFX (spr, 17)
	ScaleEntity (spr, 2048.0 / Float(RealGraphicWidth), 2048.0 / Float(RealGraphicHeight), 1)
	PositionEntity (spr, 0, 0, 1.0001)
	EntityOrder (spr, -100001)
	EntityBlend (spr, 1)
	fresize_image = spr
	
    //Create texture
	fresize_texture = CreateTexture(2048, 2048, 1+256)
	fresize_texture2 = CreateTexture(2048, 2048, 1+256)
	TextureBlend (fresize_texture2,3)
	SetBuffer(TextureBuffer(fresize_texture2))
	ClsColor( 0,0,0)
	Cls()
	SetBuffer(BackBuffer())
	//TextureAnisotropy(fresize_texture)
	EntityTexture (spr, fresize_texture,0,0)
	EntityTexture (spr, fresize_texture2,0,1)
	
	HideEntity (fresize_cam)
}

//--------------------------------------- Some new 1.3 -functions -------------------------------------------------------

export function UpdateLeave1499() {
	let r: Rooms
	let it: Items
	let r2: Rooms
	let i: int
	let r1499: Rooms
	
	if ((!Wearing1499) && PlayerRoom.RoomTemplate.Name$ == "dimension1499") {
		for (r of Rooms.each) {
			if (r = NTF_1499PrevRoom) {
				BlinkTimer = -1
				NTF_1499X = EntityX(Collider)
				NTF_1499Y = EntityY(Collider)
				NTF_1499Z = EntityZ(Collider)
				PositionEntity (Collider, NTF_1499PrevX, NTF_1499PrevY+0.05, NTF_1499PrevZ)
				ResetEntity(Collider)
				PlayerRoom = r
				UpdateDoors()
				UpdateRooms()
				if (PlayerRoom.RoomTemplate.Name = "room3storage") {
					if (EntityY(Collider)<-4600*RoomScale) {
						for (i of range(3)) {
							PlayerRoom.NPC[i].State = 2
							PositionEntity(PlayerRoom.NPC[i].Collider, EntityX(PlayerRoom.Objects[PlayerRoom.NPC[i].State2],true),EntityY(PlayerRoom.Objects[PlayerRoom.NPC[i].State2],true)+0.2,EntityZ(PlayerRoom.Objects[PlayerRoom.NPC[i].State2],true))
							ResetEntity (PlayerRoom.NPC[i].Collider)
							PlayerRoom.NPC[i].State2 = PlayerRoom.NPC[i].State2 + 1
							if (PlayerRoom.NPC[i].State2 > PlayerRoom.NPC[i].PrevState) {
								PlayerRoom.NPC[i].State2 = (PlayerRoom.NPC[i].PrevState-3)
							}
						}
					}
				} else if (PlayerRoom.RoomTemplate.Name = "pocketdimension") {
					CameraFogColor (Camera, 0,0,0)
					CameraClsColor (Camera, 0,0,0)
				}
				for (r2 of Rooms.each) {
					if (r2.RoomTemplate.Name = "dimension1499") {
						r1499 = r2
						Exit
					}
				}
				for (it of Items.each) {
					it.disttimer = 0
					if (it.itemtemplate.tempname == "scp1499" || it.itemtemplate.tempname == "super1499") {
						if (EntityY(it.collider) >= EntityY(r1499.obj)-5) {
							PositionEntity (it.collider,NTF_1499PrevX,NTF_1499PrevY+(EntityY(it.collider)-EntityY(r1499.obj)),NTF_1499PrevZ)
							ResetEntity (it.collider)
							break
						}
					}
				}
				r1499 = Null
				ShouldEntitiesFall = false
				PlaySound_Strict (LoadTempSound("SFX/SCP/1499/Exit.ogg"))
				NTF_1499PrevX = 0.0
				NTF_1499PrevY = 0.0
				NTF_1499PrevZ = 0.0
				NTF_1499PrevRoom = Null
				break
			}
		}
	}
	
}

export function CheckForPlayerInFacility() {
	//false (=0): NPC is not in facility (mostly meant for "dimension1499")
	//true (=1): NPC is in facility
	//2: NPC is in tunnels (maintenance tunnels/049 tunnels/939 storage room, etc...)
	
	if (EntityY(Collider)>100.0) {
		return false
	}
	if (EntityY(Collider)< -10.0) {
		return 2
	}
	if (EntityY(Collider)> 7.0 && EntityY(Collider)<=100.0) {
		return 2
	}
	
	return true
}

export function IsItemGoodFor1162(itt: ItemTemplates) {
	let IN: string = itt.tempname
	
	switch (itt.tempname) {
		case "key1", "key2", "key3":
			return true
		case "misc", "420", "cigarette":
			return true
		case "vest", "finevest","gasmask":
			return true
		case "radio","18vradio":
			return true
		case "clipboard","eyedrops","nvgoggles":
			return true
		case "drawing":
			if (itt.img!=0) {FreeImage (itt.img)}
			itt.img = LoadImage_Strict("GFX/items/1048/1048_"+Rand(1,20)+".jpg") //Gives a random drawing.
			return true
		default:
			if (itt.tempname != "paper") {
				return false
			} else if (Instr(itt.name, "Leaflet")) {
				return false
			} else {
				//if the item is a paper, only allow spawning it if the name contains the word "note" or "log"
				//(because those are items created recently, which D-9341 has most likely never seen)
				return ((!Instr(itt.name, "Note")) && (!Instr(itt.name, "Log")))
			}
	}
}

export function ControlSoundVolume() {
	let snd: Sound,i
	
	for (snd of Sound.each) {
		for (i of range(32)) {
			ChannelVolume (snd.channels[i],SFXVolume)
		}
	}
	
}

export function UpdateDeafPlayer() {
	
	if (DeafTimer > 0) {
		DeafTimer = DeafTimer-FPSfactor
		SFXVolume = 0.0
		if (SFXVolume > 0.0) {
			ControlSoundVolume()
		}
		DebugLog (DeafTimer)
	} else {
		DeafTimer = 0
		SFXVolume = PrevSFXVolume
		if (DeafPlayer) {ControlSoundVolume()}
		DeafPlayer = false
		//EndIf
	}
	
}

export function CheckTriggers(): string {
	let i: int,sx: float,sy: float,sz: float
	let inside: int = -1
	
	if (PlayerRoom.TriggerboxAmount = 0) {
		return ""
	} else {
		for (i of range(PlayerRoom.TriggerboxAmount)) {
			EntityAlpha (PlayerRoom.Triggerbox[i],1.0)
			sx = EntityScaleX(PlayerRoom.Triggerbox[i], 1)
			sy = Max(EntityScaleY(PlayerRoom.Triggerbox[i], 1), 0.001)
			sz = EntityScaleZ(PlayerRoom.Triggerbox[i], 1)
			GetMeshExtents(PlayerRoom.Triggerbox[i])
			if (DebugHUD) {
				EntityColor (PlayerRoom.Triggerbox[i],255,255,0)
				EntityAlpha (PlayerRoom.Triggerbox[i],0.2)
			} else {
				EntityColor (PlayerRoom.Triggerbox[i],255,255,255)
				EntityAlpha (PlayerRoom.Triggerbox[i],0.0)
			}
			if (EntityX(Collider)>((sx*Mesh_MinX)+PlayerRoom.x) && EntityX(Collider)<((sx*Mesh_MaxX)+PlayerRoom.x)) {
				if (EntityY(Collider)>((sy*Mesh_MinY)+PlayerRoom.y) && EntityY(Collider)<((sy*Mesh_MaxY)+PlayerRoom.y)) {
					if (EntityZ(Collider)>((sz*Mesh_MinZ)+PlayerRoom.z) && EntityZ(Collider)<((sz*Mesh_MaxZ)+PlayerRoom.z)) {
						inside = i
						break
					}
				}
			}
		}
		
		if (inside > -1) {return PlayerRoom.TriggerboxName[inside]}
	}
	
}

export function ScaledMouseX(): int {
	return Float(MouseX()-(RealGraphicWidth*0.5*(1.0-AspectRatioRatio)))*Float(GraphicWidth)/Float(RealGraphicWidth*AspectRatioRatio)
}

export function ScaledMouseY(): int {
	return Float(MouseY())*Float(GraphicHeight)/Float(RealGraphicHeight)
}

export function CatchErrors(location: string) {
	let errStr: string = ErrorLog()
	let errF: int
	if (Len(errStr)>0) {
		if (FileType(ErrorFile)=0) {
			errF = WriteFile(ErrorFile)
			WriteLine(errF,"An error occured in SCP - Containment Breach!")
			WriteLine(errF,"Version: "+VersionNumber)
			WriteLine(errF,"Save compatible version: "+CompatibleNumber)
			WriteLine(errF,"Date and time: "+CurrentDate()+" at "+CurrentTime())
			WriteLine(errF,"Total video memory (MB): "+TotalVidMem()/1024/1024)
			WriteLine(errF,"Available video memory (MB): "+AvailVidMem()/1024/1024)
			GlobalMemoryStatus (m.MEMORYSTATUS)
			WriteLine(errF,"Global memory status: "+(m.dwAvailPhys/1024/1024)+" MB/"+(m.dwTotalPhys/1024/1024)+" MB ("+(m.dwAvailPhys/1024)+" KB/"+(m.dwTotalPhys/1024)+" KB)")
			WriteLine(errF,"Triangles rendered: "+CurrTrisAmount)
			WriteLine(errF,"Active textures: "+ActiveTextures())
			WriteLine(errF,"")
			WriteLine(errF,"Error(s):")
		} else {
			let canwriteError: int = true
			errF = OpenFile(ErrorFile)
			while (!Eof(errF)) {
				let l: string = ReadLine(errF)
				if (Left(l,Len(location))=location) {
					canwriteError = false
					break
				}
			}
			if (canwriteError) {
				SeekFile (errF,FileSize(ErrorFile))
			}
		}
		if (canwriteError) {
			WriteLine (errF,location+" ***************")
			while (Len(errStr)>0) {
				WriteLine (errF,errStr)
				DebugLog (errStr)
				errStr = ErrorLog()
			}
		}
		Msg = "Blitz3D Error! Details in "+Chr(34)+ErrorFile+Chr(34)
		MsgTimer = 20*70
		CloseFile (errF)
	}
}

export function Create3DIcon(width: int,height: int,modelpath: string,modelX: float=0,modelY: float=0,modelZ: float=0,modelPitch: float=0,modelYaw: float=0,modelRoll: float=0,modelscaleX: float=1,modelscaleY: float=1,modelscaleZ: float=1,withfog: boolean = false) {
	let img: int = CreateImage(width,height)
	let cam: int = CreateCamera()
	let model: int
	
	CameraRange (cam,0.01,16)
	CameraViewport (cam,0,0,width,height)
	if (withfog) {
		CameraFogMode (cam,1)
		CameraFogRange (cam,CameraFogNear,CameraFogFar)
	}
	
	if (Right(Lower(modelpath$),6)=".rmesh") {
		model = LoadRMesh(modelpath$,Null)
	} else {
		model = LoadMesh(modelpath$)
	}
	ScaleEntity (model,modelscaleX,modelscaleY,modelscaleZ)
	PositionEntity (model,modelX,modelY,modelZ)
	RotateEntity (model,modelPitch,modelYaw,modelRoll)
	
	//Cls
	RenderWorld()
	CopyRect (0,0,width,height,0,0,BackBuffer(),ImageBuffer(img))
	
	FreeEntity (model)
	FreeEntity (cam)
	return img
}

export function PlayAnnouncement(file: string) { //This function streams the announcement currently playing
	
	if (IntercomStreamCHN != 0) {
		StopStream_Strict(IntercomStreamCHN)
		IntercomStreamCHN = 0
	}
	
	IntercomStreamCHN = StreamSound_Strict(file$,SFXVolume,0)
	
}

export function UpdateStreamSounds() {
	let e: Events
	
	if (FPSfactor > 0) {
		if (IntercomStreamCHN != 0) {
			SetStreamVolume_Strict(IntercomStreamCHN,SFXVolume)
		}
		for (e of Events.each) {
			if (e.SoundCHN!=0) {
				if (e.SoundCHN_isStream) {
					SetStreamVolume_Strict(e.SoundCHN,SFXVolume)
				}
			}
			if (e.SoundCHN2 != 0) {
				if (e.SoundCHN2_isStream) {
					SetStreamVolume_Strict(e.SoundCHN2,SFXVolume)
				}
			}
		}
	}
	
	if (!PlayerInReachableRoom()) {
		if (PlayerRoom.RoomTemplate.Name != "exit1" && PlayerRoom.RoomTemplate.Name != "gatea") {
			if (IntercomStreamCHN != 0) {
				StopStream_Strict(IntercomStreamCHN)
				IntercomStreamCHN = 0
			}
			if (PlayerRoom.RoomTemplate.Name$ != "dimension1499") {
				for (e of Events.each) {
					if (e.SoundCHN!=0 && e.SoundCHN_isStream) {
						StopStream_Strict(e.SoundCHN)
						e.SoundCHN = 0
						e.SoundCHN_isStream = 0
					}
					if (e.SoundCHN2!=0 && e.SoundCHN2_isStream) {
						StopStream_Strict(e.SoundCHN2)
						e.SoundCHN = 0
						e.SoundCHN_isStream = 0
					}
				}
			}
		}
	}
	
}

export function TeleportEntity(entity: int,x: float,y: float,z: float,customradius: float=0.3,isglobal: int=false,pickrange: float=2.0,dir: int=0) {
	let pvt,pick
	//dir = 0 - towards the floor (default)
	//dir = 1 - towrads the ceiling (mostly for PD decal after leaving dimension)
	
	pvt = CreatePivot()
	PositionEntity(pvt, x,y+0.05,z,isglobal)
	if (dir%=0) {
		RotateEntity(pvt,90,0,0)
	} else {
		RotateEntity(pvt,-90,0,0)
	}
	pick = EntityPick(pvt,pickrange)
	if (pick != 0) {
		if (dir%=0) {
			PositionEntity(entity, x,PickedY()+customradius+0.02,z,isglobal)
		} else {
			PositionEntity(entity, x,PickedY()+customradius-0.02,z,isglobal)
		}
		DebugLog("Entity teleported successfully")
	} else {
		PositionEntity(entity,x,y,z,isglobal)
		DebugLog("Warning: no ground found when teleporting an entity")
	}
	FreeEntity (pvt)
	ResetEntity (entity)
	DebugLog("Teleported entity to: "+EntityX(entity)+"/"+EntityY(entity)+"/"+EntityZ(entity))
	
}

export function PlayStartupVideos() {
	
	if (GetINIInt("options.ini","options","play startup video")=0) {return}
	
	let Cam = CreateCamera() 
	CameraClsMode (Cam, 0, 1)
	let Quad = CreateQuad()
	let Texture = CreateTexture(2048, 2048, 256 | 16 | 32)
	EntityTexture (Quad, Texture)
	EntityFX (Quad, 1)
	CameraRange (Cam, 0.01, 100)
	TranslateEntity (Cam, 1.0 / 2048 ,-1.0 / 2048 ,-1.0)
	EntityParent (Quad, Cam, 1)
	
	let ScaledGraphicHeight: int
	let Ratio: float = Float(RealGraphicWidth)/Float(RealGraphicHeight)
	if (Ratio>1.76 && Ratio<1.78) {
		ScaledGraphicHeight = RealGraphicHeight
		DebugLog("Not Scaled")
	} else {
		ScaledGraphicHeight = Float(RealGraphicWidth)/(16.0/9.0)
		DebugLog("Scaled: "+ScaledGraphicHeight)
	}
	
	let moviefile$ = "GFX/menu/startup_Undertow"
	BlitzMovie_Open(moviefile$+".avi") //Get movie size
	let moview = BlitzMovie_GetWidth()
	let movieh = BlitzMovie_GetHeight()
	BlitzMovie_Close()
	let image = CreateImage(moview, movieh)
	let SplashScreenVideo = BlitzMovie_OpenDecodeToImage(moviefile$+".avi", image, false)
	SplashScreenVideo = BlitzMovie_Play()
	let SplashScreenAudio = StreamSound_Strict(moviefile$+".ogg",SFXVolume,0)
	do {
		Cls()
		ProjectImage(image, RealGraphicWidth, ScaledGraphicHeight, Quad, Texture)
		Flip()
	} while (!(GetKey() || (!IsStreamPlaying_Strict(SplashScreenAudio))))
	StopStream_Strict(SplashScreenAudio)
	BlitzMovie_Stop()
	BlitzMovie_Close()
	FreeImage (image)
	
	Cls()
	Flip()
	
	moviefile$ = "GFX/menu/startup_TSS"
	BlitzMovie_Open(moviefile$+".avi") //Get movie size
	moview = BlitzMovie_GetWidth()
	movieh = BlitzMovie_GetHeight()
	BlitzMovie_Close()
	image = CreateImage(moview, movieh)
	SplashScreenVideo = BlitzMovie_OpenDecodeToImage(moviefile$+".avi", image, false)
	SplashScreenVideo = BlitzMovie_Play()
	SplashScreenAudio = StreamSound_Strict(moviefile$+".ogg",SFXVolume,0)
	do {
		Cls()
		ProjectImage(image, RealGraphicWidth, ScaledGraphicHeight, Quad, Texture)
		Flip()
	} while  (!(GetKey() || (!IsStreamPlaying_Strict(SplashScreenAudio))))
	StopStream_Strict(SplashScreenAudio)
	BlitzMovie_Stop()
	BlitzMovie_Close()
	
	FreeTexture (Texture)
	FreeEntity (Quad)
	FreeEntity (Cam)
	FreeImage (image)
	Cls()
	Flip()
	
}

export function ProjectImage(img, w: float, h: float, Quad: int, Texture: int) {
	
	let img_w: float = ImageWidth(img)
	let img_h: float = ImageHeight(img)
	if (img_w > 2048) {img_w = 2048}
	if (img_h > 2048) {img_h = 2048}
	if (img_w < 1) {img_w = 1}
	if (img_h < 1) {img_h = 1}
	
	if (w > 2048) {w = 2048}
	if (h > 2048) {h = 2048}
	if (w < 1) {w = 1}
	if (h < 1) {h = 1}
	
	let w_rel: float = w / img_w
	let h_rel: float = h / img_h
	let g_rel: float = 2048.0 / Float(RealGraphicWidth)
	let dst_x = 1024 - (img_w / 2.0)
	let dst_y = 1024 - (img_h / 2.0)
	CopyRect (0, 0, img_w, img_h, dst_x, dst_y, ImageBuffer(img), TextureBuffer(Texture))
	ScaleEntity (Quad, w_rel * g_rel, h_rel * g_rel, 0.0001)
	RenderWorld()
	
}

export function CreateQuad() {
	
	mesh = CreateMesh()
	surf = CreateSurface(mesh)
	v0 = AddVertex(surf,-1.0, 1.0, 0, 0, 0)
	v1 = AddVertex(surf, 1.0, 1.0, 0, 1, 0)
	v2 = AddVertex(surf, 1.0,-1.0, 0, 1, 1)
	v3 = AddVertex(surf,-1.0,-1.0, 0, 0, 1)
	AddTriangle(surf, v0, v1, v2)
	AddTriangle(surf, v0, v2, v3)
	UpdateNormals (mesh)
	return mesh
	
}

export function CanUseItem(canUseWithHazmat: int, canUseWithGasMask: int, canUseWithEyewear: int) {
	if (canUseWithHazmat = false && WearingHazmat) {
		Msg = "You can't use that item while wearing a hazmat suit."
		MsgTimer = 70*5
		return false
	} else if (canUseWithGasMask = false && (WearingGasMask || Wearing1499)) {
		Msg = "You can't use that item while wearing a gas mask."
		MsgTimer = 70*5
		return false
	} else if (canUseWithEyewear = false && (WearingNightVision)) {
		Msg = "You can't use that item while wearing headgear."
	}
	
	return true
}

export function ResetInput() {
	
	FlushKeys()
	FlushMouse()
	MouseHit1 = 0
	MouseHit2 = 0
	MouseDown1 = 0
	MouseUp1 = 0
	MouseHit(1)
	MouseHit(2)
	MouseDown(1)
	GrabbedEntity = 0
	Input_ResetTime = 10.0
	
}

export function Update096ElevatorEvent(e: Events,EventState: float,d: Doors,elevatorobj: int): float {
	let prevEventState: float = EventState
	
	if (EventState < 0) {
		EventState = 0
		prevEventState = 0
	}
	
	if (d.openstate == 0 && d.open == false) {
		if (Abs(EntityX(Collider)-EntityX(elevatorobj,true))<=280.0*RoomScale+(0.015*FPSfactor)) {
			if (Abs(EntityZ(Collider)-EntityZ(elevatorobj,true))<=280.0*RoomScale+(0.015*FPSfactor)) {
				if (Abs(EntityY(Collider)-EntityY(elevatorobj,true))<=280.0*RoomScale+(0.015*FPSfactor)) {
					d.locked = true
					if (EventState = 0) {
						TeleportEntity(Curr096.Collider,EntityX(d.frameobj),EntityY(d.frameobj)+1.0,EntityZ(d.frameobj),Curr096.CollRadius)
						PointEntity (Curr096.Collider,elevatorobj)
						RotateEntity (Curr096.Collider,0,EntityYaw(Curr096.Collider),0)
						MoveEntity (Curr096.Collider,0,0,-0.5)
						ResetEntity (Curr096.Collider)
						Curr096.State = 6
						SetNPCFrame(Curr096,0)
						e.Sound = LoadSound_Strict("SFX/SCP/096/ElevatorSlam.ogg")
						EventState = EventState + FPSfactor * 1.4
					}
				}
			}
		}
	}
	
	if (EventState > 0) {
		if (prevEventState = 0) {
			e.SoundCHN = PlaySound_Strict(e.Sound)
		}
		
		if (EventState > 70*1.9 && EventState < 70*2+FPSfactor) {
			CameraShake = 7
		} else if (EventState > 70*4.2 && EventState < 70*4.25+FPSfactor) {
			CameraShake = 1
		} else if (EventState > 70*5.9 && EventState < 70*5.95+FPSfactor) {
			CameraShake = 1
		} else if (EventState > 70*7.25 && EventState < 70*7.3+FPSfactor) {
			CameraShake = 1
			d.fastopen = true
			d.open = true
			Curr096.State = 4
			Curr096.LastSeen = 1
		} else if (EventState > 70*8.1 && EventState < 70*8.15+FPSfactor) {
			CameraShake = 1
		}
		
		if (EventState <= 70*8.1) {
			d.openstate = Min(d.openstate,20)
		}
		EventState = EventState + FPSfactor * 1.4
	}
	return EventState
	
}

export function RotateEntity90DegreeAngles(entity: int) {
	let angle = WrapAngle(entity)
	
	if (angle < 45.0) {
		return 0
 	} else if (angle >= 45.0 && angle < 135) {
		return 90
 	} else if (angle >= 135 && angle < 225) {
		return 180
	} else {
		return 270
	}
}
